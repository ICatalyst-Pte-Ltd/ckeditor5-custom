import { jsx as Jn, jsxs as x1 } from "react/jsx-runtime";
import * as Ht from "react";
import mi, { useContext as zP, createElement as Yf, Fragment as WP, forwardRef as jP, useMemo as k1, useRef as UP, useEffect as A1 } from "react";
var et = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function D0(i) {
  return i && i.__esModule && Object.prototype.hasOwnProperty.call(i, "default") ? i.default : i;
}
function HP(i) {
  if (i.__esModule)
    return i;
  var e = i.default;
  if (typeof e == "function") {
    var t = function n() {
      if (this instanceof n) {
        var r = [null];
        r.push.apply(r, arguments);
        var s = Function.bind.apply(e, r);
        return new s();
      }
      return e.apply(this, arguments);
    };
    t.prototype = e.prototype;
  } else
    t = {};
  return Object.defineProperty(t, "__esModule", { value: !0 }), Object.keys(i).forEach(function(n) {
    var r = Object.getOwnPropertyDescriptor(i, n);
    Object.defineProperty(t, n, r.get ? r : {
      enumerable: !0,
      get: function() {
        return i[n];
      }
    });
  }), t;
}
var sd = {}, qP = {
  get exports() {
    return sd;
  },
  set exports(i) {
    sd = i;
  }
};
/*!
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md.
 */
(function(i, e) {
  (function(t, n) {
    i.exports = n(mi);
  })(self, (t) => (() => {
    var n = { 703: (l, u, h) => {
      var f = h(414);
      function m() {
      }
      function v() {
      }
      v.resetWarningCache = m, l.exports = function() {
        function C(x, N, y, A, P, E) {
          if (E !== f) {
            var V = new Error("Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types");
            throw V.name = "Invariant Violation", V;
          }
        }
        function k() {
          return C;
        }
        C.isRequired = C;
        var S = { array: C, bigint: C, bool: C, func: C, number: C, object: C, string: C, symbol: C, any: C, arrayOf: k, element: C, elementType: C, instanceOf: k, node: C, objectOf: k, oneOf: k, oneOfType: k, shape: k, exact: k, checkPropTypes: v, resetWarningCache: m };
        return S.PropTypes = S, S;
      };
    }, 697: (l, u, h) => {
      l.exports = h(703)();
    }, 414: (l) => {
      l.exports = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
    }, 787: (l) => {
      l.exports = t;
    } }, r = {};
    function s(l) {
      var u = r[l];
      if (u !== void 0)
        return u.exports;
      var h = r[l] = { exports: {} };
      return n[l](h, h.exports, s), h.exports;
    }
    s.n = (l) => {
      var u = l && l.__esModule ? () => l.default : () => l;
      return s.d(u, { a: u }), u;
    }, s.d = (l, u) => {
      for (var h in u)
        s.o(u, h) && !s.o(l, h) && Object.defineProperty(l, h, { enumerable: !0, get: u[h] });
    }, s.o = (l, u) => Object.prototype.hasOwnProperty.call(l, u), s.r = (l) => {
      typeof Symbol < "u" && Symbol.toStringTag && Object.defineProperty(l, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(l, "__esModule", { value: !0 });
    };
    var o = {};
    return (() => {
      s.r(o), s.d(o, { CKEditor: () => Gi, CKEditorContext: () => ka });
      var l = s(787), u = s.n(l), h = s(697), f = s.n(h);
      const m = new Array(256).fill("").map((_, w) => ("0" + w.toString(16)).slice(-2));
      class v {
        constructor(w) {
          if (this.crashes = [], this.state = "initializing", this._now = Date.now, this.crashes = [], this._crashNumberLimit = typeof w.crashNumberLimit == "number" ? w.crashNumberLimit : 3, this._minimumNonErrorTimePeriod = typeof w.minimumNonErrorTimePeriod == "number" ? w.minimumNonErrorTimePeriod : 5e3, this._boundErrorHandler = (O) => {
            const G = "error" in O ? O.error : O.reason;
            G instanceof Error && this._handleError(G, O);
          }, this._listeners = {}, !this._restart)
            throw new Error("The Watchdog class was split into the abstract `Watchdog` class and the `EditorWatchdog` class. Please, use `EditorWatchdog` if you have used the `Watchdog` class previously.");
        }
        destroy() {
          this._stopErrorHandling(), this._listeners = {};
        }
        on(w, O) {
          this._listeners[w] || (this._listeners[w] = []), this._listeners[w].push(O);
        }
        off(w, O) {
          this._listeners[w] = this._listeners[w].filter((G) => G !== O);
        }
        _fire(w, ...O) {
          const G = this._listeners[w] || [];
          for (const Ce of G)
            Ce.apply(this, [null, ...O]);
        }
        _startErrorHandling() {
          window.addEventListener("error", this._boundErrorHandler), window.addEventListener("unhandledrejection", this._boundErrorHandler);
        }
        _stopErrorHandling() {
          window.removeEventListener("error", this._boundErrorHandler), window.removeEventListener("unhandledrejection", this._boundErrorHandler);
        }
        _handleError(w, O) {
          if (this._shouldReactToError(w)) {
            this.crashes.push({ message: w.message, stack: w.stack, filename: O instanceof ErrorEvent ? O.filename : void 0, lineno: O instanceof ErrorEvent ? O.lineno : void 0, colno: O instanceof ErrorEvent ? O.colno : void 0, date: this._now() });
            const G = this._shouldRestart();
            this.state = "crashed", this._fire("stateChange"), this._fire("error", { error: w, causesRestart: G }), G ? this._restart() : (this.state = "crashedPermanently", this._fire("stateChange"));
          }
        }
        _shouldReactToError(w) {
          return w.is && w.is("CKEditorError") && w.context !== void 0 && w.context !== null && this.state === "ready" && this._isErrorComingFromThisItem(w);
        }
        _shouldRestart() {
          return this.crashes.length <= this._crashNumberLimit ? !0 : (this.crashes[this.crashes.length - 1].date - this.crashes[this.crashes.length - 1 - this._crashNumberLimit].date) / this._crashNumberLimit > this._minimumNonErrorTimePeriod;
        }
      }
      function C(_, w = /* @__PURE__ */ new Set()) {
        const O = [_], G = /* @__PURE__ */ new Set();
        let Ce = 0;
        for (; O.length > Ce; ) {
          const Re = O[Ce++];
          if (!G.has(Re) && k(Re) && !w.has(Re))
            if (G.add(Re), Symbol.iterator in Re)
              try {
                for (const Ie of Re)
                  O.push(Ie);
              } catch {
              }
            else
              for (const Ie in Re)
                Ie !== "defaultValue" && O.push(Re[Ie]);
        }
        return G;
      }
      function k(_) {
        const w = Object.prototype.toString.call(_), O = typeof _;
        return !(O === "number" || O === "boolean" || O === "string" || O === "symbol" || O === "function" || w === "[object Date]" || w === "[object RegExp]" || w === "[object Module]" || _ == null || _._watchdogExcluded || _ instanceof EventTarget || _ instanceof Event);
      }
      function S(_, w, O = /* @__PURE__ */ new Set()) {
        if (_ === w && typeof (G = _) == "object" && G !== null)
          return !0;
        var G;
        const Ce = C(_, O), Re = C(w, O);
        for (const Ie of Ce)
          if (Re.has(Ie))
            return !0;
        return !1;
      }
      const x = function(_) {
        var w = typeof _;
        return _ != null && (w == "object" || w == "function");
      }, N = typeof et == "object" && et && et.Object === Object && et;
      var y = typeof self == "object" && self && self.Object === Object && self;
      const A = N || y || Function("return this")(), P = function() {
        return A.Date.now();
      };
      var E = /\s/;
      const V = function(_) {
        for (var w = _.length; w-- && E.test(_.charAt(w)); )
          ;
        return w;
      };
      var j = /^\s+/;
      const U = function(_) {
        return _ && _.slice(0, V(_) + 1).replace(j, "");
      }, $ = A.Symbol;
      var M = Object.prototype, D = M.hasOwnProperty, J = M.toString, H = $ ? $.toStringTag : void 0;
      const Y = function(_) {
        var w = D.call(_, H), O = _[H];
        try {
          _[H] = void 0;
          var G = !0;
        } catch {
        }
        var Ce = J.call(_);
        return G && (w ? _[H] = O : delete _[H]), Ce;
      };
      var le = Object.prototype.toString;
      const me = function(_) {
        return le.call(_);
      };
      var ee = $ ? $.toStringTag : void 0;
      const te = function(_) {
        return _ == null ? _ === void 0 ? "[object Undefined]" : "[object Null]" : ee && ee in Object(_) ? Y(_) : me(_);
      }, ne = function(_) {
        return _ != null && typeof _ == "object";
      }, z = function(_) {
        return typeof _ == "symbol" || ne(_) && te(_) == "[object Symbol]";
      };
      var se = /^[-+]0x[0-9a-f]+$/i, ve = /^0b[01]+$/i, ue = /^0o[0-7]+$/i, ce = parseInt;
      const he = function(_) {
        if (typeof _ == "number")
          return _;
        if (z(_))
          return NaN;
        if (x(_)) {
          var w = typeof _.valueOf == "function" ? _.valueOf() : _;
          _ = x(w) ? w + "" : w;
        }
        if (typeof _ != "string")
          return _ === 0 ? _ : +_;
        _ = U(_);
        var O = ve.test(_);
        return O || ue.test(_) ? ce(_.slice(2), O ? 2 : 8) : se.test(_) ? NaN : +_;
      };
      var be = Math.max, Ee = Math.min;
      const Pe = function(_, w, O) {
        var G, Ce, Re, Ie, Ve, $t, Rt = 0, ao = !1, mr = !1, _i = !0;
        if (typeof _ != "function")
          throw new TypeError("Expected a function");
        function ii(ke) {
          var $e = G, Et = Ce;
          return G = Ce = void 0, Rt = ke, Ie = _.apply(Et, $e);
        }
        function F(ke) {
          var $e = ke - $t;
          return $t === void 0 || $e >= w || $e < 0 || mr && ke - Rt >= Re;
        }
        function Z() {
          var ke = P();
          if (F(ke))
            return K(ke);
          Ve = setTimeout(Z, function($e) {
            var Et = w - ($e - $t);
            return mr ? Ee(Et, Re - ($e - Rt)) : Et;
          }(ke));
        }
        function K(ke) {
          return Ve = void 0, _i && G ? ii(ke) : (G = Ce = void 0, Ie);
        }
        function pe() {
          var ke = P(), $e = F(ke);
          if (G = arguments, Ce = this, $t = ke, $e) {
            if (Ve === void 0)
              return function(Et) {
                return Rt = Et, Ve = setTimeout(Z, w), ao ? ii(Et) : Ie;
              }($t);
            if (mr)
              return clearTimeout(Ve), Ve = setTimeout(Z, w), ii($t);
          }
          return Ve === void 0 && (Ve = setTimeout(Z, w)), Ie;
        }
        return w = he(w) || 0, x(O) && (ao = !!O.leading, Re = (mr = "maxWait" in O) ? be(he(O.maxWait) || 0, w) : Re, _i = "trailing" in O ? !!O.trailing : _i), pe.cancel = function() {
          Ve !== void 0 && clearTimeout(Ve), Rt = 0, G = $t = Ce = Ve = void 0;
        }, pe.flush = function() {
          return Ve === void 0 ? Ie : K(P());
        }, pe;
      }, Se = function(_, w, O) {
        var G = !0, Ce = !0;
        if (typeof _ != "function")
          throw new TypeError("Expected a function");
        return x(O) && (G = "leading" in O ? !!O.leading : G, Ce = "trailing" in O ? !!O.trailing : Ce), Pe(_, w, { leading: G, maxWait: w, trailing: Ce });
      }, ye = function() {
        this.__data__ = [], this.size = 0;
      }, De = function(_, w) {
        return _ === w || _ != _ && w != w;
      }, q = function(_, w) {
        for (var O = _.length; O--; )
          if (De(_[O][0], w))
            return O;
        return -1;
      };
      var Ze = Array.prototype.splice;
      const de = function(_) {
        var w = this.__data__, O = q(w, _);
        return !(O < 0) && (O == w.length - 1 ? w.pop() : Ze.call(w, O, 1), --this.size, !0);
      }, Ye = function(_) {
        var w = this.__data__, O = q(w, _);
        return O < 0 ? void 0 : w[O][1];
      }, nn = function(_) {
        return q(this.__data__, _) > -1;
      }, rn = function(_, w) {
        var O = this.__data__, G = q(O, _);
        return G < 0 ? (++this.size, O.push([_, w])) : O[G][1] = w, this;
      };
      function Qn(_) {
        var w = -1, O = _ == null ? 0 : _.length;
        for (this.clear(); ++w < O; ) {
          var G = _[w];
          this.set(G[0], G[1]);
        }
      }
      Qn.prototype.clear = ye, Qn.prototype.delete = de, Qn.prototype.get = Ye, Qn.prototype.has = nn, Qn.prototype.set = rn;
      const zn = Qn, Jt = function() {
        this.__data__ = new zn(), this.size = 0;
      }, sn = function(_) {
        var w = this.__data__, O = w.delete(_);
        return this.size = w.size, O;
      }, Wn = function(_) {
        return this.__data__.get(_);
      }, gi = function(_) {
        return this.__data__.has(_);
      }, jn = function(_) {
        if (!x(_))
          return !1;
        var w = te(_);
        return w == "[object Function]" || w == "[object GeneratorFunction]" || w == "[object AsyncFunction]" || w == "[object Proxy]";
      }, Un = A["__core-js_shared__"];
      var dn = function() {
        var _ = /[^.]+$/.exec(Un && Un.keys && Un.keys.IE_PROTO || "");
        return _ ? "Symbol(src)_1." + _ : "";
      }();
      const on = function(_) {
        return !!dn && dn in _;
      };
      var On = Function.prototype.toString;
      const Mn = function(_) {
        if (_ != null) {
          try {
            return On.call(_);
          } catch {
          }
          try {
            return _ + "";
          } catch {
          }
        }
        return "";
      };
      var I = /^\[object .+?Constructor\]$/, ge = Function.prototype, xe = Object.prototype, Be = ge.toString, Fe = xe.hasOwnProperty, an = RegExp("^" + Be.call(Fe).replace(/[\\^$.*+?()[\]{}|]/g, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
      const _n = function(_) {
        return !(!x(_) || on(_)) && (jn(_) ? an : I).test(Mn(_));
      }, Xt = function(_, w) {
        return _?.[w];
      }, hn = function(_, w) {
        var O = Xt(_, w);
        return _n(O) ? O : void 0;
      }, vn = hn(A, "Map"), Cn = hn(Object, "create"), ln = function() {
        this.__data__ = Cn ? Cn(null) : {}, this.size = 0;
      }, pi = function(_) {
        var w = this.has(_) && delete this.__data__[_];
        return this.size -= w ? 1 : 0, w;
      };
      var Ui = Object.prototype.hasOwnProperty;
      const ei = function(_) {
        var w = this.__data__;
        if (Cn) {
          var O = w[_];
          return O === "__lodash_hash_undefined__" ? void 0 : O;
        }
        return Ui.call(w, _) ? w[_] : void 0;
      };
      var Nn = Object.prototype.hasOwnProperty;
      const Vr = function(_) {
        var w = this.__data__;
        return Cn ? w[_] !== void 0 : Nn.call(w, _);
      }, Sn = function(_, w) {
        var O = this.__data__;
        return this.size += this.has(_) ? 0 : 1, O[_] = Cn && w === void 0 ? "__lodash_hash_undefined__" : w, this;
      };
      function Ft(_) {
        var w = -1, O = _ == null ? 0 : _.length;
        for (this.clear(); ++w < O; ) {
          var G = _[w];
          this.set(G[0], G[1]);
        }
      }
      Ft.prototype.clear = ln, Ft.prototype.delete = pi, Ft.prototype.get = ei, Ft.prototype.has = Vr, Ft.prototype.set = Sn;
      const ti = Ft, Lr = function() {
        this.size = 0, this.__data__ = { hash: new ti(), map: new (vn || zn)(), string: new ti() };
      }, ni = function(_) {
        var w = typeof _;
        return w == "string" || w == "number" || w == "symbol" || w == "boolean" ? _ !== "__proto__" : _ === null;
      }, wn = function(_, w) {
        var O = _.__data__;
        return ni(w) ? O[typeof w == "string" ? "string" : "hash"] : O.map;
      }, ft = function(_) {
        var w = wn(this, _).delete(_);
        return this.size -= w ? 1 : 0, w;
      }, xh = function(_) {
        return wn(this, _).get(_);
      }, kh = function(_) {
        return wn(this, _).has(_);
      }, Ah = function(_, w) {
        var O = wn(this, _), G = O.size;
        return O.set(_, w), this.size += O.size == G ? 0 : 1, this;
      };
      function Fr(_) {
        var w = -1, O = _ == null ? 0 : _.length;
        for (this.clear(); ++w < O; ) {
          var G = _[w];
          this.set(G[0], G[1]);
        }
      }
      Fr.prototype.clear = Lr, Fr.prototype.delete = ft, Fr.prototype.get = xh, Fr.prototype.has = kh, Fr.prototype.set = Ah;
      const Ph = Fr, Ih = function(_, w) {
        var O = this.__data__;
        if (O instanceof zn) {
          var G = O.__data__;
          if (!vn || G.length < 199)
            return G.push([_, w]), this.size = ++O.size, this;
          O = this.__data__ = new Ph(G);
        }
        return O.set(_, w), this.size = O.size, this;
      };
      function $r(_) {
        var w = this.__data__ = new zn(_);
        this.size = w.size;
      }
      $r.prototype.clear = Jt, $r.prototype.delete = sn, $r.prototype.get = Wn, $r.prototype.has = gi, $r.prototype.set = Ih;
      const Rh = $r, Kl = function(_, w) {
        for (var O = -1, G = _ == null ? 0 : _.length; ++O < G && w(_[O], O, _) !== !1; )
          ;
        return _;
      }, Gl = function() {
        try {
          var _ = hn(Object, "defineProperty");
          return _({}, "", {}), _;
        } catch {
        }
      }(), Yl = function(_, w, O) {
        w == "__proto__" && Gl ? Gl(_, w, { configurable: !0, enumerable: !0, value: O, writable: !0 }) : _[w] = O;
      };
      var Oh = Object.prototype.hasOwnProperty;
      const Jl = function(_, w, O) {
        var G = _[w];
        Oh.call(_, w) && De(G, O) && (O !== void 0 || w in _) || Yl(_, w, O);
      }, Ys = function(_, w, O, G) {
        var Ce = !O;
        O || (O = {});
        for (var Re = -1, Ie = w.length; ++Re < Ie; ) {
          var Ve = w[Re], $t = G ? G(O[Ve], _[Ve], Ve, O, _) : void 0;
          $t === void 0 && ($t = _[Ve]), Ce ? Yl(O, Ve, $t) : Jl(O, Ve, $t);
        }
        return O;
      }, Mh = function(_, w) {
        for (var O = -1, G = Array(_); ++O < _; )
          G[O] = w(O);
        return G;
      }, us = function(_) {
        return ne(_) && te(_) == "[object Arguments]";
      };
      var Xl = Object.prototype, Js = Xl.hasOwnProperty, Nh = Xl.propertyIsEnumerable;
      const Dh = us(function() {
        return arguments;
      }()) ? us : function(_) {
        return ne(_) && Js.call(_, "callee") && !Nh.call(_, "callee");
      }, sa = Array.isArray, Zl = function() {
        return !1;
      };
      var oa = e && !e.nodeType && e, aa = oa && !0 && i && !i.nodeType && i, Ql = aa && aa.exports === oa ? A.Buffer : void 0;
      const ec = (Ql ? Ql.isBuffer : void 0) || Zl;
      var Bh = /^(?:0|[1-9]\d*)$/;
      const Vh = function(_, w) {
        var O = typeof _;
        return !!(w = w ?? 9007199254740991) && (O == "number" || O != "symbol" && Bh.test(_)) && _ > -1 && _ % 1 == 0 && _ < w;
      }, la = function(_) {
        return typeof _ == "number" && _ > -1 && _ % 1 == 0 && _ <= 9007199254740991;
      };
      var _t = {};
      _t["[object Float32Array]"] = _t["[object Float64Array]"] = _t["[object Int8Array]"] = _t["[object Int16Array]"] = _t["[object Int32Array]"] = _t["[object Uint8Array]"] = _t["[object Uint8ClampedArray]"] = _t["[object Uint16Array]"] = _t["[object Uint32Array]"] = !0, _t["[object Arguments]"] = _t["[object Array]"] = _t["[object ArrayBuffer]"] = _t["[object Boolean]"] = _t["[object DataView]"] = _t["[object Date]"] = _t["[object Error]"] = _t["[object Function]"] = _t["[object Map]"] = _t["[object Number]"] = _t["[object Object]"] = _t["[object RegExp]"] = _t["[object Set]"] = _t["[object String]"] = _t["[object WeakMap]"] = !1;
      const tc = function(_) {
        return ne(_) && la(_.length) && !!_t[te(_)];
      }, ds = function(_) {
        return function(w) {
          return _(w);
        };
      };
      var nc = e && !e.nodeType && e, zr = nc && !0 && i && !i.nodeType && i, Wr = zr && zr.exports === nc && N.process;
      const hr = function() {
        try {
          var _ = zr && zr.require && zr.require("util").types;
          return _ || Wr && Wr.binding && Wr.binding("util");
        } catch {
        }
      }();
      var ic = hr && hr.isTypedArray;
      const rc = ic ? ds(ic) : tc;
      var sc = Object.prototype.hasOwnProperty;
      const Xs = function(_, w) {
        var O = sa(_), G = !O && Dh(_), Ce = !O && !G && ec(_), Re = !O && !G && !Ce && rc(_), Ie = O || G || Ce || Re, Ve = Ie ? Mh(_.length, String) : [], $t = Ve.length;
        for (var Rt in _)
          !w && !sc.call(_, Rt) || Ie && (Rt == "length" || Ce && (Rt == "offset" || Rt == "parent") || Re && (Rt == "buffer" || Rt == "byteLength" || Rt == "byteOffset") || Vh(Rt, $t)) || Ve.push(Rt);
        return Ve;
      };
      var Lh = Object.prototype;
      const Zs = function(_) {
        var w = _ && _.constructor;
        return _ === (typeof w == "function" && w.prototype || Lh);
      }, Qs = function(_, w) {
        return function(O) {
          return _(w(O));
        };
      }, ca = Qs(Object.keys, Object);
      var jr = Object.prototype.hasOwnProperty;
      const oc = function(_) {
        if (!Zs(_))
          return ca(_);
        var w = [];
        for (var O in Object(_))
          jr.call(_, O) && O != "constructor" && w.push(O);
        return w;
      }, ua = function(_) {
        return _ != null && la(_.length) && !jn(_);
      }, da = function(_) {
        return ua(_) ? Xs(_) : oc(_);
      }, ac = function(_, w) {
        return _ && Ys(w, da(w), _);
      }, lc = function(_) {
        var w = [];
        if (_ != null)
          for (var O in Object(_))
            w.push(O);
        return w;
      };
      var cc = Object.prototype.hasOwnProperty;
      const uc = function(_) {
        if (!x(_))
          return lc(_);
        var w = Zs(_), O = [];
        for (var G in _)
          (G != "constructor" || !w && cc.call(_, G)) && O.push(G);
        return O;
      }, ha = function(_) {
        return ua(_) ? Xs(_, !0) : uc(_);
      }, Fh = function(_, w) {
        return _ && Ys(w, ha(w), _);
      };
      var dc = e && !e.nodeType && e, fa = dc && !0 && i && !i.nodeType && i, hc = fa && fa.exports === dc ? A.Buffer : void 0, fc = hc ? hc.allocUnsafe : void 0;
      const $h = function(_, w) {
        if (w)
          return _.slice();
        var O = _.length, G = fc ? fc(O) : new _.constructor(O);
        return _.copy(G), G;
      }, zh = function(_, w) {
        var O = -1, G = _.length;
        for (w || (w = Array(G)); ++O < G; )
          w[O] = _[O];
        return w;
      }, ma = function(_, w) {
        for (var O = -1, G = _ == null ? 0 : _.length, Ce = 0, Re = []; ++O < G; ) {
          var Ie = _[O];
          w(Ie, O, _) && (Re[Ce++] = Ie);
        }
        return Re;
      }, mc = function() {
        return [];
      };
      var Wh = Object.prototype.propertyIsEnumerable, gc = Object.getOwnPropertySymbols;
      const ga = gc ? function(_) {
        return _ == null ? [] : (_ = Object(_), ma(gc(_), function(w) {
          return Wh.call(_, w);
        }));
      } : mc, jh = function(_, w) {
        return Ys(_, ga(_), w);
      }, vt = function(_, w) {
        for (var O = -1, G = w.length, Ce = _.length; ++O < G; )
          _[Ce + O] = w[O];
        return _;
      }, rt = Qs(Object.getPrototypeOf, Object), pc = Object.getOwnPropertySymbols ? function(_) {
        for (var w = []; _; )
          vt(w, ga(_)), _ = rt(_);
        return w;
      } : mc, Uh = function(_, w) {
        return Ys(_, pc(_), w);
      }, _c = function(_, w, O) {
        var G = w(_);
        return sa(_) ? G : vt(G, O(_));
      }, Hh = function(_) {
        return _c(_, da, ga);
      }, qh = function(_) {
        return _c(_, ha, pc);
      }, pa = hn(A, "DataView"), eo = hn(A, "Promise"), _a = hn(A, "Set"), Zt = hn(A, "WeakMap");
      var to = "[object Map]", Hi = "[object Promise]", va = "[object Set]", no = "[object WeakMap]", Dn = "[object DataView]", vc = Mn(pa), wc = Mn(vn), bc = Mn(eo), yc = Mn(_a), Ec = Mn(Zt), qi = te;
      (pa && qi(new pa(new ArrayBuffer(1))) != Dn || vn && qi(new vn()) != to || eo && qi(eo.resolve()) != Hi || _a && qi(new _a()) != va || Zt && qi(new Zt()) != no) && (qi = function(_) {
        var w = te(_), O = w == "[object Object]" ? _.constructor : void 0, G = O ? Mn(O) : "";
        if (G)
          switch (G) {
            case vc:
              return Dn;
            case wc:
              return to;
            case bc:
              return Hi;
            case yc:
              return va;
            case Ec:
              return no;
          }
        return w;
      });
      const bn = qi;
      var Kh = Object.prototype.hasOwnProperty;
      const Hn = function(_) {
        var w = _.length, O = new _.constructor(w);
        return w && typeof _[0] == "string" && Kh.call(_, "index") && (O.index = _.index, O.input = _.input), O;
      }, Cc = A.Uint8Array, io = function(_) {
        var w = new _.constructor(_.byteLength);
        return new Cc(w).set(new Cc(_)), w;
      }, Ki = function(_, w) {
        var O = w ? io(_.buffer) : _.buffer;
        return new _.constructor(O, _.byteOffset, _.byteLength);
      };
      var ro = /\w*$/;
      const wa = function(_) {
        var w = new _.constructor(_.source, ro.exec(_));
        return w.lastIndex = _.lastIndex, w;
      };
      var yt = $ ? $.prototype : void 0, Oi = yt ? yt.valueOf : void 0;
      const ba = function(_) {
        return Oi ? Object(Oi.call(_)) : {};
      }, Gh = function(_, w) {
        var O = w ? io(_.buffer) : _.buffer;
        return new _.constructor(O, _.byteOffset, _.length);
      }, ya = function(_, w, O) {
        var G = _.constructor;
        switch (w) {
          case "[object ArrayBuffer]":
            return io(_);
          case "[object Boolean]":
          case "[object Date]":
            return new G(+_);
          case "[object DataView]":
            return Ki(_, O);
          case "[object Float32Array]":
          case "[object Float64Array]":
          case "[object Int8Array]":
          case "[object Int16Array]":
          case "[object Int32Array]":
          case "[object Uint8Array]":
          case "[object Uint8ClampedArray]":
          case "[object Uint16Array]":
          case "[object Uint32Array]":
            return Gh(_, O);
          case "[object Map]":
          case "[object Set]":
            return new G();
          case "[object Number]":
          case "[object String]":
            return new G(_);
          case "[object RegExp]":
            return wa(_);
          case "[object Symbol]":
            return ba(_);
        }
      };
      var Sc = Object.create;
      const Yh = function() {
        function _() {
        }
        return function(w) {
          if (!x(w))
            return {};
          if (Sc)
            return Sc(w);
          _.prototype = w;
          var O = new _();
          return _.prototype = void 0, O;
        };
      }(), Jh = function(_) {
        return typeof _.constructor != "function" || Zs(_) ? {} : Yh(rt(_));
      }, Tc = function(_) {
        return ne(_) && bn(_) == "[object Map]";
      };
      var hs = hr && hr.isMap;
      const Ur = hs ? ds(hs) : Tc, Xh = function(_) {
        return ne(_) && bn(_) == "[object Set]";
      };
      var Ea = hr && hr.isSet;
      const xc = Ea ? ds(Ea) : Xh;
      var so = "[object Arguments]", oo = "[object Function]", Ca = "[object Object]", wt = {};
      wt[so] = wt["[object Array]"] = wt["[object ArrayBuffer]"] = wt["[object DataView]"] = wt["[object Boolean]"] = wt["[object Date]"] = wt["[object Float32Array]"] = wt["[object Float64Array]"] = wt["[object Int8Array]"] = wt["[object Int16Array]"] = wt["[object Int32Array]"] = wt["[object Map]"] = wt["[object Number]"] = wt[Ca] = wt["[object RegExp]"] = wt["[object Set]"] = wt["[object String]"] = wt["[object Symbol]"] = wt["[object Uint8Array]"] = wt["[object Uint8ClampedArray]"] = wt["[object Uint16Array]"] = wt["[object Uint32Array]"] = !0, wt["[object Error]"] = wt[oo] = wt["[object WeakMap]"] = !1;
      const Sa = function _(w, O, G, Ce, Re, Ie) {
        var Ve, $t = 1 & O, Rt = 2 & O, ao = 4 & O;
        if (G && (Ve = Re ? G(w, Ce, Re, Ie) : G(w)), Ve !== void 0)
          return Ve;
        if (!x(w))
          return w;
        var mr = sa(w);
        if (mr) {
          if (Ve = Hn(w), !$t)
            return zh(w, Ve);
        } else {
          var _i = bn(w), ii = _i == oo || _i == "[object GeneratorFunction]";
          if (ec(w))
            return $h(w, $t);
          if (_i == Ca || _i == so || ii && !Re) {
            if (Ve = Rt || ii ? {} : Jh(w), !$t)
              return Rt ? Uh(w, Fh(Ve, w)) : jh(w, ac(Ve, w));
          } else {
            if (!wt[_i])
              return Re ? w : {};
            Ve = ya(w, _i, $t);
          }
        }
        Ie || (Ie = new Rh());
        var F = Ie.get(w);
        if (F)
          return F;
        Ie.set(w, Ve), xc(w) ? w.forEach(function(K) {
          Ve.add(_(K, O, G, K, w, Ie));
        }) : Ur(w) && w.forEach(function(K, pe) {
          Ve.set(pe, _(K, O, G, pe, w, Ie));
        });
        var Z = mr ? void 0 : (ao ? Rt ? qh : Hh : Rt ? ha : da)(w);
        return Kl(Z || w, function(K, pe) {
          Z && (K = w[pe = K]), Jl(Ve, pe, _(K, O, G, pe, w, Ie));
        }), Ve;
      }, Ta = function(_, w) {
        return Sa(_, 5, w = typeof w == "function" ? w : void 0);
      };
      var Zh = Function.prototype, kc = Object.prototype, Tn = Zh.toString, xa = kc.hasOwnProperty, fs = Tn.call(Object);
      const Ac = function(_) {
        if (!ne(_) || te(_) != "[object Object]")
          return !1;
        var w = rt(_);
        if (w === null)
          return !0;
        var O = xa.call(w, "constructor") && w.constructor;
        return typeof O == "function" && O instanceof O && Tn.call(O) == fs;
      }, Pc = function(_) {
        return ne(_) && _.nodeType === 1 && !Ac(_);
      };
      class Ic extends v {
        constructor(w, O = {}) {
          super(O), this._editor = null, this._throttledSave = Se(this._save.bind(this), typeof O.saveInterval == "number" ? O.saveInterval : 5e3), w && (this._creator = (G, Ce) => w.create(G, Ce)), this._destructor = (G) => G.destroy();
        }
        get editor() {
          return this._editor;
        }
        get _item() {
          return this._editor;
        }
        setCreator(w) {
          this._creator = w;
        }
        setDestructor(w) {
          this._destructor = w;
        }
        _restart() {
          return Promise.resolve().then(() => (this.state = "initializing", this._fire("stateChange"), this._destroy())).catch((w) => {
            console.error("An error happened during the editor destroying.", w);
          }).then(() => {
            if (typeof this._elementOrData == "string")
              return this.create(this._data, this._config, this._config.context);
            {
              const w = Object.assign({}, this._config, { initialData: this._data });
              return this.create(this._elementOrData, w, w.context);
            }
          }).then(() => {
            this._fire("restart");
          });
        }
        create(w = this._elementOrData, O = this._config, G) {
          return Promise.resolve().then(() => (super._startErrorHandling(), this._elementOrData = w, this._config = this._cloneEditorConfiguration(O) || {}, this._config.context = G, this._creator(w, this._config))).then((Ce) => {
            this._editor = Ce, Ce.model.document.on("change:data", this._throttledSave), this._lastDocumentVersion = Ce.model.document.version, this._data = this._getData(), this.state = "ready", this._fire("stateChange");
          });
        }
        destroy() {
          return Promise.resolve().then(() => (this.state = "destroyed", this._fire("stateChange"), super.destroy(), this._destroy()));
        }
        _destroy() {
          return Promise.resolve().then(() => {
            this._stopErrorHandling(), this._throttledSave.flush();
            const w = this._editor;
            return this._editor = null, w.model.document.off("change:data", this._throttledSave), this._destructor(w);
          });
        }
        _save() {
          const w = this._editor.model.document.version;
          try {
            this._data = this._getData(), this._lastDocumentVersion = w;
          } catch (O) {
            console.error(O, "An error happened during restoring editor data. Editor will be restored from the previously saved data.");
          }
        }
        _setExcludedProperties(w) {
          this._excludedProps = w;
        }
        _getData() {
          const w = {};
          for (const O of this._editor.model.document.getRootNames())
            w[O] = this._editor.data.get({ rootName: O });
          return w;
        }
        _isErrorComingFromThisItem(w) {
          return S(this._editor, w.context, this._excludedProps);
        }
        _cloneEditorConfiguration(w) {
          return Ta(w, (O, G) => Pc(O) || G === "context" ? O : void 0);
        }
      }
      const ms = Symbol("MainQueueId");
      class Rc extends v {
        constructor(w, O = {}) {
          super(O), this._watchdogs = /* @__PURE__ */ new Map(), this._context = null, this._contextProps = /* @__PURE__ */ new Set(), this._actionQueues = new Qh(), this._watchdogConfig = O, this._creator = (G) => w.create(G), this._destructor = (G) => G.destroy(), this._actionQueues.onEmpty(() => {
            this.state === "initializing" && (this.state = "ready", this._fire("stateChange"));
          });
        }
        setCreator(w) {
          this._creator = w;
        }
        setDestructor(w) {
          this._destructor = w;
        }
        get context() {
          return this._context;
        }
        create(w = {}) {
          return this._actionQueues.enqueue(ms, () => (this._contextConfig = w, this._create()));
        }
        getItem(w) {
          return this._getWatchdog(w)._item;
        }
        getItemState(w) {
          return this._getWatchdog(w).state;
        }
        add(w) {
          const O = Oc(w);
          return Promise.all(O.map((G) => this._actionQueues.enqueue(G.id, () => {
            if (this.state === "destroyed")
              throw new Error("Cannot add items to destroyed watchdog.");
            if (!this._context)
              throw new Error("Context was not created yet. You should call the `ContextWatchdog#create()` method first.");
            let Ce;
            if (this._watchdogs.has(G.id))
              throw new Error(`Item with the given id is already added: '${G.id}'.`);
            if (G.type === "editor")
              return Ce = new Ic(null, this._watchdogConfig), Ce.setCreator(G.creator), Ce._setExcludedProperties(this._contextProps), G.destructor && Ce.setDestructor(G.destructor), this._watchdogs.set(G.id, Ce), Ce.on("error", (Re, { error: Ie, causesRestart: Ve }) => {
                this._fire("itemError", { itemId: G.id, error: Ie }), Ve && this._actionQueues.enqueue(G.id, () => new Promise(($t) => {
                  const Rt = () => {
                    Ce.off("restart", Rt), this._fire("itemRestart", { itemId: G.id }), $t();
                  };
                  Ce.on("restart", Rt);
                }));
              }), Ce.create(G.sourceElementOrData, G.config, this._context);
            throw new Error(`Not supported item type: '${G.type}'.`);
          })));
        }
        remove(w) {
          const O = Oc(w);
          return Promise.all(O.map((G) => this._actionQueues.enqueue(G, () => {
            const Ce = this._getWatchdog(G);
            return this._watchdogs.delete(G), Ce.destroy();
          })));
        }
        destroy() {
          return this._actionQueues.enqueue(ms, () => (this.state = "destroyed", this._fire("stateChange"), super.destroy(), this._destroy()));
        }
        _restart() {
          return this._actionQueues.enqueue(ms, () => (this.state = "initializing", this._fire("stateChange"), this._destroy().catch((w) => {
            console.error("An error happened during destroying the context or items.", w);
          }).then(() => this._create()).then(() => this._fire("restart"))));
        }
        _create() {
          return Promise.resolve().then(() => (this._startErrorHandling(), this._creator(this._contextConfig))).then((w) => (this._context = w, this._contextProps = C(this._context), Promise.all(Array.from(this._watchdogs.values()).map((O) => (O._setExcludedProperties(this._contextProps), O.create(void 0, void 0, this._context))))));
        }
        _destroy() {
          return Promise.resolve().then(() => {
            this._stopErrorHandling();
            const w = this._context;
            return this._context = null, this._contextProps = /* @__PURE__ */ new Set(), Promise.all(Array.from(this._watchdogs.values()).map((O) => O.destroy())).then(() => this._destructor(w));
          });
        }
        _getWatchdog(w) {
          const O = this._watchdogs.get(w);
          if (!O)
            throw new Error(`Item with the given id was not registered: ${w}.`);
          return O;
        }
        _isErrorComingFromThisItem(w) {
          for (const O of this._watchdogs.values())
            if (O._isErrorComingFromThisItem(w))
              return !1;
          return S(this._context, w.context);
        }
      }
      class Qh {
        constructor() {
          this._onEmptyCallbacks = [], this._queues = /* @__PURE__ */ new Map(), this._activeActions = 0;
        }
        onEmpty(w) {
          this._onEmptyCallbacks.push(w);
        }
        enqueue(w, O) {
          const G = w === ms;
          this._activeActions++, this._queues.get(w) || this._queues.set(w, Promise.resolve());
          const Ce = (G ? Promise.all(this._queues.values()) : Promise.all([this._queues.get(ms), this._queues.get(w)])).then(O), Re = Ce.catch(() => {
          });
          return this._queues.set(w, Re), Ce.finally(() => {
            this._activeActions--, this._queues.get(w) === Re && this._activeActions === 0 && this._onEmptyCallbacks.forEach((Ie) => Ie());
          });
        }
      }
      function Oc(_) {
        return Array.isArray(_) ? _ : [_];
      }
      const fr = u().createContext("contextWatchdog");
      class ka extends u().Component {
        constructor(w, O) {
          super(w, O), this.contextWatchdog = null, this.props.isLayoutReady && this._initializeContextWatchdog(this.props.config);
        }
        shouldComponentUpdate(w) {
          return this._shouldComponentUpdate(w);
        }
        async _shouldComponentUpdate(w) {
          return w.id !== this.props.id && (this.contextWatchdog && await this.contextWatchdog.destroy(), await this._initializeContextWatchdog(w.config)), w.isLayoutReady && !this.contextWatchdog ? (await this._initializeContextWatchdog(w.config), !0) : this.props.children !== w.children;
        }
        render() {
          return u().createElement(fr.Provider, { value: this.contextWatchdog }, this.props.children);
        }
        componentWillUnmount() {
          this._destroyContext();
        }
        async _initializeContextWatchdog(w) {
          this.contextWatchdog = new Rc(this.props.context, this.props.watchdogConfig), this.contextWatchdog.on("error", (O, G) => {
            this.props.onError(G.error, { phase: "runtime", willContextRestart: G.causesRestart });
          }), this.contextWatchdog.on("stateChange", () => {
            this.contextWatchdog.state === "ready" && this.props.onReady && this.props.onReady(this.contextWatchdog.context);
          }), await this.contextWatchdog.create(w).catch((O) => {
            this.props.onError(O, { phase: "initialization", willContextRestart: !1 });
          });
        }
        async _destroyContext() {
          this.contextWatchdog && (await this.contextWatchdog.destroy(), this.contextWatchdog = null);
        }
      }
      ka.defaultProps = { isLayoutReady: !0, onError: (_, w) => console.error(_, w) }, ka.propTypes = { id: f().string, isLayoutReady: f().bool, context: f().func, watchdogConfig: f().object, config: f().object, onReady: f().func, onError: f().func };
      const Aa = "Lock from React integration (@ckeditor/ckeditor5-react)";
      class Gi extends u().Component {
        constructor(w) {
          super(w), this.editorDestructionInProgress = null, this.domContainer = u().createRef(), this.watchdog = null;
          const { CKEDITOR_VERSION: O } = window;
          if (O) {
            const [G] = O.split(".").map(Number);
            G < 37 && console.warn("The <CKEditor> component requires using CKEditor 5 in version 37 or higher.");
          } else
            console.warn('Cannot find the "CKEDITOR_VERSION" in the "window" scope.');
        }
        get editor() {
          return this.watchdog ? this.watchdog.editor : null;
        }
        shouldComponentUpdate(w) {
          return !!this.editor && (w.id !== this.props.id || (this._shouldUpdateEditor(w) && this.editor.data.set(w.data), "disabled" in w && (w.disabled ? this.editor.enableReadOnlyMode(Aa) : this.editor.disableReadOnlyMode(Aa)), !1));
        }
        async componentDidMount() {
          await this._initializeEditor();
        }
        async componentDidUpdate() {
          await this._destroyEditor(), await this._initializeEditor();
        }
        async componentWillUnmount() {
          await this._destroyEditor();
        }
        render() {
          return u().createElement("div", { ref: this.domContainer });
        }
        async _initializeEditor() {
          await this.editorDestructionInProgress, this.watchdog || (this.context instanceof Rc ? this.watchdog = new Mc(this.context) : this.watchdog = new Gi._EditorWatchdog(this.props.editor, this.props.watchdogConfig), this.watchdog.setCreator((w, O) => this._createEditor(w, O)), this.watchdog.on("error", (w, { error: O, causesRestart: G }) => {
            (this.props.onError || console.error)(O, { phase: "runtime", willEditorRestart: G });
          }), await this.watchdog.create(this.domContainer.current, this._getConfig()).catch((w) => {
            (this.props.onError || console.error)(w, { phase: "initialization", willEditorRestart: !1 });
          }));
        }
        _createEditor(w, O) {
          return this.props.editor.create(w, O).then((G) => {
            "disabled" in this.props && this.props.disabled && G.enableReadOnlyMode(Aa);
            const Ce = G.model.document, Re = G.editing.view.document;
            return Ce.on("change:data", (Ie) => {
              this.props.onChange && this.props.onChange(Ie, G);
            }), Re.on("focus", (Ie) => {
              this.props.onFocus && this.props.onFocus(Ie, G);
            }), Re.on("blur", (Ie) => {
              this.props.onBlur && this.props.onBlur(Ie, G);
            }), setTimeout(() => {
              this.props.onReady && this.props.onReady(G);
            }), G;
          });
        }
        async _destroyEditor() {
          this.editorDestructionInProgress = new Promise((w) => {
            setTimeout(() => {
              this.watchdog ? this.watchdog.destroy().then(() => {
                this.watchdog = null, w();
              }) : w();
            });
          });
        }
        _shouldUpdateEditor(w) {
          return this.props.data !== w.data && this.editor.data.get() !== w.data;
        }
        _getConfig() {
          const w = this.props.config || {};
          return this.props.data && w.initialData && console.warn("Editor data should be provided either using `config.initialData` or `data` properties. The config property is over the data value and the first one will be used when specified both."), { ...w, initialData: w.initialData || this.props.data || "" };
        }
      }
      Gi.contextType = fr, Gi.propTypes = { editor: f().func.isRequired, data: f().string, config: f().object, watchdogConfig: f().object, onChange: f().func, onReady: f().func, onFocus: f().func, onBlur: f().func, onError: f().func, disabled: f().bool, id: f().any }, Gi._EditorWatchdog = Ic;
      class Mc {
        constructor(w) {
          this._contextWatchdog = w, this._id = function() {
            const O = 4294967296 * Math.random() >>> 0, G = 4294967296 * Math.random() >>> 0, Ce = 4294967296 * Math.random() >>> 0, Re = 4294967296 * Math.random() >>> 0;
            return "e" + m[O >> 0 & 255] + m[O >> 8 & 255] + m[O >> 16 & 255] + m[O >> 24 & 255] + m[G >> 0 & 255] + m[G >> 8 & 255] + m[G >> 16 & 255] + m[G >> 24 & 255] + m[Ce >> 0 & 255] + m[Ce >> 8 & 255] + m[Ce >> 16 & 255] + m[Ce >> 24 & 255] + m[Re >> 0 & 255] + m[Re >> 8 & 255] + m[Re >> 16 & 255] + m[Re >> 24 & 255];
          }();
        }
        setCreator(w) {
          this._creator = w;
        }
        create(w, O) {
          return this._contextWatchdog.add({ sourceElementOrData: w, config: O, creator: this._creator, id: this._id, type: "editor" });
        }
        on(w, O) {
          this._contextWatchdog.on("itemError", (G, { itemId: Ce, error: Re }) => {
            Ce === this._id && O(null, { error: Re, causesRestart: void 0 });
          });
        }
        destroy() {
          return this._contextWatchdog.state === "ready" ? this._contextWatchdog.remove(this._id) : Promise.resolve();
        }
        get editor() {
          return this._contextWatchdog.getItem(this._id);
        }
      }
    })(), o;
  })());
})(qP, sd);
var od = {}, KP = {
  get exports() {
    return od;
  },
  set exports(i) {
    od = i;
  }
};
/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
(function(i, e) {
  (function() {
    var t, n = "4.17.21", r = 200, s = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", o = "Expected a function", l = "Invalid `variable` option passed into `_.template`", u = "__lodash_hash_undefined__", h = 500, f = "__lodash_placeholder__", m = 1, v = 2, C = 4, k = 1, S = 2, x = 1, N = 2, y = 4, A = 8, P = 16, E = 32, V = 64, j = 128, U = 256, $ = 512, M = 30, D = "...", J = 800, H = 16, Y = 1, le = 2, me = 3, ee = 1 / 0, te = 9007199254740991, ne = 17976931348623157e292, z = 0 / 0, se = 4294967295, ve = se - 1, ue = se >>> 1, ce = [
      ["ary", j],
      ["bind", x],
      ["bindKey", N],
      ["curry", A],
      ["curryRight", P],
      ["flip", $],
      ["partial", E],
      ["partialRight", V],
      ["rearg", U]
    ], he = "[object Arguments]", be = "[object Array]", Ee = "[object AsyncFunction]", Pe = "[object Boolean]", Se = "[object Date]", ye = "[object DOMException]", De = "[object Error]", q = "[object Function]", Ze = "[object GeneratorFunction]", de = "[object Map]", Ye = "[object Number]", nn = "[object Null]", rn = "[object Object]", Qn = "[object Promise]", zn = "[object Proxy]", Jt = "[object RegExp]", sn = "[object Set]", Wn = "[object String]", gi = "[object Symbol]", jn = "[object Undefined]", Un = "[object WeakMap]", dn = "[object WeakSet]", on = "[object ArrayBuffer]", On = "[object DataView]", Mn = "[object Float32Array]", I = "[object Float64Array]", ge = "[object Int8Array]", xe = "[object Int16Array]", Be = "[object Int32Array]", Fe = "[object Uint8Array]", an = "[object Uint8ClampedArray]", _n = "[object Uint16Array]", Xt = "[object Uint32Array]", hn = /\b__p \+= '';/g, vn = /\b(__p \+=) '' \+/g, Cn = /(__e\(.*?\)|\b__t\)) \+\n'';/g, ln = /&(?:amp|lt|gt|quot|#39);/g, pi = /[&<>"']/g, Ui = RegExp(ln.source), ei = RegExp(pi.source), Nn = /<%-([\s\S]+?)%>/g, Vr = /<%([\s\S]+?)%>/g, Sn = /<%=([\s\S]+?)%>/g, Ft = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, ti = /^\w*$/, Lr = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, ni = /[\\^$.*+?()[\]{}|]/g, wn = RegExp(ni.source), ft = /^\s+/, xh = /\s/, kh = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, Ah = /\{\n\/\* \[wrapped with (.+)\] \*/, Fr = /,? & /, Ph = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g, Ih = /[()=,{}\[\]\/\s]/, $r = /\\(\\)?/g, Rh = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g, Kl = /\w*$/, Gl = /^[-+]0x[0-9a-f]+$/i, Yl = /^0b[01]+$/i, Oh = /^\[object .+?Constructor\]$/, Jl = /^0o[0-7]+$/i, Ys = /^(?:0|[1-9]\d*)$/, Mh = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g, us = /($^)/, Xl = /['\n\r\u2028\u2029\\]/g, Js = "\\ud800-\\udfff", Nh = "\\u0300-\\u036f", Dh = "\\ufe20-\\ufe2f", sa = "\\u20d0-\\u20ff", Zl = Nh + Dh + sa, oa = "\\u2700-\\u27bf", aa = "a-z\\xdf-\\xf6\\xf8-\\xff", Ql = "\\xac\\xb1\\xd7\\xf7", ec = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", Bh = "\\u2000-\\u206f", Vh = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", la = "A-Z\\xc0-\\xd6\\xd8-\\xde", _t = "\\ufe0e\\ufe0f", tc = Ql + ec + Bh + Vh, ds = "['’]", nc = "[" + Js + "]", zr = "[" + tc + "]", Wr = "[" + Zl + "]", hr = "\\d+", ic = "[" + oa + "]", rc = "[" + aa + "]", sc = "[^" + Js + tc + hr + oa + aa + la + "]", Xs = "\\ud83c[\\udffb-\\udfff]", Lh = "(?:" + Wr + "|" + Xs + ")", Zs = "[^" + Js + "]", Qs = "(?:\\ud83c[\\udde6-\\uddff]){2}", ca = "[\\ud800-\\udbff][\\udc00-\\udfff]", jr = "[" + la + "]", oc = "\\u200d", ua = "(?:" + rc + "|" + sc + ")", da = "(?:" + jr + "|" + sc + ")", ac = "(?:" + ds + "(?:d|ll|m|re|s|t|ve))?", lc = "(?:" + ds + "(?:D|LL|M|RE|S|T|VE))?", cc = Lh + "?", uc = "[" + _t + "]?", ha = "(?:" + oc + "(?:" + [Zs, Qs, ca].join("|") + ")" + uc + cc + ")*", Fh = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", dc = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", fa = uc + cc + ha, hc = "(?:" + [ic, Qs, ca].join("|") + ")" + fa, fc = "(?:" + [Zs + Wr + "?", Wr, Qs, ca, nc].join("|") + ")", $h = RegExp(ds, "g"), zh = RegExp(Wr, "g"), ma = RegExp(Xs + "(?=" + Xs + ")|" + fc + fa, "g"), mc = RegExp([
      jr + "?" + rc + "+" + ac + "(?=" + [zr, jr, "$"].join("|") + ")",
      da + "+" + lc + "(?=" + [zr, jr + ua, "$"].join("|") + ")",
      jr + "?" + ua + "+" + ac,
      jr + "+" + lc,
      dc,
      Fh,
      hr,
      hc
    ].join("|"), "g"), Wh = RegExp("[" + oc + Js + Zl + _t + "]"), gc = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/, ga = [
      "Array",
      "Buffer",
      "DataView",
      "Date",
      "Error",
      "Float32Array",
      "Float64Array",
      "Function",
      "Int8Array",
      "Int16Array",
      "Int32Array",
      "Map",
      "Math",
      "Object",
      "Promise",
      "RegExp",
      "Set",
      "String",
      "Symbol",
      "TypeError",
      "Uint8Array",
      "Uint8ClampedArray",
      "Uint16Array",
      "Uint32Array",
      "WeakMap",
      "_",
      "clearTimeout",
      "isFinite",
      "parseInt",
      "setTimeout"
    ], jh = -1, vt = {};
    vt[Mn] = vt[I] = vt[ge] = vt[xe] = vt[Be] = vt[Fe] = vt[an] = vt[_n] = vt[Xt] = !0, vt[he] = vt[be] = vt[on] = vt[Pe] = vt[On] = vt[Se] = vt[De] = vt[q] = vt[de] = vt[Ye] = vt[rn] = vt[Jt] = vt[sn] = vt[Wn] = vt[Un] = !1;
    var rt = {};
    rt[he] = rt[be] = rt[on] = rt[On] = rt[Pe] = rt[Se] = rt[Mn] = rt[I] = rt[ge] = rt[xe] = rt[Be] = rt[de] = rt[Ye] = rt[rn] = rt[Jt] = rt[sn] = rt[Wn] = rt[gi] = rt[Fe] = rt[an] = rt[_n] = rt[Xt] = !0, rt[De] = rt[q] = rt[Un] = !1;
    var pc = {
      // Latin-1 Supplement block.
      À: "A",
      Á: "A",
      Â: "A",
      Ã: "A",
      Ä: "A",
      Å: "A",
      à: "a",
      á: "a",
      â: "a",
      ã: "a",
      ä: "a",
      å: "a",
      Ç: "C",
      ç: "c",
      Ð: "D",
      ð: "d",
      È: "E",
      É: "E",
      Ê: "E",
      Ë: "E",
      è: "e",
      é: "e",
      ê: "e",
      ë: "e",
      Ì: "I",
      Í: "I",
      Î: "I",
      Ï: "I",
      ì: "i",
      í: "i",
      î: "i",
      ï: "i",
      Ñ: "N",
      ñ: "n",
      Ò: "O",
      Ó: "O",
      Ô: "O",
      Õ: "O",
      Ö: "O",
      Ø: "O",
      ò: "o",
      ó: "o",
      ô: "o",
      õ: "o",
      ö: "o",
      ø: "o",
      Ù: "U",
      Ú: "U",
      Û: "U",
      Ü: "U",
      ù: "u",
      ú: "u",
      û: "u",
      ü: "u",
      Ý: "Y",
      ý: "y",
      ÿ: "y",
      Æ: "Ae",
      æ: "ae",
      Þ: "Th",
      þ: "th",
      ß: "ss",
      // Latin Extended-A block.
      Ā: "A",
      Ă: "A",
      Ą: "A",
      ā: "a",
      ă: "a",
      ą: "a",
      Ć: "C",
      Ĉ: "C",
      Ċ: "C",
      Č: "C",
      ć: "c",
      ĉ: "c",
      ċ: "c",
      č: "c",
      Ď: "D",
      Đ: "D",
      ď: "d",
      đ: "d",
      Ē: "E",
      Ĕ: "E",
      Ė: "E",
      Ę: "E",
      Ě: "E",
      ē: "e",
      ĕ: "e",
      ė: "e",
      ę: "e",
      ě: "e",
      Ĝ: "G",
      Ğ: "G",
      Ġ: "G",
      Ģ: "G",
      ĝ: "g",
      ğ: "g",
      ġ: "g",
      ģ: "g",
      Ĥ: "H",
      Ħ: "H",
      ĥ: "h",
      ħ: "h",
      Ĩ: "I",
      Ī: "I",
      Ĭ: "I",
      Į: "I",
      İ: "I",
      ĩ: "i",
      ī: "i",
      ĭ: "i",
      į: "i",
      ı: "i",
      Ĵ: "J",
      ĵ: "j",
      Ķ: "K",
      ķ: "k",
      ĸ: "k",
      Ĺ: "L",
      Ļ: "L",
      Ľ: "L",
      Ŀ: "L",
      Ł: "L",
      ĺ: "l",
      ļ: "l",
      ľ: "l",
      ŀ: "l",
      ł: "l",
      Ń: "N",
      Ņ: "N",
      Ň: "N",
      Ŋ: "N",
      ń: "n",
      ņ: "n",
      ň: "n",
      ŋ: "n",
      Ō: "O",
      Ŏ: "O",
      Ő: "O",
      ō: "o",
      ŏ: "o",
      ő: "o",
      Ŕ: "R",
      Ŗ: "R",
      Ř: "R",
      ŕ: "r",
      ŗ: "r",
      ř: "r",
      Ś: "S",
      Ŝ: "S",
      Ş: "S",
      Š: "S",
      ś: "s",
      ŝ: "s",
      ş: "s",
      š: "s",
      Ţ: "T",
      Ť: "T",
      Ŧ: "T",
      ţ: "t",
      ť: "t",
      ŧ: "t",
      Ũ: "U",
      Ū: "U",
      Ŭ: "U",
      Ů: "U",
      Ű: "U",
      Ų: "U",
      ũ: "u",
      ū: "u",
      ŭ: "u",
      ů: "u",
      ű: "u",
      ų: "u",
      Ŵ: "W",
      ŵ: "w",
      Ŷ: "Y",
      ŷ: "y",
      Ÿ: "Y",
      Ź: "Z",
      Ż: "Z",
      Ž: "Z",
      ź: "z",
      ż: "z",
      ž: "z",
      Ĳ: "IJ",
      ĳ: "ij",
      Œ: "Oe",
      œ: "oe",
      ŉ: "'n",
      ſ: "s"
    }, Uh = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#39;"
    }, _c = {
      "&amp;": "&",
      "&lt;": "<",
      "&gt;": ">",
      "&quot;": '"',
      "&#39;": "'"
    }, Hh = {
      "\\": "\\",
      "'": "'",
      "\n": "n",
      "\r": "r",
      "\u2028": "u2028",
      "\u2029": "u2029"
    }, qh = parseFloat, pa = parseInt, eo = typeof et == "object" && et && et.Object === Object && et, _a = typeof self == "object" && self && self.Object === Object && self, Zt = eo || _a || Function("return this")(), to = e && !e.nodeType && e, Hi = to && !0 && i && !i.nodeType && i, va = Hi && Hi.exports === to, no = va && eo.process, Dn = function() {
      try {
        var F = Hi && Hi.require && Hi.require("util").types;
        return F || no && no.binding && no.binding("util");
      } catch {
      }
    }(), vc = Dn && Dn.isArrayBuffer, wc = Dn && Dn.isDate, bc = Dn && Dn.isMap, yc = Dn && Dn.isRegExp, Ec = Dn && Dn.isSet, qi = Dn && Dn.isTypedArray;
    function bn(F, Z, K) {
      switch (K.length) {
        case 0:
          return F.call(Z);
        case 1:
          return F.call(Z, K[0]);
        case 2:
          return F.call(Z, K[0], K[1]);
        case 3:
          return F.call(Z, K[0], K[1], K[2]);
      }
      return F.apply(Z, K);
    }
    function Kh(F, Z, K, pe) {
      for (var ke = -1, $e = F == null ? 0 : F.length; ++ke < $e; ) {
        var Et = F[ke];
        Z(pe, Et, K(Et), F);
      }
      return pe;
    }
    function Hn(F, Z) {
      for (var K = -1, pe = F == null ? 0 : F.length; ++K < pe && Z(F[K], K, F) !== !1; )
        ;
      return F;
    }
    function Cc(F, Z) {
      for (var K = F == null ? 0 : F.length; K-- && Z(F[K], K, F) !== !1; )
        ;
      return F;
    }
    function io(F, Z) {
      for (var K = -1, pe = F == null ? 0 : F.length; ++K < pe; )
        if (!Z(F[K], K, F))
          return !1;
      return !0;
    }
    function Ki(F, Z) {
      for (var K = -1, pe = F == null ? 0 : F.length, ke = 0, $e = []; ++K < pe; ) {
        var Et = F[K];
        Z(Et, K, F) && ($e[ke++] = Et);
      }
      return $e;
    }
    function ro(F, Z) {
      var K = F == null ? 0 : F.length;
      return !!K && Ur(F, Z, 0) > -1;
    }
    function wa(F, Z, K) {
      for (var pe = -1, ke = F == null ? 0 : F.length; ++pe < ke; )
        if (K(Z, F[pe]))
          return !0;
      return !1;
    }
    function yt(F, Z) {
      for (var K = -1, pe = F == null ? 0 : F.length, ke = Array(pe); ++K < pe; )
        ke[K] = Z(F[K], K, F);
      return ke;
    }
    function Oi(F, Z) {
      for (var K = -1, pe = Z.length, ke = F.length; ++K < pe; )
        F[ke + K] = Z[K];
      return F;
    }
    function ba(F, Z, K, pe) {
      var ke = -1, $e = F == null ? 0 : F.length;
      for (pe && $e && (K = F[++ke]); ++ke < $e; )
        K = Z(K, F[ke], ke, F);
      return K;
    }
    function Gh(F, Z, K, pe) {
      var ke = F == null ? 0 : F.length;
      for (pe && ke && (K = F[--ke]); ke--; )
        K = Z(K, F[ke], ke, F);
      return K;
    }
    function ya(F, Z) {
      for (var K = -1, pe = F == null ? 0 : F.length; ++K < pe; )
        if (Z(F[K], K, F))
          return !0;
      return !1;
    }
    var Sc = so("length");
    function Yh(F) {
      return F.split("");
    }
    function Jh(F) {
      return F.match(Ph) || [];
    }
    function Tc(F, Z, K) {
      var pe;
      return K(F, function(ke, $e, Et) {
        if (Z(ke, $e, Et))
          return pe = $e, !1;
      }), pe;
    }
    function hs(F, Z, K, pe) {
      for (var ke = F.length, $e = K + (pe ? 1 : -1); pe ? $e-- : ++$e < ke; )
        if (Z(F[$e], $e, F))
          return $e;
      return -1;
    }
    function Ur(F, Z, K) {
      return Z === Z ? G(F, Z, K) : hs(F, Ea, K);
    }
    function Xh(F, Z, K, pe) {
      for (var ke = K - 1, $e = F.length; ++ke < $e; )
        if (pe(F[ke], Z))
          return ke;
      return -1;
    }
    function Ea(F) {
      return F !== F;
    }
    function xc(F, Z) {
      var K = F == null ? 0 : F.length;
      return K ? Sa(F, Z) / K : z;
    }
    function so(F) {
      return function(Z) {
        return Z == null ? t : Z[F];
      };
    }
    function oo(F) {
      return function(Z) {
        return F == null ? t : F[Z];
      };
    }
    function Ca(F, Z, K, pe, ke) {
      return ke(F, function($e, Et, Ct) {
        K = pe ? (pe = !1, $e) : Z(K, $e, Et, Ct);
      }), K;
    }
    function wt(F, Z) {
      var K = F.length;
      for (F.sort(Z); K--; )
        F[K] = F[K].value;
      return F;
    }
    function Sa(F, Z) {
      for (var K, pe = -1, ke = F.length; ++pe < ke; ) {
        var $e = Z(F[pe]);
        $e !== t && (K = K === t ? $e : K + $e);
      }
      return K;
    }
    function Ta(F, Z) {
      for (var K = -1, pe = Array(F); ++K < F; )
        pe[K] = Z(K);
      return pe;
    }
    function Zh(F, Z) {
      return yt(Z, function(K) {
        return [K, F[K]];
      });
    }
    function kc(F) {
      return F && F.slice(0, Ve(F) + 1).replace(ft, "");
    }
    function Tn(F) {
      return function(Z) {
        return F(Z);
      };
    }
    function xa(F, Z) {
      return yt(Z, function(K) {
        return F[K];
      });
    }
    function fs(F, Z) {
      return F.has(Z);
    }
    function Ac(F, Z) {
      for (var K = -1, pe = F.length; ++K < pe && Ur(Z, F[K], 0) > -1; )
        ;
      return K;
    }
    function Pc(F, Z) {
      for (var K = F.length; K-- && Ur(Z, F[K], 0) > -1; )
        ;
      return K;
    }
    function Ic(F, Z) {
      for (var K = F.length, pe = 0; K--; )
        F[K] === Z && ++pe;
      return pe;
    }
    var ms = oo(pc), Rc = oo(Uh);
    function Qh(F) {
      return "\\" + Hh[F];
    }
    function Oc(F, Z) {
      return F == null ? t : F[Z];
    }
    function fr(F) {
      return Wh.test(F);
    }
    function ka(F) {
      return gc.test(F);
    }
    function Aa(F) {
      for (var Z, K = []; !(Z = F.next()).done; )
        K.push(Z.value);
      return K;
    }
    function Gi(F) {
      var Z = -1, K = Array(F.size);
      return F.forEach(function(pe, ke) {
        K[++Z] = [ke, pe];
      }), K;
    }
    function Mc(F, Z) {
      return function(K) {
        return F(Z(K));
      };
    }
    function _(F, Z) {
      for (var K = -1, pe = F.length, ke = 0, $e = []; ++K < pe; ) {
        var Et = F[K];
        (Et === Z || Et === f) && (F[K] = f, $e[ke++] = K);
      }
      return $e;
    }
    function w(F) {
      var Z = -1, K = Array(F.size);
      return F.forEach(function(pe) {
        K[++Z] = pe;
      }), K;
    }
    function O(F) {
      var Z = -1, K = Array(F.size);
      return F.forEach(function(pe) {
        K[++Z] = [pe, pe];
      }), K;
    }
    function G(F, Z, K) {
      for (var pe = K - 1, ke = F.length; ++pe < ke; )
        if (F[pe] === Z)
          return pe;
      return -1;
    }
    function Ce(F, Z, K) {
      for (var pe = K + 1; pe--; )
        if (F[pe] === Z)
          return pe;
      return pe;
    }
    function Re(F) {
      return fr(F) ? Rt(F) : Sc(F);
    }
    function Ie(F) {
      return fr(F) ? ao(F) : Yh(F);
    }
    function Ve(F) {
      for (var Z = F.length; Z-- && xh.test(F.charAt(Z)); )
        ;
      return Z;
    }
    var $t = oo(_c);
    function Rt(F) {
      for (var Z = ma.lastIndex = 0; ma.test(F); )
        ++Z;
      return Z;
    }
    function ao(F) {
      return F.match(ma) || [];
    }
    function mr(F) {
      return F.match(mc) || [];
    }
    var _i = function F(Z) {
      Z = Z == null ? Zt : ii.defaults(Zt.Object(), Z, ii.pick(Zt, ga));
      var K = Z.Array, pe = Z.Date, ke = Z.Error, $e = Z.Function, Et = Z.Math, Ct = Z.Object, ef = Z.RegExp, NS = Z.String, wi = Z.TypeError, Nc = K.prototype, DS = $e.prototype, lo = Ct.prototype, Dc = Z["__core-js_shared__"], Bc = DS.toString, mt = lo.hasOwnProperty, BS = 0, Vp = function() {
        var a = /[^.]+$/.exec(Dc && Dc.keys && Dc.keys.IE_PROTO || "");
        return a ? "Symbol(src)_1." + a : "";
      }(), Vc = lo.toString, VS = Bc.call(Ct), LS = Zt._, FS = ef(
        "^" + Bc.call(mt).replace(ni, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
      ), Lc = va ? Z.Buffer : t, Hr = Z.Symbol, Fc = Z.Uint8Array, Lp = Lc ? Lc.allocUnsafe : t, $c = Mc(Ct.getPrototypeOf, Ct), Fp = Ct.create, $p = lo.propertyIsEnumerable, zc = Nc.splice, zp = Hr ? Hr.isConcatSpreadable : t, Pa = Hr ? Hr.iterator : t, gs = Hr ? Hr.toStringTag : t, Wc = function() {
        try {
          var a = bs(Ct, "defineProperty");
          return a({}, "", {}), a;
        } catch {
        }
      }(), $S = Z.clearTimeout !== Zt.clearTimeout && Z.clearTimeout, zS = pe && pe.now !== Zt.Date.now && pe.now, WS = Z.setTimeout !== Zt.setTimeout && Z.setTimeout, jc = Et.ceil, Uc = Et.floor, tf = Ct.getOwnPropertySymbols, jS = Lc ? Lc.isBuffer : t, Wp = Z.isFinite, US = Nc.join, HS = Mc(Ct.keys, Ct), cn = Et.max, xn = Et.min, qS = pe.now, KS = Z.parseInt, jp = Et.random, GS = Nc.reverse, nf = bs(Z, "DataView"), Ia = bs(Z, "Map"), rf = bs(Z, "Promise"), co = bs(Z, "Set"), Ra = bs(Z, "WeakMap"), Oa = bs(Ct, "create"), Hc = Ra && new Ra(), uo = {}, YS = ys(nf), JS = ys(Ia), XS = ys(rf), ZS = ys(co), QS = ys(Ra), qc = Hr ? Hr.prototype : t, Ma = qc ? qc.valueOf : t, Up = qc ? qc.toString : t;
      function b(a) {
        if (Wt(a) && !Le(a) && !(a instanceof Je)) {
          if (a instanceof bi)
            return a;
          if (mt.call(a, "__wrapped__"))
            return H_(a);
        }
        return new bi(a);
      }
      var ho = function() {
        function a() {
        }
        return function(c) {
          if (!zt(c))
            return {};
          if (Fp)
            return Fp(c);
          a.prototype = c;
          var d = new a();
          return a.prototype = t, d;
        };
      }();
      function Kc() {
      }
      function bi(a, c) {
        this.__wrapped__ = a, this.__actions__ = [], this.__chain__ = !!c, this.__index__ = 0, this.__values__ = t;
      }
      b.templateSettings = {
        /**
         * Used to detect `data` property values to be HTML-escaped.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */
        escape: Nn,
        /**
         * Used to detect code to be evaluated.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */
        evaluate: Vr,
        /**
         * Used to detect `data` property values to inject.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */
        interpolate: Sn,
        /**
         * Used to reference the data object in the template text.
         *
         * @memberOf _.templateSettings
         * @type {string}
         */
        variable: "",
        /**
         * Used to import variables into the compiled template.
         *
         * @memberOf _.templateSettings
         * @type {Object}
         */
        imports: {
          /**
           * A reference to the `lodash` function.
           *
           * @memberOf _.templateSettings.imports
           * @type {Function}
           */
          _: b
        }
      }, b.prototype = Kc.prototype, b.prototype.constructor = b, bi.prototype = ho(Kc.prototype), bi.prototype.constructor = bi;
      function Je(a) {
        this.__wrapped__ = a, this.__actions__ = [], this.__dir__ = 1, this.__filtered__ = !1, this.__iteratees__ = [], this.__takeCount__ = se, this.__views__ = [];
      }
      function eT() {
        var a = new Je(this.__wrapped__);
        return a.__actions__ = qn(this.__actions__), a.__dir__ = this.__dir__, a.__filtered__ = this.__filtered__, a.__iteratees__ = qn(this.__iteratees__), a.__takeCount__ = this.__takeCount__, a.__views__ = qn(this.__views__), a;
      }
      function tT() {
        if (this.__filtered__) {
          var a = new Je(this);
          a.__dir__ = -1, a.__filtered__ = !0;
        } else
          a = this.clone(), a.__dir__ *= -1;
        return a;
      }
      function nT() {
        var a = this.__wrapped__.value(), c = this.__dir__, d = Le(a), g = c < 0, p = d ? a.length : 0, T = mx(0, p, this.__views__), R = T.start, L = T.end, W = L - R, ie = g ? L : R - 1, re = this.__iteratees__, ae = re.length, we = 0, Te = xn(W, this.__takeCount__);
        if (!d || !g && p == W && Te == W)
          return m_(a, this.__actions__);
        var Me = [];
        e:
          for (; W-- && we < Te; ) {
            ie += c;
            for (var je = -1, Ne = a[ie]; ++je < ae; ) {
              var Ge = re[je], Qe = Ge.iteratee, oi = Ge.type, Ln = Qe(Ne);
              if (oi == le)
                Ne = Ln;
              else if (!Ln) {
                if (oi == Y)
                  continue e;
                break e;
              }
            }
            Me[we++] = Ne;
          }
        return Me;
      }
      Je.prototype = ho(Kc.prototype), Je.prototype.constructor = Je;
      function ps(a) {
        var c = -1, d = a == null ? 0 : a.length;
        for (this.clear(); ++c < d; ) {
          var g = a[c];
          this.set(g[0], g[1]);
        }
      }
      function iT() {
        this.__data__ = Oa ? Oa(null) : {}, this.size = 0;
      }
      function rT(a) {
        var c = this.has(a) && delete this.__data__[a];
        return this.size -= c ? 1 : 0, c;
      }
      function sT(a) {
        var c = this.__data__;
        if (Oa) {
          var d = c[a];
          return d === u ? t : d;
        }
        return mt.call(c, a) ? c[a] : t;
      }
      function oT(a) {
        var c = this.__data__;
        return Oa ? c[a] !== t : mt.call(c, a);
      }
      function aT(a, c) {
        var d = this.__data__;
        return this.size += this.has(a) ? 0 : 1, d[a] = Oa && c === t ? u : c, this;
      }
      ps.prototype.clear = iT, ps.prototype.delete = rT, ps.prototype.get = sT, ps.prototype.has = oT, ps.prototype.set = aT;
      function gr(a) {
        var c = -1, d = a == null ? 0 : a.length;
        for (this.clear(); ++c < d; ) {
          var g = a[c];
          this.set(g[0], g[1]);
        }
      }
      function lT() {
        this.__data__ = [], this.size = 0;
      }
      function cT(a) {
        var c = this.__data__, d = Gc(c, a);
        if (d < 0)
          return !1;
        var g = c.length - 1;
        return d == g ? c.pop() : zc.call(c, d, 1), --this.size, !0;
      }
      function uT(a) {
        var c = this.__data__, d = Gc(c, a);
        return d < 0 ? t : c[d][1];
      }
      function dT(a) {
        return Gc(this.__data__, a) > -1;
      }
      function hT(a, c) {
        var d = this.__data__, g = Gc(d, a);
        return g < 0 ? (++this.size, d.push([a, c])) : d[g][1] = c, this;
      }
      gr.prototype.clear = lT, gr.prototype.delete = cT, gr.prototype.get = uT, gr.prototype.has = dT, gr.prototype.set = hT;
      function pr(a) {
        var c = -1, d = a == null ? 0 : a.length;
        for (this.clear(); ++c < d; ) {
          var g = a[c];
          this.set(g[0], g[1]);
        }
      }
      function fT() {
        this.size = 0, this.__data__ = {
          hash: new ps(),
          map: new (Ia || gr)(),
          string: new ps()
        };
      }
      function mT(a) {
        var c = ou(this, a).delete(a);
        return this.size -= c ? 1 : 0, c;
      }
      function gT(a) {
        return ou(this, a).get(a);
      }
      function pT(a) {
        return ou(this, a).has(a);
      }
      function _T(a, c) {
        var d = ou(this, a), g = d.size;
        return d.set(a, c), this.size += d.size == g ? 0 : 1, this;
      }
      pr.prototype.clear = fT, pr.prototype.delete = mT, pr.prototype.get = gT, pr.prototype.has = pT, pr.prototype.set = _T;
      function _s(a) {
        var c = -1, d = a == null ? 0 : a.length;
        for (this.__data__ = new pr(); ++c < d; )
          this.add(a[c]);
      }
      function vT(a) {
        return this.__data__.set(a, u), this;
      }
      function wT(a) {
        return this.__data__.has(a);
      }
      _s.prototype.add = _s.prototype.push = vT, _s.prototype.has = wT;
      function Mi(a) {
        var c = this.__data__ = new gr(a);
        this.size = c.size;
      }
      function bT() {
        this.__data__ = new gr(), this.size = 0;
      }
      function yT(a) {
        var c = this.__data__, d = c.delete(a);
        return this.size = c.size, d;
      }
      function ET(a) {
        return this.__data__.get(a);
      }
      function CT(a) {
        return this.__data__.has(a);
      }
      function ST(a, c) {
        var d = this.__data__;
        if (d instanceof gr) {
          var g = d.__data__;
          if (!Ia || g.length < r - 1)
            return g.push([a, c]), this.size = ++d.size, this;
          d = this.__data__ = new pr(g);
        }
        return d.set(a, c), this.size = d.size, this;
      }
      Mi.prototype.clear = bT, Mi.prototype.delete = yT, Mi.prototype.get = ET, Mi.prototype.has = CT, Mi.prototype.set = ST;
      function Hp(a, c) {
        var d = Le(a), g = !d && Es(a), p = !d && !g && Jr(a), T = !d && !g && !p && po(a), R = d || g || p || T, L = R ? Ta(a.length, NS) : [], W = L.length;
        for (var ie in a)
          (c || mt.call(a, ie)) && !(R && // Safari 9 has enumerable `arguments.length` in strict mode.
          (ie == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
          p && (ie == "offset" || ie == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
          T && (ie == "buffer" || ie == "byteLength" || ie == "byteOffset") || // Skip index properties.
          br(ie, W))) && L.push(ie);
        return L;
      }
      function qp(a) {
        var c = a.length;
        return c ? a[gf(0, c - 1)] : t;
      }
      function TT(a, c) {
        return au(qn(a), vs(c, 0, a.length));
      }
      function xT(a) {
        return au(qn(a));
      }
      function sf(a, c, d) {
        (d !== t && !Ni(a[c], d) || d === t && !(c in a)) && _r(a, c, d);
      }
      function Na(a, c, d) {
        var g = a[c];
        (!(mt.call(a, c) && Ni(g, d)) || d === t && !(c in a)) && _r(a, c, d);
      }
      function Gc(a, c) {
        for (var d = a.length; d--; )
          if (Ni(a[d][0], c))
            return d;
        return -1;
      }
      function kT(a, c, d, g) {
        return qr(a, function(p, T, R) {
          c(g, p, d(p), R);
        }), g;
      }
      function Kp(a, c) {
        return a && Ji(c, fn(c), a);
      }
      function AT(a, c) {
        return a && Ji(c, Gn(c), a);
      }
      function _r(a, c, d) {
        c == "__proto__" && Wc ? Wc(a, c, {
          configurable: !0,
          enumerable: !0,
          value: d,
          writable: !0
        }) : a[c] = d;
      }
      function of(a, c) {
        for (var d = -1, g = c.length, p = K(g), T = a == null; ++d < g; )
          p[d] = T ? t : $f(a, c[d]);
        return p;
      }
      function vs(a, c, d) {
        return a === a && (d !== t && (a = a <= d ? a : d), c !== t && (a = a >= c ? a : c)), a;
      }
      function yi(a, c, d, g, p, T) {
        var R, L = c & m, W = c & v, ie = c & C;
        if (d && (R = p ? d(a, g, p, T) : d(a)), R !== t)
          return R;
        if (!zt(a))
          return a;
        var re = Le(a);
        if (re) {
          if (R = px(a), !L)
            return qn(a, R);
        } else {
          var ae = kn(a), we = ae == q || ae == Ze;
          if (Jr(a))
            return __(a, L);
          if (ae == rn || ae == he || we && !p) {
            if (R = W || we ? {} : B_(a), !L)
              return W ? sx(a, AT(R, a)) : rx(a, Kp(R, a));
          } else {
            if (!rt[ae])
              return p ? a : {};
            R = _x(a, ae, L);
          }
        }
        T || (T = new Mi());
        var Te = T.get(a);
        if (Te)
          return Te;
        T.set(a, R), d1(a) ? a.forEach(function(Ne) {
          R.add(yi(Ne, c, d, Ne, a, T));
        }) : c1(a) && a.forEach(function(Ne, Ge) {
          R.set(Ge, yi(Ne, c, d, Ge, a, T));
        });
        var Me = ie ? W ? xf : Tf : W ? Gn : fn, je = re ? t : Me(a);
        return Hn(je || a, function(Ne, Ge) {
          je && (Ge = Ne, Ne = a[Ge]), Na(R, Ge, yi(Ne, c, d, Ge, a, T));
        }), R;
      }
      function PT(a) {
        var c = fn(a);
        return function(d) {
          return Gp(d, a, c);
        };
      }
      function Gp(a, c, d) {
        var g = d.length;
        if (a == null)
          return !g;
        for (a = Ct(a); g--; ) {
          var p = d[g], T = c[p], R = a[p];
          if (R === t && !(p in a) || !T(R))
            return !1;
        }
        return !0;
      }
      function Yp(a, c, d) {
        if (typeof a != "function")
          throw new wi(o);
        return za(function() {
          a.apply(t, d);
        }, c);
      }
      function Da(a, c, d, g) {
        var p = -1, T = ro, R = !0, L = a.length, W = [], ie = c.length;
        if (!L)
          return W;
        d && (c = yt(c, Tn(d))), g ? (T = wa, R = !1) : c.length >= r && (T = fs, R = !1, c = new _s(c));
        e:
          for (; ++p < L; ) {
            var re = a[p], ae = d == null ? re : d(re);
            if (re = g || re !== 0 ? re : 0, R && ae === ae) {
              for (var we = ie; we--; )
                if (c[we] === ae)
                  continue e;
              W.push(re);
            } else
              T(c, ae, g) || W.push(re);
          }
        return W;
      }
      var qr = E_(Yi), Jp = E_(lf, !0);
      function IT(a, c) {
        var d = !0;
        return qr(a, function(g, p, T) {
          return d = !!c(g, p, T), d;
        }), d;
      }
      function Yc(a, c, d) {
        for (var g = -1, p = a.length; ++g < p; ) {
          var T = a[g], R = c(T);
          if (R != null && (L === t ? R === R && !si(R) : d(R, L)))
            var L = R, W = T;
        }
        return W;
      }
      function RT(a, c, d, g) {
        var p = a.length;
        for (d = ze(d), d < 0 && (d = -d > p ? 0 : p + d), g = g === t || g > p ? p : ze(g), g < 0 && (g += p), g = d > g ? 0 : f1(g); d < g; )
          a[d++] = c;
        return a;
      }
      function Xp(a, c) {
        var d = [];
        return qr(a, function(g, p, T) {
          c(g, p, T) && d.push(g);
        }), d;
      }
      function yn(a, c, d, g, p) {
        var T = -1, R = a.length;
        for (d || (d = wx), p || (p = []); ++T < R; ) {
          var L = a[T];
          c > 0 && d(L) ? c > 1 ? yn(L, c - 1, d, g, p) : Oi(p, L) : g || (p[p.length] = L);
        }
        return p;
      }
      var af = C_(), Zp = C_(!0);
      function Yi(a, c) {
        return a && af(a, c, fn);
      }
      function lf(a, c) {
        return a && Zp(a, c, fn);
      }
      function Jc(a, c) {
        return Ki(c, function(d) {
          return yr(a[d]);
        });
      }
      function ws(a, c) {
        c = Gr(c, a);
        for (var d = 0, g = c.length; a != null && d < g; )
          a = a[Xi(c[d++])];
        return d && d == g ? a : t;
      }
      function Qp(a, c, d) {
        var g = c(a);
        return Le(a) ? g : Oi(g, d(a));
      }
      function Bn(a) {
        return a == null ? a === t ? jn : nn : gs && gs in Ct(a) ? fx(a) : xx(a);
      }
      function cf(a, c) {
        return a > c;
      }
      function OT(a, c) {
        return a != null && mt.call(a, c);
      }
      function MT(a, c) {
        return a != null && c in Ct(a);
      }
      function NT(a, c, d) {
        return a >= xn(c, d) && a < cn(c, d);
      }
      function uf(a, c, d) {
        for (var g = d ? wa : ro, p = a[0].length, T = a.length, R = T, L = K(T), W = 1 / 0, ie = []; R--; ) {
          var re = a[R];
          R && c && (re = yt(re, Tn(c))), W = xn(re.length, W), L[R] = !d && (c || p >= 120 && re.length >= 120) ? new _s(R && re) : t;
        }
        re = a[0];
        var ae = -1, we = L[0];
        e:
          for (; ++ae < p && ie.length < W; ) {
            var Te = re[ae], Me = c ? c(Te) : Te;
            if (Te = d || Te !== 0 ? Te : 0, !(we ? fs(we, Me) : g(ie, Me, d))) {
              for (R = T; --R; ) {
                var je = L[R];
                if (!(je ? fs(je, Me) : g(a[R], Me, d)))
                  continue e;
              }
              we && we.push(Me), ie.push(Te);
            }
          }
        return ie;
      }
      function DT(a, c, d, g) {
        return Yi(a, function(p, T, R) {
          c(g, d(p), T, R);
        }), g;
      }
      function Ba(a, c, d) {
        c = Gr(c, a), a = $_(a, c);
        var g = a == null ? a : a[Xi(Ci(c))];
        return g == null ? t : bn(g, a, d);
      }
      function e_(a) {
        return Wt(a) && Bn(a) == he;
      }
      function BT(a) {
        return Wt(a) && Bn(a) == on;
      }
      function VT(a) {
        return Wt(a) && Bn(a) == Se;
      }
      function Va(a, c, d, g, p) {
        return a === c ? !0 : a == null || c == null || !Wt(a) && !Wt(c) ? a !== a && c !== c : LT(a, c, d, g, Va, p);
      }
      function LT(a, c, d, g, p, T) {
        var R = Le(a), L = Le(c), W = R ? be : kn(a), ie = L ? be : kn(c);
        W = W == he ? rn : W, ie = ie == he ? rn : ie;
        var re = W == rn, ae = ie == rn, we = W == ie;
        if (we && Jr(a)) {
          if (!Jr(c))
            return !1;
          R = !0, re = !1;
        }
        if (we && !re)
          return T || (T = new Mi()), R || po(a) ? M_(a, c, d, g, p, T) : dx(a, c, W, d, g, p, T);
        if (!(d & k)) {
          var Te = re && mt.call(a, "__wrapped__"), Me = ae && mt.call(c, "__wrapped__");
          if (Te || Me) {
            var je = Te ? a.value() : a, Ne = Me ? c.value() : c;
            return T || (T = new Mi()), p(je, Ne, d, g, T);
          }
        }
        return we ? (T || (T = new Mi()), hx(a, c, d, g, p, T)) : !1;
      }
      function FT(a) {
        return Wt(a) && kn(a) == de;
      }
      function df(a, c, d, g) {
        var p = d.length, T = p, R = !g;
        if (a == null)
          return !T;
        for (a = Ct(a); p--; ) {
          var L = d[p];
          if (R && L[2] ? L[1] !== a[L[0]] : !(L[0] in a))
            return !1;
        }
        for (; ++p < T; ) {
          L = d[p];
          var W = L[0], ie = a[W], re = L[1];
          if (R && L[2]) {
            if (ie === t && !(W in a))
              return !1;
          } else {
            var ae = new Mi();
            if (g)
              var we = g(ie, re, W, a, c, ae);
            if (!(we === t ? Va(re, ie, k | S, g, ae) : we))
              return !1;
          }
        }
        return !0;
      }
      function t_(a) {
        if (!zt(a) || yx(a))
          return !1;
        var c = yr(a) ? FS : Oh;
        return c.test(ys(a));
      }
      function $T(a) {
        return Wt(a) && Bn(a) == Jt;
      }
      function zT(a) {
        return Wt(a) && kn(a) == sn;
      }
      function WT(a) {
        return Wt(a) && fu(a.length) && !!vt[Bn(a)];
      }
      function n_(a) {
        return typeof a == "function" ? a : a == null ? Yn : typeof a == "object" ? Le(a) ? s_(a[0], a[1]) : r_(a) : S1(a);
      }
      function hf(a) {
        if (!$a(a))
          return HS(a);
        var c = [];
        for (var d in Ct(a))
          mt.call(a, d) && d != "constructor" && c.push(d);
        return c;
      }
      function jT(a) {
        if (!zt(a))
          return Tx(a);
        var c = $a(a), d = [];
        for (var g in a)
          g == "constructor" && (c || !mt.call(a, g)) || d.push(g);
        return d;
      }
      function ff(a, c) {
        return a < c;
      }
      function i_(a, c) {
        var d = -1, g = Kn(a) ? K(a.length) : [];
        return qr(a, function(p, T, R) {
          g[++d] = c(p, T, R);
        }), g;
      }
      function r_(a) {
        var c = Af(a);
        return c.length == 1 && c[0][2] ? L_(c[0][0], c[0][1]) : function(d) {
          return d === a || df(d, a, c);
        };
      }
      function s_(a, c) {
        return If(a) && V_(c) ? L_(Xi(a), c) : function(d) {
          var g = $f(d, a);
          return g === t && g === c ? zf(d, a) : Va(c, g, k | S);
        };
      }
      function Xc(a, c, d, g, p) {
        a !== c && af(c, function(T, R) {
          if (p || (p = new Mi()), zt(T))
            UT(a, c, R, d, Xc, g, p);
          else {
            var L = g ? g(Of(a, R), T, R + "", a, c, p) : t;
            L === t && (L = T), sf(a, R, L);
          }
        }, Gn);
      }
      function UT(a, c, d, g, p, T, R) {
        var L = Of(a, d), W = Of(c, d), ie = R.get(W);
        if (ie) {
          sf(a, d, ie);
          return;
        }
        var re = T ? T(L, W, d + "", a, c, R) : t, ae = re === t;
        if (ae) {
          var we = Le(W), Te = !we && Jr(W), Me = !we && !Te && po(W);
          re = W, we || Te || Me ? Le(L) ? re = L : Qt(L) ? re = qn(L) : Te ? (ae = !1, re = __(W, !0)) : Me ? (ae = !1, re = v_(W, !0)) : re = [] : Wa(W) || Es(W) ? (re = L, Es(L) ? re = m1(L) : (!zt(L) || yr(L)) && (re = B_(W))) : ae = !1;
        }
        ae && (R.set(W, re), p(re, W, g, T, R), R.delete(W)), sf(a, d, re);
      }
      function o_(a, c) {
        var d = a.length;
        if (d)
          return c += c < 0 ? d : 0, br(c, d) ? a[c] : t;
      }
      function a_(a, c, d) {
        c.length ? c = yt(c, function(T) {
          return Le(T) ? function(R) {
            return ws(R, T.length === 1 ? T[0] : T);
          } : T;
        }) : c = [Yn];
        var g = -1;
        c = yt(c, Tn(Oe()));
        var p = i_(a, function(T, R, L) {
          var W = yt(c, function(ie) {
            return ie(T);
          });
          return { criteria: W, index: ++g, value: T };
        });
        return wt(p, function(T, R) {
          return ix(T, R, d);
        });
      }
      function HT(a, c) {
        return l_(a, c, function(d, g) {
          return zf(a, g);
        });
      }
      function l_(a, c, d) {
        for (var g = -1, p = c.length, T = {}; ++g < p; ) {
          var R = c[g], L = ws(a, R);
          d(L, R) && La(T, Gr(R, a), L);
        }
        return T;
      }
      function qT(a) {
        return function(c) {
          return ws(c, a);
        };
      }
      function mf(a, c, d, g) {
        var p = g ? Xh : Ur, T = -1, R = c.length, L = a;
        for (a === c && (c = qn(c)), d && (L = yt(a, Tn(d))); ++T < R; )
          for (var W = 0, ie = c[T], re = d ? d(ie) : ie; (W = p(L, re, W, g)) > -1; )
            L !== a && zc.call(L, W, 1), zc.call(a, W, 1);
        return a;
      }
      function c_(a, c) {
        for (var d = a ? c.length : 0, g = d - 1; d--; ) {
          var p = c[d];
          if (d == g || p !== T) {
            var T = p;
            br(p) ? zc.call(a, p, 1) : vf(a, p);
          }
        }
        return a;
      }
      function gf(a, c) {
        return a + Uc(jp() * (c - a + 1));
      }
      function KT(a, c, d, g) {
        for (var p = -1, T = cn(jc((c - a) / (d || 1)), 0), R = K(T); T--; )
          R[g ? T : ++p] = a, a += d;
        return R;
      }
      function pf(a, c) {
        var d = "";
        if (!a || c < 1 || c > te)
          return d;
        do
          c % 2 && (d += a), c = Uc(c / 2), c && (a += a);
        while (c);
        return d;
      }
      function He(a, c) {
        return Mf(F_(a, c, Yn), a + "");
      }
      function GT(a) {
        return qp(_o(a));
      }
      function YT(a, c) {
        var d = _o(a);
        return au(d, vs(c, 0, d.length));
      }
      function La(a, c, d, g) {
        if (!zt(a))
          return a;
        c = Gr(c, a);
        for (var p = -1, T = c.length, R = T - 1, L = a; L != null && ++p < T; ) {
          var W = Xi(c[p]), ie = d;
          if (W === "__proto__" || W === "constructor" || W === "prototype")
            return a;
          if (p != R) {
            var re = L[W];
            ie = g ? g(re, W, L) : t, ie === t && (ie = zt(re) ? re : br(c[p + 1]) ? [] : {});
          }
          Na(L, W, ie), L = L[W];
        }
        return a;
      }
      var u_ = Hc ? function(a, c) {
        return Hc.set(a, c), a;
      } : Yn, JT = Wc ? function(a, c) {
        return Wc(a, "toString", {
          configurable: !0,
          enumerable: !1,
          value: jf(c),
          writable: !0
        });
      } : Yn;
      function XT(a) {
        return au(_o(a));
      }
      function Ei(a, c, d) {
        var g = -1, p = a.length;
        c < 0 && (c = -c > p ? 0 : p + c), d = d > p ? p : d, d < 0 && (d += p), p = c > d ? 0 : d - c >>> 0, c >>>= 0;
        for (var T = K(p); ++g < p; )
          T[g] = a[g + c];
        return T;
      }
      function ZT(a, c) {
        var d;
        return qr(a, function(g, p, T) {
          return d = c(g, p, T), !d;
        }), !!d;
      }
      function Zc(a, c, d) {
        var g = 0, p = a == null ? g : a.length;
        if (typeof c == "number" && c === c && p <= ue) {
          for (; g < p; ) {
            var T = g + p >>> 1, R = a[T];
            R !== null && !si(R) && (d ? R <= c : R < c) ? g = T + 1 : p = T;
          }
          return p;
        }
        return _f(a, c, Yn, d);
      }
      function _f(a, c, d, g) {
        var p = 0, T = a == null ? 0 : a.length;
        if (T === 0)
          return 0;
        c = d(c);
        for (var R = c !== c, L = c === null, W = si(c), ie = c === t; p < T; ) {
          var re = Uc((p + T) / 2), ae = d(a[re]), we = ae !== t, Te = ae === null, Me = ae === ae, je = si(ae);
          if (R)
            var Ne = g || Me;
          else
            ie ? Ne = Me && (g || we) : L ? Ne = Me && we && (g || !Te) : W ? Ne = Me && we && !Te && (g || !je) : Te || je ? Ne = !1 : Ne = g ? ae <= c : ae < c;
          Ne ? p = re + 1 : T = re;
        }
        return xn(T, ve);
      }
      function d_(a, c) {
        for (var d = -1, g = a.length, p = 0, T = []; ++d < g; ) {
          var R = a[d], L = c ? c(R) : R;
          if (!d || !Ni(L, W)) {
            var W = L;
            T[p++] = R === 0 ? 0 : R;
          }
        }
        return T;
      }
      function h_(a) {
        return typeof a == "number" ? a : si(a) ? z : +a;
      }
      function ri(a) {
        if (typeof a == "string")
          return a;
        if (Le(a))
          return yt(a, ri) + "";
        if (si(a))
          return Up ? Up.call(a) : "";
        var c = a + "";
        return c == "0" && 1 / a == -ee ? "-0" : c;
      }
      function Kr(a, c, d) {
        var g = -1, p = ro, T = a.length, R = !0, L = [], W = L;
        if (d)
          R = !1, p = wa;
        else if (T >= r) {
          var ie = c ? null : cx(a);
          if (ie)
            return w(ie);
          R = !1, p = fs, W = new _s();
        } else
          W = c ? [] : L;
        e:
          for (; ++g < T; ) {
            var re = a[g], ae = c ? c(re) : re;
            if (re = d || re !== 0 ? re : 0, R && ae === ae) {
              for (var we = W.length; we--; )
                if (W[we] === ae)
                  continue e;
              c && W.push(ae), L.push(re);
            } else
              p(W, ae, d) || (W !== L && W.push(ae), L.push(re));
          }
        return L;
      }
      function vf(a, c) {
        return c = Gr(c, a), a = $_(a, c), a == null || delete a[Xi(Ci(c))];
      }
      function f_(a, c, d, g) {
        return La(a, c, d(ws(a, c)), g);
      }
      function Qc(a, c, d, g) {
        for (var p = a.length, T = g ? p : -1; (g ? T-- : ++T < p) && c(a[T], T, a); )
          ;
        return d ? Ei(a, g ? 0 : T, g ? T + 1 : p) : Ei(a, g ? T + 1 : 0, g ? p : T);
      }
      function m_(a, c) {
        var d = a;
        return d instanceof Je && (d = d.value()), ba(c, function(g, p) {
          return p.func.apply(p.thisArg, Oi([g], p.args));
        }, d);
      }
      function wf(a, c, d) {
        var g = a.length;
        if (g < 2)
          return g ? Kr(a[0]) : [];
        for (var p = -1, T = K(g); ++p < g; )
          for (var R = a[p], L = -1; ++L < g; )
            L != p && (T[p] = Da(T[p] || R, a[L], c, d));
        return Kr(yn(T, 1), c, d);
      }
      function g_(a, c, d) {
        for (var g = -1, p = a.length, T = c.length, R = {}; ++g < p; ) {
          var L = g < T ? c[g] : t;
          d(R, a[g], L);
        }
        return R;
      }
      function bf(a) {
        return Qt(a) ? a : [];
      }
      function yf(a) {
        return typeof a == "function" ? a : Yn;
      }
      function Gr(a, c) {
        return Le(a) ? a : If(a, c) ? [a] : U_(st(a));
      }
      var QT = He;
      function Yr(a, c, d) {
        var g = a.length;
        return d = d === t ? g : d, !c && d >= g ? a : Ei(a, c, d);
      }
      var p_ = $S || function(a) {
        return Zt.clearTimeout(a);
      };
      function __(a, c) {
        if (c)
          return a.slice();
        var d = a.length, g = Lp ? Lp(d) : new a.constructor(d);
        return a.copy(g), g;
      }
      function Ef(a) {
        var c = new a.constructor(a.byteLength);
        return new Fc(c).set(new Fc(a)), c;
      }
      function ex(a, c) {
        var d = c ? Ef(a.buffer) : a.buffer;
        return new a.constructor(d, a.byteOffset, a.byteLength);
      }
      function tx(a) {
        var c = new a.constructor(a.source, Kl.exec(a));
        return c.lastIndex = a.lastIndex, c;
      }
      function nx(a) {
        return Ma ? Ct(Ma.call(a)) : {};
      }
      function v_(a, c) {
        var d = c ? Ef(a.buffer) : a.buffer;
        return new a.constructor(d, a.byteOffset, a.length);
      }
      function w_(a, c) {
        if (a !== c) {
          var d = a !== t, g = a === null, p = a === a, T = si(a), R = c !== t, L = c === null, W = c === c, ie = si(c);
          if (!L && !ie && !T && a > c || T && R && W && !L && !ie || g && R && W || !d && W || !p)
            return 1;
          if (!g && !T && !ie && a < c || ie && d && p && !g && !T || L && d && p || !R && p || !W)
            return -1;
        }
        return 0;
      }
      function ix(a, c, d) {
        for (var g = -1, p = a.criteria, T = c.criteria, R = p.length, L = d.length; ++g < R; ) {
          var W = w_(p[g], T[g]);
          if (W) {
            if (g >= L)
              return W;
            var ie = d[g];
            return W * (ie == "desc" ? -1 : 1);
          }
        }
        return a.index - c.index;
      }
      function b_(a, c, d, g) {
        for (var p = -1, T = a.length, R = d.length, L = -1, W = c.length, ie = cn(T - R, 0), re = K(W + ie), ae = !g; ++L < W; )
          re[L] = c[L];
        for (; ++p < R; )
          (ae || p < T) && (re[d[p]] = a[p]);
        for (; ie--; )
          re[L++] = a[p++];
        return re;
      }
      function y_(a, c, d, g) {
        for (var p = -1, T = a.length, R = -1, L = d.length, W = -1, ie = c.length, re = cn(T - L, 0), ae = K(re + ie), we = !g; ++p < re; )
          ae[p] = a[p];
        for (var Te = p; ++W < ie; )
          ae[Te + W] = c[W];
        for (; ++R < L; )
          (we || p < T) && (ae[Te + d[R]] = a[p++]);
        return ae;
      }
      function qn(a, c) {
        var d = -1, g = a.length;
        for (c || (c = K(g)); ++d < g; )
          c[d] = a[d];
        return c;
      }
      function Ji(a, c, d, g) {
        var p = !d;
        d || (d = {});
        for (var T = -1, R = c.length; ++T < R; ) {
          var L = c[T], W = g ? g(d[L], a[L], L, d, a) : t;
          W === t && (W = a[L]), p ? _r(d, L, W) : Na(d, L, W);
        }
        return d;
      }
      function rx(a, c) {
        return Ji(a, Pf(a), c);
      }
      function sx(a, c) {
        return Ji(a, N_(a), c);
      }
      function eu(a, c) {
        return function(d, g) {
          var p = Le(d) ? Kh : kT, T = c ? c() : {};
          return p(d, a, Oe(g, 2), T);
        };
      }
      function fo(a) {
        return He(function(c, d) {
          var g = -1, p = d.length, T = p > 1 ? d[p - 1] : t, R = p > 2 ? d[2] : t;
          for (T = a.length > 3 && typeof T == "function" ? (p--, T) : t, R && Vn(d[0], d[1], R) && (T = p < 3 ? t : T, p = 1), c = Ct(c); ++g < p; ) {
            var L = d[g];
            L && a(c, L, g, T);
          }
          return c;
        });
      }
      function E_(a, c) {
        return function(d, g) {
          if (d == null)
            return d;
          if (!Kn(d))
            return a(d, g);
          for (var p = d.length, T = c ? p : -1, R = Ct(d); (c ? T-- : ++T < p) && g(R[T], T, R) !== !1; )
            ;
          return d;
        };
      }
      function C_(a) {
        return function(c, d, g) {
          for (var p = -1, T = Ct(c), R = g(c), L = R.length; L--; ) {
            var W = R[a ? L : ++p];
            if (d(T[W], W, T) === !1)
              break;
          }
          return c;
        };
      }
      function ox(a, c, d) {
        var g = c & x, p = Fa(a);
        function T() {
          var R = this && this !== Zt && this instanceof T ? p : a;
          return R.apply(g ? d : this, arguments);
        }
        return T;
      }
      function S_(a) {
        return function(c) {
          c = st(c);
          var d = fr(c) ? Ie(c) : t, g = d ? d[0] : c.charAt(0), p = d ? Yr(d, 1).join("") : c.slice(1);
          return g[a]() + p;
        };
      }
      function mo(a) {
        return function(c) {
          return ba(E1(y1(c).replace($h, "")), a, "");
        };
      }
      function Fa(a) {
        return function() {
          var c = arguments;
          switch (c.length) {
            case 0:
              return new a();
            case 1:
              return new a(c[0]);
            case 2:
              return new a(c[0], c[1]);
            case 3:
              return new a(c[0], c[1], c[2]);
            case 4:
              return new a(c[0], c[1], c[2], c[3]);
            case 5:
              return new a(c[0], c[1], c[2], c[3], c[4]);
            case 6:
              return new a(c[0], c[1], c[2], c[3], c[4], c[5]);
            case 7:
              return new a(c[0], c[1], c[2], c[3], c[4], c[5], c[6]);
          }
          var d = ho(a.prototype), g = a.apply(d, c);
          return zt(g) ? g : d;
        };
      }
      function ax(a, c, d) {
        var g = Fa(a);
        function p() {
          for (var T = arguments.length, R = K(T), L = T, W = go(p); L--; )
            R[L] = arguments[L];
          var ie = T < 3 && R[0] !== W && R[T - 1] !== W ? [] : _(R, W);
          if (T -= ie.length, T < d)
            return P_(
              a,
              c,
              tu,
              p.placeholder,
              t,
              R,
              ie,
              t,
              t,
              d - T
            );
          var re = this && this !== Zt && this instanceof p ? g : a;
          return bn(re, this, R);
        }
        return p;
      }
      function T_(a) {
        return function(c, d, g) {
          var p = Ct(c);
          if (!Kn(c)) {
            var T = Oe(d, 3);
            c = fn(c), d = function(L) {
              return T(p[L], L, p);
            };
          }
          var R = a(c, d, g);
          return R > -1 ? p[T ? c[R] : R] : t;
        };
      }
      function x_(a) {
        return wr(function(c) {
          var d = c.length, g = d, p = bi.prototype.thru;
          for (a && c.reverse(); g--; ) {
            var T = c[g];
            if (typeof T != "function")
              throw new wi(o);
            if (p && !R && su(T) == "wrapper")
              var R = new bi([], !0);
          }
          for (g = R ? g : d; ++g < d; ) {
            T = c[g];
            var L = su(T), W = L == "wrapper" ? kf(T) : t;
            W && Rf(W[0]) && W[1] == (j | A | E | U) && !W[4].length && W[9] == 1 ? R = R[su(W[0])].apply(R, W[3]) : R = T.length == 1 && Rf(T) ? R[L]() : R.thru(T);
          }
          return function() {
            var ie = arguments, re = ie[0];
            if (R && ie.length == 1 && Le(re))
              return R.plant(re).value();
            for (var ae = 0, we = d ? c[ae].apply(this, ie) : re; ++ae < d; )
              we = c[ae].call(this, we);
            return we;
          };
        });
      }
      function tu(a, c, d, g, p, T, R, L, W, ie) {
        var re = c & j, ae = c & x, we = c & N, Te = c & (A | P), Me = c & $, je = we ? t : Fa(a);
        function Ne() {
          for (var Ge = arguments.length, Qe = K(Ge), oi = Ge; oi--; )
            Qe[oi] = arguments[oi];
          if (Te)
            var Ln = go(Ne), ai = Ic(Qe, Ln);
          if (g && (Qe = b_(Qe, g, p, Te)), T && (Qe = y_(Qe, T, R, Te)), Ge -= ai, Te && Ge < ie) {
            var en = _(Qe, Ln);
            return P_(
              a,
              c,
              tu,
              Ne.placeholder,
              d,
              Qe,
              en,
              L,
              W,
              ie - Ge
            );
          }
          var Di = ae ? d : this, Cr = we ? Di[a] : a;
          return Ge = Qe.length, L ? Qe = kx(Qe, L) : Me && Ge > 1 && Qe.reverse(), re && W < Ge && (Qe.length = W), this && this !== Zt && this instanceof Ne && (Cr = je || Fa(Cr)), Cr.apply(Di, Qe);
        }
        return Ne;
      }
      function k_(a, c) {
        return function(d, g) {
          return DT(d, a, c(g), {});
        };
      }
      function nu(a, c) {
        return function(d, g) {
          var p;
          if (d === t && g === t)
            return c;
          if (d !== t && (p = d), g !== t) {
            if (p === t)
              return g;
            typeof d == "string" || typeof g == "string" ? (d = ri(d), g = ri(g)) : (d = h_(d), g = h_(g)), p = a(d, g);
          }
          return p;
        };
      }
      function Cf(a) {
        return wr(function(c) {
          return c = yt(c, Tn(Oe())), He(function(d) {
            var g = this;
            return a(c, function(p) {
              return bn(p, g, d);
            });
          });
        });
      }
      function iu(a, c) {
        c = c === t ? " " : ri(c);
        var d = c.length;
        if (d < 2)
          return d ? pf(c, a) : c;
        var g = pf(c, jc(a / Re(c)));
        return fr(c) ? Yr(Ie(g), 0, a).join("") : g.slice(0, a);
      }
      function lx(a, c, d, g) {
        var p = c & x, T = Fa(a);
        function R() {
          for (var L = -1, W = arguments.length, ie = -1, re = g.length, ae = K(re + W), we = this && this !== Zt && this instanceof R ? T : a; ++ie < re; )
            ae[ie] = g[ie];
          for (; W--; )
            ae[ie++] = arguments[++L];
          return bn(we, p ? d : this, ae);
        }
        return R;
      }
      function A_(a) {
        return function(c, d, g) {
          return g && typeof g != "number" && Vn(c, d, g) && (d = g = t), c = Er(c), d === t ? (d = c, c = 0) : d = Er(d), g = g === t ? c < d ? 1 : -1 : Er(g), KT(c, d, g, a);
        };
      }
      function ru(a) {
        return function(c, d) {
          return typeof c == "string" && typeof d == "string" || (c = Si(c), d = Si(d)), a(c, d);
        };
      }
      function P_(a, c, d, g, p, T, R, L, W, ie) {
        var re = c & A, ae = re ? R : t, we = re ? t : R, Te = re ? T : t, Me = re ? t : T;
        c |= re ? E : V, c &= ~(re ? V : E), c & y || (c &= ~(x | N));
        var je = [
          a,
          c,
          p,
          Te,
          ae,
          Me,
          we,
          L,
          W,
          ie
        ], Ne = d.apply(t, je);
        return Rf(a) && z_(Ne, je), Ne.placeholder = g, W_(Ne, a, c);
      }
      function Sf(a) {
        var c = Et[a];
        return function(d, g) {
          if (d = Si(d), g = g == null ? 0 : xn(ze(g), 292), g && Wp(d)) {
            var p = (st(d) + "e").split("e"), T = c(p[0] + "e" + (+p[1] + g));
            return p = (st(T) + "e").split("e"), +(p[0] + "e" + (+p[1] - g));
          }
          return c(d);
        };
      }
      var cx = co && 1 / w(new co([, -0]))[1] == ee ? function(a) {
        return new co(a);
      } : qf;
      function I_(a) {
        return function(c) {
          var d = kn(c);
          return d == de ? Gi(c) : d == sn ? O(c) : Zh(c, a(c));
        };
      }
      function vr(a, c, d, g, p, T, R, L) {
        var W = c & N;
        if (!W && typeof a != "function")
          throw new wi(o);
        var ie = g ? g.length : 0;
        if (ie || (c &= ~(E | V), g = p = t), R = R === t ? R : cn(ze(R), 0), L = L === t ? L : ze(L), ie -= p ? p.length : 0, c & V) {
          var re = g, ae = p;
          g = p = t;
        }
        var we = W ? t : kf(a), Te = [
          a,
          c,
          d,
          g,
          p,
          re,
          ae,
          T,
          R,
          L
        ];
        if (we && Sx(Te, we), a = Te[0], c = Te[1], d = Te[2], g = Te[3], p = Te[4], L = Te[9] = Te[9] === t ? W ? 0 : a.length : cn(Te[9] - ie, 0), !L && c & (A | P) && (c &= ~(A | P)), !c || c == x)
          var Me = ox(a, c, d);
        else
          c == A || c == P ? Me = ax(a, c, L) : (c == E || c == (x | E)) && !p.length ? Me = lx(a, c, d, g) : Me = tu.apply(t, Te);
        var je = we ? u_ : z_;
        return W_(je(Me, Te), a, c);
      }
      function R_(a, c, d, g) {
        return a === t || Ni(a, lo[d]) && !mt.call(g, d) ? c : a;
      }
      function O_(a, c, d, g, p, T) {
        return zt(a) && zt(c) && (T.set(c, a), Xc(a, c, t, O_, T), T.delete(c)), a;
      }
      function ux(a) {
        return Wa(a) ? t : a;
      }
      function M_(a, c, d, g, p, T) {
        var R = d & k, L = a.length, W = c.length;
        if (L != W && !(R && W > L))
          return !1;
        var ie = T.get(a), re = T.get(c);
        if (ie && re)
          return ie == c && re == a;
        var ae = -1, we = !0, Te = d & S ? new _s() : t;
        for (T.set(a, c), T.set(c, a); ++ae < L; ) {
          var Me = a[ae], je = c[ae];
          if (g)
            var Ne = R ? g(je, Me, ae, c, a, T) : g(Me, je, ae, a, c, T);
          if (Ne !== t) {
            if (Ne)
              continue;
            we = !1;
            break;
          }
          if (Te) {
            if (!ya(c, function(Ge, Qe) {
              if (!fs(Te, Qe) && (Me === Ge || p(Me, Ge, d, g, T)))
                return Te.push(Qe);
            })) {
              we = !1;
              break;
            }
          } else if (!(Me === je || p(Me, je, d, g, T))) {
            we = !1;
            break;
          }
        }
        return T.delete(a), T.delete(c), we;
      }
      function dx(a, c, d, g, p, T, R) {
        switch (d) {
          case On:
            if (a.byteLength != c.byteLength || a.byteOffset != c.byteOffset)
              return !1;
            a = a.buffer, c = c.buffer;
          case on:
            return !(a.byteLength != c.byteLength || !T(new Fc(a), new Fc(c)));
          case Pe:
          case Se:
          case Ye:
            return Ni(+a, +c);
          case De:
            return a.name == c.name && a.message == c.message;
          case Jt:
          case Wn:
            return a == c + "";
          case de:
            var L = Gi;
          case sn:
            var W = g & k;
            if (L || (L = w), a.size != c.size && !W)
              return !1;
            var ie = R.get(a);
            if (ie)
              return ie == c;
            g |= S, R.set(a, c);
            var re = M_(L(a), L(c), g, p, T, R);
            return R.delete(a), re;
          case gi:
            if (Ma)
              return Ma.call(a) == Ma.call(c);
        }
        return !1;
      }
      function hx(a, c, d, g, p, T) {
        var R = d & k, L = Tf(a), W = L.length, ie = Tf(c), re = ie.length;
        if (W != re && !R)
          return !1;
        for (var ae = W; ae--; ) {
          var we = L[ae];
          if (!(R ? we in c : mt.call(c, we)))
            return !1;
        }
        var Te = T.get(a), Me = T.get(c);
        if (Te && Me)
          return Te == c && Me == a;
        var je = !0;
        T.set(a, c), T.set(c, a);
        for (var Ne = R; ++ae < W; ) {
          we = L[ae];
          var Ge = a[we], Qe = c[we];
          if (g)
            var oi = R ? g(Qe, Ge, we, c, a, T) : g(Ge, Qe, we, a, c, T);
          if (!(oi === t ? Ge === Qe || p(Ge, Qe, d, g, T) : oi)) {
            je = !1;
            break;
          }
          Ne || (Ne = we == "constructor");
        }
        if (je && !Ne) {
          var Ln = a.constructor, ai = c.constructor;
          Ln != ai && "constructor" in a && "constructor" in c && !(typeof Ln == "function" && Ln instanceof Ln && typeof ai == "function" && ai instanceof ai) && (je = !1);
        }
        return T.delete(a), T.delete(c), je;
      }
      function wr(a) {
        return Mf(F_(a, t, G_), a + "");
      }
      function Tf(a) {
        return Qp(a, fn, Pf);
      }
      function xf(a) {
        return Qp(a, Gn, N_);
      }
      var kf = Hc ? function(a) {
        return Hc.get(a);
      } : qf;
      function su(a) {
        for (var c = a.name + "", d = uo[c], g = mt.call(uo, c) ? d.length : 0; g--; ) {
          var p = d[g], T = p.func;
          if (T == null || T == a)
            return p.name;
        }
        return c;
      }
      function go(a) {
        var c = mt.call(b, "placeholder") ? b : a;
        return c.placeholder;
      }
      function Oe() {
        var a = b.iteratee || Uf;
        return a = a === Uf ? n_ : a, arguments.length ? a(arguments[0], arguments[1]) : a;
      }
      function ou(a, c) {
        var d = a.__data__;
        return bx(c) ? d[typeof c == "string" ? "string" : "hash"] : d.map;
      }
      function Af(a) {
        for (var c = fn(a), d = c.length; d--; ) {
          var g = c[d], p = a[g];
          c[d] = [g, p, V_(p)];
        }
        return c;
      }
      function bs(a, c) {
        var d = Oc(a, c);
        return t_(d) ? d : t;
      }
      function fx(a) {
        var c = mt.call(a, gs), d = a[gs];
        try {
          a[gs] = t;
          var g = !0;
        } catch {
        }
        var p = Vc.call(a);
        return g && (c ? a[gs] = d : delete a[gs]), p;
      }
      var Pf = tf ? function(a) {
        return a == null ? [] : (a = Ct(a), Ki(tf(a), function(c) {
          return $p.call(a, c);
        }));
      } : Kf, N_ = tf ? function(a) {
        for (var c = []; a; )
          Oi(c, Pf(a)), a = $c(a);
        return c;
      } : Kf, kn = Bn;
      (nf && kn(new nf(new ArrayBuffer(1))) != On || Ia && kn(new Ia()) != de || rf && kn(rf.resolve()) != Qn || co && kn(new co()) != sn || Ra && kn(new Ra()) != Un) && (kn = function(a) {
        var c = Bn(a), d = c == rn ? a.constructor : t, g = d ? ys(d) : "";
        if (g)
          switch (g) {
            case YS:
              return On;
            case JS:
              return de;
            case XS:
              return Qn;
            case ZS:
              return sn;
            case QS:
              return Un;
          }
        return c;
      });
      function mx(a, c, d) {
        for (var g = -1, p = d.length; ++g < p; ) {
          var T = d[g], R = T.size;
          switch (T.type) {
            case "drop":
              a += R;
              break;
            case "dropRight":
              c -= R;
              break;
            case "take":
              c = xn(c, a + R);
              break;
            case "takeRight":
              a = cn(a, c - R);
              break;
          }
        }
        return { start: a, end: c };
      }
      function gx(a) {
        var c = a.match(Ah);
        return c ? c[1].split(Fr) : [];
      }
      function D_(a, c, d) {
        c = Gr(c, a);
        for (var g = -1, p = c.length, T = !1; ++g < p; ) {
          var R = Xi(c[g]);
          if (!(T = a != null && d(a, R)))
            break;
          a = a[R];
        }
        return T || ++g != p ? T : (p = a == null ? 0 : a.length, !!p && fu(p) && br(R, p) && (Le(a) || Es(a)));
      }
      function px(a) {
        var c = a.length, d = new a.constructor(c);
        return c && typeof a[0] == "string" && mt.call(a, "index") && (d.index = a.index, d.input = a.input), d;
      }
      function B_(a) {
        return typeof a.constructor == "function" && !$a(a) ? ho($c(a)) : {};
      }
      function _x(a, c, d) {
        var g = a.constructor;
        switch (c) {
          case on:
            return Ef(a);
          case Pe:
          case Se:
            return new g(+a);
          case On:
            return ex(a, d);
          case Mn:
          case I:
          case ge:
          case xe:
          case Be:
          case Fe:
          case an:
          case _n:
          case Xt:
            return v_(a, d);
          case de:
            return new g();
          case Ye:
          case Wn:
            return new g(a);
          case Jt:
            return tx(a);
          case sn:
            return new g();
          case gi:
            return nx(a);
        }
      }
      function vx(a, c) {
        var d = c.length;
        if (!d)
          return a;
        var g = d - 1;
        return c[g] = (d > 1 ? "& " : "") + c[g], c = c.join(d > 2 ? ", " : " "), a.replace(kh, `{
/* [wrapped with ` + c + `] */
`);
      }
      function wx(a) {
        return Le(a) || Es(a) || !!(zp && a && a[zp]);
      }
      function br(a, c) {
        var d = typeof a;
        return c = c ?? te, !!c && (d == "number" || d != "symbol" && Ys.test(a)) && a > -1 && a % 1 == 0 && a < c;
      }
      function Vn(a, c, d) {
        if (!zt(d))
          return !1;
        var g = typeof c;
        return (g == "number" ? Kn(d) && br(c, d.length) : g == "string" && c in d) ? Ni(d[c], a) : !1;
      }
      function If(a, c) {
        if (Le(a))
          return !1;
        var d = typeof a;
        return d == "number" || d == "symbol" || d == "boolean" || a == null || si(a) ? !0 : ti.test(a) || !Ft.test(a) || c != null && a in Ct(c);
      }
      function bx(a) {
        var c = typeof a;
        return c == "string" || c == "number" || c == "symbol" || c == "boolean" ? a !== "__proto__" : a === null;
      }
      function Rf(a) {
        var c = su(a), d = b[c];
        if (typeof d != "function" || !(c in Je.prototype))
          return !1;
        if (a === d)
          return !0;
        var g = kf(d);
        return !!g && a === g[0];
      }
      function yx(a) {
        return !!Vp && Vp in a;
      }
      var Ex = Dc ? yr : Gf;
      function $a(a) {
        var c = a && a.constructor, d = typeof c == "function" && c.prototype || lo;
        return a === d;
      }
      function V_(a) {
        return a === a && !zt(a);
      }
      function L_(a, c) {
        return function(d) {
          return d == null ? !1 : d[a] === c && (c !== t || a in Ct(d));
        };
      }
      function Cx(a) {
        var c = du(a, function(g) {
          return d.size === h && d.clear(), g;
        }), d = c.cache;
        return c;
      }
      function Sx(a, c) {
        var d = a[1], g = c[1], p = d | g, T = p < (x | N | j), R = g == j && d == A || g == j && d == U && a[7].length <= c[8] || g == (j | U) && c[7].length <= c[8] && d == A;
        if (!(T || R))
          return a;
        g & x && (a[2] = c[2], p |= d & x ? 0 : y);
        var L = c[3];
        if (L) {
          var W = a[3];
          a[3] = W ? b_(W, L, c[4]) : L, a[4] = W ? _(a[3], f) : c[4];
        }
        return L = c[5], L && (W = a[5], a[5] = W ? y_(W, L, c[6]) : L, a[6] = W ? _(a[5], f) : c[6]), L = c[7], L && (a[7] = L), g & j && (a[8] = a[8] == null ? c[8] : xn(a[8], c[8])), a[9] == null && (a[9] = c[9]), a[0] = c[0], a[1] = p, a;
      }
      function Tx(a) {
        var c = [];
        if (a != null)
          for (var d in Ct(a))
            c.push(d);
        return c;
      }
      function xx(a) {
        return Vc.call(a);
      }
      function F_(a, c, d) {
        return c = cn(c === t ? a.length - 1 : c, 0), function() {
          for (var g = arguments, p = -1, T = cn(g.length - c, 0), R = K(T); ++p < T; )
            R[p] = g[c + p];
          p = -1;
          for (var L = K(c + 1); ++p < c; )
            L[p] = g[p];
          return L[c] = d(R), bn(a, this, L);
        };
      }
      function $_(a, c) {
        return c.length < 2 ? a : ws(a, Ei(c, 0, -1));
      }
      function kx(a, c) {
        for (var d = a.length, g = xn(c.length, d), p = qn(a); g--; ) {
          var T = c[g];
          a[g] = br(T, d) ? p[T] : t;
        }
        return a;
      }
      function Of(a, c) {
        if (!(c === "constructor" && typeof a[c] == "function") && c != "__proto__")
          return a[c];
      }
      var z_ = j_(u_), za = WS || function(a, c) {
        return Zt.setTimeout(a, c);
      }, Mf = j_(JT);
      function W_(a, c, d) {
        var g = c + "";
        return Mf(a, vx(g, Ax(gx(g), d)));
      }
      function j_(a) {
        var c = 0, d = 0;
        return function() {
          var g = qS(), p = H - (g - d);
          if (d = g, p > 0) {
            if (++c >= J)
              return arguments[0];
          } else
            c = 0;
          return a.apply(t, arguments);
        };
      }
      function au(a, c) {
        var d = -1, g = a.length, p = g - 1;
        for (c = c === t ? g : c; ++d < c; ) {
          var T = gf(d, p), R = a[T];
          a[T] = a[d], a[d] = R;
        }
        return a.length = c, a;
      }
      var U_ = Cx(function(a) {
        var c = [];
        return a.charCodeAt(0) === 46 && c.push(""), a.replace(Lr, function(d, g, p, T) {
          c.push(p ? T.replace($r, "$1") : g || d);
        }), c;
      });
      function Xi(a) {
        if (typeof a == "string" || si(a))
          return a;
        var c = a + "";
        return c == "0" && 1 / a == -ee ? "-0" : c;
      }
      function ys(a) {
        if (a != null) {
          try {
            return Bc.call(a);
          } catch {
          }
          try {
            return a + "";
          } catch {
          }
        }
        return "";
      }
      function Ax(a, c) {
        return Hn(ce, function(d) {
          var g = "_." + d[0];
          c & d[1] && !ro(a, g) && a.push(g);
        }), a.sort();
      }
      function H_(a) {
        if (a instanceof Je)
          return a.clone();
        var c = new bi(a.__wrapped__, a.__chain__);
        return c.__actions__ = qn(a.__actions__), c.__index__ = a.__index__, c.__values__ = a.__values__, c;
      }
      function Px(a, c, d) {
        (d ? Vn(a, c, d) : c === t) ? c = 1 : c = cn(ze(c), 0);
        var g = a == null ? 0 : a.length;
        if (!g || c < 1)
          return [];
        for (var p = 0, T = 0, R = K(jc(g / c)); p < g; )
          R[T++] = Ei(a, p, p += c);
        return R;
      }
      function Ix(a) {
        for (var c = -1, d = a == null ? 0 : a.length, g = 0, p = []; ++c < d; ) {
          var T = a[c];
          T && (p[g++] = T);
        }
        return p;
      }
      function Rx() {
        var a = arguments.length;
        if (!a)
          return [];
        for (var c = K(a - 1), d = arguments[0], g = a; g--; )
          c[g - 1] = arguments[g];
        return Oi(Le(d) ? qn(d) : [d], yn(c, 1));
      }
      var Ox = He(function(a, c) {
        return Qt(a) ? Da(a, yn(c, 1, Qt, !0)) : [];
      }), Mx = He(function(a, c) {
        var d = Ci(c);
        return Qt(d) && (d = t), Qt(a) ? Da(a, yn(c, 1, Qt, !0), Oe(d, 2)) : [];
      }), Nx = He(function(a, c) {
        var d = Ci(c);
        return Qt(d) && (d = t), Qt(a) ? Da(a, yn(c, 1, Qt, !0), t, d) : [];
      });
      function Dx(a, c, d) {
        var g = a == null ? 0 : a.length;
        return g ? (c = d || c === t ? 1 : ze(c), Ei(a, c < 0 ? 0 : c, g)) : [];
      }
      function Bx(a, c, d) {
        var g = a == null ? 0 : a.length;
        return g ? (c = d || c === t ? 1 : ze(c), c = g - c, Ei(a, 0, c < 0 ? 0 : c)) : [];
      }
      function Vx(a, c) {
        return a && a.length ? Qc(a, Oe(c, 3), !0, !0) : [];
      }
      function Lx(a, c) {
        return a && a.length ? Qc(a, Oe(c, 3), !0) : [];
      }
      function Fx(a, c, d, g) {
        var p = a == null ? 0 : a.length;
        return p ? (d && typeof d != "number" && Vn(a, c, d) && (d = 0, g = p), RT(a, c, d, g)) : [];
      }
      function q_(a, c, d) {
        var g = a == null ? 0 : a.length;
        if (!g)
          return -1;
        var p = d == null ? 0 : ze(d);
        return p < 0 && (p = cn(g + p, 0)), hs(a, Oe(c, 3), p);
      }
      function K_(a, c, d) {
        var g = a == null ? 0 : a.length;
        if (!g)
          return -1;
        var p = g - 1;
        return d !== t && (p = ze(d), p = d < 0 ? cn(g + p, 0) : xn(p, g - 1)), hs(a, Oe(c, 3), p, !0);
      }
      function G_(a) {
        var c = a == null ? 0 : a.length;
        return c ? yn(a, 1) : [];
      }
      function $x(a) {
        var c = a == null ? 0 : a.length;
        return c ? yn(a, ee) : [];
      }
      function zx(a, c) {
        var d = a == null ? 0 : a.length;
        return d ? (c = c === t ? 1 : ze(c), yn(a, c)) : [];
      }
      function Wx(a) {
        for (var c = -1, d = a == null ? 0 : a.length, g = {}; ++c < d; ) {
          var p = a[c];
          g[p[0]] = p[1];
        }
        return g;
      }
      function Y_(a) {
        return a && a.length ? a[0] : t;
      }
      function jx(a, c, d) {
        var g = a == null ? 0 : a.length;
        if (!g)
          return -1;
        var p = d == null ? 0 : ze(d);
        return p < 0 && (p = cn(g + p, 0)), Ur(a, c, p);
      }
      function Ux(a) {
        var c = a == null ? 0 : a.length;
        return c ? Ei(a, 0, -1) : [];
      }
      var Hx = He(function(a) {
        var c = yt(a, bf);
        return c.length && c[0] === a[0] ? uf(c) : [];
      }), qx = He(function(a) {
        var c = Ci(a), d = yt(a, bf);
        return c === Ci(d) ? c = t : d.pop(), d.length && d[0] === a[0] ? uf(d, Oe(c, 2)) : [];
      }), Kx = He(function(a) {
        var c = Ci(a), d = yt(a, bf);
        return c = typeof c == "function" ? c : t, c && d.pop(), d.length && d[0] === a[0] ? uf(d, t, c) : [];
      });
      function Gx(a, c) {
        return a == null ? "" : US.call(a, c);
      }
      function Ci(a) {
        var c = a == null ? 0 : a.length;
        return c ? a[c - 1] : t;
      }
      function Yx(a, c, d) {
        var g = a == null ? 0 : a.length;
        if (!g)
          return -1;
        var p = g;
        return d !== t && (p = ze(d), p = p < 0 ? cn(g + p, 0) : xn(p, g - 1)), c === c ? Ce(a, c, p) : hs(a, Ea, p, !0);
      }
      function Jx(a, c) {
        return a && a.length ? o_(a, ze(c)) : t;
      }
      var Xx = He(J_);
      function J_(a, c) {
        return a && a.length && c && c.length ? mf(a, c) : a;
      }
      function Zx(a, c, d) {
        return a && a.length && c && c.length ? mf(a, c, Oe(d, 2)) : a;
      }
      function Qx(a, c, d) {
        return a && a.length && c && c.length ? mf(a, c, t, d) : a;
      }
      var e2 = wr(function(a, c) {
        var d = a == null ? 0 : a.length, g = of(a, c);
        return c_(a, yt(c, function(p) {
          return br(p, d) ? +p : p;
        }).sort(w_)), g;
      });
      function t2(a, c) {
        var d = [];
        if (!(a && a.length))
          return d;
        var g = -1, p = [], T = a.length;
        for (c = Oe(c, 3); ++g < T; ) {
          var R = a[g];
          c(R, g, a) && (d.push(R), p.push(g));
        }
        return c_(a, p), d;
      }
      function Nf(a) {
        return a == null ? a : GS.call(a);
      }
      function n2(a, c, d) {
        var g = a == null ? 0 : a.length;
        return g ? (d && typeof d != "number" && Vn(a, c, d) ? (c = 0, d = g) : (c = c == null ? 0 : ze(c), d = d === t ? g : ze(d)), Ei(a, c, d)) : [];
      }
      function i2(a, c) {
        return Zc(a, c);
      }
      function r2(a, c, d) {
        return _f(a, c, Oe(d, 2));
      }
      function s2(a, c) {
        var d = a == null ? 0 : a.length;
        if (d) {
          var g = Zc(a, c);
          if (g < d && Ni(a[g], c))
            return g;
        }
        return -1;
      }
      function o2(a, c) {
        return Zc(a, c, !0);
      }
      function a2(a, c, d) {
        return _f(a, c, Oe(d, 2), !0);
      }
      function l2(a, c) {
        var d = a == null ? 0 : a.length;
        if (d) {
          var g = Zc(a, c, !0) - 1;
          if (Ni(a[g], c))
            return g;
        }
        return -1;
      }
      function c2(a) {
        return a && a.length ? d_(a) : [];
      }
      function u2(a, c) {
        return a && a.length ? d_(a, Oe(c, 2)) : [];
      }
      function d2(a) {
        var c = a == null ? 0 : a.length;
        return c ? Ei(a, 1, c) : [];
      }
      function h2(a, c, d) {
        return a && a.length ? (c = d || c === t ? 1 : ze(c), Ei(a, 0, c < 0 ? 0 : c)) : [];
      }
      function f2(a, c, d) {
        var g = a == null ? 0 : a.length;
        return g ? (c = d || c === t ? 1 : ze(c), c = g - c, Ei(a, c < 0 ? 0 : c, g)) : [];
      }
      function m2(a, c) {
        return a && a.length ? Qc(a, Oe(c, 3), !1, !0) : [];
      }
      function g2(a, c) {
        return a && a.length ? Qc(a, Oe(c, 3)) : [];
      }
      var p2 = He(function(a) {
        return Kr(yn(a, 1, Qt, !0));
      }), _2 = He(function(a) {
        var c = Ci(a);
        return Qt(c) && (c = t), Kr(yn(a, 1, Qt, !0), Oe(c, 2));
      }), v2 = He(function(a) {
        var c = Ci(a);
        return c = typeof c == "function" ? c : t, Kr(yn(a, 1, Qt, !0), t, c);
      });
      function w2(a) {
        return a && a.length ? Kr(a) : [];
      }
      function b2(a, c) {
        return a && a.length ? Kr(a, Oe(c, 2)) : [];
      }
      function y2(a, c) {
        return c = typeof c == "function" ? c : t, a && a.length ? Kr(a, t, c) : [];
      }
      function Df(a) {
        if (!(a && a.length))
          return [];
        var c = 0;
        return a = Ki(a, function(d) {
          if (Qt(d))
            return c = cn(d.length, c), !0;
        }), Ta(c, function(d) {
          return yt(a, so(d));
        });
      }
      function X_(a, c) {
        if (!(a && a.length))
          return [];
        var d = Df(a);
        return c == null ? d : yt(d, function(g) {
          return bn(c, t, g);
        });
      }
      var E2 = He(function(a, c) {
        return Qt(a) ? Da(a, c) : [];
      }), C2 = He(function(a) {
        return wf(Ki(a, Qt));
      }), S2 = He(function(a) {
        var c = Ci(a);
        return Qt(c) && (c = t), wf(Ki(a, Qt), Oe(c, 2));
      }), T2 = He(function(a) {
        var c = Ci(a);
        return c = typeof c == "function" ? c : t, wf(Ki(a, Qt), t, c);
      }), x2 = He(Df);
      function k2(a, c) {
        return g_(a || [], c || [], Na);
      }
      function A2(a, c) {
        return g_(a || [], c || [], La);
      }
      var P2 = He(function(a) {
        var c = a.length, d = c > 1 ? a[c - 1] : t;
        return d = typeof d == "function" ? (a.pop(), d) : t, X_(a, d);
      });
      function Z_(a) {
        var c = b(a);
        return c.__chain__ = !0, c;
      }
      function I2(a, c) {
        return c(a), a;
      }
      function lu(a, c) {
        return c(a);
      }
      var R2 = wr(function(a) {
        var c = a.length, d = c ? a[0] : 0, g = this.__wrapped__, p = function(T) {
          return of(T, a);
        };
        return c > 1 || this.__actions__.length || !(g instanceof Je) || !br(d) ? this.thru(p) : (g = g.slice(d, +d + (c ? 1 : 0)), g.__actions__.push({
          func: lu,
          args: [p],
          thisArg: t
        }), new bi(g, this.__chain__).thru(function(T) {
          return c && !T.length && T.push(t), T;
        }));
      });
      function O2() {
        return Z_(this);
      }
      function M2() {
        return new bi(this.value(), this.__chain__);
      }
      function N2() {
        this.__values__ === t && (this.__values__ = h1(this.value()));
        var a = this.__index__ >= this.__values__.length, c = a ? t : this.__values__[this.__index__++];
        return { done: a, value: c };
      }
      function D2() {
        return this;
      }
      function B2(a) {
        for (var c, d = this; d instanceof Kc; ) {
          var g = H_(d);
          g.__index__ = 0, g.__values__ = t, c ? p.__wrapped__ = g : c = g;
          var p = g;
          d = d.__wrapped__;
        }
        return p.__wrapped__ = a, c;
      }
      function V2() {
        var a = this.__wrapped__;
        if (a instanceof Je) {
          var c = a;
          return this.__actions__.length && (c = new Je(this)), c = c.reverse(), c.__actions__.push({
            func: lu,
            args: [Nf],
            thisArg: t
          }), new bi(c, this.__chain__);
        }
        return this.thru(Nf);
      }
      function L2() {
        return m_(this.__wrapped__, this.__actions__);
      }
      var F2 = eu(function(a, c, d) {
        mt.call(a, d) ? ++a[d] : _r(a, d, 1);
      });
      function $2(a, c, d) {
        var g = Le(a) ? io : IT;
        return d && Vn(a, c, d) && (c = t), g(a, Oe(c, 3));
      }
      function z2(a, c) {
        var d = Le(a) ? Ki : Xp;
        return d(a, Oe(c, 3));
      }
      var W2 = T_(q_), j2 = T_(K_);
      function U2(a, c) {
        return yn(cu(a, c), 1);
      }
      function H2(a, c) {
        return yn(cu(a, c), ee);
      }
      function q2(a, c, d) {
        return d = d === t ? 1 : ze(d), yn(cu(a, c), d);
      }
      function Q_(a, c) {
        var d = Le(a) ? Hn : qr;
        return d(a, Oe(c, 3));
      }
      function e1(a, c) {
        var d = Le(a) ? Cc : Jp;
        return d(a, Oe(c, 3));
      }
      var K2 = eu(function(a, c, d) {
        mt.call(a, d) ? a[d].push(c) : _r(a, d, [c]);
      });
      function G2(a, c, d, g) {
        a = Kn(a) ? a : _o(a), d = d && !g ? ze(d) : 0;
        var p = a.length;
        return d < 0 && (d = cn(p + d, 0)), mu(a) ? d <= p && a.indexOf(c, d) > -1 : !!p && Ur(a, c, d) > -1;
      }
      var Y2 = He(function(a, c, d) {
        var g = -1, p = typeof c == "function", T = Kn(a) ? K(a.length) : [];
        return qr(a, function(R) {
          T[++g] = p ? bn(c, R, d) : Ba(R, c, d);
        }), T;
      }), J2 = eu(function(a, c, d) {
        _r(a, d, c);
      });
      function cu(a, c) {
        var d = Le(a) ? yt : i_;
        return d(a, Oe(c, 3));
      }
      function X2(a, c, d, g) {
        return a == null ? [] : (Le(c) || (c = c == null ? [] : [c]), d = g ? t : d, Le(d) || (d = d == null ? [] : [d]), a_(a, c, d));
      }
      var Z2 = eu(function(a, c, d) {
        a[d ? 0 : 1].push(c);
      }, function() {
        return [[], []];
      });
      function Q2(a, c, d) {
        var g = Le(a) ? ba : Ca, p = arguments.length < 3;
        return g(a, Oe(c, 4), d, p, qr);
      }
      function ek(a, c, d) {
        var g = Le(a) ? Gh : Ca, p = arguments.length < 3;
        return g(a, Oe(c, 4), d, p, Jp);
      }
      function tk(a, c) {
        var d = Le(a) ? Ki : Xp;
        return d(a, hu(Oe(c, 3)));
      }
      function nk(a) {
        var c = Le(a) ? qp : GT;
        return c(a);
      }
      function ik(a, c, d) {
        (d ? Vn(a, c, d) : c === t) ? c = 1 : c = ze(c);
        var g = Le(a) ? TT : YT;
        return g(a, c);
      }
      function rk(a) {
        var c = Le(a) ? xT : XT;
        return c(a);
      }
      function sk(a) {
        if (a == null)
          return 0;
        if (Kn(a))
          return mu(a) ? Re(a) : a.length;
        var c = kn(a);
        return c == de || c == sn ? a.size : hf(a).length;
      }
      function ok(a, c, d) {
        var g = Le(a) ? ya : ZT;
        return d && Vn(a, c, d) && (c = t), g(a, Oe(c, 3));
      }
      var ak = He(function(a, c) {
        if (a == null)
          return [];
        var d = c.length;
        return d > 1 && Vn(a, c[0], c[1]) ? c = [] : d > 2 && Vn(c[0], c[1], c[2]) && (c = [c[0]]), a_(a, yn(c, 1), []);
      }), uu = zS || function() {
        return Zt.Date.now();
      };
      function lk(a, c) {
        if (typeof c != "function")
          throw new wi(o);
        return a = ze(a), function() {
          if (--a < 1)
            return c.apply(this, arguments);
        };
      }
      function t1(a, c, d) {
        return c = d ? t : c, c = a && c == null ? a.length : c, vr(a, j, t, t, t, t, c);
      }
      function n1(a, c) {
        var d;
        if (typeof c != "function")
          throw new wi(o);
        return a = ze(a), function() {
          return --a > 0 && (d = c.apply(this, arguments)), a <= 1 && (c = t), d;
        };
      }
      var Bf = He(function(a, c, d) {
        var g = x;
        if (d.length) {
          var p = _(d, go(Bf));
          g |= E;
        }
        return vr(a, g, c, d, p);
      }), i1 = He(function(a, c, d) {
        var g = x | N;
        if (d.length) {
          var p = _(d, go(i1));
          g |= E;
        }
        return vr(c, g, a, d, p);
      });
      function r1(a, c, d) {
        c = d ? t : c;
        var g = vr(a, A, t, t, t, t, t, c);
        return g.placeholder = r1.placeholder, g;
      }
      function s1(a, c, d) {
        c = d ? t : c;
        var g = vr(a, P, t, t, t, t, t, c);
        return g.placeholder = s1.placeholder, g;
      }
      function o1(a, c, d) {
        var g, p, T, R, L, W, ie = 0, re = !1, ae = !1, we = !0;
        if (typeof a != "function")
          throw new wi(o);
        c = Si(c) || 0, zt(d) && (re = !!d.leading, ae = "maxWait" in d, T = ae ? cn(Si(d.maxWait) || 0, c) : T, we = "trailing" in d ? !!d.trailing : we);
        function Te(en) {
          var Di = g, Cr = p;
          return g = p = t, ie = en, R = a.apply(Cr, Di), R;
        }
        function Me(en) {
          return ie = en, L = za(Ge, c), re ? Te(en) : R;
        }
        function je(en) {
          var Di = en - W, Cr = en - ie, T1 = c - Di;
          return ae ? xn(T1, T - Cr) : T1;
        }
        function Ne(en) {
          var Di = en - W, Cr = en - ie;
          return W === t || Di >= c || Di < 0 || ae && Cr >= T;
        }
        function Ge() {
          var en = uu();
          if (Ne(en))
            return Qe(en);
          L = za(Ge, je(en));
        }
        function Qe(en) {
          return L = t, we && g ? Te(en) : (g = p = t, R);
        }
        function oi() {
          L !== t && p_(L), ie = 0, g = W = p = L = t;
        }
        function Ln() {
          return L === t ? R : Qe(uu());
        }
        function ai() {
          var en = uu(), Di = Ne(en);
          if (g = arguments, p = this, W = en, Di) {
            if (L === t)
              return Me(W);
            if (ae)
              return p_(L), L = za(Ge, c), Te(W);
          }
          return L === t && (L = za(Ge, c)), R;
        }
        return ai.cancel = oi, ai.flush = Ln, ai;
      }
      var ck = He(function(a, c) {
        return Yp(a, 1, c);
      }), uk = He(function(a, c, d) {
        return Yp(a, Si(c) || 0, d);
      });
      function dk(a) {
        return vr(a, $);
      }
      function du(a, c) {
        if (typeof a != "function" || c != null && typeof c != "function")
          throw new wi(o);
        var d = function() {
          var g = arguments, p = c ? c.apply(this, g) : g[0], T = d.cache;
          if (T.has(p))
            return T.get(p);
          var R = a.apply(this, g);
          return d.cache = T.set(p, R) || T, R;
        };
        return d.cache = new (du.Cache || pr)(), d;
      }
      du.Cache = pr;
      function hu(a) {
        if (typeof a != "function")
          throw new wi(o);
        return function() {
          var c = arguments;
          switch (c.length) {
            case 0:
              return !a.call(this);
            case 1:
              return !a.call(this, c[0]);
            case 2:
              return !a.call(this, c[0], c[1]);
            case 3:
              return !a.call(this, c[0], c[1], c[2]);
          }
          return !a.apply(this, c);
        };
      }
      function hk(a) {
        return n1(2, a);
      }
      var fk = QT(function(a, c) {
        c = c.length == 1 && Le(c[0]) ? yt(c[0], Tn(Oe())) : yt(yn(c, 1), Tn(Oe()));
        var d = c.length;
        return He(function(g) {
          for (var p = -1, T = xn(g.length, d); ++p < T; )
            g[p] = c[p].call(this, g[p]);
          return bn(a, this, g);
        });
      }), Vf = He(function(a, c) {
        var d = _(c, go(Vf));
        return vr(a, E, t, c, d);
      }), a1 = He(function(a, c) {
        var d = _(c, go(a1));
        return vr(a, V, t, c, d);
      }), mk = wr(function(a, c) {
        return vr(a, U, t, t, t, c);
      });
      function gk(a, c) {
        if (typeof a != "function")
          throw new wi(o);
        return c = c === t ? c : ze(c), He(a, c);
      }
      function pk(a, c) {
        if (typeof a != "function")
          throw new wi(o);
        return c = c == null ? 0 : cn(ze(c), 0), He(function(d) {
          var g = d[c], p = Yr(d, 0, c);
          return g && Oi(p, g), bn(a, this, p);
        });
      }
      function _k(a, c, d) {
        var g = !0, p = !0;
        if (typeof a != "function")
          throw new wi(o);
        return zt(d) && (g = "leading" in d ? !!d.leading : g, p = "trailing" in d ? !!d.trailing : p), o1(a, c, {
          leading: g,
          maxWait: c,
          trailing: p
        });
      }
      function vk(a) {
        return t1(a, 1);
      }
      function wk(a, c) {
        return Vf(yf(c), a);
      }
      function bk() {
        if (!arguments.length)
          return [];
        var a = arguments[0];
        return Le(a) ? a : [a];
      }
      function yk(a) {
        return yi(a, C);
      }
      function Ek(a, c) {
        return c = typeof c == "function" ? c : t, yi(a, C, c);
      }
      function Ck(a) {
        return yi(a, m | C);
      }
      function Sk(a, c) {
        return c = typeof c == "function" ? c : t, yi(a, m | C, c);
      }
      function Tk(a, c) {
        return c == null || Gp(a, c, fn(c));
      }
      function Ni(a, c) {
        return a === c || a !== a && c !== c;
      }
      var xk = ru(cf), kk = ru(function(a, c) {
        return a >= c;
      }), Es = e_(function() {
        return arguments;
      }()) ? e_ : function(a) {
        return Wt(a) && mt.call(a, "callee") && !$p.call(a, "callee");
      }, Le = K.isArray, Ak = vc ? Tn(vc) : BT;
      function Kn(a) {
        return a != null && fu(a.length) && !yr(a);
      }
      function Qt(a) {
        return Wt(a) && Kn(a);
      }
      function Pk(a) {
        return a === !0 || a === !1 || Wt(a) && Bn(a) == Pe;
      }
      var Jr = jS || Gf, Ik = wc ? Tn(wc) : VT;
      function Rk(a) {
        return Wt(a) && a.nodeType === 1 && !Wa(a);
      }
      function Ok(a) {
        if (a == null)
          return !0;
        if (Kn(a) && (Le(a) || typeof a == "string" || typeof a.splice == "function" || Jr(a) || po(a) || Es(a)))
          return !a.length;
        var c = kn(a);
        if (c == de || c == sn)
          return !a.size;
        if ($a(a))
          return !hf(a).length;
        for (var d in a)
          if (mt.call(a, d))
            return !1;
        return !0;
      }
      function Mk(a, c) {
        return Va(a, c);
      }
      function Nk(a, c, d) {
        d = typeof d == "function" ? d : t;
        var g = d ? d(a, c) : t;
        return g === t ? Va(a, c, t, d) : !!g;
      }
      function Lf(a) {
        if (!Wt(a))
          return !1;
        var c = Bn(a);
        return c == De || c == ye || typeof a.message == "string" && typeof a.name == "string" && !Wa(a);
      }
      function Dk(a) {
        return typeof a == "number" && Wp(a);
      }
      function yr(a) {
        if (!zt(a))
          return !1;
        var c = Bn(a);
        return c == q || c == Ze || c == Ee || c == zn;
      }
      function l1(a) {
        return typeof a == "number" && a == ze(a);
      }
      function fu(a) {
        return typeof a == "number" && a > -1 && a % 1 == 0 && a <= te;
      }
      function zt(a) {
        var c = typeof a;
        return a != null && (c == "object" || c == "function");
      }
      function Wt(a) {
        return a != null && typeof a == "object";
      }
      var c1 = bc ? Tn(bc) : FT;
      function Bk(a, c) {
        return a === c || df(a, c, Af(c));
      }
      function Vk(a, c, d) {
        return d = typeof d == "function" ? d : t, df(a, c, Af(c), d);
      }
      function Lk(a) {
        return u1(a) && a != +a;
      }
      function Fk(a) {
        if (Ex(a))
          throw new ke(s);
        return t_(a);
      }
      function $k(a) {
        return a === null;
      }
      function zk(a) {
        return a == null;
      }
      function u1(a) {
        return typeof a == "number" || Wt(a) && Bn(a) == Ye;
      }
      function Wa(a) {
        if (!Wt(a) || Bn(a) != rn)
          return !1;
        var c = $c(a);
        if (c === null)
          return !0;
        var d = mt.call(c, "constructor") && c.constructor;
        return typeof d == "function" && d instanceof d && Bc.call(d) == VS;
      }
      var Ff = yc ? Tn(yc) : $T;
      function Wk(a) {
        return l1(a) && a >= -te && a <= te;
      }
      var d1 = Ec ? Tn(Ec) : zT;
      function mu(a) {
        return typeof a == "string" || !Le(a) && Wt(a) && Bn(a) == Wn;
      }
      function si(a) {
        return typeof a == "symbol" || Wt(a) && Bn(a) == gi;
      }
      var po = qi ? Tn(qi) : WT;
      function jk(a) {
        return a === t;
      }
      function Uk(a) {
        return Wt(a) && kn(a) == Un;
      }
      function Hk(a) {
        return Wt(a) && Bn(a) == dn;
      }
      var qk = ru(ff), Kk = ru(function(a, c) {
        return a <= c;
      });
      function h1(a) {
        if (!a)
          return [];
        if (Kn(a))
          return mu(a) ? Ie(a) : qn(a);
        if (Pa && a[Pa])
          return Aa(a[Pa]());
        var c = kn(a), d = c == de ? Gi : c == sn ? w : _o;
        return d(a);
      }
      function Er(a) {
        if (!a)
          return a === 0 ? a : 0;
        if (a = Si(a), a === ee || a === -ee) {
          var c = a < 0 ? -1 : 1;
          return c * ne;
        }
        return a === a ? a : 0;
      }
      function ze(a) {
        var c = Er(a), d = c % 1;
        return c === c ? d ? c - d : c : 0;
      }
      function f1(a) {
        return a ? vs(ze(a), 0, se) : 0;
      }
      function Si(a) {
        if (typeof a == "number")
          return a;
        if (si(a))
          return z;
        if (zt(a)) {
          var c = typeof a.valueOf == "function" ? a.valueOf() : a;
          a = zt(c) ? c + "" : c;
        }
        if (typeof a != "string")
          return a === 0 ? a : +a;
        a = kc(a);
        var d = Yl.test(a);
        return d || Jl.test(a) ? pa(a.slice(2), d ? 2 : 8) : Gl.test(a) ? z : +a;
      }
      function m1(a) {
        return Ji(a, Gn(a));
      }
      function Gk(a) {
        return a ? vs(ze(a), -te, te) : a === 0 ? a : 0;
      }
      function st(a) {
        return a == null ? "" : ri(a);
      }
      var Yk = fo(function(a, c) {
        if ($a(c) || Kn(c)) {
          Ji(c, fn(c), a);
          return;
        }
        for (var d in c)
          mt.call(c, d) && Na(a, d, c[d]);
      }), g1 = fo(function(a, c) {
        Ji(c, Gn(c), a);
      }), gu = fo(function(a, c, d, g) {
        Ji(c, Gn(c), a, g);
      }), Jk = fo(function(a, c, d, g) {
        Ji(c, fn(c), a, g);
      }), Xk = wr(of);
      function Zk(a, c) {
        var d = ho(a);
        return c == null ? d : Kp(d, c);
      }
      var Qk = He(function(a, c) {
        a = Ct(a);
        var d = -1, g = c.length, p = g > 2 ? c[2] : t;
        for (p && Vn(c[0], c[1], p) && (g = 1); ++d < g; )
          for (var T = c[d], R = Gn(T), L = -1, W = R.length; ++L < W; ) {
            var ie = R[L], re = a[ie];
            (re === t || Ni(re, lo[ie]) && !mt.call(a, ie)) && (a[ie] = T[ie]);
          }
        return a;
      }), eA = He(function(a) {
        return a.push(t, O_), bn(p1, t, a);
      });
      function tA(a, c) {
        return Tc(a, Oe(c, 3), Yi);
      }
      function nA(a, c) {
        return Tc(a, Oe(c, 3), lf);
      }
      function iA(a, c) {
        return a == null ? a : af(a, Oe(c, 3), Gn);
      }
      function rA(a, c) {
        return a == null ? a : Zp(a, Oe(c, 3), Gn);
      }
      function sA(a, c) {
        return a && Yi(a, Oe(c, 3));
      }
      function oA(a, c) {
        return a && lf(a, Oe(c, 3));
      }
      function aA(a) {
        return a == null ? [] : Jc(a, fn(a));
      }
      function lA(a) {
        return a == null ? [] : Jc(a, Gn(a));
      }
      function $f(a, c, d) {
        var g = a == null ? t : ws(a, c);
        return g === t ? d : g;
      }
      function cA(a, c) {
        return a != null && D_(a, c, OT);
      }
      function zf(a, c) {
        return a != null && D_(a, c, MT);
      }
      var uA = k_(function(a, c, d) {
        c != null && typeof c.toString != "function" && (c = Vc.call(c)), a[c] = d;
      }, jf(Yn)), dA = k_(function(a, c, d) {
        c != null && typeof c.toString != "function" && (c = Vc.call(c)), mt.call(a, c) ? a[c].push(d) : a[c] = [d];
      }, Oe), hA = He(Ba);
      function fn(a) {
        return Kn(a) ? Hp(a) : hf(a);
      }
      function Gn(a) {
        return Kn(a) ? Hp(a, !0) : jT(a);
      }
      function fA(a, c) {
        var d = {};
        return c = Oe(c, 3), Yi(a, function(g, p, T) {
          _r(d, c(g, p, T), g);
        }), d;
      }
      function mA(a, c) {
        var d = {};
        return c = Oe(c, 3), Yi(a, function(g, p, T) {
          _r(d, p, c(g, p, T));
        }), d;
      }
      var gA = fo(function(a, c, d) {
        Xc(a, c, d);
      }), p1 = fo(function(a, c, d, g) {
        Xc(a, c, d, g);
      }), pA = wr(function(a, c) {
        var d = {};
        if (a == null)
          return d;
        var g = !1;
        c = yt(c, function(T) {
          return T = Gr(T, a), g || (g = T.length > 1), T;
        }), Ji(a, xf(a), d), g && (d = yi(d, m | v | C, ux));
        for (var p = c.length; p--; )
          vf(d, c[p]);
        return d;
      });
      function _A(a, c) {
        return _1(a, hu(Oe(c)));
      }
      var vA = wr(function(a, c) {
        return a == null ? {} : HT(a, c);
      });
      function _1(a, c) {
        if (a == null)
          return {};
        var d = yt(xf(a), function(g) {
          return [g];
        });
        return c = Oe(c), l_(a, d, function(g, p) {
          return c(g, p[0]);
        });
      }
      function wA(a, c, d) {
        c = Gr(c, a);
        var g = -1, p = c.length;
        for (p || (p = 1, a = t); ++g < p; ) {
          var T = a == null ? t : a[Xi(c[g])];
          T === t && (g = p, T = d), a = yr(T) ? T.call(a) : T;
        }
        return a;
      }
      function bA(a, c, d) {
        return a == null ? a : La(a, c, d);
      }
      function yA(a, c, d, g) {
        return g = typeof g == "function" ? g : t, a == null ? a : La(a, c, d, g);
      }
      var v1 = I_(fn), w1 = I_(Gn);
      function EA(a, c, d) {
        var g = Le(a), p = g || Jr(a) || po(a);
        if (c = Oe(c, 4), d == null) {
          var T = a && a.constructor;
          p ? d = g ? new T() : [] : zt(a) ? d = yr(T) ? ho($c(a)) : {} : d = {};
        }
        return (p ? Hn : Yi)(a, function(R, L, W) {
          return c(d, R, L, W);
        }), d;
      }
      function CA(a, c) {
        return a == null ? !0 : vf(a, c);
      }
      function SA(a, c, d) {
        return a == null ? a : f_(a, c, yf(d));
      }
      function TA(a, c, d, g) {
        return g = typeof g == "function" ? g : t, a == null ? a : f_(a, c, yf(d), g);
      }
      function _o(a) {
        return a == null ? [] : xa(a, fn(a));
      }
      function xA(a) {
        return a == null ? [] : xa(a, Gn(a));
      }
      function kA(a, c, d) {
        return d === t && (d = c, c = t), d !== t && (d = Si(d), d = d === d ? d : 0), c !== t && (c = Si(c), c = c === c ? c : 0), vs(Si(a), c, d);
      }
      function AA(a, c, d) {
        return c = Er(c), d === t ? (d = c, c = 0) : d = Er(d), a = Si(a), NT(a, c, d);
      }
      function PA(a, c, d) {
        if (d && typeof d != "boolean" && Vn(a, c, d) && (c = d = t), d === t && (typeof c == "boolean" ? (d = c, c = t) : typeof a == "boolean" && (d = a, a = t)), a === t && c === t ? (a = 0, c = 1) : (a = Er(a), c === t ? (c = a, a = 0) : c = Er(c)), a > c) {
          var g = a;
          a = c, c = g;
        }
        if (d || a % 1 || c % 1) {
          var p = jp();
          return xn(a + p * (c - a + qh("1e-" + ((p + "").length - 1))), c);
        }
        return gf(a, c);
      }
      var IA = mo(function(a, c, d) {
        return c = c.toLowerCase(), a + (d ? b1(c) : c);
      });
      function b1(a) {
        return Wf(st(a).toLowerCase());
      }
      function y1(a) {
        return a = st(a), a && a.replace(Mh, ms).replace(zh, "");
      }
      function RA(a, c, d) {
        a = st(a), c = ri(c);
        var g = a.length;
        d = d === t ? g : vs(ze(d), 0, g);
        var p = d;
        return d -= c.length, d >= 0 && a.slice(d, p) == c;
      }
      function OA(a) {
        return a = st(a), a && ei.test(a) ? a.replace(pi, Rc) : a;
      }
      function MA(a) {
        return a = st(a), a && wn.test(a) ? a.replace(ni, "\\$&") : a;
      }
      var NA = mo(function(a, c, d) {
        return a + (d ? "-" : "") + c.toLowerCase();
      }), DA = mo(function(a, c, d) {
        return a + (d ? " " : "") + c.toLowerCase();
      }), BA = S_("toLowerCase");
      function VA(a, c, d) {
        a = st(a), c = ze(c);
        var g = c ? Re(a) : 0;
        if (!c || g >= c)
          return a;
        var p = (c - g) / 2;
        return iu(Uc(p), d) + a + iu(jc(p), d);
      }
      function LA(a, c, d) {
        a = st(a), c = ze(c);
        var g = c ? Re(a) : 0;
        return c && g < c ? a + iu(c - g, d) : a;
      }
      function FA(a, c, d) {
        a = st(a), c = ze(c);
        var g = c ? Re(a) : 0;
        return c && g < c ? iu(c - g, d) + a : a;
      }
      function $A(a, c, d) {
        return d || c == null ? c = 0 : c && (c = +c), KS(st(a).replace(ft, ""), c || 0);
      }
      function zA(a, c, d) {
        return (d ? Vn(a, c, d) : c === t) ? c = 1 : c = ze(c), pf(st(a), c);
      }
      function WA() {
        var a = arguments, c = st(a[0]);
        return a.length < 3 ? c : c.replace(a[1], a[2]);
      }
      var jA = mo(function(a, c, d) {
        return a + (d ? "_" : "") + c.toLowerCase();
      });
      function UA(a, c, d) {
        return d && typeof d != "number" && Vn(a, c, d) && (c = d = t), d = d === t ? se : d >>> 0, d ? (a = st(a), a && (typeof c == "string" || c != null && !Ff(c)) && (c = ri(c), !c && fr(a)) ? Yr(Ie(a), 0, d) : a.split(c, d)) : [];
      }
      var HA = mo(function(a, c, d) {
        return a + (d ? " " : "") + Wf(c);
      });
      function qA(a, c, d) {
        return a = st(a), d = d == null ? 0 : vs(ze(d), 0, a.length), c = ri(c), a.slice(d, d + c.length) == c;
      }
      function KA(a, c, d) {
        var g = b.templateSettings;
        d && Vn(a, c, d) && (c = t), a = st(a), c = gu({}, c, g, R_);
        var p = gu({}, c.imports, g.imports, R_), T = fn(p), R = xa(p, T), L, W, ie = 0, re = c.interpolate || us, ae = "__p += '", we = ef(
          (c.escape || us).source + "|" + re.source + "|" + (re === Sn ? Rh : us).source + "|" + (c.evaluate || us).source + "|$",
          "g"
        ), Te = "//# sourceURL=" + (mt.call(c, "sourceURL") ? (c.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++jh + "]") + `
`;
        a.replace(we, function(Ne, Ge, Qe, oi, Ln, ai) {
          return Qe || (Qe = oi), ae += a.slice(ie, ai).replace(Xl, Qh), Ge && (L = !0, ae += `' +
__e(` + Ge + `) +
'`), Ln && (W = !0, ae += `';
` + Ln + `;
__p += '`), Qe && (ae += `' +
((__t = (` + Qe + `)) == null ? '' : __t) +
'`), ie = ai + Ne.length, Ne;
        }), ae += `';
`;
        var Me = mt.call(c, "variable") && c.variable;
        if (!Me)
          ae = `with (obj) {
` + ae + `
}
`;
        else if (Ih.test(Me))
          throw new ke(l);
        ae = (W ? ae.replace(hn, "") : ae).replace(vn, "$1").replace(Cn, "$1;"), ae = "function(" + (Me || "obj") + `) {
` + (Me ? "" : `obj || (obj = {});
`) + "var __t, __p = ''" + (L ? ", __e = _.escape" : "") + (W ? `, __j = Array.prototype.join;
function print() { __p += __j.call(arguments, '') }
` : `;
`) + ae + `return __p
}`;
        var je = C1(function() {
          return $e(T, Te + "return " + ae).apply(t, R);
        });
        if (je.source = ae, Lf(je))
          throw je;
        return je;
      }
      function GA(a) {
        return st(a).toLowerCase();
      }
      function YA(a) {
        return st(a).toUpperCase();
      }
      function JA(a, c, d) {
        if (a = st(a), a && (d || c === t))
          return kc(a);
        if (!a || !(c = ri(c)))
          return a;
        var g = Ie(a), p = Ie(c), T = Ac(g, p), R = Pc(g, p) + 1;
        return Yr(g, T, R).join("");
      }
      function XA(a, c, d) {
        if (a = st(a), a && (d || c === t))
          return a.slice(0, Ve(a) + 1);
        if (!a || !(c = ri(c)))
          return a;
        var g = Ie(a), p = Pc(g, Ie(c)) + 1;
        return Yr(g, 0, p).join("");
      }
      function ZA(a, c, d) {
        if (a = st(a), a && (d || c === t))
          return a.replace(ft, "");
        if (!a || !(c = ri(c)))
          return a;
        var g = Ie(a), p = Ac(g, Ie(c));
        return Yr(g, p).join("");
      }
      function QA(a, c) {
        var d = M, g = D;
        if (zt(c)) {
          var p = "separator" in c ? c.separator : p;
          d = "length" in c ? ze(c.length) : d, g = "omission" in c ? ri(c.omission) : g;
        }
        a = st(a);
        var T = a.length;
        if (fr(a)) {
          var R = Ie(a);
          T = R.length;
        }
        if (d >= T)
          return a;
        var L = d - Re(g);
        if (L < 1)
          return g;
        var W = R ? Yr(R, 0, L).join("") : a.slice(0, L);
        if (p === t)
          return W + g;
        if (R && (L += W.length - L), Ff(p)) {
          if (a.slice(L).search(p)) {
            var ie, re = W;
            for (p.global || (p = ef(p.source, st(Kl.exec(p)) + "g")), p.lastIndex = 0; ie = p.exec(re); )
              var ae = ie.index;
            W = W.slice(0, ae === t ? L : ae);
          }
        } else if (a.indexOf(ri(p), L) != L) {
          var we = W.lastIndexOf(p);
          we > -1 && (W = W.slice(0, we));
        }
        return W + g;
      }
      function eP(a) {
        return a = st(a), a && Ui.test(a) ? a.replace(ln, $t) : a;
      }
      var tP = mo(function(a, c, d) {
        return a + (d ? " " : "") + c.toUpperCase();
      }), Wf = S_("toUpperCase");
      function E1(a, c, d) {
        return a = st(a), c = d ? t : c, c === t ? ka(a) ? mr(a) : Jh(a) : a.match(c) || [];
      }
      var C1 = He(function(a, c) {
        try {
          return bn(a, t, c);
        } catch (d) {
          return Lf(d) ? d : new ke(d);
        }
      }), nP = wr(function(a, c) {
        return Hn(c, function(d) {
          d = Xi(d), _r(a, d, Bf(a[d], a));
        }), a;
      });
      function iP(a) {
        var c = a == null ? 0 : a.length, d = Oe();
        return a = c ? yt(a, function(g) {
          if (typeof g[1] != "function")
            throw new wi(o);
          return [d(g[0]), g[1]];
        }) : [], He(function(g) {
          for (var p = -1; ++p < c; ) {
            var T = a[p];
            if (bn(T[0], this, g))
              return bn(T[1], this, g);
          }
        });
      }
      function rP(a) {
        return PT(yi(a, m));
      }
      function jf(a) {
        return function() {
          return a;
        };
      }
      function sP(a, c) {
        return a == null || a !== a ? c : a;
      }
      var oP = x_(), aP = x_(!0);
      function Yn(a) {
        return a;
      }
      function Uf(a) {
        return n_(typeof a == "function" ? a : yi(a, m));
      }
      function lP(a) {
        return r_(yi(a, m));
      }
      function cP(a, c) {
        return s_(a, yi(c, m));
      }
      var uP = He(function(a, c) {
        return function(d) {
          return Ba(d, a, c);
        };
      }), dP = He(function(a, c) {
        return function(d) {
          return Ba(a, d, c);
        };
      });
      function Hf(a, c, d) {
        var g = fn(c), p = Jc(c, g);
        d == null && !(zt(c) && (p.length || !g.length)) && (d = c, c = a, a = this, p = Jc(c, fn(c)));
        var T = !(zt(d) && "chain" in d) || !!d.chain, R = yr(a);
        return Hn(p, function(L) {
          var W = c[L];
          a[L] = W, R && (a.prototype[L] = function() {
            var ie = this.__chain__;
            if (T || ie) {
              var re = a(this.__wrapped__), ae = re.__actions__ = qn(this.__actions__);
              return ae.push({ func: W, args: arguments, thisArg: a }), re.__chain__ = ie, re;
            }
            return W.apply(a, Oi([this.value()], arguments));
          });
        }), a;
      }
      function hP() {
        return Zt._ === this && (Zt._ = LS), this;
      }
      function qf() {
      }
      function fP(a) {
        return a = ze(a), He(function(c) {
          return o_(c, a);
        });
      }
      var mP = Cf(yt), gP = Cf(io), pP = Cf(ya);
      function S1(a) {
        return If(a) ? so(Xi(a)) : qT(a);
      }
      function _P(a) {
        return function(c) {
          return a == null ? t : ws(a, c);
        };
      }
      var vP = A_(), wP = A_(!0);
      function Kf() {
        return [];
      }
      function Gf() {
        return !1;
      }
      function bP() {
        return {};
      }
      function yP() {
        return "";
      }
      function EP() {
        return !0;
      }
      function CP(a, c) {
        if (a = ze(a), a < 1 || a > te)
          return [];
        var d = se, g = xn(a, se);
        c = Oe(c), a -= se;
        for (var p = Ta(g, c); ++d < a; )
          c(d);
        return p;
      }
      function SP(a) {
        return Le(a) ? yt(a, Xi) : si(a) ? [a] : qn(U_(st(a)));
      }
      function TP(a) {
        var c = ++BS;
        return st(a) + c;
      }
      var xP = nu(function(a, c) {
        return a + c;
      }, 0), kP = Sf("ceil"), AP = nu(function(a, c) {
        return a / c;
      }, 1), PP = Sf("floor");
      function IP(a) {
        return a && a.length ? Yc(a, Yn, cf) : t;
      }
      function RP(a, c) {
        return a && a.length ? Yc(a, Oe(c, 2), cf) : t;
      }
      function OP(a) {
        return xc(a, Yn);
      }
      function MP(a, c) {
        return xc(a, Oe(c, 2));
      }
      function NP(a) {
        return a && a.length ? Yc(a, Yn, ff) : t;
      }
      function DP(a, c) {
        return a && a.length ? Yc(a, Oe(c, 2), ff) : t;
      }
      var BP = nu(function(a, c) {
        return a * c;
      }, 1), VP = Sf("round"), LP = nu(function(a, c) {
        return a - c;
      }, 0);
      function FP(a) {
        return a && a.length ? Sa(a, Yn) : 0;
      }
      function $P(a, c) {
        return a && a.length ? Sa(a, Oe(c, 2)) : 0;
      }
      return b.after = lk, b.ary = t1, b.assign = Yk, b.assignIn = g1, b.assignInWith = gu, b.assignWith = Jk, b.at = Xk, b.before = n1, b.bind = Bf, b.bindAll = nP, b.bindKey = i1, b.castArray = bk, b.chain = Z_, b.chunk = Px, b.compact = Ix, b.concat = Rx, b.cond = iP, b.conforms = rP, b.constant = jf, b.countBy = F2, b.create = Zk, b.curry = r1, b.curryRight = s1, b.debounce = o1, b.defaults = Qk, b.defaultsDeep = eA, b.defer = ck, b.delay = uk, b.difference = Ox, b.differenceBy = Mx, b.differenceWith = Nx, b.drop = Dx, b.dropRight = Bx, b.dropRightWhile = Vx, b.dropWhile = Lx, b.fill = Fx, b.filter = z2, b.flatMap = U2, b.flatMapDeep = H2, b.flatMapDepth = q2, b.flatten = G_, b.flattenDeep = $x, b.flattenDepth = zx, b.flip = dk, b.flow = oP, b.flowRight = aP, b.fromPairs = Wx, b.functions = aA, b.functionsIn = lA, b.groupBy = K2, b.initial = Ux, b.intersection = Hx, b.intersectionBy = qx, b.intersectionWith = Kx, b.invert = uA, b.invertBy = dA, b.invokeMap = Y2, b.iteratee = Uf, b.keyBy = J2, b.keys = fn, b.keysIn = Gn, b.map = cu, b.mapKeys = fA, b.mapValues = mA, b.matches = lP, b.matchesProperty = cP, b.memoize = du, b.merge = gA, b.mergeWith = p1, b.method = uP, b.methodOf = dP, b.mixin = Hf, b.negate = hu, b.nthArg = fP, b.omit = pA, b.omitBy = _A, b.once = hk, b.orderBy = X2, b.over = mP, b.overArgs = fk, b.overEvery = gP, b.overSome = pP, b.partial = Vf, b.partialRight = a1, b.partition = Z2, b.pick = vA, b.pickBy = _1, b.property = S1, b.propertyOf = _P, b.pull = Xx, b.pullAll = J_, b.pullAllBy = Zx, b.pullAllWith = Qx, b.pullAt = e2, b.range = vP, b.rangeRight = wP, b.rearg = mk, b.reject = tk, b.remove = t2, b.rest = gk, b.reverse = Nf, b.sampleSize = ik, b.set = bA, b.setWith = yA, b.shuffle = rk, b.slice = n2, b.sortBy = ak, b.sortedUniq = c2, b.sortedUniqBy = u2, b.split = UA, b.spread = pk, b.tail = d2, b.take = h2, b.takeRight = f2, b.takeRightWhile = m2, b.takeWhile = g2, b.tap = I2, b.throttle = _k, b.thru = lu, b.toArray = h1, b.toPairs = v1, b.toPairsIn = w1, b.toPath = SP, b.toPlainObject = m1, b.transform = EA, b.unary = vk, b.union = p2, b.unionBy = _2, b.unionWith = v2, b.uniq = w2, b.uniqBy = b2, b.uniqWith = y2, b.unset = CA, b.unzip = Df, b.unzipWith = X_, b.update = SA, b.updateWith = TA, b.values = _o, b.valuesIn = xA, b.without = E2, b.words = E1, b.wrap = wk, b.xor = C2, b.xorBy = S2, b.xorWith = T2, b.zip = x2, b.zipObject = k2, b.zipObjectDeep = A2, b.zipWith = P2, b.entries = v1, b.entriesIn = w1, b.extend = g1, b.extendWith = gu, Hf(b, b), b.add = xP, b.attempt = C1, b.camelCase = IA, b.capitalize = b1, b.ceil = kP, b.clamp = kA, b.clone = yk, b.cloneDeep = Ck, b.cloneDeepWith = Sk, b.cloneWith = Ek, b.conformsTo = Tk, b.deburr = y1, b.defaultTo = sP, b.divide = AP, b.endsWith = RA, b.eq = Ni, b.escape = OA, b.escapeRegExp = MA, b.every = $2, b.find = W2, b.findIndex = q_, b.findKey = tA, b.findLast = j2, b.findLastIndex = K_, b.findLastKey = nA, b.floor = PP, b.forEach = Q_, b.forEachRight = e1, b.forIn = iA, b.forInRight = rA, b.forOwn = sA, b.forOwnRight = oA, b.get = $f, b.gt = xk, b.gte = kk, b.has = cA, b.hasIn = zf, b.head = Y_, b.identity = Yn, b.includes = G2, b.indexOf = jx, b.inRange = AA, b.invoke = hA, b.isArguments = Es, b.isArray = Le, b.isArrayBuffer = Ak, b.isArrayLike = Kn, b.isArrayLikeObject = Qt, b.isBoolean = Pk, b.isBuffer = Jr, b.isDate = Ik, b.isElement = Rk, b.isEmpty = Ok, b.isEqual = Mk, b.isEqualWith = Nk, b.isError = Lf, b.isFinite = Dk, b.isFunction = yr, b.isInteger = l1, b.isLength = fu, b.isMap = c1, b.isMatch = Bk, b.isMatchWith = Vk, b.isNaN = Lk, b.isNative = Fk, b.isNil = zk, b.isNull = $k, b.isNumber = u1, b.isObject = zt, b.isObjectLike = Wt, b.isPlainObject = Wa, b.isRegExp = Ff, b.isSafeInteger = Wk, b.isSet = d1, b.isString = mu, b.isSymbol = si, b.isTypedArray = po, b.isUndefined = jk, b.isWeakMap = Uk, b.isWeakSet = Hk, b.join = Gx, b.kebabCase = NA, b.last = Ci, b.lastIndexOf = Yx, b.lowerCase = DA, b.lowerFirst = BA, b.lt = qk, b.lte = Kk, b.max = IP, b.maxBy = RP, b.mean = OP, b.meanBy = MP, b.min = NP, b.minBy = DP, b.stubArray = Kf, b.stubFalse = Gf, b.stubObject = bP, b.stubString = yP, b.stubTrue = EP, b.multiply = BP, b.nth = Jx, b.noConflict = hP, b.noop = qf, b.now = uu, b.pad = VA, b.padEnd = LA, b.padStart = FA, b.parseInt = $A, b.random = PA, b.reduce = Q2, b.reduceRight = ek, b.repeat = zA, b.replace = WA, b.result = wA, b.round = VP, b.runInContext = F, b.sample = nk, b.size = sk, b.snakeCase = jA, b.some = ok, b.sortedIndex = i2, b.sortedIndexBy = r2, b.sortedIndexOf = s2, b.sortedLastIndex = o2, b.sortedLastIndexBy = a2, b.sortedLastIndexOf = l2, b.startCase = HA, b.startsWith = qA, b.subtract = LP, b.sum = FP, b.sumBy = $P, b.template = KA, b.times = CP, b.toFinite = Er, b.toInteger = ze, b.toLength = f1, b.toLower = GA, b.toNumber = Si, b.toSafeInteger = Gk, b.toString = st, b.toUpper = YA, b.trim = JA, b.trimEnd = XA, b.trimStart = ZA, b.truncate = QA, b.unescape = eP, b.uniqueId = TP, b.upperCase = tP, b.upperFirst = Wf, b.each = Q_, b.eachRight = e1, b.first = Y_, Hf(b, function() {
        var a = {};
        return Yi(b, function(c, d) {
          mt.call(b.prototype, d) || (a[d] = c);
        }), a;
      }(), { chain: !1 }), b.VERSION = n, Hn(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(a) {
        b[a].placeholder = b;
      }), Hn(["drop", "take"], function(a, c) {
        Je.prototype[a] = function(d) {
          d = d === t ? 1 : cn(ze(d), 0);
          var g = this.__filtered__ && !c ? new Je(this) : this.clone();
          return g.__filtered__ ? g.__takeCount__ = xn(d, g.__takeCount__) : g.__views__.push({
            size: xn(d, se),
            type: a + (g.__dir__ < 0 ? "Right" : "")
          }), g;
        }, Je.prototype[a + "Right"] = function(d) {
          return this.reverse()[a](d).reverse();
        };
      }), Hn(["filter", "map", "takeWhile"], function(a, c) {
        var d = c + 1, g = d == Y || d == me;
        Je.prototype[a] = function(p) {
          var T = this.clone();
          return T.__iteratees__.push({
            iteratee: Oe(p, 3),
            type: d
          }), T.__filtered__ = T.__filtered__ || g, T;
        };
      }), Hn(["head", "last"], function(a, c) {
        var d = "take" + (c ? "Right" : "");
        Je.prototype[a] = function() {
          return this[d](1).value()[0];
        };
      }), Hn(["initial", "tail"], function(a, c) {
        var d = "drop" + (c ? "" : "Right");
        Je.prototype[a] = function() {
          return this.__filtered__ ? new Je(this) : this[d](1);
        };
      }), Je.prototype.compact = function() {
        return this.filter(Yn);
      }, Je.prototype.find = function(a) {
        return this.filter(a).head();
      }, Je.prototype.findLast = function(a) {
        return this.reverse().find(a);
      }, Je.prototype.invokeMap = He(function(a, c) {
        return typeof a == "function" ? new Je(this) : this.map(function(d) {
          return Ba(d, a, c);
        });
      }), Je.prototype.reject = function(a) {
        return this.filter(hu(Oe(a)));
      }, Je.prototype.slice = function(a, c) {
        a = ze(a);
        var d = this;
        return d.__filtered__ && (a > 0 || c < 0) ? new Je(d) : (a < 0 ? d = d.takeRight(-a) : a && (d = d.drop(a)), c !== t && (c = ze(c), d = c < 0 ? d.dropRight(-c) : d.take(c - a)), d);
      }, Je.prototype.takeRightWhile = function(a) {
        return this.reverse().takeWhile(a).reverse();
      }, Je.prototype.toArray = function() {
        return this.take(se);
      }, Yi(Je.prototype, function(a, c) {
        var d = /^(?:filter|find|map|reject)|While$/.test(c), g = /^(?:head|last)$/.test(c), p = b[g ? "take" + (c == "last" ? "Right" : "") : c], T = g || /^find/.test(c);
        p && (b.prototype[c] = function() {
          var R = this.__wrapped__, L = g ? [1] : arguments, W = R instanceof Je, ie = L[0], re = W || Le(R), ae = function(Ge) {
            var Qe = p.apply(b, Oi([Ge], L));
            return g && we ? Qe[0] : Qe;
          };
          re && d && typeof ie == "function" && ie.length != 1 && (W = re = !1);
          var we = this.__chain__, Te = !!this.__actions__.length, Me = T && !we, je = W && !Te;
          if (!T && re) {
            R = je ? R : new Je(this);
            var Ne = a.apply(R, L);
            return Ne.__actions__.push({ func: lu, args: [ae], thisArg: t }), new bi(Ne, we);
          }
          return Me && je ? a.apply(this, L) : (Ne = this.thru(ae), Me ? g ? Ne.value()[0] : Ne.value() : Ne);
        });
      }), Hn(["pop", "push", "shift", "sort", "splice", "unshift"], function(a) {
        var c = Nc[a], d = /^(?:push|sort|unshift)$/.test(a) ? "tap" : "thru", g = /^(?:pop|shift)$/.test(a);
        b.prototype[a] = function() {
          var p = arguments;
          if (g && !this.__chain__) {
            var T = this.value();
            return c.apply(Le(T) ? T : [], p);
          }
          return this[d](function(R) {
            return c.apply(Le(R) ? R : [], p);
          });
        };
      }), Yi(Je.prototype, function(a, c) {
        var d = b[c];
        if (d) {
          var g = d.name + "";
          mt.call(uo, g) || (uo[g] = []), uo[g].push({ name: c, func: d });
        }
      }), uo[tu(t, N).name] = [{
        name: "wrapper",
        func: t
      }], Je.prototype.clone = eT, Je.prototype.reverse = tT, Je.prototype.value = nT, b.prototype.at = R2, b.prototype.chain = O2, b.prototype.commit = M2, b.prototype.next = N2, b.prototype.plant = B2, b.prototype.reverse = V2, b.prototype.toJSON = b.prototype.valueOf = b.prototype.value = L2, b.prototype.first = b.prototype.head, Pa && (b.prototype[Pa] = D2), b;
    }, ii = _i();
    Hi ? ((Hi.exports = ii)._ = ii, to._ = ii) : Zt._ = ii;
  }).call(et);
})(KP, od);
const nl = od.runInContext();
nl.mixin({
  // Immutable set for setting state
  setIn: (i, e, t) => nl.setWith(nl.clone(i), e, t, nl.clone)
});
const P1 = nl;
function Ae() {
  return Ae = Object.assign ? Object.assign.bind() : function(i) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var n in t)
        Object.prototype.hasOwnProperty.call(t, n) && (i[n] = t[n]);
    }
    return i;
  }, Ae.apply(this, arguments);
}
var Rs = {};
function pu(i) {
  return i !== null && typeof i == "object" && i.constructor === Object;
}
function ki(i, e, t = {
  clone: !0
}) {
  const n = t.clone ? Ae({}, i) : i;
  return pu(i) && pu(e) && Object.keys(e).forEach((r) => {
    r !== "__proto__" && (pu(e[r]) && r in i && pu(i[r]) ? n[r] = ki(i[r], e[r], t) : n[r] = e[r]);
  }), n;
}
var Ue = {}, I1 = {
  get exports() {
    return Ue;
  },
  set exports(i) {
    Ue = i;
  }
}, ad = {}, GP = {
  get exports() {
    return ad;
  },
  set exports(i) {
    ad = i;
  }
}, ot = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var R1;
function YP() {
  if (R1)
    return ot;
  R1 = 1;
  var i = typeof Symbol == "function" && Symbol.for, e = i ? Symbol.for("react.element") : 60103, t = i ? Symbol.for("react.portal") : 60106, n = i ? Symbol.for("react.fragment") : 60107, r = i ? Symbol.for("react.strict_mode") : 60108, s = i ? Symbol.for("react.profiler") : 60114, o = i ? Symbol.for("react.provider") : 60109, l = i ? Symbol.for("react.context") : 60110, u = i ? Symbol.for("react.async_mode") : 60111, h = i ? Symbol.for("react.concurrent_mode") : 60111, f = i ? Symbol.for("react.forward_ref") : 60112, m = i ? Symbol.for("react.suspense") : 60113, v = i ? Symbol.for("react.suspense_list") : 60120, C = i ? Symbol.for("react.memo") : 60115, k = i ? Symbol.for("react.lazy") : 60116, S = i ? Symbol.for("react.block") : 60121, x = i ? Symbol.for("react.fundamental") : 60117, N = i ? Symbol.for("react.responder") : 60118, y = i ? Symbol.for("react.scope") : 60119;
  function A(E) {
    if (typeof E == "object" && E !== null) {
      var V = E.$$typeof;
      switch (V) {
        case e:
          switch (E = E.type, E) {
            case u:
            case h:
            case n:
            case s:
            case r:
            case m:
              return E;
            default:
              switch (E = E && E.$$typeof, E) {
                case l:
                case f:
                case k:
                case C:
                case o:
                  return E;
                default:
                  return V;
              }
          }
        case t:
          return V;
      }
    }
  }
  function P(E) {
    return A(E) === h;
  }
  return ot.AsyncMode = u, ot.ConcurrentMode = h, ot.ContextConsumer = l, ot.ContextProvider = o, ot.Element = e, ot.ForwardRef = f, ot.Fragment = n, ot.Lazy = k, ot.Memo = C, ot.Portal = t, ot.Profiler = s, ot.StrictMode = r, ot.Suspense = m, ot.isAsyncMode = function(E) {
    return P(E) || A(E) === u;
  }, ot.isConcurrentMode = P, ot.isContextConsumer = function(E) {
    return A(E) === l;
  }, ot.isContextProvider = function(E) {
    return A(E) === o;
  }, ot.isElement = function(E) {
    return typeof E == "object" && E !== null && E.$$typeof === e;
  }, ot.isForwardRef = function(E) {
    return A(E) === f;
  }, ot.isFragment = function(E) {
    return A(E) === n;
  }, ot.isLazy = function(E) {
    return A(E) === k;
  }, ot.isMemo = function(E) {
    return A(E) === C;
  }, ot.isPortal = function(E) {
    return A(E) === t;
  }, ot.isProfiler = function(E) {
    return A(E) === s;
  }, ot.isStrictMode = function(E) {
    return A(E) === r;
  }, ot.isSuspense = function(E) {
    return A(E) === m;
  }, ot.isValidElementType = function(E) {
    return typeof E == "string" || typeof E == "function" || E === n || E === h || E === s || E === r || E === m || E === v || typeof E == "object" && E !== null && (E.$$typeof === k || E.$$typeof === C || E.$$typeof === o || E.$$typeof === l || E.$$typeof === f || E.$$typeof === x || E.$$typeof === N || E.$$typeof === y || E.$$typeof === S);
  }, ot.typeOf = A, ot;
}
var at = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var O1;
function JP() {
  return O1 || (O1 = 1, process.env.NODE_ENV !== "production" && function() {
    var i = typeof Symbol == "function" && Symbol.for, e = i ? Symbol.for("react.element") : 60103, t = i ? Symbol.for("react.portal") : 60106, n = i ? Symbol.for("react.fragment") : 60107, r = i ? Symbol.for("react.strict_mode") : 60108, s = i ? Symbol.for("react.profiler") : 60114, o = i ? Symbol.for("react.provider") : 60109, l = i ? Symbol.for("react.context") : 60110, u = i ? Symbol.for("react.async_mode") : 60111, h = i ? Symbol.for("react.concurrent_mode") : 60111, f = i ? Symbol.for("react.forward_ref") : 60112, m = i ? Symbol.for("react.suspense") : 60113, v = i ? Symbol.for("react.suspense_list") : 60120, C = i ? Symbol.for("react.memo") : 60115, k = i ? Symbol.for("react.lazy") : 60116, S = i ? Symbol.for("react.block") : 60121, x = i ? Symbol.for("react.fundamental") : 60117, N = i ? Symbol.for("react.responder") : 60118, y = i ? Symbol.for("react.scope") : 60119;
    function A(q) {
      return typeof q == "string" || typeof q == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      q === n || q === h || q === s || q === r || q === m || q === v || typeof q == "object" && q !== null && (q.$$typeof === k || q.$$typeof === C || q.$$typeof === o || q.$$typeof === l || q.$$typeof === f || q.$$typeof === x || q.$$typeof === N || q.$$typeof === y || q.$$typeof === S);
    }
    function P(q) {
      if (typeof q == "object" && q !== null) {
        var Ze = q.$$typeof;
        switch (Ze) {
          case e:
            var de = q.type;
            switch (de) {
              case u:
              case h:
              case n:
              case s:
              case r:
              case m:
                return de;
              default:
                var Ye = de && de.$$typeof;
                switch (Ye) {
                  case l:
                  case f:
                  case k:
                  case C:
                  case o:
                    return Ye;
                  default:
                    return Ze;
                }
            }
          case t:
            return Ze;
        }
      }
    }
    var E = u, V = h, j = l, U = o, $ = e, M = f, D = n, J = k, H = C, Y = t, le = s, me = r, ee = m, te = !1;
    function ne(q) {
      return te || (te = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), z(q) || P(q) === u;
    }
    function z(q) {
      return P(q) === h;
    }
    function se(q) {
      return P(q) === l;
    }
    function ve(q) {
      return P(q) === o;
    }
    function ue(q) {
      return typeof q == "object" && q !== null && q.$$typeof === e;
    }
    function ce(q) {
      return P(q) === f;
    }
    function he(q) {
      return P(q) === n;
    }
    function be(q) {
      return P(q) === k;
    }
    function Ee(q) {
      return P(q) === C;
    }
    function Pe(q) {
      return P(q) === t;
    }
    function Se(q) {
      return P(q) === s;
    }
    function ye(q) {
      return P(q) === r;
    }
    function De(q) {
      return P(q) === m;
    }
    at.AsyncMode = E, at.ConcurrentMode = V, at.ContextConsumer = j, at.ContextProvider = U, at.Element = $, at.ForwardRef = M, at.Fragment = D, at.Lazy = J, at.Memo = H, at.Portal = Y, at.Profiler = le, at.StrictMode = me, at.Suspense = ee, at.isAsyncMode = ne, at.isConcurrentMode = z, at.isContextConsumer = se, at.isContextProvider = ve, at.isElement = ue, at.isForwardRef = ce, at.isFragment = he, at.isLazy = be, at.isMemo = Ee, at.isPortal = Pe, at.isProfiler = Se, at.isStrictMode = ye, at.isSuspense = De, at.isValidElementType = A, at.typeOf = P;
  }()), at;
}
var M1;
function B0() {
  return M1 || (M1 = 1, function(i) {
    process.env.NODE_ENV === "production" ? i.exports = YP() : i.exports = JP();
  }(GP)), ad;
}
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var Jf, N1;
function XP() {
  if (N1)
    return Jf;
  N1 = 1;
  var i = Object.getOwnPropertySymbols, e = Object.prototype.hasOwnProperty, t = Object.prototype.propertyIsEnumerable;
  function n(s) {
    if (s == null)
      throw new TypeError("Object.assign cannot be called with null or undefined");
    return Object(s);
  }
  function r() {
    try {
      if (!Object.assign)
        return !1;
      var s = new String("abc");
      if (s[5] = "de", Object.getOwnPropertyNames(s)[0] === "5")
        return !1;
      for (var o = {}, l = 0; l < 10; l++)
        o["_" + String.fromCharCode(l)] = l;
      var u = Object.getOwnPropertyNames(o).map(function(f) {
        return o[f];
      });
      if (u.join("") !== "0123456789")
        return !1;
      var h = {};
      return "abcdefghijklmnopqrst".split("").forEach(function(f) {
        h[f] = f;
      }), Object.keys(Object.assign({}, h)).join("") === "abcdefghijklmnopqrst";
    } catch {
      return !1;
    }
  }
  return Jf = r() ? Object.assign : function(s, o) {
    for (var l, u = n(s), h, f = 1; f < arguments.length; f++) {
      l = Object(arguments[f]);
      for (var m in l)
        e.call(l, m) && (u[m] = l[m]);
      if (i) {
        h = i(l);
        for (var v = 0; v < h.length; v++)
          t.call(l, h[v]) && (u[h[v]] = l[h[v]]);
      }
    }
    return u;
  }, Jf;
}
var Xf, D1;
function Ag() {
  if (D1)
    return Xf;
  D1 = 1;
  var i = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return Xf = i, Xf;
}
var Zf, B1;
function V0() {
  return B1 || (B1 = 1, Zf = Function.call.bind(Object.prototype.hasOwnProperty)), Zf;
}
var Qf, V1;
function ZP() {
  if (V1)
    return Qf;
  V1 = 1;
  var i = function() {
  };
  if (process.env.NODE_ENV !== "production") {
    var e = Ag(), t = {}, n = V0();
    i = function(s) {
      var o = "Warning: " + s;
      typeof console < "u" && console.error(o);
      try {
        throw new Error(o);
      } catch {
      }
    };
  }
  function r(s, o, l, u, h) {
    if (process.env.NODE_ENV !== "production") {
      for (var f in s)
        if (n(s, f)) {
          var m;
          try {
            if (typeof s[f] != "function") {
              var v = Error(
                (u || "React class") + ": " + l + " type `" + f + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof s[f] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
              );
              throw v.name = "Invariant Violation", v;
            }
            m = s[f](o, f, u, l, null, e);
          } catch (k) {
            m = k;
          }
          if (m && !(m instanceof Error) && i(
            (u || "React class") + ": type specification of " + l + " `" + f + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof m + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
          ), m instanceof Error && !(m.message in t)) {
            t[m.message] = !0;
            var C = h ? h() : "";
            i(
              "Failed " + l + " type: " + m.message + (C ?? "")
            );
          }
        }
    }
  }
  return r.resetWarningCache = function() {
    process.env.NODE_ENV !== "production" && (t = {});
  }, Qf = r, Qf;
}
var em, L1;
function QP() {
  if (L1)
    return em;
  L1 = 1;
  var i = B0(), e = XP(), t = Ag(), n = V0(), r = ZP(), s = function() {
  };
  process.env.NODE_ENV !== "production" && (s = function(l) {
    var u = "Warning: " + l;
    typeof console < "u" && console.error(u);
    try {
      throw new Error(u);
    } catch {
    }
  });
  function o() {
    return null;
  }
  return em = function(l, u) {
    var h = typeof Symbol == "function" && Symbol.iterator, f = "@@iterator";
    function m(z) {
      var se = z && (h && z[h] || z[f]);
      if (typeof se == "function")
        return se;
    }
    var v = "<<anonymous>>", C = {
      array: N("array"),
      bigint: N("bigint"),
      bool: N("boolean"),
      func: N("function"),
      number: N("number"),
      object: N("object"),
      string: N("string"),
      symbol: N("symbol"),
      any: y(),
      arrayOf: A,
      element: P(),
      elementType: E(),
      instanceOf: V,
      node: M(),
      objectOf: U,
      oneOf: j,
      oneOfType: $,
      shape: J,
      exact: H
    };
    function k(z, se) {
      return z === se ? z !== 0 || 1 / z === 1 / se : z !== z && se !== se;
    }
    function S(z, se) {
      this.message = z, this.data = se && typeof se == "object" ? se : {}, this.stack = "";
    }
    S.prototype = Error.prototype;
    function x(z) {
      if (process.env.NODE_ENV !== "production")
        var se = {}, ve = 0;
      function ue(he, be, Ee, Pe, Se, ye, De) {
        if (Pe = Pe || v, ye = ye || Ee, De !== t) {
          if (u) {
            var q = new Error(
              "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
            );
            throw q.name = "Invariant Violation", q;
          } else if (process.env.NODE_ENV !== "production" && typeof console < "u") {
            var Ze = Pe + ":" + Ee;
            !se[Ze] && // Avoid spamming the console because they are often not actionable except for lib authors
            ve < 3 && (s(
              "You are manually calling a React.PropTypes validation function for the `" + ye + "` prop on `" + Pe + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
            ), se[Ze] = !0, ve++);
          }
        }
        return be[Ee] == null ? he ? be[Ee] === null ? new S("The " + Se + " `" + ye + "` is marked as required " + ("in `" + Pe + "`, but its value is `null`.")) : new S("The " + Se + " `" + ye + "` is marked as required in " + ("`" + Pe + "`, but its value is `undefined`.")) : null : z(be, Ee, Pe, Se, ye);
      }
      var ce = ue.bind(null, !1);
      return ce.isRequired = ue.bind(null, !0), ce;
    }
    function N(z) {
      function se(ve, ue, ce, he, be, Ee) {
        var Pe = ve[ue], Se = me(Pe);
        if (Se !== z) {
          var ye = ee(Pe);
          return new S(
            "Invalid " + he + " `" + be + "` of type " + ("`" + ye + "` supplied to `" + ce + "`, expected ") + ("`" + z + "`."),
            { expectedType: z }
          );
        }
        return null;
      }
      return x(se);
    }
    function y() {
      return x(o);
    }
    function A(z) {
      function se(ve, ue, ce, he, be) {
        if (typeof z != "function")
          return new S("Property `" + be + "` of component `" + ce + "` has invalid PropType notation inside arrayOf.");
        var Ee = ve[ue];
        if (!Array.isArray(Ee)) {
          var Pe = me(Ee);
          return new S("Invalid " + he + " `" + be + "` of type " + ("`" + Pe + "` supplied to `" + ce + "`, expected an array."));
        }
        for (var Se = 0; Se < Ee.length; Se++) {
          var ye = z(Ee, Se, ce, he, be + "[" + Se + "]", t);
          if (ye instanceof Error)
            return ye;
        }
        return null;
      }
      return x(se);
    }
    function P() {
      function z(se, ve, ue, ce, he) {
        var be = se[ve];
        if (!l(be)) {
          var Ee = me(be);
          return new S("Invalid " + ce + " `" + he + "` of type " + ("`" + Ee + "` supplied to `" + ue + "`, expected a single ReactElement."));
        }
        return null;
      }
      return x(z);
    }
    function E() {
      function z(se, ve, ue, ce, he) {
        var be = se[ve];
        if (!i.isValidElementType(be)) {
          var Ee = me(be);
          return new S("Invalid " + ce + " `" + he + "` of type " + ("`" + Ee + "` supplied to `" + ue + "`, expected a single ReactElement type."));
        }
        return null;
      }
      return x(z);
    }
    function V(z) {
      function se(ve, ue, ce, he, be) {
        if (!(ve[ue] instanceof z)) {
          var Ee = z.name || v, Pe = ne(ve[ue]);
          return new S("Invalid " + he + " `" + be + "` of type " + ("`" + Pe + "` supplied to `" + ce + "`, expected ") + ("instance of `" + Ee + "`."));
        }
        return null;
      }
      return x(se);
    }
    function j(z) {
      if (!Array.isArray(z))
        return process.env.NODE_ENV !== "production" && (arguments.length > 1 ? s(
          "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
        ) : s("Invalid argument supplied to oneOf, expected an array.")), o;
      function se(ve, ue, ce, he, be) {
        for (var Ee = ve[ue], Pe = 0; Pe < z.length; Pe++)
          if (k(Ee, z[Pe]))
            return null;
        var Se = JSON.stringify(z, function(De, q) {
          var Ze = ee(q);
          return Ze === "symbol" ? String(q) : q;
        });
        return new S("Invalid " + he + " `" + be + "` of value `" + String(Ee) + "` " + ("supplied to `" + ce + "`, expected one of " + Se + "."));
      }
      return x(se);
    }
    function U(z) {
      function se(ve, ue, ce, he, be) {
        if (typeof z != "function")
          return new S("Property `" + be + "` of component `" + ce + "` has invalid PropType notation inside objectOf.");
        var Ee = ve[ue], Pe = me(Ee);
        if (Pe !== "object")
          return new S("Invalid " + he + " `" + be + "` of type " + ("`" + Pe + "` supplied to `" + ce + "`, expected an object."));
        for (var Se in Ee)
          if (n(Ee, Se)) {
            var ye = z(Ee, Se, ce, he, be + "." + Se, t);
            if (ye instanceof Error)
              return ye;
          }
        return null;
      }
      return x(se);
    }
    function $(z) {
      if (!Array.isArray(z))
        return process.env.NODE_ENV !== "production" && s("Invalid argument supplied to oneOfType, expected an instance of array."), o;
      for (var se = 0; se < z.length; se++) {
        var ve = z[se];
        if (typeof ve != "function")
          return s(
            "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + te(ve) + " at index " + se + "."
          ), o;
      }
      function ue(ce, he, be, Ee, Pe) {
        for (var Se = [], ye = 0; ye < z.length; ye++) {
          var De = z[ye], q = De(ce, he, be, Ee, Pe, t);
          if (q == null)
            return null;
          q.data && n(q.data, "expectedType") && Se.push(q.data.expectedType);
        }
        var Ze = Se.length > 0 ? ", expected one of type [" + Se.join(", ") + "]" : "";
        return new S("Invalid " + Ee + " `" + Pe + "` supplied to " + ("`" + be + "`" + Ze + "."));
      }
      return x(ue);
    }
    function M() {
      function z(se, ve, ue, ce, he) {
        return Y(se[ve]) ? null : new S("Invalid " + ce + " `" + he + "` supplied to " + ("`" + ue + "`, expected a ReactNode."));
      }
      return x(z);
    }
    function D(z, se, ve, ue, ce) {
      return new S(
        (z || "React class") + ": " + se + " type `" + ve + "." + ue + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + ce + "`."
      );
    }
    function J(z) {
      function se(ve, ue, ce, he, be) {
        var Ee = ve[ue], Pe = me(Ee);
        if (Pe !== "object")
          return new S("Invalid " + he + " `" + be + "` of type `" + Pe + "` " + ("supplied to `" + ce + "`, expected `object`."));
        for (var Se in z) {
          var ye = z[Se];
          if (typeof ye != "function")
            return D(ce, he, be, Se, ee(ye));
          var De = ye(Ee, Se, ce, he, be + "." + Se, t);
          if (De)
            return De;
        }
        return null;
      }
      return x(se);
    }
    function H(z) {
      function se(ve, ue, ce, he, be) {
        var Ee = ve[ue], Pe = me(Ee);
        if (Pe !== "object")
          return new S("Invalid " + he + " `" + be + "` of type `" + Pe + "` " + ("supplied to `" + ce + "`, expected `object`."));
        var Se = e({}, ve[ue], z);
        for (var ye in Se) {
          var De = z[ye];
          if (n(z, ye) && typeof De != "function")
            return D(ce, he, be, ye, ee(De));
          if (!De)
            return new S(
              "Invalid " + he + " `" + be + "` key `" + ye + "` supplied to `" + ce + "`.\nBad object: " + JSON.stringify(ve[ue], null, "  ") + `
Valid keys: ` + JSON.stringify(Object.keys(z), null, "  ")
            );
          var q = De(Ee, ye, ce, he, be + "." + ye, t);
          if (q)
            return q;
        }
        return null;
      }
      return x(se);
    }
    function Y(z) {
      switch (typeof z) {
        case "number":
        case "string":
        case "undefined":
          return !0;
        case "boolean":
          return !z;
        case "object":
          if (Array.isArray(z))
            return z.every(Y);
          if (z === null || l(z))
            return !0;
          var se = m(z);
          if (se) {
            var ve = se.call(z), ue;
            if (se !== z.entries) {
              for (; !(ue = ve.next()).done; )
                if (!Y(ue.value))
                  return !1;
            } else
              for (; !(ue = ve.next()).done; ) {
                var ce = ue.value;
                if (ce && !Y(ce[1]))
                  return !1;
              }
          } else
            return !1;
          return !0;
        default:
          return !1;
      }
    }
    function le(z, se) {
      return z === "symbol" ? !0 : se ? se["@@toStringTag"] === "Symbol" || typeof Symbol == "function" && se instanceof Symbol : !1;
    }
    function me(z) {
      var se = typeof z;
      return Array.isArray(z) ? "array" : z instanceof RegExp ? "object" : le(se, z) ? "symbol" : se;
    }
    function ee(z) {
      if (typeof z > "u" || z === null)
        return "" + z;
      var se = me(z);
      if (se === "object") {
        if (z instanceof Date)
          return "date";
        if (z instanceof RegExp)
          return "regexp";
      }
      return se;
    }
    function te(z) {
      var se = ee(z);
      switch (se) {
        case "array":
        case "object":
          return "an " + se;
        case "boolean":
        case "date":
        case "regexp":
          return "a " + se;
        default:
          return se;
      }
    }
    function ne(z) {
      return !z.constructor || !z.constructor.name ? v : z.constructor.name;
    }
    return C.checkPropTypes = r, C.resetWarningCache = r.resetWarningCache, C.PropTypes = C, C;
  }, em;
}
var tm, F1;
function e5() {
  if (F1)
    return tm;
  F1 = 1;
  var i = Ag();
  function e() {
  }
  function t() {
  }
  return t.resetWarningCache = e, tm = function() {
    function n(o, l, u, h, f, m) {
      if (m !== i) {
        var v = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw v.name = "Invariant Violation", v;
      }
    }
    n.isRequired = n;
    function r() {
      return n;
    }
    var s = {
      array: n,
      bigint: n,
      bool: n,
      func: n,
      number: n,
      object: n,
      string: n,
      symbol: n,
      any: n,
      arrayOf: r,
      element: n,
      elementType: n,
      instanceOf: r,
      node: n,
      objectOf: r,
      oneOf: r,
      oneOfType: r,
      shape: r,
      exact: r,
      checkPropTypes: t,
      resetWarningCache: e
    };
    return s.PropTypes = s, s;
  }, tm;
}
if (process.env.NODE_ENV !== "production") {
  var t5 = B0(), n5 = !0;
  I1.exports = QP()(t5.isElement, n5);
} else
  I1.exports = e5()();
const i5 = "exact-prop: ​";
function L0(i) {
  return process.env.NODE_ENV === "production" ? i : Ae({}, i, {
    [i5]: (e) => {
      const t = Object.keys(e).filter((n) => !i.hasOwnProperty(n));
      return t.length > 0 ? new Error(`The following props are not supported: ${t.map((n) => `\`${n}\``).join(", ")}. Please remove them.`) : null;
    }
  });
}
function Pi(i) {
  let e = "https://mui.com/production-error/?code=" + i;
  for (let t = 1; t < arguments.length; t += 1)
    e += "&args[]=" + encodeURIComponent(arguments[t]);
  return "Minified MUI error #" + i + "; visit " + e + " for the full message.";
}
var ld = {}, r5 = {
  get exports() {
    return ld;
  },
  set exports(i) {
    ld = i;
  }
}, lt = {};
/**
 * @license React
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var $1;
function s5() {
  if ($1)
    return lt;
  $1 = 1;
  var i = Symbol.for("react.element"), e = Symbol.for("react.portal"), t = Symbol.for("react.fragment"), n = Symbol.for("react.strict_mode"), r = Symbol.for("react.profiler"), s = Symbol.for("react.provider"), o = Symbol.for("react.context"), l = Symbol.for("react.server_context"), u = Symbol.for("react.forward_ref"), h = Symbol.for("react.suspense"), f = Symbol.for("react.suspense_list"), m = Symbol.for("react.memo"), v = Symbol.for("react.lazy"), C = Symbol.for("react.offscreen"), k;
  k = Symbol.for("react.module.reference");
  function S(x) {
    if (typeof x == "object" && x !== null) {
      var N = x.$$typeof;
      switch (N) {
        case i:
          switch (x = x.type, x) {
            case t:
            case r:
            case n:
            case h:
            case f:
              return x;
            default:
              switch (x = x && x.$$typeof, x) {
                case l:
                case o:
                case u:
                case v:
                case m:
                case s:
                  return x;
                default:
                  return N;
              }
          }
        case e:
          return N;
      }
    }
  }
  return lt.ContextConsumer = o, lt.ContextProvider = s, lt.Element = i, lt.ForwardRef = u, lt.Fragment = t, lt.Lazy = v, lt.Memo = m, lt.Portal = e, lt.Profiler = r, lt.StrictMode = n, lt.Suspense = h, lt.SuspenseList = f, lt.isAsyncMode = function() {
    return !1;
  }, lt.isConcurrentMode = function() {
    return !1;
  }, lt.isContextConsumer = function(x) {
    return S(x) === o;
  }, lt.isContextProvider = function(x) {
    return S(x) === s;
  }, lt.isElement = function(x) {
    return typeof x == "object" && x !== null && x.$$typeof === i;
  }, lt.isForwardRef = function(x) {
    return S(x) === u;
  }, lt.isFragment = function(x) {
    return S(x) === t;
  }, lt.isLazy = function(x) {
    return S(x) === v;
  }, lt.isMemo = function(x) {
    return S(x) === m;
  }, lt.isPortal = function(x) {
    return S(x) === e;
  }, lt.isProfiler = function(x) {
    return S(x) === r;
  }, lt.isStrictMode = function(x) {
    return S(x) === n;
  }, lt.isSuspense = function(x) {
    return S(x) === h;
  }, lt.isSuspenseList = function(x) {
    return S(x) === f;
  }, lt.isValidElementType = function(x) {
    return typeof x == "string" || typeof x == "function" || x === t || x === r || x === n || x === h || x === f || x === C || typeof x == "object" && x !== null && (x.$$typeof === v || x.$$typeof === m || x.$$typeof === s || x.$$typeof === o || x.$$typeof === u || x.$$typeof === k || x.getModuleId !== void 0);
  }, lt.typeOf = S, lt;
}
var ct = {};
/**
 * @license React
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var z1;
function o5() {
  return z1 || (z1 = 1, process.env.NODE_ENV !== "production" && function() {
    var i = Symbol.for("react.element"), e = Symbol.for("react.portal"), t = Symbol.for("react.fragment"), n = Symbol.for("react.strict_mode"), r = Symbol.for("react.profiler"), s = Symbol.for("react.provider"), o = Symbol.for("react.context"), l = Symbol.for("react.server_context"), u = Symbol.for("react.forward_ref"), h = Symbol.for("react.suspense"), f = Symbol.for("react.suspense_list"), m = Symbol.for("react.memo"), v = Symbol.for("react.lazy"), C = Symbol.for("react.offscreen"), k = !1, S = !1, x = !1, N = !1, y = !1, A;
    A = Symbol.for("react.module.reference");
    function P(de) {
      return !!(typeof de == "string" || typeof de == "function" || de === t || de === r || y || de === n || de === h || de === f || N || de === C || k || S || x || typeof de == "object" && de !== null && (de.$$typeof === v || de.$$typeof === m || de.$$typeof === s || de.$$typeof === o || de.$$typeof === u || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      de.$$typeof === A || de.getModuleId !== void 0));
    }
    function E(de) {
      if (typeof de == "object" && de !== null) {
        var Ye = de.$$typeof;
        switch (Ye) {
          case i:
            var nn = de.type;
            switch (nn) {
              case t:
              case r:
              case n:
              case h:
              case f:
                return nn;
              default:
                var rn = nn && nn.$$typeof;
                switch (rn) {
                  case l:
                  case o:
                  case u:
                  case v:
                  case m:
                  case s:
                    return rn;
                  default:
                    return Ye;
                }
            }
          case e:
            return Ye;
        }
      }
    }
    var V = o, j = s, U = i, $ = u, M = t, D = v, J = m, H = e, Y = r, le = n, me = h, ee = f, te = !1, ne = !1;
    function z(de) {
      return te || (te = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 18+.")), !1;
    }
    function se(de) {
      return ne || (ne = !0, console.warn("The ReactIs.isConcurrentMode() alias has been deprecated, and will be removed in React 18+.")), !1;
    }
    function ve(de) {
      return E(de) === o;
    }
    function ue(de) {
      return E(de) === s;
    }
    function ce(de) {
      return typeof de == "object" && de !== null && de.$$typeof === i;
    }
    function he(de) {
      return E(de) === u;
    }
    function be(de) {
      return E(de) === t;
    }
    function Ee(de) {
      return E(de) === v;
    }
    function Pe(de) {
      return E(de) === m;
    }
    function Se(de) {
      return E(de) === e;
    }
    function ye(de) {
      return E(de) === r;
    }
    function De(de) {
      return E(de) === n;
    }
    function q(de) {
      return E(de) === h;
    }
    function Ze(de) {
      return E(de) === f;
    }
    ct.ContextConsumer = V, ct.ContextProvider = j, ct.Element = U, ct.ForwardRef = $, ct.Fragment = M, ct.Lazy = D, ct.Memo = J, ct.Portal = H, ct.Profiler = Y, ct.StrictMode = le, ct.Suspense = me, ct.SuspenseList = ee, ct.isAsyncMode = z, ct.isConcurrentMode = se, ct.isContextConsumer = ve, ct.isContextProvider = ue, ct.isElement = ce, ct.isForwardRef = he, ct.isFragment = be, ct.isLazy = Ee, ct.isMemo = Pe, ct.isPortal = Se, ct.isProfiler = ye, ct.isStrictMode = De, ct.isSuspense = q, ct.isSuspenseList = Ze, ct.isValidElementType = P, ct.typeOf = E;
  }()), ct;
}
(function(i) {
  process.env.NODE_ENV === "production" ? i.exports = s5() : i.exports = o5();
})(r5);
const a5 = /^\s*function(?:\s|\s*\/\*.*\*\/\s*)+([^(\s/]*)\s*/;
function l5(i) {
  const e = `${i}`.match(a5);
  return e && e[1] || "";
}
function F0(i, e = "") {
  return i.displayName || i.name || l5(i) || e;
}
function W1(i, e, t) {
  const n = F0(e);
  return i.displayName || (n !== "" ? `${t}(${n})` : t);
}
function c5(i) {
  if (i != null) {
    if (typeof i == "string")
      return i;
    if (typeof i == "function")
      return F0(i, "Component");
    if (typeof i == "object")
      switch (i.$$typeof) {
        case ld.ForwardRef:
          return W1(i, i.render, "ForwardRef");
        case ld.Memo:
          return W1(i, i.type, "memo");
        default:
          return;
      }
  }
}
function ol(i) {
  if (typeof i != "string")
    throw new Error(process.env.NODE_ENV !== "production" ? "MUI: `capitalize(string)` expects a string argument." : Pi(7));
  return i.charAt(0).toUpperCase() + i.slice(1);
}
function $0(i, e) {
  const t = Ae({}, e);
  return Object.keys(i).forEach((n) => {
    if (n.toString().match(/^(components|slots)$/))
      t[n] = Ae({}, i[n], t[n]);
    else if (n.toString().match(/^(componentsProps|slotProps)$/)) {
      const r = i[n] || {}, s = e[n];
      t[n] = {}, !s || !Object.keys(s) ? t[n] = r : !r || !Object.keys(r) ? t[n] = s : (t[n] = Ae({}, s), Object.keys(r).forEach((o) => {
        t[n][o] = $0(r[o], s[o]);
      }));
    } else
      t[n] === void 0 && (t[n] = i[n]);
  }), t;
}
const j1 = (i) => i, u5 = () => {
  let i = j1;
  return {
    configure(e) {
      i = e;
    },
    generate(e) {
      return i(e);
    },
    reset() {
      i = j1;
    }
  };
}, d5 = u5(), h5 = d5, f5 = {
  active: "active",
  checked: "checked",
  completed: "completed",
  disabled: "disabled",
  error: "error",
  expanded: "expanded",
  focused: "focused",
  focusVisible: "focusVisible",
  required: "required",
  selected: "selected"
};
function m5(i, e, t = "Mui") {
  const n = f5[e];
  return n ? `${t}-${n}` : `${h5.generate(i)}-${e}`;
}
function $n(i, e) {
  if (i == null)
    return {};
  var t = {}, n = Object.keys(i), r, s;
  for (s = 0; s < n.length; s++)
    r = n[s], !(e.indexOf(r) >= 0) && (t[r] = i[r]);
  return t;
}
var cd = {}, g5 = {
  get exports() {
    return cd;
  },
  set exports(i) {
    cd = i;
  }
}, U1;
function kl() {
  return U1 || (U1 = 1, function(i) {
    function e() {
      return i.exports = e = Object.assign ? Object.assign.bind() : function(t) {
        for (var n = 1; n < arguments.length; n++) {
          var r = arguments[n];
          for (var s in r)
            Object.prototype.hasOwnProperty.call(r, s) && (t[s] = r[s]);
        }
        return t;
      }, i.exports.__esModule = !0, i.exports.default = i.exports, e.apply(this, arguments);
    }
    i.exports = e, i.exports.__esModule = !0, i.exports.default = i.exports;
  }(g5)), cd;
}
kl();
var ud = {}, p5 = {
  get exports() {
    return ud;
  },
  set exports(i) {
    ud = i;
  }
}, _u = {}, H1;
function _5() {
  if (H1)
    return _u;
  H1 = 1, Object.defineProperty(_u, "__esModule", { value: !0 });
  function i(e) {
    var t = /* @__PURE__ */ Object.create(null);
    return function(n) {
      return t[n] === void 0 && (t[n] = e(n)), t[n];
    };
  }
  return _u.default = i, _u;
}
var vu = {}, q1;
function v5() {
  if (q1)
    return vu;
  q1 = 1, Object.defineProperty(vu, "__esModule", { value: !0 });
  function i(e) {
    var t = /* @__PURE__ */ Object.create(null);
    return function(n) {
      return t[n] === void 0 && (t[n] = e(n)), t[n];
    };
  }
  return vu.default = i, vu;
}
var K1;
function Al() {
  return K1 || (K1 = 1, function(i) {
    process.env.NODE_ENV === "production" ? i.exports = _5() : i.exports = v5();
  }(p5)), ud;
}
var w5 = Al();
const b5 = /* @__PURE__ */ D0(w5);
var y5 = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|download|draggable|encType|enterKeyHint|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/, E5 = /* @__PURE__ */ b5(
  function(i) {
    return y5.test(i) || i.charCodeAt(0) === 111 && i.charCodeAt(1) === 110 && i.charCodeAt(2) < 91;
  }
  /* Z+1 */
), Fi = {}, C5 = {
  get exports() {
    return Fi;
  },
  set exports(i) {
    Fi = i;
  }
}, nm = {}, Vo = {}, S5 = {
  get exports() {
    return Vo;
  },
  set exports(i) {
    Vo = i;
  }
}, wu = {}, dd = {}, T5 = {
  get exports() {
    return dd;
  },
  set exports(i) {
    dd = i;
  }
}, bu = {}, G1;
function x5() {
  if (G1)
    return bu;
  G1 = 1, Object.defineProperty(bu, "__esModule", { value: !0 });
  function i(n) {
    if (n.sheet)
      return n.sheet;
    for (var r = 0; r < document.styleSheets.length; r++)
      if (document.styleSheets[r].ownerNode === n)
        return document.styleSheets[r];
  }
  function e(n) {
    var r = document.createElement("style");
    return r.setAttribute("data-emotion", n.key), n.nonce !== void 0 && r.setAttribute("nonce", n.nonce), r.appendChild(document.createTextNode("")), r.setAttribute("data-s", ""), r;
  }
  var t = /* @__PURE__ */ function() {
    function n(s) {
      var o = this;
      this._insertTag = function(l) {
        var u;
        o.tags.length === 0 ? o.insertionPoint ? u = o.insertionPoint.nextSibling : o.prepend ? u = o.container.firstChild : u = o.before : u = o.tags[o.tags.length - 1].nextSibling, o.container.insertBefore(l, u), o.tags.push(l);
      }, this.isSpeedy = s.speedy === void 0 ? !0 : s.speedy, this.tags = [], this.ctr = 0, this.nonce = s.nonce, this.key = s.key, this.container = s.container, this.prepend = s.prepend, this.insertionPoint = s.insertionPoint, this.before = null;
    }
    var r = n.prototype;
    return r.hydrate = function(o) {
      o.forEach(this._insertTag);
    }, r.insert = function(o) {
      this.ctr % (this.isSpeedy ? 65e3 : 1) === 0 && this._insertTag(e(this));
      var l = this.tags[this.tags.length - 1];
      if (this.isSpeedy) {
        var u = i(l);
        try {
          u.insertRule(o, u.cssRules.length);
        } catch {
        }
      } else
        l.appendChild(document.createTextNode(o));
      this.ctr++;
    }, r.flush = function() {
      this.tags.forEach(function(o) {
        return o.parentNode && o.parentNode.removeChild(o);
      }), this.tags = [], this.ctr = 0;
    }, n;
  }();
  return bu.StyleSheet = t, bu;
}
var yu = {}, Y1;
function k5() {
  if (Y1)
    return yu;
  Y1 = 1, Object.defineProperty(yu, "__esModule", { value: !0 });
  function i(n) {
    if (n.sheet)
      return n.sheet;
    for (var r = 0; r < document.styleSheets.length; r++)
      if (document.styleSheets[r].ownerNode === n)
        return document.styleSheets[r];
  }
  function e(n) {
    var r = document.createElement("style");
    return r.setAttribute("data-emotion", n.key), n.nonce !== void 0 && r.setAttribute("nonce", n.nonce), r.appendChild(document.createTextNode("")), r.setAttribute("data-s", ""), r;
  }
  var t = /* @__PURE__ */ function() {
    function n(s) {
      var o = this;
      this._insertTag = function(l) {
        var u;
        o.tags.length === 0 ? o.insertionPoint ? u = o.insertionPoint.nextSibling : o.prepend ? u = o.container.firstChild : u = o.before : u = o.tags[o.tags.length - 1].nextSibling, o.container.insertBefore(l, u), o.tags.push(l);
      }, this.isSpeedy = s.speedy === void 0 ? process.env.NODE_ENV === "production" : s.speedy, this.tags = [], this.ctr = 0, this.nonce = s.nonce, this.key = s.key, this.container = s.container, this.prepend = s.prepend, this.insertionPoint = s.insertionPoint, this.before = null;
    }
    var r = n.prototype;
    return r.hydrate = function(o) {
      o.forEach(this._insertTag);
    }, r.insert = function(o) {
      this.ctr % (this.isSpeedy ? 65e3 : 1) === 0 && this._insertTag(e(this));
      var l = this.tags[this.tags.length - 1];
      if (process.env.NODE_ENV !== "production") {
        var u = o.charCodeAt(0) === 64 && o.charCodeAt(1) === 105;
        u && this._alreadyInsertedOrderInsensitiveRule && console.error(`You're attempting to insert the following rule:
` + o + "\n\n`@import` rules must be before all other types of rules in a stylesheet but other rules have already been inserted. Please ensure that `@import` rules are before all other rules."), this._alreadyInsertedOrderInsensitiveRule = this._alreadyInsertedOrderInsensitiveRule || !u;
      }
      if (this.isSpeedy) {
        var h = i(l);
        try {
          h.insertRule(o, h.cssRules.length);
        } catch (f) {
          process.env.NODE_ENV !== "production" && !/:(-moz-placeholder|-moz-focus-inner|-moz-focusring|-ms-input-placeholder|-moz-read-write|-moz-read-only|-ms-clear|-ms-expand|-ms-reveal){/.test(o) && console.error('There was a problem inserting the following rule: "' + o + '"', f);
        }
      } else
        l.appendChild(document.createTextNode(o));
      this.ctr++;
    }, r.flush = function() {
      this.tags.forEach(function(o) {
        return o.parentNode && o.parentNode.removeChild(o);
      }), this.tags = [], this.ctr = 0, process.env.NODE_ENV !== "production" && (this._alreadyInsertedOrderInsensitiveRule = !1);
    }, n;
  }();
  return yu.StyleSheet = t, yu;
}
var J1;
function z0() {
  return J1 || (J1 = 1, function(i) {
    process.env.NODE_ENV === "production" ? i.exports = x5() : i.exports = k5();
  }(T5)), dd;
}
var al = {}, A5 = {
  get exports() {
    return al;
  },
  set exports(i) {
    al = i;
  }
}, X1;
function W0() {
  return X1 || (X1 = 1, function(i, e) {
    (function(t, n) {
      n(e);
    })(et, function(t) {
      var n = "-ms-", r = "-moz-", s = "-webkit-", o = "comm", l = "rule", u = "decl", h = "@page", f = "@media", m = "@import", v = "@charset", C = "@viewport", k = "@supports", S = "@document", x = "@namespace", N = "@keyframes", y = "@font-face", A = "@counter-style", P = "@font-feature-values", E = Math.abs, V = String.fromCharCode, j = Object.assign;
      function U(I, ge) {
        return H(I, 0) ^ 45 ? (((ge << 2 ^ H(I, 0)) << 2 ^ H(I, 1)) << 2 ^ H(I, 2)) << 2 ^ H(I, 3) : 0;
      }
      function $(I) {
        return I.trim();
      }
      function M(I, ge) {
        return (I = ge.exec(I)) ? I[0] : I;
      }
      function D(I, ge, xe) {
        return I.replace(ge, xe);
      }
      function J(I, ge) {
        return I.indexOf(ge);
      }
      function H(I, ge) {
        return I.charCodeAt(ge) | 0;
      }
      function Y(I, ge, xe) {
        return I.slice(ge, xe);
      }
      function le(I) {
        return I.length;
      }
      function me(I) {
        return I.length;
      }
      function ee(I, ge) {
        return ge.push(I), I;
      }
      function te(I, ge) {
        return I.map(ge).join("");
      }
      t.line = 1, t.column = 1, t.length = 0, t.position = 0, t.character = 0, t.characters = "";
      function ne(I, ge, xe, Be, Fe, an, _n) {
        return { value: I, root: ge, parent: xe, type: Be, props: Fe, children: an, line: t.line, column: t.column, length: _n, return: "" };
      }
      function z(I, ge) {
        return j(ne("", null, null, "", null, null, 0), I, { length: -I.length }, ge);
      }
      function se() {
        return t.character;
      }
      function ve() {
        return t.character = t.position > 0 ? H(t.characters, --t.position) : 0, t.column--, t.character === 10 && (t.column = 1, t.line--), t.character;
      }
      function ue() {
        return t.character = t.position < t.length ? H(t.characters, t.position++) : 0, t.column++, t.character === 10 && (t.column = 1, t.line++), t.character;
      }
      function ce() {
        return H(t.characters, t.position);
      }
      function he() {
        return t.position;
      }
      function be(I, ge) {
        return Y(t.characters, I, ge);
      }
      function Ee(I) {
        switch (I) {
          case 0:
          case 9:
          case 10:
          case 13:
          case 32:
            return 5;
          case 33:
          case 43:
          case 44:
          case 47:
          case 62:
          case 64:
          case 126:
          case 59:
          case 123:
          case 125:
            return 4;
          case 58:
            return 3;
          case 34:
          case 39:
          case 40:
          case 91:
            return 2;
          case 41:
          case 93:
            return 1;
        }
        return 0;
      }
      function Pe(I) {
        return t.line = t.column = 1, t.length = le(t.characters = I), t.position = 0, [];
      }
      function Se(I) {
        return t.characters = "", I;
      }
      function ye(I) {
        return $(be(t.position - 1, Ye(I === 91 ? I + 2 : I === 40 ? I + 1 : I)));
      }
      function De(I) {
        return Se(Ze(Pe(I)));
      }
      function q(I) {
        for (; (t.character = ce()) && t.character < 33; )
          ue();
        return Ee(I) > 2 || Ee(t.character) > 3 ? "" : " ";
      }
      function Ze(I) {
        for (; ue(); )
          switch (Ee(t.character)) {
            case 0:
              ee(rn(t.position - 1), I);
              break;
            case 2:
              ee(ye(t.character), I);
              break;
            default:
              ee(V(t.character), I);
          }
        return I;
      }
      function de(I, ge) {
        for (; --ge && ue() && !(t.character < 48 || t.character > 102 || t.character > 57 && t.character < 65 || t.character > 70 && t.character < 97); )
          ;
        return be(I, he() + (ge < 6 && ce() == 32 && ue() == 32));
      }
      function Ye(I) {
        for (; ue(); )
          switch (t.character) {
            case I:
              return t.position;
            case 34:
            case 39:
              I !== 34 && I !== 39 && Ye(t.character);
              break;
            case 40:
              I === 41 && Ye(I);
              break;
            case 92:
              ue();
              break;
          }
        return t.position;
      }
      function nn(I, ge) {
        for (; ue() && I + t.character !== 47 + 10; )
          if (I + t.character === 42 + 42 && ce() === 47)
            break;
        return "/*" + be(ge, t.position - 1) + "*" + V(I === 47 ? I : ue());
      }
      function rn(I) {
        for (; !Ee(ce()); )
          ue();
        return be(I, t.position);
      }
      function Qn(I) {
        return Se(zn("", null, null, null, [""], I = Pe(I), 0, [0], I));
      }
      function zn(I, ge, xe, Be, Fe, an, _n, Xt, hn) {
        for (var vn = 0, Cn = 0, ln = _n, pi = 0, Ui = 0, ei = 0, Nn = 1, Vr = 1, Sn = 1, Ft = 0, ti = "", Lr = Fe, ni = an, wn = Be, ft = ti; Vr; )
          switch (ei = Ft, Ft = ue()) {
            case 40:
              if (ei != 108 && H(ft, ln - 1) == 58) {
                J(ft += D(ye(Ft), "&", "&\f"), "&\f") != -1 && (Sn = -1);
                break;
              }
            case 34:
            case 39:
            case 91:
              ft += ye(Ft);
              break;
            case 9:
            case 10:
            case 13:
            case 32:
              ft += q(ei);
              break;
            case 92:
              ft += de(he() - 1, 7);
              continue;
            case 47:
              switch (ce()) {
                case 42:
                case 47:
                  ee(sn(nn(ue(), he()), ge, xe), hn);
                  break;
                default:
                  ft += "/";
              }
              break;
            case 123 * Nn:
              Xt[vn++] = le(ft) * Sn;
            case 125 * Nn:
            case 59:
            case 0:
              switch (Ft) {
                case 0:
                case 125:
                  Vr = 0;
                case 59 + Cn:
                  Ui > 0 && le(ft) - ln && ee(Ui > 32 ? Wn(ft + ";", Be, xe, ln - 1) : Wn(D(ft, " ", "") + ";", Be, xe, ln - 2), hn);
                  break;
                case 59:
                  ft += ";";
                default:
                  if (ee(wn = Jt(ft, ge, xe, vn, Cn, Fe, Xt, ti, Lr = [], ni = [], ln), an), Ft === 123)
                    if (Cn === 0)
                      zn(ft, ge, wn, wn, Lr, an, ln, Xt, ni);
                    else
                      switch (pi === 99 && H(ft, 3) === 110 ? 100 : pi) {
                        case 100:
                        case 109:
                        case 115:
                          zn(I, wn, wn, Be && ee(Jt(I, wn, wn, 0, 0, Fe, Xt, ti, Fe, Lr = [], ln), ni), Fe, ni, ln, Xt, Be ? Lr : ni);
                          break;
                        default:
                          zn(ft, wn, wn, wn, [""], ni, 0, Xt, ni);
                      }
              }
              vn = Cn = Ui = 0, Nn = Sn = 1, ti = ft = "", ln = _n;
              break;
            case 58:
              ln = 1 + le(ft), Ui = ei;
            default:
              if (Nn < 1) {
                if (Ft == 123)
                  --Nn;
                else if (Ft == 125 && Nn++ == 0 && ve() == 125)
                  continue;
              }
              switch (ft += V(Ft), Ft * Nn) {
                case 38:
                  Sn = Cn > 0 ? 1 : (ft += "\f", -1);
                  break;
                case 44:
                  Xt[vn++] = (le(ft) - 1) * Sn, Sn = 1;
                  break;
                case 64:
                  ce() === 45 && (ft += ye(ue())), pi = ce(), Cn = ln = le(ti = ft += rn(he())), Ft++;
                  break;
                case 45:
                  ei === 45 && le(ft) == 2 && (Nn = 0);
              }
          }
        return an;
      }
      function Jt(I, ge, xe, Be, Fe, an, _n, Xt, hn, vn, Cn) {
        for (var ln = Fe - 1, pi = Fe === 0 ? an : [""], Ui = me(pi), ei = 0, Nn = 0, Vr = 0; ei < Be; ++ei)
          for (var Sn = 0, Ft = Y(I, ln + 1, ln = E(Nn = _n[ei])), ti = I; Sn < Ui; ++Sn)
            (ti = $(Nn > 0 ? pi[Sn] + " " + Ft : D(Ft, /&\f/g, pi[Sn]))) && (hn[Vr++] = ti);
        return ne(I, ge, xe, Fe === 0 ? l : Xt, hn, vn, Cn);
      }
      function sn(I, ge, xe) {
        return ne(I, ge, xe, o, V(se()), Y(I, 2, -2), 0);
      }
      function Wn(I, ge, xe, Be) {
        return ne(I, ge, xe, u, Y(I, 0, Be), Y(I, Be + 1, -1), Be);
      }
      function gi(I, ge, xe) {
        switch (U(I, ge)) {
          case 5103:
            return s + "print-" + I + I;
          case 5737:
          case 4201:
          case 3177:
          case 3433:
          case 1641:
          case 4457:
          case 2921:
          case 5572:
          case 6356:
          case 5844:
          case 3191:
          case 6645:
          case 3005:
          case 6391:
          case 5879:
          case 5623:
          case 6135:
          case 4599:
          case 4855:
          case 4215:
          case 6389:
          case 5109:
          case 5365:
          case 5621:
          case 3829:
            return s + I + I;
          case 4789:
            return r + I + I;
          case 5349:
          case 4246:
          case 4810:
          case 6968:
          case 2756:
            return s + I + r + I + n + I + I;
          case 5936:
            switch (H(I, ge + 11)) {
              case 114:
                return s + I + n + D(I, /[svh]\w+-[tblr]{2}/, "tb") + I;
              case 108:
                return s + I + n + D(I, /[svh]\w+-[tblr]{2}/, "tb-rl") + I;
              case 45:
                return s + I + n + D(I, /[svh]\w+-[tblr]{2}/, "lr") + I;
            }
          case 6828:
          case 4268:
          case 2903:
            return s + I + n + I + I;
          case 6165:
            return s + I + n + "flex-" + I + I;
          case 5187:
            return s + I + D(I, /(\w+).+(:[^]+)/, s + "box-$1$2" + n + "flex-$1$2") + I;
          case 5443:
            return s + I + n + "flex-item-" + D(I, /flex-|-self/g, "") + (M(I, /flex-|baseline/) ? "" : n + "grid-row-" + D(I, /flex-|-self/g, "")) + I;
          case 4675:
            return s + I + n + "flex-line-pack" + D(I, /align-content|flex-|-self/g, "") + I;
          case 5548:
            return s + I + n + D(I, "shrink", "negative") + I;
          case 5292:
            return s + I + n + D(I, "basis", "preferred-size") + I;
          case 6060:
            return s + "box-" + D(I, "-grow", "") + s + I + n + D(I, "grow", "positive") + I;
          case 4554:
            return s + D(I, /([^-])(transform)/g, "$1" + s + "$2") + I;
          case 6187:
            return D(D(D(I, /(zoom-|grab)/, s + "$1"), /(image-set)/, s + "$1"), I, "") + I;
          case 5495:
          case 3959:
            return D(I, /(image-set\([^]*)/, s + "$1$`$1");
          case 4968:
            return D(D(I, /(.+:)(flex-)?(.*)/, s + "box-pack:$3" + n + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + s + I + I;
          case 4200:
            if (!M(I, /flex-|baseline/))
              return n + "grid-column-align" + Y(I, ge) + I;
            break;
          case 2592:
          case 3360:
            return n + D(I, "template-", "") + I;
          case 4384:
          case 3616:
            return xe && xe.some(function(Be, Fe) {
              return ge = Fe, M(Be.props, /grid-\w+-end/);
            }) ? ~J(I + (xe = xe[ge].value), "span") ? I : n + D(I, "-start", "") + I + n + "grid-row-span:" + (~J(xe, "span") ? M(xe, /\d+/) : +M(xe, /\d+/) - +M(I, /\d+/)) + ";" : n + D(I, "-start", "") + I;
          case 4896:
          case 4128:
            return xe && xe.some(function(Be) {
              return M(Be.props, /grid-\w+-start/);
            }) ? I : n + D(D(I, "-end", "-span"), "span ", "") + I;
          case 4095:
          case 3583:
          case 4068:
          case 2532:
            return D(I, /(.+)-inline(.+)/, s + "$1$2") + I;
          case 8116:
          case 7059:
          case 5753:
          case 5535:
          case 5445:
          case 5701:
          case 4933:
          case 4677:
          case 5533:
          case 5789:
          case 5021:
          case 4765:
            if (le(I) - 1 - ge > 6)
              switch (H(I, ge + 1)) {
                case 109:
                  if (H(I, ge + 4) !== 45)
                    break;
                case 102:
                  return D(I, /(.+:)(.+)-([^]+)/, "$1" + s + "$2-$3$1" + r + (H(I, ge + 3) == 108 ? "$3" : "$2-$3")) + I;
                case 115:
                  return ~J(I, "stretch") ? gi(D(I, "stretch", "fill-available"), ge, xe) + I : I;
              }
            break;
          case 5152:
          case 5920:
            return D(I, /(.+?):(\d+)(\s*\/\s*(span)?\s*(\d+))?(.*)/, function(Be, Fe, an, _n, Xt, hn, vn) {
              return n + Fe + ":" + an + vn + (_n ? n + Fe + "-span:" + (Xt ? hn : +hn - +an) + vn : "") + I;
            });
          case 4949:
            if (H(I, ge + 6) === 121)
              return D(I, ":", ":" + s) + I;
            break;
          case 6444:
            switch (H(I, H(I, 14) === 45 ? 18 : 11)) {
              case 120:
                return D(I, /(.+:)([^;\s!]+)(;|(\s+)?!.+)?/, "$1" + s + (H(I, 14) === 45 ? "inline-" : "") + "box$3$1" + s + "$2$3$1" + n + "$2box$3") + I;
              case 100:
                return D(I, ":", ":" + n) + I;
            }
            break;
          case 5719:
          case 2647:
          case 2135:
          case 3927:
          case 2391:
            return D(I, "scroll-", "scroll-snap-") + I;
        }
        return I;
      }
      function jn(I, ge) {
        for (var xe = "", Be = me(I), Fe = 0; Fe < Be; Fe++)
          xe += ge(I[Fe], Fe, I, ge) || "";
        return xe;
      }
      function Un(I, ge, xe, Be) {
        switch (I.type) {
          case m:
          case u:
            return I.return = I.return || I.value;
          case o:
            return "";
          case N:
            return I.return = I.value + "{" + jn(I.children, Be) + "}";
          case l:
            I.value = I.props.join(",");
        }
        return le(xe = jn(I.children, Be)) ? I.return = I.value + "{" + xe + "}" : "";
      }
      function dn(I) {
        var ge = me(I);
        return function(xe, Be, Fe, an) {
          for (var _n = "", Xt = 0; Xt < ge; Xt++)
            _n += I[Xt](xe, Be, Fe, an) || "";
          return _n;
        };
      }
      function on(I) {
        return function(ge) {
          ge.root || (ge = ge.return) && I(ge);
        };
      }
      function On(I, ge, xe, Be) {
        if (I.length > -1 && !I.return)
          switch (I.type) {
            case u:
              I.return = gi(I.value, I.length, xe);
              return;
            case N:
              return jn([z(I, { value: D(I.value, "@", "@" + s) })], Be);
            case l:
              if (I.length)
                return te(I.props, function(Fe) {
                  switch (M(Fe, /(::plac\w+|:read-\w+)/)) {
                    case ":read-only":
                    case ":read-write":
                      return jn([z(I, { props: [D(Fe, /:(read-\w+)/, ":" + r + "$1")] })], Be);
                    case "::placeholder":
                      return jn([z(I, { props: [D(Fe, /:(plac\w+)/, ":" + s + "input-$1")] }), z(I, { props: [D(Fe, /:(plac\w+)/, ":" + r + "$1")] }), z(I, { props: [D(Fe, /:(plac\w+)/, n + "input-$1")] })], Be);
                  }
                  return "";
                });
          }
      }
      function Mn(I) {
        switch (I.type) {
          case l:
            I.props = I.props.map(function(ge) {
              return te(De(ge), function(xe, Be, Fe) {
                switch (H(xe, 0)) {
                  case 12:
                    return Y(xe, 1, le(xe));
                  case 0:
                  case 40:
                  case 43:
                  case 62:
                  case 126:
                    return xe;
                  case 58:
                    Fe[++Be] === "global" && (Fe[Be] = "", Fe[++Be] = "\f" + Y(Fe[Be], Be = 1, -1));
                  case 32:
                    return Be === 1 ? "" : xe;
                  default:
                    switch (Be) {
                      case 0:
                        return I = xe, me(Fe) > 1 ? "" : xe;
                      case (Be = me(Fe) - 1):
                      case 2:
                        return Be === 2 ? xe + I + I : xe + I;
                      default:
                        return xe;
                    }
                }
              });
            });
        }
      }
      t.CHARSET = v, t.COMMENT = o, t.COUNTER_STYLE = A, t.DECLARATION = u, t.DOCUMENT = S, t.FONT_FACE = y, t.FONT_FEATURE_VALUES = P, t.IMPORT = m, t.KEYFRAMES = N, t.MEDIA = f, t.MOZ = r, t.MS = n, t.NAMESPACE = x, t.PAGE = h, t.RULESET = l, t.SUPPORTS = k, t.VIEWPORT = C, t.WEBKIT = s, t.abs = E, t.alloc = Pe, t.append = ee, t.assign = j, t.caret = he, t.char = se, t.charat = H, t.combine = te, t.comment = sn, t.commenter = nn, t.compile = Qn, t.copy = z, t.dealloc = Se, t.declaration = Wn, t.delimit = ye, t.delimiter = Ye, t.escaping = de, t.from = V, t.hash = U, t.identifier = rn, t.indexof = J, t.match = M, t.middleware = dn, t.namespace = Mn, t.next = ue, t.node = ne, t.parse = zn, t.peek = ce, t.prefix = gi, t.prefixer = On, t.prev = ve, t.replace = D, t.ruleset = Jt, t.rulesheet = on, t.serialize = jn, t.sizeof = me, t.slice = be, t.stringify = Un, t.strlen = le, t.substr = Y, t.token = Ee, t.tokenize = De, t.tokenizer = Ze, t.trim = $, t.whitespace = q, Object.defineProperty(t, "__esModule", { value: !0 });
    });
  }(A5, al)), al;
}
var hd = {}, P5 = {
  get exports() {
    return hd;
  },
  set exports(i) {
    hd = i;
  }
}, Eu = {}, Z1;
function I5() {
  if (Z1)
    return Eu;
  Z1 = 1, Object.defineProperty(Eu, "__esModule", { value: !0 });
  var i = function(t) {
    var n = /* @__PURE__ */ new WeakMap();
    return function(r) {
      if (n.has(r))
        return n.get(r);
      var s = t(r);
      return n.set(r, s), s;
    };
  };
  return Eu.default = i, Eu;
}
var Cu = {}, Q1;
function R5() {
  if (Q1)
    return Cu;
  Q1 = 1, Object.defineProperty(Cu, "__esModule", { value: !0 });
  var i = function(t) {
    var n = /* @__PURE__ */ new WeakMap();
    return function(r) {
      if (n.has(r))
        return n.get(r);
      var s = t(r);
      return n.set(r, s), s;
    };
  };
  return Cu.default = i, Cu;
}
var ev;
function Jo() {
  return ev || (ev = 1, function(i) {
    process.env.NODE_ENV === "production" ? i.exports = I5() : i.exports = R5();
  }(P5)), hd;
}
var tv;
function O5() {
  if (tv)
    return wu;
  tv = 1, Object.defineProperty(wu, "__esModule", { value: !0 });
  var i = z0(), e = W0(), t = Jo(), n = Al();
  function r(A) {
    return A && A.__esModule ? A : { default: A };
  }
  var s = /* @__PURE__ */ r(t), o = /* @__PURE__ */ r(n), l = function(P, E, V) {
    for (var j = 0, U = 0; j = U, U = e.peek(), j === 38 && U === 12 && (E[V] = 1), !e.token(U); )
      e.next();
    return e.slice(P, e.position);
  }, u = function(P, E) {
    var V = -1, j = 44;
    do
      switch (e.token(j)) {
        case 0:
          j === 38 && e.peek() === 12 && (E[V] = 1), P[V] += l(e.position - 1, E, V);
          break;
        case 2:
          P[V] += e.delimit(j);
          break;
        case 4:
          if (j === 44) {
            P[++V] = e.peek() === 58 ? "&\f" : "", E[V] = P[V].length;
            break;
          }
        default:
          P[V] += e.from(j);
      }
    while (j = e.next());
    return P;
  }, h = function(P, E) {
    return e.dealloc(u(e.alloc(P), E));
  }, f = /* @__PURE__ */ new WeakMap(), m = function(P) {
    if (!(P.type !== "rule" || !P.parent || // positive .length indicates that this rule contains pseudo
    // negative .length indicates that this rule has been already prefixed
    P.length < 1)) {
      for (var E = P.value, V = P.parent, j = P.column === V.column && P.line === V.line; V.type !== "rule"; )
        if (V = V.parent, !V)
          return;
      if (!(P.props.length === 1 && E.charCodeAt(0) !== 58 && !f.get(V)) && !j) {
        f.set(P, !0);
        for (var U = [], $ = h(E, U), M = V.props, D = 0, J = 0; D < $.length; D++)
          for (var H = 0; H < M.length; H++, J++)
            P.props[J] = U[D] ? $[D].replace(/&\f/g, M[H]) : M[H] + " " + $[D];
      }
    }
  }, v = function(P) {
    if (P.type === "decl") {
      var E = P.value;
      // charcode for l
      E.charCodeAt(0) === 108 && // charcode for b
      E.charCodeAt(2) === 98 && (P.return = "", P.value = "");
    }
  };
  function C(A, P) {
    switch (e.hash(A, P)) {
      case 5103:
        return e.WEBKIT + "print-" + A + A;
      case 5737:
      case 4201:
      case 3177:
      case 3433:
      case 1641:
      case 4457:
      case 2921:
      case 5572:
      case 6356:
      case 5844:
      case 3191:
      case 6645:
      case 3005:
      case 6391:
      case 5879:
      case 5623:
      case 6135:
      case 4599:
      case 4855:
      case 4215:
      case 6389:
      case 5109:
      case 5365:
      case 5621:
      case 3829:
        return e.WEBKIT + A + A;
      case 5349:
      case 4246:
      case 4810:
      case 6968:
      case 2756:
        return e.WEBKIT + A + e.MOZ + A + e.MS + A + A;
      case 6828:
      case 4268:
        return e.WEBKIT + A + e.MS + A + A;
      case 6165:
        return e.WEBKIT + A + e.MS + "flex-" + A + A;
      case 5187:
        return e.WEBKIT + A + e.replace(A, /(\w+).+(:[^]+)/, e.WEBKIT + "box-$1$2" + e.MS + "flex-$1$2") + A;
      case 5443:
        return e.WEBKIT + A + e.MS + "flex-item-" + e.replace(A, /flex-|-self/, "") + A;
      case 4675:
        return e.WEBKIT + A + e.MS + "flex-line-pack" + e.replace(A, /align-content|flex-|-self/, "") + A;
      case 5548:
        return e.WEBKIT + A + e.MS + e.replace(A, "shrink", "negative") + A;
      case 5292:
        return e.WEBKIT + A + e.MS + e.replace(A, "basis", "preferred-size") + A;
      case 6060:
        return e.WEBKIT + "box-" + e.replace(A, "-grow", "") + e.WEBKIT + A + e.MS + e.replace(A, "grow", "positive") + A;
      case 4554:
        return e.WEBKIT + e.replace(A, /([^-])(transform)/g, "$1" + e.WEBKIT + "$2") + A;
      case 6187:
        return e.replace(e.replace(e.replace(A, /(zoom-|grab)/, e.WEBKIT + "$1"), /(image-set)/, e.WEBKIT + "$1"), A, "") + A;
      case 5495:
      case 3959:
        return e.replace(A, /(image-set\([^]*)/, e.WEBKIT + "$1$`$1");
      case 4968:
        return e.replace(e.replace(A, /(.+:)(flex-)?(.*)/, e.WEBKIT + "box-pack:$3" + e.MS + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + e.WEBKIT + A + A;
      case 4095:
      case 3583:
      case 4068:
      case 2532:
        return e.replace(A, /(.+)-inline(.+)/, e.WEBKIT + "$1$2") + A;
      case 8116:
      case 7059:
      case 5753:
      case 5535:
      case 5445:
      case 5701:
      case 4933:
      case 4677:
      case 5533:
      case 5789:
      case 5021:
      case 4765:
        if (e.strlen(A) - 1 - P > 6)
          switch (e.charat(A, P + 1)) {
            case 109:
              if (e.charat(A, P + 4) !== 45)
                break;
            case 102:
              return e.replace(A, /(.+:)(.+)-([^]+)/, "$1" + e.WEBKIT + "$2-$3$1" + e.MOZ + (e.charat(A, P + 3) == 108 ? "$3" : "$2-$3")) + A;
            case 115:
              return ~e.indexof(A, "stretch") ? C(e.replace(A, "stretch", "fill-available"), P) + A : A;
          }
        break;
      case 4949:
        if (e.charat(A, P + 1) !== 115)
          break;
      case 6444:
        switch (e.charat(A, e.strlen(A) - 3 - (~e.indexof(A, "!important") && 10))) {
          case 107:
            return e.replace(A, ":", ":" + e.WEBKIT) + A;
          case 101:
            return e.replace(A, /(.+:)([^;!]+)(;|!.+)?/, "$1" + e.WEBKIT + (e.charat(A, 14) === 45 ? "inline-" : "") + "box$3$1" + e.WEBKIT + "$2$3$1" + e.MS + "$2box$3") + A;
        }
        break;
      case 5936:
        switch (e.charat(A, P + 11)) {
          case 114:
            return e.WEBKIT + A + e.MS + e.replace(A, /[svh]\w+-[tblr]{2}/, "tb") + A;
          case 108:
            return e.WEBKIT + A + e.MS + e.replace(A, /[svh]\w+-[tblr]{2}/, "tb-rl") + A;
          case 45:
            return e.WEBKIT + A + e.MS + e.replace(A, /[svh]\w+-[tblr]{2}/, "lr") + A;
        }
        return e.WEBKIT + A + e.MS + A + A;
    }
    return A;
  }
  var k = function(P, E, V, j) {
    if (P.length > -1 && !P.return)
      switch (P.type) {
        case e.DECLARATION:
          P.return = C(P.value, P.length);
          break;
        case e.KEYFRAMES:
          return e.serialize([e.copy(P, {
            value: e.replace(P.value, "@", "@" + e.WEBKIT)
          })], j);
        case e.RULESET:
          if (P.length)
            return e.combine(P.props, function(U) {
              switch (e.match(U, /(::plac\w+|:read-\w+)/)) {
                case ":read-only":
                case ":read-write":
                  return e.serialize([e.copy(P, {
                    props: [e.replace(U, /:(read-\w+)/, ":" + e.MOZ + "$1")]
                  })], j);
                case "::placeholder":
                  return e.serialize([e.copy(P, {
                    props: [e.replace(U, /:(plac\w+)/, ":" + e.WEBKIT + "input-$1")]
                  }), e.copy(P, {
                    props: [e.replace(U, /:(plac\w+)/, ":" + e.MOZ + "$1")]
                  }), e.copy(P, {
                    props: [e.replace(U, /:(plac\w+)/, e.MS + "input-$1")]
                  })], j);
              }
              return "";
            });
      }
  }, S = typeof document < "u", x = S ? void 0 : s.default(function() {
    return o.default(function() {
      var A = {};
      return function(P) {
        return A[P];
      };
    });
  }), N = [k], y = function(P) {
    var E = P.key;
    if (S && E === "css") {
      var V = document.querySelectorAll("style[data-emotion]:not([data-s])");
      Array.prototype.forEach.call(V, function(ue) {
        var ce = ue.getAttribute("data-emotion");
        ce.indexOf(" ") !== -1 && (document.head.appendChild(ue), ue.setAttribute("data-s", ""));
      });
    }
    var j = P.stylisPlugins || N, U = {}, $, M = [];
    S && ($ = P.container || document.head, Array.prototype.forEach.call(
      // this means we will ignore elements which don't have a space in them which
      // means that the style elements we're looking at are only Emotion 11 server-rendered style elements
      document.querySelectorAll('style[data-emotion^="' + E + ' "]'),
      function(ue) {
        for (var ce = ue.getAttribute("data-emotion").split(" "), he = 1; he < ce.length; he++)
          U[ce[he]] = !0;
        M.push(ue);
      }
    ));
    var D, J = [m, v];
    if (S) {
      var H, Y = [e.stringify, e.rulesheet(function(ue) {
        H.insert(ue);
      })], le = e.middleware(J.concat(j, Y)), me = function(ce) {
        return e.serialize(e.compile(ce), le);
      };
      D = function(ce, he, be, Ee) {
        H = be, me(ce ? ce + "{" + he.styles + "}" : he.styles), Ee && (ve.inserted[he.name] = !0);
      };
    } else {
      var ee = [e.stringify], te = e.middleware(J.concat(j, ee)), ne = function(ce) {
        return e.serialize(e.compile(ce), te);
      }, z = x(j)(E), se = function(ce, he) {
        var be = he.name;
        return z[be] === void 0 && (z[be] = ne(ce ? ce + "{" + he.styles + "}" : he.styles)), z[be];
      };
      D = function(ce, he, be, Ee) {
        var Pe = he.name, Se = se(ce, he);
        if (ve.compat === void 0)
          return Ee && (ve.inserted[Pe] = !0), Se;
        if (Ee)
          ve.inserted[Pe] = Se;
        else
          return Se;
      };
    }
    var ve = {
      key: E,
      sheet: new i.StyleSheet({
        key: E,
        container: $,
        nonce: P.nonce,
        speedy: P.speedy,
        prepend: P.prepend,
        insertionPoint: P.insertionPoint
      }),
      nonce: P.nonce,
      inserted: U,
      registered: {},
      insert: D
    };
    return ve.sheet.hydrate(M), ve;
  };
  return wu.default = y, wu;
}
var Su = {}, nv;
function M5() {
  if (nv)
    return Su;
  nv = 1, Object.defineProperty(Su, "__esModule", { value: !0 });
  var i = z0(), e = W0(), t = Jo(), n = Al();
  function r(M) {
    return M && M.__esModule ? M : { default: M };
  }
  var s = /* @__PURE__ */ r(t), o = /* @__PURE__ */ r(n), l = function(D, J, H) {
    for (var Y = 0, le = 0; Y = le, le = e.peek(), Y === 38 && le === 12 && (J[H] = 1), !e.token(le); )
      e.next();
    return e.slice(D, e.position);
  }, u = function(D, J) {
    var H = -1, Y = 44;
    do
      switch (e.token(Y)) {
        case 0:
          Y === 38 && e.peek() === 12 && (J[H] = 1), D[H] += l(e.position - 1, J, H);
          break;
        case 2:
          D[H] += e.delimit(Y);
          break;
        case 4:
          if (Y === 44) {
            D[++H] = e.peek() === 58 ? "&\f" : "", J[H] = D[H].length;
            break;
          }
        default:
          D[H] += e.from(Y);
      }
    while (Y = e.next());
    return D;
  }, h = function(D, J) {
    return e.dealloc(u(e.alloc(D), J));
  }, f = /* @__PURE__ */ new WeakMap(), m = function(D) {
    if (!(D.type !== "rule" || !D.parent || // positive .length indicates that this rule contains pseudo
    // negative .length indicates that this rule has been already prefixed
    D.length < 1)) {
      for (var J = D.value, H = D.parent, Y = D.column === H.column && D.line === H.line; H.type !== "rule"; )
        if (H = H.parent, !H)
          return;
      if (!(D.props.length === 1 && J.charCodeAt(0) !== 58 && !f.get(H)) && !Y) {
        f.set(D, !0);
        for (var le = [], me = h(J, le), ee = H.props, te = 0, ne = 0; te < me.length; te++)
          for (var z = 0; z < ee.length; z++, ne++)
            D.props[ne] = le[te] ? me[te].replace(/&\f/g, ee[z]) : ee[z] + " " + me[te];
      }
    }
  }, v = function(D) {
    if (D.type === "decl") {
      var J = D.value;
      // charcode for l
      J.charCodeAt(0) === 108 && // charcode for b
      J.charCodeAt(2) === 98 && (D.return = "", D.value = "");
    }
  }, C = "emotion-disable-server-rendering-unsafe-selector-warning-please-do-not-use-this-the-warning-exists-for-a-reason", k = function(D) {
    return D.type === "comm" && D.children.indexOf(C) > -1;
  }, S = function(D) {
    return function(J, H, Y) {
      if (!(J.type !== "rule" || D.compat)) {
        var le = J.value.match(/(:first|:nth|:nth-last)-child/g);
        if (le) {
          for (var me = J.parent === Y[0], ee = me ? Y[0].children : (
            // global rule at the root level
            Y
          ), te = ee.length - 1; te >= 0; te--) {
            var ne = ee[te];
            if (ne.line < J.line)
              break;
            if (ne.column < J.column) {
              if (k(ne))
                return;
              break;
            }
          }
          le.forEach(function(z) {
            console.error('The pseudo class "' + z + '" is potentially unsafe when doing server-side rendering. Try changing it to "' + z.split("-child")[0] + '-of-type".');
          });
        }
      }
    };
  }, x = function(D) {
    return D.type.charCodeAt(1) === 105 && D.type.charCodeAt(0) === 64;
  }, N = function(D, J) {
    for (var H = D - 1; H >= 0; H--)
      if (!x(J[H]))
        return !0;
    return !1;
  }, y = function(D) {
    D.type = "", D.value = "", D.return = "", D.children = "", D.props = "";
  }, A = function(D, J, H) {
    x(D) && (D.parent ? (console.error("`@import` rules can't be nested inside other rules. Please move it to the top level and put it before regular rules. Keep in mind that they can only be used within global styles."), y(D)) : N(J, H) && (console.error("`@import` rules can't be after other rules. Please put your `@import` rules before your other rules."), y(D)));
  };
  function P(M, D) {
    switch (e.hash(M, D)) {
      case 5103:
        return e.WEBKIT + "print-" + M + M;
      case 5737:
      case 4201:
      case 3177:
      case 3433:
      case 1641:
      case 4457:
      case 2921:
      case 5572:
      case 6356:
      case 5844:
      case 3191:
      case 6645:
      case 3005:
      case 6391:
      case 5879:
      case 5623:
      case 6135:
      case 4599:
      case 4855:
      case 4215:
      case 6389:
      case 5109:
      case 5365:
      case 5621:
      case 3829:
        return e.WEBKIT + M + M;
      case 5349:
      case 4246:
      case 4810:
      case 6968:
      case 2756:
        return e.WEBKIT + M + e.MOZ + M + e.MS + M + M;
      case 6828:
      case 4268:
        return e.WEBKIT + M + e.MS + M + M;
      case 6165:
        return e.WEBKIT + M + e.MS + "flex-" + M + M;
      case 5187:
        return e.WEBKIT + M + e.replace(M, /(\w+).+(:[^]+)/, e.WEBKIT + "box-$1$2" + e.MS + "flex-$1$2") + M;
      case 5443:
        return e.WEBKIT + M + e.MS + "flex-item-" + e.replace(M, /flex-|-self/, "") + M;
      case 4675:
        return e.WEBKIT + M + e.MS + "flex-line-pack" + e.replace(M, /align-content|flex-|-self/, "") + M;
      case 5548:
        return e.WEBKIT + M + e.MS + e.replace(M, "shrink", "negative") + M;
      case 5292:
        return e.WEBKIT + M + e.MS + e.replace(M, "basis", "preferred-size") + M;
      case 6060:
        return e.WEBKIT + "box-" + e.replace(M, "-grow", "") + e.WEBKIT + M + e.MS + e.replace(M, "grow", "positive") + M;
      case 4554:
        return e.WEBKIT + e.replace(M, /([^-])(transform)/g, "$1" + e.WEBKIT + "$2") + M;
      case 6187:
        return e.replace(e.replace(e.replace(M, /(zoom-|grab)/, e.WEBKIT + "$1"), /(image-set)/, e.WEBKIT + "$1"), M, "") + M;
      case 5495:
      case 3959:
        return e.replace(M, /(image-set\([^]*)/, e.WEBKIT + "$1$`$1");
      case 4968:
        return e.replace(e.replace(M, /(.+:)(flex-)?(.*)/, e.WEBKIT + "box-pack:$3" + e.MS + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + e.WEBKIT + M + M;
      case 4095:
      case 3583:
      case 4068:
      case 2532:
        return e.replace(M, /(.+)-inline(.+)/, e.WEBKIT + "$1$2") + M;
      case 8116:
      case 7059:
      case 5753:
      case 5535:
      case 5445:
      case 5701:
      case 4933:
      case 4677:
      case 5533:
      case 5789:
      case 5021:
      case 4765:
        if (e.strlen(M) - 1 - D > 6)
          switch (e.charat(M, D + 1)) {
            case 109:
              if (e.charat(M, D + 4) !== 45)
                break;
            case 102:
              return e.replace(M, /(.+:)(.+)-([^]+)/, "$1" + e.WEBKIT + "$2-$3$1" + e.MOZ + (e.charat(M, D + 3) == 108 ? "$3" : "$2-$3")) + M;
            case 115:
              return ~e.indexof(M, "stretch") ? P(e.replace(M, "stretch", "fill-available"), D) + M : M;
          }
        break;
      case 4949:
        if (e.charat(M, D + 1) !== 115)
          break;
      case 6444:
        switch (e.charat(M, e.strlen(M) - 3 - (~e.indexof(M, "!important") && 10))) {
          case 107:
            return e.replace(M, ":", ":" + e.WEBKIT) + M;
          case 101:
            return e.replace(M, /(.+:)([^;!]+)(;|!.+)?/, "$1" + e.WEBKIT + (e.charat(M, 14) === 45 ? "inline-" : "") + "box$3$1" + e.WEBKIT + "$2$3$1" + e.MS + "$2box$3") + M;
        }
        break;
      case 5936:
        switch (e.charat(M, D + 11)) {
          case 114:
            return e.WEBKIT + M + e.MS + e.replace(M, /[svh]\w+-[tblr]{2}/, "tb") + M;
          case 108:
            return e.WEBKIT + M + e.MS + e.replace(M, /[svh]\w+-[tblr]{2}/, "tb-rl") + M;
          case 45:
            return e.WEBKIT + M + e.MS + e.replace(M, /[svh]\w+-[tblr]{2}/, "lr") + M;
        }
        return e.WEBKIT + M + e.MS + M + M;
    }
    return M;
  }
  var E = function(D, J, H, Y) {
    if (D.length > -1 && !D.return)
      switch (D.type) {
        case e.DECLARATION:
          D.return = P(D.value, D.length);
          break;
        case e.KEYFRAMES:
          return e.serialize([e.copy(D, {
            value: e.replace(D.value, "@", "@" + e.WEBKIT)
          })], Y);
        case e.RULESET:
          if (D.length)
            return e.combine(D.props, function(le) {
              switch (e.match(le, /(::plac\w+|:read-\w+)/)) {
                case ":read-only":
                case ":read-write":
                  return e.serialize([e.copy(D, {
                    props: [e.replace(le, /:(read-\w+)/, ":" + e.MOZ + "$1")]
                  })], Y);
                case "::placeholder":
                  return e.serialize([e.copy(D, {
                    props: [e.replace(le, /:(plac\w+)/, ":" + e.WEBKIT + "input-$1")]
                  }), e.copy(D, {
                    props: [e.replace(le, /:(plac\w+)/, ":" + e.MOZ + "$1")]
                  }), e.copy(D, {
                    props: [e.replace(le, /:(plac\w+)/, e.MS + "input-$1")]
                  })], Y);
              }
              return "";
            });
      }
  }, V = typeof document < "u", j = V ? void 0 : s.default(function() {
    return o.default(function() {
      var M = {};
      return function(D) {
        return M[D];
      };
    });
  }), U = [E], $ = function(D) {
    var J = D.key;
    if (process.env.NODE_ENV !== "production" && !J)
      throw new Error(`You have to configure \`key\` for your cache. Please make sure it's unique (and not equal to 'css') as it's used for linking styles to your cache.
If multiple caches share the same key they might "fight" for each other's style elements.`);
    if (V && J === "css") {
      var H = document.querySelectorAll("style[data-emotion]:not([data-s])");
      Array.prototype.forEach.call(H, function(ye) {
        var De = ye.getAttribute("data-emotion");
        De.indexOf(" ") !== -1 && (document.head.appendChild(ye), ye.setAttribute("data-s", ""));
      });
    }
    var Y = D.stylisPlugins || U;
    if (process.env.NODE_ENV !== "production" && /[^a-z-]/.test(J))
      throw new Error('Emotion key must only contain lower case alphabetical characters and - but "' + J + '" was passed');
    var le = {}, me, ee = [];
    V && (me = D.container || document.head, Array.prototype.forEach.call(
      // this means we will ignore elements which don't have a space in them which
      // means that the style elements we're looking at are only Emotion 11 server-rendered style elements
      document.querySelectorAll('style[data-emotion^="' + J + ' "]'),
      function(ye) {
        for (var De = ye.getAttribute("data-emotion").split(" "), q = 1; q < De.length; q++)
          le[De[q]] = !0;
        ee.push(ye);
      }
    ));
    var te, ne = [m, v];
    if (process.env.NODE_ENV !== "production" && ne.push(S({
      get compat() {
        return Se.compat;
      }
    }), A), V) {
      var z, se = [e.stringify, process.env.NODE_ENV !== "production" ? function(ye) {
        ye.root || (ye.return ? z.insert(ye.return) : ye.value && ye.type !== e.COMMENT && z.insert(ye.value + "{}"));
      } : e.rulesheet(function(ye) {
        z.insert(ye);
      })], ve = e.middleware(ne.concat(Y, se)), ue = function(De) {
        return e.serialize(e.compile(De), ve);
      };
      te = function(De, q, Ze, de) {
        z = Ze, process.env.NODE_ENV !== "production" && q.map !== void 0 && (z = {
          insert: function(nn) {
            Ze.insert(nn + q.map);
          }
        }), ue(De ? De + "{" + q.styles + "}" : q.styles), de && (Se.inserted[q.name] = !0);
      };
    } else {
      var ce = [e.stringify], he = e.middleware(ne.concat(Y, ce)), be = function(De) {
        return e.serialize(e.compile(De), he);
      }, Ee = j(Y)(J), Pe = function(De, q) {
        var Ze = q.name;
        return Ee[Ze] === void 0 && (Ee[Ze] = be(De ? De + "{" + q.styles + "}" : q.styles)), Ee[Ze];
      };
      te = function(De, q, Ze, de) {
        var Ye = q.name, nn = Pe(De, q);
        if (Se.compat === void 0)
          return de && (Se.inserted[Ye] = !0), // using === development instead of !== production
          // because if people do ssr in tests, the source maps showing up would be annoying
          process.env.NODE_ENV === "development" && q.map !== void 0 ? nn + q.map : nn;
        if (de)
          Se.inserted[Ye] = nn;
        else
          return nn;
      };
    }
    var Se = {
      key: J,
      sheet: new i.StyleSheet({
        key: J,
        container: me,
        nonce: D.nonce,
        speedy: D.speedy,
        prepend: D.prepend,
        insertionPoint: D.insertionPoint
      }),
      nonce: D.nonce,
      inserted: le,
      registered: {},
      insert: te
    };
    return Se.sheet.hydrate(ee), Se;
  };
  return Su.default = $, Su;
}
(function(i) {
  process.env.NODE_ENV === "production" ? i.exports = O5() : i.exports = M5();
})(S5);
const N5 = /* @__PURE__ */ D0(Vo);
var im = {}, Tu = {}, fd = {}, D5 = {
  get exports() {
    return fd;
  },
  set exports(i) {
    fd = i;
  }
}, ut = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var iv;
function B5() {
  if (iv)
    return ut;
  iv = 1;
  var i = typeof Symbol == "function" && Symbol.for, e = i ? Symbol.for("react.element") : 60103, t = i ? Symbol.for("react.portal") : 60106, n = i ? Symbol.for("react.fragment") : 60107, r = i ? Symbol.for("react.strict_mode") : 60108, s = i ? Symbol.for("react.profiler") : 60114, o = i ? Symbol.for("react.provider") : 60109, l = i ? Symbol.for("react.context") : 60110, u = i ? Symbol.for("react.async_mode") : 60111, h = i ? Symbol.for("react.concurrent_mode") : 60111, f = i ? Symbol.for("react.forward_ref") : 60112, m = i ? Symbol.for("react.suspense") : 60113, v = i ? Symbol.for("react.suspense_list") : 60120, C = i ? Symbol.for("react.memo") : 60115, k = i ? Symbol.for("react.lazy") : 60116, S = i ? Symbol.for("react.block") : 60121, x = i ? Symbol.for("react.fundamental") : 60117, N = i ? Symbol.for("react.responder") : 60118, y = i ? Symbol.for("react.scope") : 60119;
  function A(E) {
    if (typeof E == "object" && E !== null) {
      var V = E.$$typeof;
      switch (V) {
        case e:
          switch (E = E.type, E) {
            case u:
            case h:
            case n:
            case s:
            case r:
            case m:
              return E;
            default:
              switch (E = E && E.$$typeof, E) {
                case l:
                case f:
                case k:
                case C:
                case o:
                  return E;
                default:
                  return V;
              }
          }
        case t:
          return V;
      }
    }
  }
  function P(E) {
    return A(E) === h;
  }
  return ut.AsyncMode = u, ut.ConcurrentMode = h, ut.ContextConsumer = l, ut.ContextProvider = o, ut.Element = e, ut.ForwardRef = f, ut.Fragment = n, ut.Lazy = k, ut.Memo = C, ut.Portal = t, ut.Profiler = s, ut.StrictMode = r, ut.Suspense = m, ut.isAsyncMode = function(E) {
    return P(E) || A(E) === u;
  }, ut.isConcurrentMode = P, ut.isContextConsumer = function(E) {
    return A(E) === l;
  }, ut.isContextProvider = function(E) {
    return A(E) === o;
  }, ut.isElement = function(E) {
    return typeof E == "object" && E !== null && E.$$typeof === e;
  }, ut.isForwardRef = function(E) {
    return A(E) === f;
  }, ut.isFragment = function(E) {
    return A(E) === n;
  }, ut.isLazy = function(E) {
    return A(E) === k;
  }, ut.isMemo = function(E) {
    return A(E) === C;
  }, ut.isPortal = function(E) {
    return A(E) === t;
  }, ut.isProfiler = function(E) {
    return A(E) === s;
  }, ut.isStrictMode = function(E) {
    return A(E) === r;
  }, ut.isSuspense = function(E) {
    return A(E) === m;
  }, ut.isValidElementType = function(E) {
    return typeof E == "string" || typeof E == "function" || E === n || E === h || E === s || E === r || E === m || E === v || typeof E == "object" && E !== null && (E.$$typeof === k || E.$$typeof === C || E.$$typeof === o || E.$$typeof === l || E.$$typeof === f || E.$$typeof === x || E.$$typeof === N || E.$$typeof === y || E.$$typeof === S);
  }, ut.typeOf = A, ut;
}
var dt = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var rv;
function V5() {
  return rv || (rv = 1, process.env.NODE_ENV !== "production" && function() {
    var i = typeof Symbol == "function" && Symbol.for, e = i ? Symbol.for("react.element") : 60103, t = i ? Symbol.for("react.portal") : 60106, n = i ? Symbol.for("react.fragment") : 60107, r = i ? Symbol.for("react.strict_mode") : 60108, s = i ? Symbol.for("react.profiler") : 60114, o = i ? Symbol.for("react.provider") : 60109, l = i ? Symbol.for("react.context") : 60110, u = i ? Symbol.for("react.async_mode") : 60111, h = i ? Symbol.for("react.concurrent_mode") : 60111, f = i ? Symbol.for("react.forward_ref") : 60112, m = i ? Symbol.for("react.suspense") : 60113, v = i ? Symbol.for("react.suspense_list") : 60120, C = i ? Symbol.for("react.memo") : 60115, k = i ? Symbol.for("react.lazy") : 60116, S = i ? Symbol.for("react.block") : 60121, x = i ? Symbol.for("react.fundamental") : 60117, N = i ? Symbol.for("react.responder") : 60118, y = i ? Symbol.for("react.scope") : 60119;
    function A(q) {
      return typeof q == "string" || typeof q == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      q === n || q === h || q === s || q === r || q === m || q === v || typeof q == "object" && q !== null && (q.$$typeof === k || q.$$typeof === C || q.$$typeof === o || q.$$typeof === l || q.$$typeof === f || q.$$typeof === x || q.$$typeof === N || q.$$typeof === y || q.$$typeof === S);
    }
    function P(q) {
      if (typeof q == "object" && q !== null) {
        var Ze = q.$$typeof;
        switch (Ze) {
          case e:
            var de = q.type;
            switch (de) {
              case u:
              case h:
              case n:
              case s:
              case r:
              case m:
                return de;
              default:
                var Ye = de && de.$$typeof;
                switch (Ye) {
                  case l:
                  case f:
                  case k:
                  case C:
                  case o:
                    return Ye;
                  default:
                    return Ze;
                }
            }
          case t:
            return Ze;
        }
      }
    }
    var E = u, V = h, j = l, U = o, $ = e, M = f, D = n, J = k, H = C, Y = t, le = s, me = r, ee = m, te = !1;
    function ne(q) {
      return te || (te = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), z(q) || P(q) === u;
    }
    function z(q) {
      return P(q) === h;
    }
    function se(q) {
      return P(q) === l;
    }
    function ve(q) {
      return P(q) === o;
    }
    function ue(q) {
      return typeof q == "object" && q !== null && q.$$typeof === e;
    }
    function ce(q) {
      return P(q) === f;
    }
    function he(q) {
      return P(q) === n;
    }
    function be(q) {
      return P(q) === k;
    }
    function Ee(q) {
      return P(q) === C;
    }
    function Pe(q) {
      return P(q) === t;
    }
    function Se(q) {
      return P(q) === s;
    }
    function ye(q) {
      return P(q) === r;
    }
    function De(q) {
      return P(q) === m;
    }
    dt.AsyncMode = E, dt.ConcurrentMode = V, dt.ContextConsumer = j, dt.ContextProvider = U, dt.Element = $, dt.ForwardRef = M, dt.Fragment = D, dt.Lazy = J, dt.Memo = H, dt.Portal = Y, dt.Profiler = le, dt.StrictMode = me, dt.Suspense = ee, dt.isAsyncMode = ne, dt.isConcurrentMode = z, dt.isContextConsumer = se, dt.isContextProvider = ve, dt.isElement = ue, dt.isForwardRef = ce, dt.isFragment = he, dt.isLazy = be, dt.isMemo = Ee, dt.isPortal = Pe, dt.isProfiler = Se, dt.isStrictMode = ye, dt.isSuspense = De, dt.isValidElementType = A, dt.typeOf = P;
  }()), dt;
}
var sv;
function L5() {
  return sv || (sv = 1, function(i) {
    process.env.NODE_ENV === "production" ? i.exports = B5() : i.exports = V5();
  }(D5)), fd;
}
var rm, ov;
function Dd() {
  if (ov)
    return rm;
  ov = 1;
  var i = L5(), e = {
    childContextTypes: !0,
    contextType: !0,
    contextTypes: !0,
    defaultProps: !0,
    displayName: !0,
    getDefaultProps: !0,
    getDerivedStateFromError: !0,
    getDerivedStateFromProps: !0,
    mixins: !0,
    propTypes: !0,
    type: !0
  }, t = {
    name: !0,
    length: !0,
    prototype: !0,
    caller: !0,
    callee: !0,
    arguments: !0,
    arity: !0
  }, n = {
    $$typeof: !0,
    render: !0,
    defaultProps: !0,
    displayName: !0,
    propTypes: !0
  }, r = {
    $$typeof: !0,
    compare: !0,
    defaultProps: !0,
    displayName: !0,
    propTypes: !0,
    type: !0
  }, s = {};
  s[i.ForwardRef] = n, s[i.Memo] = r;
  function o(k) {
    return i.isMemo(k) ? r : s[k.$$typeof] || e;
  }
  var l = Object.defineProperty, u = Object.getOwnPropertyNames, h = Object.getOwnPropertySymbols, f = Object.getOwnPropertyDescriptor, m = Object.getPrototypeOf, v = Object.prototype;
  function C(k, S, x) {
    if (typeof S != "string") {
      if (v) {
        var N = m(S);
        N && N !== v && C(k, N, x);
      }
      var y = u(S);
      h && (y = y.concat(h(S)));
      for (var A = o(k), P = o(S), E = 0; E < y.length; ++E) {
        var V = y[E];
        if (!t[V] && !(x && x[V]) && !(P && P[V]) && !(A && A[V])) {
          var j = f(S, V);
          try {
            l(k, V, j);
          } catch {
          }
        }
      }
    }
    return k;
  }
  return rm = C, rm;
}
var av;
function j0() {
  if (av)
    return Tu;
  av = 1, Object.defineProperty(Tu, "__esModule", { value: !0 });
  var i = Dd();
  function e(r) {
    return r && r.__esModule ? r : { default: r };
  }
  var t = /* @__PURE__ */ e(i), n = function(r, s) {
    return t.default(r, s);
  };
  return Tu.default = n, Tu;
}
var or = {}, F5 = {
  get exports() {
    return or;
  },
  set exports(i) {
    or = i;
  }
}, vo = {}, lv;
function $5() {
  if (lv)
    return vo;
  lv = 1, Object.defineProperty(vo, "__esModule", { value: !0 });
  var i = typeof document < "u";
  function e(r, s, o) {
    var l = "";
    return o.split(" ").forEach(function(u) {
      r[u] !== void 0 ? s.push(r[u] + ";") : l += u + " ";
    }), l;
  }
  var t = function(s, o, l) {
    var u = s.key + "-" + o.name;
    // we only need to add the styles to the registered cache if the
    // class name could be used further down
    // the tree but if it's a string tag, we know it won't
    // so we don't have to add it to registered cache.
    // this improves memory usage since we can avoid storing the whole style string
    (l === !1 || // we need to always store it if we're in compat mode and
    // in node since emotion-server relies on whether a style is in
    // the registered cache to know whether a style is global or not
    // also, note that this check will be dead code eliminated in the browser
    i === !1 && s.compat !== void 0) && s.registered[u] === void 0 && (s.registered[u] = o.styles);
  }, n = function(s, o, l) {
    t(s, o, l);
    var u = s.key + "-" + o.name;
    if (s.inserted[o.name] === void 0) {
      var h = "", f = o;
      do {
        var m = s.insert(o === f ? "." + u : "", f, s.sheet, !0);
        !i && m !== void 0 && (h += m), f = f.next;
      } while (f !== void 0);
      if (!i && h.length !== 0)
        return h;
    }
  };
  return vo.getRegisteredStyles = e, vo.insertStyles = n, vo.registerStyles = t, vo;
}
var wo = {}, cv;
function z5() {
  if (cv)
    return wo;
  cv = 1, Object.defineProperty(wo, "__esModule", { value: !0 });
  var i = typeof document < "u";
  function e(r, s, o) {
    var l = "";
    return o.split(" ").forEach(function(u) {
      r[u] !== void 0 ? s.push(r[u] + ";") : l += u + " ";
    }), l;
  }
  var t = function(s, o, l) {
    var u = s.key + "-" + o.name;
    // we only need to add the styles to the registered cache if the
    // class name could be used further down
    // the tree but if it's a string tag, we know it won't
    // so we don't have to add it to registered cache.
    // this improves memory usage since we can avoid storing the whole style string
    (l === !1 || // we need to always store it if we're in compat mode and
    // in node since emotion-server relies on whether a style is in
    // the registered cache to know whether a style is global or not
    // also, note that this check will be dead code eliminated in the browser
    i === !1 && s.compat !== void 0) && s.registered[u] === void 0 && (s.registered[u] = o.styles);
  }, n = function(s, o, l) {
    t(s, o, l);
    var u = s.key + "-" + o.name;
    if (s.inserted[o.name] === void 0) {
      var h = "", f = o;
      do {
        var m = s.insert(o === f ? "." + u : "", f, s.sheet, !0);
        !i && m !== void 0 && (h += m), f = f.next;
      } while (f !== void 0);
      if (!i && h.length !== 0)
        return h;
    }
  };
  return wo.getRegisteredStyles = e, wo.insertStyles = n, wo.registerStyles = t, wo;
}
(function(i) {
  process.env.NODE_ENV === "production" ? i.exports = $5() : i.exports = z5();
})(F5);
var ts = {}, W5 = {
  get exports() {
    return ts;
  },
  set exports(i) {
    ts = i;
  }
}, xu = {}, md = {}, j5 = {
  get exports() {
    return md;
  },
  set exports(i) {
    md = i;
  }
}, ku = {}, uv;
function U5() {
  if (uv)
    return ku;
  uv = 1, Object.defineProperty(ku, "__esModule", { value: !0 });
  function i(e) {
    for (var t = 0, n, r = 0, s = e.length; s >= 4; ++r, s -= 4)
      n = e.charCodeAt(r) & 255 | (e.charCodeAt(++r) & 255) << 8 | (e.charCodeAt(++r) & 255) << 16 | (e.charCodeAt(++r) & 255) << 24, n = /* Math.imul(k, m): */
      (n & 65535) * 1540483477 + ((n >>> 16) * 59797 << 16), n ^= /* k >>> r: */
      n >>> 24, t = /* Math.imul(k, m): */
      (n & 65535) * 1540483477 + ((n >>> 16) * 59797 << 16) ^ /* Math.imul(h, m): */
      (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16);
    switch (s) {
      case 3:
        t ^= (e.charCodeAt(r + 2) & 255) << 16;
      case 2:
        t ^= (e.charCodeAt(r + 1) & 255) << 8;
      case 1:
        t ^= e.charCodeAt(r) & 255, t = /* Math.imul(h, m): */
        (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16);
    }
    return t ^= t >>> 13, t = /* Math.imul(h, m): */
    (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16), ((t ^ t >>> 15) >>> 0).toString(36);
  }
  return ku.default = i, ku;
}
var Au = {}, dv;
function H5() {
  if (dv)
    return Au;
  dv = 1, Object.defineProperty(Au, "__esModule", { value: !0 });
  function i(e) {
    for (var t = 0, n, r = 0, s = e.length; s >= 4; ++r, s -= 4)
      n = e.charCodeAt(r) & 255 | (e.charCodeAt(++r) & 255) << 8 | (e.charCodeAt(++r) & 255) << 16 | (e.charCodeAt(++r) & 255) << 24, n = /* Math.imul(k, m): */
      (n & 65535) * 1540483477 + ((n >>> 16) * 59797 << 16), n ^= /* k >>> r: */
      n >>> 24, t = /* Math.imul(k, m): */
      (n & 65535) * 1540483477 + ((n >>> 16) * 59797 << 16) ^ /* Math.imul(h, m): */
      (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16);
    switch (s) {
      case 3:
        t ^= (e.charCodeAt(r + 2) & 255) << 16;
      case 2:
        t ^= (e.charCodeAt(r + 1) & 255) << 8;
      case 1:
        t ^= e.charCodeAt(r) & 255, t = /* Math.imul(h, m): */
        (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16);
    }
    return t ^= t >>> 13, t = /* Math.imul(h, m): */
    (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16), ((t ^ t >>> 15) >>> 0).toString(36);
  }
  return Au.default = i, Au;
}
var hv;
function U0() {
  return hv || (hv = 1, function(i) {
    process.env.NODE_ENV === "production" ? i.exports = U5() : i.exports = H5();
  }(j5)), md;
}
var gd = {}, q5 = {
  get exports() {
    return gd;
  },
  set exports(i) {
    gd = i;
  }
}, Pu = {}, fv;
function K5() {
  if (fv)
    return Pu;
  fv = 1, Object.defineProperty(Pu, "__esModule", { value: !0 });
  var i = {
    animationIterationCount: 1,
    borderImageOutset: 1,
    borderImageSlice: 1,
    borderImageWidth: 1,
    boxFlex: 1,
    boxFlexGroup: 1,
    boxOrdinalGroup: 1,
    columnCount: 1,
    columns: 1,
    flex: 1,
    flexGrow: 1,
    flexPositive: 1,
    flexShrink: 1,
    flexNegative: 1,
    flexOrder: 1,
    gridRow: 1,
    gridRowEnd: 1,
    gridRowSpan: 1,
    gridRowStart: 1,
    gridColumn: 1,
    gridColumnEnd: 1,
    gridColumnSpan: 1,
    gridColumnStart: 1,
    msGridRow: 1,
    msGridRowSpan: 1,
    msGridColumn: 1,
    msGridColumnSpan: 1,
    fontWeight: 1,
    lineHeight: 1,
    opacity: 1,
    order: 1,
    orphans: 1,
    tabSize: 1,
    widows: 1,
    zIndex: 1,
    zoom: 1,
    WebkitLineClamp: 1,
    // SVG-related properties
    fillOpacity: 1,
    floodOpacity: 1,
    stopOpacity: 1,
    strokeDasharray: 1,
    strokeDashoffset: 1,
    strokeMiterlimit: 1,
    strokeOpacity: 1,
    strokeWidth: 1
  };
  return Pu.default = i, Pu;
}
var Iu = {}, mv;
function G5() {
  if (mv)
    return Iu;
  mv = 1, Object.defineProperty(Iu, "__esModule", { value: !0 });
  var i = {
    animationIterationCount: 1,
    borderImageOutset: 1,
    borderImageSlice: 1,
    borderImageWidth: 1,
    boxFlex: 1,
    boxFlexGroup: 1,
    boxOrdinalGroup: 1,
    columnCount: 1,
    columns: 1,
    flex: 1,
    flexGrow: 1,
    flexPositive: 1,
    flexShrink: 1,
    flexNegative: 1,
    flexOrder: 1,
    gridRow: 1,
    gridRowEnd: 1,
    gridRowSpan: 1,
    gridRowStart: 1,
    gridColumn: 1,
    gridColumnEnd: 1,
    gridColumnSpan: 1,
    gridColumnStart: 1,
    msGridRow: 1,
    msGridRowSpan: 1,
    msGridColumn: 1,
    msGridColumnSpan: 1,
    fontWeight: 1,
    lineHeight: 1,
    opacity: 1,
    order: 1,
    orphans: 1,
    tabSize: 1,
    widows: 1,
    zIndex: 1,
    zoom: 1,
    WebkitLineClamp: 1,
    // SVG-related properties
    fillOpacity: 1,
    floodOpacity: 1,
    stopOpacity: 1,
    strokeDasharray: 1,
    strokeDashoffset: 1,
    strokeMiterlimit: 1,
    strokeOpacity: 1,
    strokeWidth: 1
  };
  return Iu.default = i, Iu;
}
var gv;
function H0() {
  return gv || (gv = 1, function(i) {
    process.env.NODE_ENV === "production" ? i.exports = K5() : i.exports = G5();
  }(q5)), gd;
}
var pv;
function Y5() {
  if (pv)
    return xu;
  pv = 1, Object.defineProperty(xu, "__esModule", { value: !0 });
  var i = U0(), e = H0(), t = Al();
  function n(A) {
    return A && A.__esModule ? A : { default: A };
  }
  var r = /* @__PURE__ */ n(i), s = /* @__PURE__ */ n(e), o = /* @__PURE__ */ n(t), l = /[A-Z]|^ms/g, u = /_EMO_([^_]+?)_([^]*?)_EMO_/g, h = function(P) {
    return P.charCodeAt(1) === 45;
  }, f = function(P) {
    return P != null && typeof P != "boolean";
  }, m = /* @__PURE__ */ o.default(function(A) {
    return h(A) ? A : A.replace(l, "-$&").toLowerCase();
  }), v = function(P, E) {
    switch (P) {
      case "animation":
      case "animationName":
        if (typeof E == "string")
          return E.replace(u, function(V, j, U) {
            return N = {
              name: j,
              styles: U,
              next: N
            }, j;
          });
    }
    return s.default[P] !== 1 && !h(P) && typeof E == "number" && E !== 0 ? E + "px" : E;
  }, C = "Component selectors can only be used in conjunction with @emotion/babel-plugin, the swc Emotion plugin, or another Emotion-aware compiler transform.";
  function k(A, P, E) {
    if (E == null)
      return "";
    if (E.__emotion_styles !== void 0)
      return E;
    switch (typeof E) {
      case "boolean":
        return "";
      case "object": {
        if (E.anim === 1)
          return N = {
            name: E.name,
            styles: E.styles,
            next: N
          }, E.name;
        if (E.styles !== void 0) {
          var V = E.next;
          if (V !== void 0)
            for (; V !== void 0; )
              N = {
                name: V.name,
                styles: V.styles,
                next: N
              }, V = V.next;
          var j = E.styles + ";";
          return j;
        }
        return S(A, P, E);
      }
      case "function": {
        if (A !== void 0) {
          var U = N, $ = E(A);
          return N = U, k(A, P, $);
        }
        break;
      }
    }
    if (P == null)
      return E;
    var M = P[E];
    return M !== void 0 ? M : E;
  }
  function S(A, P, E) {
    var V = "";
    if (Array.isArray(E))
      for (var j = 0; j < E.length; j++)
        V += k(A, P, E[j]) + ";";
    else
      for (var U in E) {
        var $ = E[U];
        if (typeof $ != "object")
          P != null && P[$] !== void 0 ? V += U + "{" + P[$] + "}" : f($) && (V += m(U) + ":" + v(U, $) + ";");
        else if (Array.isArray($) && typeof $[0] == "string" && (P == null || P[$[0]] === void 0))
          for (var M = 0; M < $.length; M++)
            f($[M]) && (V += m(U) + ":" + v(U, $[M]) + ";");
        else {
          var D = k(A, P, $);
          switch (U) {
            case "animation":
            case "animationName": {
              V += m(U) + ":" + D + ";";
              break;
            }
            default:
              V += U + "{" + D + "}";
          }
        }
      }
    return V;
  }
  var x = /label:\s*([^\s;\n{]+)\s*(;|$)/g, N, y = function(P, E, V) {
    if (P.length === 1 && typeof P[0] == "object" && P[0] !== null && P[0].styles !== void 0)
      return P[0];
    var j = !0, U = "";
    N = void 0;
    var $ = P[0];
    $ == null || $.raw === void 0 ? (j = !1, U += k(V, E, $)) : U += $[0];
    for (var M = 1; M < P.length; M++)
      U += k(V, E, P[M]), j && (U += $[M]);
    x.lastIndex = 0;
    for (var D = "", J; (J = x.exec(U)) !== null; )
      D += "-" + // $FlowFixMe we know it's not null
      J[1];
    var H = r.default(U) + D;
    return {
      name: H,
      styles: U,
      next: N
    };
  };
  return xu.serializeStyles = y, xu;
}
var Ru = {}, _v;
function J5() {
  if (_v)
    return Ru;
  _v = 1, Object.defineProperty(Ru, "__esModule", { value: !0 });
  var i = U0(), e = H0(), t = Al();
  function n(J) {
    return J && J.__esModule ? J : { default: J };
  }
  var r = /* @__PURE__ */ n(i), s = /* @__PURE__ */ n(e), o = /* @__PURE__ */ n(t), l = `You have illegal escape sequence in your template literal, most likely inside content's property value.
Because you write your CSS inside a JavaScript string you actually have to do double escaping, so for example "content: '\\00d7';" should become "content: '\\\\00d7';".
You can read more about this here:
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#ES2018_revision_of_illegal_escape_sequences`, u = "You have passed in falsy value as style object's key (can happen when in example you pass unexported component as computed key).", h = /[A-Z]|^ms/g, f = /_EMO_([^_]+?)_([^]*?)_EMO_/g, m = function(H) {
    return H.charCodeAt(1) === 45;
  }, v = function(H) {
    return H != null && typeof H != "boolean";
  }, C = /* @__PURE__ */ o.default(function(J) {
    return m(J) ? J : J.replace(h, "-$&").toLowerCase();
  }), k = function(H, Y) {
    switch (H) {
      case "animation":
      case "animationName":
        if (typeof Y == "string")
          return Y.replace(f, function(le, me, ee) {
            return M = {
              name: me,
              styles: ee,
              next: M
            }, me;
          });
    }
    return s.default[H] !== 1 && !m(H) && typeof Y == "number" && Y !== 0 ? Y + "px" : Y;
  };
  if (process.env.NODE_ENV !== "production") {
    var S = /(var|attr|counters?|url|element|(((repeating-)?(linear|radial))|conic)-gradient)\(|(no-)?(open|close)-quote/, x = ["normal", "none", "initial", "inherit", "unset"], N = k, y = /^-ms-/, A = /-(.)/g, P = {};
    k = function(H, Y) {
      if (H === "content" && (typeof Y != "string" || x.indexOf(Y) === -1 && !S.test(Y) && (Y.charAt(0) !== Y.charAt(Y.length - 1) || Y.charAt(0) !== '"' && Y.charAt(0) !== "'")))
        throw new Error("You seem to be using a value for 'content' without quotes, try replacing it with `content: '\"" + Y + "\"'`");
      var le = N(H, Y);
      return le !== "" && !m(H) && H.indexOf("-") !== -1 && P[H] === void 0 && (P[H] = !0, console.error("Using kebab-case for css properties in objects is not supported. Did you mean " + H.replace(y, "ms-").replace(A, function(me, ee) {
        return ee.toUpperCase();
      }) + "?")), le;
    };
  }
  var E = "Component selectors can only be used in conjunction with @emotion/babel-plugin, the swc Emotion plugin, or another Emotion-aware compiler transform.";
  function V(J, H, Y) {
    if (Y == null)
      return "";
    if (Y.__emotion_styles !== void 0) {
      if (process.env.NODE_ENV !== "production" && Y.toString() === "NO_COMPONENT_SELECTOR")
        throw new Error(E);
      return Y;
    }
    switch (typeof Y) {
      case "boolean":
        return "";
      case "object": {
        if (Y.anim === 1)
          return M = {
            name: Y.name,
            styles: Y.styles,
            next: M
          }, Y.name;
        if (Y.styles !== void 0) {
          var le = Y.next;
          if (le !== void 0)
            for (; le !== void 0; )
              M = {
                name: le.name,
                styles: le.styles,
                next: M
              }, le = le.next;
          var me = Y.styles + ";";
          return process.env.NODE_ENV !== "production" && Y.map !== void 0 && (me += Y.map), me;
        }
        return j(J, H, Y);
      }
      case "function": {
        if (J !== void 0) {
          var ee = M, te = Y(J);
          return M = ee, V(J, H, te);
        } else
          process.env.NODE_ENV !== "production" && console.error("Functions that are interpolated in css calls will be stringified.\nIf you want to have a css call based on props, create a function that returns a css call like this\nlet dynamicStyle = (props) => css`color: ${props.color}`\nIt can be called directly with props or interpolated in a styled call like this\nlet SomeComponent = styled('div')`${dynamicStyle}`");
        break;
      }
      case "string":
        if (process.env.NODE_ENV !== "production") {
          var ne = [], z = Y.replace(f, function(ve, ue, ce) {
            var he = "animation" + ne.length;
            return ne.push("const " + he + " = keyframes`" + ce.replace(/^@keyframes animation-\w+/, "") + "`"), "${" + he + "}";
          });
          ne.length && console.error("`keyframes` output got interpolated into plain string, please wrap it with `css`.\n\nInstead of doing this:\n\n" + [].concat(ne, ["`" + z + "`"]).join(`
`) + `

You should wrap it with \`css\` like this:

` + ("css`" + z + "`"));
        }
        break;
    }
    if (H == null)
      return Y;
    var se = H[Y];
    return se !== void 0 ? se : Y;
  }
  function j(J, H, Y) {
    var le = "";
    if (Array.isArray(Y))
      for (var me = 0; me < Y.length; me++)
        le += V(J, H, Y[me]) + ";";
    else
      for (var ee in Y) {
        var te = Y[ee];
        if (typeof te != "object")
          H != null && H[te] !== void 0 ? le += ee + "{" + H[te] + "}" : v(te) && (le += C(ee) + ":" + k(ee, te) + ";");
        else {
          if (ee === "NO_COMPONENT_SELECTOR" && process.env.NODE_ENV !== "production")
            throw new Error(E);
          if (Array.isArray(te) && typeof te[0] == "string" && (H == null || H[te[0]] === void 0))
            for (var ne = 0; ne < te.length; ne++)
              v(te[ne]) && (le += C(ee) + ":" + k(ee, te[ne]) + ";");
          else {
            var z = V(J, H, te);
            switch (ee) {
              case "animation":
              case "animationName": {
                le += C(ee) + ":" + z + ";";
                break;
              }
              default:
                process.env.NODE_ENV !== "production" && ee === "undefined" && console.error(u), le += ee + "{" + z + "}";
            }
          }
        }
      }
    return le;
  }
  var U = /label:\s*([^\s;\n{]+)\s*(;|$)/g, $;
  process.env.NODE_ENV !== "production" && ($ = /\/\*#\ssourceMappingURL=data:application\/json;\S+\s+\*\//g);
  var M, D = function(H, Y, le) {
    if (H.length === 1 && typeof H[0] == "object" && H[0] !== null && H[0].styles !== void 0)
      return H[0];
    var me = !0, ee = "";
    M = void 0;
    var te = H[0];
    te == null || te.raw === void 0 ? (me = !1, ee += V(le, Y, te)) : (process.env.NODE_ENV !== "production" && te[0] === void 0 && console.error(l), ee += te[0]);
    for (var ne = 1; ne < H.length; ne++)
      ee += V(le, Y, H[ne]), me && (process.env.NODE_ENV !== "production" && te[ne] === void 0 && console.error(l), ee += te[ne]);
    var z;
    process.env.NODE_ENV !== "production" && (ee = ee.replace($, function(ce) {
      return z = ce, "";
    })), U.lastIndex = 0;
    for (var se = "", ve; (ve = U.exec(ee)) !== null; )
      se += "-" + // $FlowFixMe we know it's not null
      ve[1];
    var ue = r.default(ee) + se;
    return process.env.NODE_ENV !== "production" ? {
      name: ue,
      styles: ee,
      map: z,
      next: M,
      toString: function() {
        return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop).";
      }
    } : {
      name: ue,
      styles: ee,
      next: M
    };
  };
  return Ru.serializeStyles = D, Ru;
}
(function(i) {
  process.env.NODE_ENV === "production" ? i.exports = Y5() : i.exports = J5();
})(W5);
var pd = {}, X5 = {
  get exports() {
    return pd;
  },
  set exports(i) {
    pd = i;
  }
}, ja = {}, vv;
function Z5() {
  if (vv)
    return ja;
  vv = 1, Object.defineProperty(ja, "__esModule", { value: !0 });
  var i = mi;
  function e(u) {
    if (u && u.__esModule)
      return u;
    var h = /* @__PURE__ */ Object.create(null);
    return u && Object.keys(u).forEach(function(f) {
      if (f !== "default") {
        var m = Object.getOwnPropertyDescriptor(u, f);
        Object.defineProperty(h, f, m.get ? m : {
          enumerable: !0,
          get: function() {
            return u[f];
          }
        });
      }
    }), h.default = u, Object.freeze(h);
  }
  var t = /* @__PURE__ */ e(i), n = typeof document < "u", r = function(h) {
    return h();
  }, s = t["useInsertionEffect"] ? t["useInsertionEffect"] : !1, o = n && s || r, l = s || i.useLayoutEffect;
  return ja.useInsertionEffectAlwaysWithSyncFallback = o, ja.useInsertionEffectWithLayoutFallback = l, ja;
}
var Ua = {}, wv;
function Q5() {
  if (wv)
    return Ua;
  wv = 1, Object.defineProperty(Ua, "__esModule", { value: !0 });
  var i = mi;
  function e(u) {
    if (u && u.__esModule)
      return u;
    var h = /* @__PURE__ */ Object.create(null);
    return u && Object.keys(u).forEach(function(f) {
      if (f !== "default") {
        var m = Object.getOwnPropertyDescriptor(u, f);
        Object.defineProperty(h, f, m.get ? m : {
          enumerable: !0,
          get: function() {
            return u[f];
          }
        });
      }
    }), h.default = u, Object.freeze(h);
  }
  var t = /* @__PURE__ */ e(i), n = typeof document < "u", r = function(h) {
    return h();
  }, s = t["useInsertionEffect"] ? t["useInsertionEffect"] : !1, o = n && s || r, l = s || i.useLayoutEffect;
  return Ua.useInsertionEffectAlwaysWithSyncFallback = o, Ua.useInsertionEffectWithLayoutFallback = l, Ua;
}
var bv;
function Pl() {
  return bv || (bv = 1, function(i) {
    process.env.NODE_ENV === "production" ? i.exports = Z5() : i.exports = Q5();
  }(X5)), pd;
}
var yv;
function eI() {
  return yv || (yv = 1, function(i) {
    var e = mi, t = Vo, n = kl(), r = Jo(), s = j0(), o = or, l = ts, u = Pl();
    function h(D) {
      return D && D.__esModule ? D : { default: D };
    }
    var f = /* @__PURE__ */ h(t), m = /* @__PURE__ */ h(r), v = typeof document < "u", C = {}.hasOwnProperty, k = /* @__PURE__ */ e.createContext(
      // we're doing this to avoid preconstruct's dead code elimination in this one case
      // because this module is primarily intended for the browser and node
      // but it's also required in react native and similar environments sometimes
      // and we could have a special build just for that
      // but this is much easier and the native packages
      // might use a different theme context in the future anyway
      typeof HTMLElement < "u" ? /* @__PURE__ */ f.default({
        key: "css"
      }) : null
    ), S = k.Provider, x = function() {
      return e.useContext(k);
    };
    i.withEmotionCache = function(J) {
      return /* @__PURE__ */ e.forwardRef(function(H, Y) {
        var le = e.useContext(k);
        return J(H, le, Y);
      });
    }, v || (i.withEmotionCache = function(J) {
      return function(H) {
        var Y = e.useContext(k);
        return Y === null ? (Y = f.default({
          key: "css"
        }), /* @__PURE__ */ e.createElement(k.Provider, {
          value: Y
        }, J(H, Y))) : J(H, Y);
      };
    });
    var N = /* @__PURE__ */ e.createContext({}), y = function() {
      return e.useContext(N);
    }, A = function(J, H) {
      if (typeof H == "function") {
        var Y = H(J);
        return Y;
      }
      return n({}, J, H);
    }, P = /* @__PURE__ */ m.default(function(D) {
      return m.default(function(J) {
        return A(D, J);
      });
    }), E = function(J) {
      var H = e.useContext(N);
      return J.theme !== H && (H = P(H)(J.theme)), /* @__PURE__ */ e.createElement(N.Provider, {
        value: H
      }, J.children);
    };
    function V(D) {
      var J = D.displayName || D.name || "Component", H = function(me, ee) {
        var te = e.useContext(N);
        return /* @__PURE__ */ e.createElement(D, n({
          theme: te,
          ref: ee
        }, me));
      }, Y = /* @__PURE__ */ e.forwardRef(H);
      return Y.displayName = "WithTheme(" + J + ")", s.default(Y, D);
    }
    var j = "__EMOTION_TYPE_PLEASE_DO_NOT_USE__", U = function(J, H) {
      var Y = {};
      for (var le in H)
        C.call(H, le) && (Y[le] = H[le]);
      return Y[j] = J, Y;
    }, $ = function(J) {
      var H = J.cache, Y = J.serialized, le = J.isStringTag;
      o.registerStyles(H, Y, le);
      var me = u.useInsertionEffectAlwaysWithSyncFallback(function() {
        return o.insertStyles(H, Y, le);
      });
      if (!v && me !== void 0) {
        for (var ee, te = Y.name, ne = Y.next; ne !== void 0; )
          te += " " + ne.name, ne = ne.next;
        return /* @__PURE__ */ e.createElement("style", (ee = {}, ee["data-emotion"] = H.key + " " + te, ee.dangerouslySetInnerHTML = {
          __html: me
        }, ee.nonce = H.sheet.nonce, ee));
      }
      return null;
    }, M = /* @__PURE__ */ i.withEmotionCache(function(D, J, H) {
      var Y = D.css;
      typeof Y == "string" && J.registered[Y] !== void 0 && (Y = J.registered[Y]);
      var le = D[j], me = [Y], ee = "";
      typeof D.className == "string" ? ee = o.getRegisteredStyles(J.registered, me, D.className) : D.className != null && (ee = D.className + " ");
      var te = l.serializeStyles(me, void 0, e.useContext(N));
      ee += J.key + "-" + te.name;
      var ne = {};
      for (var z in D)
        C.call(D, z) && z !== "css" && z !== j && (ne[z] = D[z]);
      return ne.ref = H, ne.className = ee, /* @__PURE__ */ e.createElement(e.Fragment, null, /* @__PURE__ */ e.createElement($, {
        cache: J,
        serialized: te,
        isStringTag: typeof le == "string"
      }), /* @__PURE__ */ e.createElement(le, ne));
    });
    i.CacheProvider = S, i.Emotion = M, i.ThemeContext = N, i.ThemeProvider = E, i.__unsafe_useEmotionCache = x, i.createEmotionProps = U, i.hasOwnProperty = C, i.isBrowser = v, i.useTheme = y, i.withTheme = V;
  }(im)), im;
}
var Ev;
function tI() {
  return Ev || (Ev = 1, function(i) {
    Object.defineProperty(i, "__esModule", { value: !0 });
    var e = mi, t = eI();
    kl(), Jo(), Dd(), j0();
    var n = or, r = ts, s = Pl(), o = function(S, x) {
      var N = arguments;
      if (x == null || !t.hasOwnProperty.call(x, "css"))
        return e.createElement.apply(void 0, N);
      var y = N.length, A = new Array(y);
      A[0] = t.Emotion, A[1] = t.createEmotionProps(S, x);
      for (var P = 2; P < y; P++)
        A[P] = N[P];
      return e.createElement.apply(null, A);
    }, l = /* @__PURE__ */ t.withEmotionCache(function(k, S) {
      var x = k.styles, N = r.serializeStyles([x], void 0, e.useContext(t.ThemeContext));
      if (!t.isBrowser) {
        for (var y, A = N.name, P = N.styles, E = N.next; E !== void 0; )
          A += " " + E.name, P += E.styles, E = E.next;
        var V = S.compat === !0, j = S.insert("", {
          name: A,
          styles: P
        }, S.sheet, V);
        return V ? null : /* @__PURE__ */ e.createElement("style", (y = {}, y["data-emotion"] = S.key + "-global " + A, y.dangerouslySetInnerHTML = {
          __html: j
        }, y.nonce = S.sheet.nonce, y));
      }
      var U = e.useRef();
      return s.useInsertionEffectWithLayoutFallback(function() {
        var $ = S.key + "-global", M = new S.sheet.constructor({
          key: $,
          nonce: S.sheet.nonce,
          container: S.sheet.container,
          speedy: S.sheet.isSpeedy
        }), D = !1, J = document.querySelector('style[data-emotion="' + $ + " " + N.name + '"]');
        return S.sheet.tags.length && (M.before = S.sheet.tags[0]), J !== null && (D = !0, J.setAttribute("data-emotion", $), M.hydrate([J])), U.current = [M, D], function() {
          M.flush();
        };
      }, [S]), s.useInsertionEffectWithLayoutFallback(function() {
        var $ = U.current, M = $[0], D = $[1];
        if (D) {
          $[1] = !1;
          return;
        }
        if (N.next !== void 0 && n.insertStyles(S, N.next, !0), M.tags.length) {
          var J = M.tags[M.tags.length - 1].nextElementSibling;
          M.before = J, M.flush();
        }
        S.insert("", N, M, !1);
      }, [S, N.name]), null;
    });
    function u() {
      for (var k = arguments.length, S = new Array(k), x = 0; x < k; x++)
        S[x] = arguments[x];
      return r.serializeStyles(S);
    }
    var h = function() {
      var S = u.apply(void 0, arguments), x = "animation-" + S.name;
      return {
        name: x,
        styles: "@keyframes " + x + "{" + S.styles + "}",
        anim: 1,
        toString: function() {
          return "_EMO_" + this.name + "_" + this.styles + "_EMO_";
        }
      };
    }, f = function k(S) {
      for (var x = S.length, N = 0, y = ""; N < x; N++) {
        var A = S[N];
        if (A != null) {
          var P = void 0;
          switch (typeof A) {
            case "boolean":
              break;
            case "object": {
              if (Array.isArray(A))
                P = k(A);
              else {
                P = "";
                for (var E in A)
                  A[E] && E && (P && (P += " "), P += E);
              }
              break;
            }
            default:
              P = A;
          }
          P && (y && (y += " "), y += P);
        }
      }
      return y;
    };
    function m(k, S, x) {
      var N = [], y = n.getRegisteredStyles(k, N, x);
      return N.length < 2 ? x : y + S(N);
    }
    var v = function(S) {
      var x = S.cache, N = S.serializedArr, y = s.useInsertionEffectAlwaysWithSyncFallback(function() {
        for (var P = "", E = 0; E < N.length; E++) {
          var V = n.insertStyles(x, N[E], !1);
          !t.isBrowser && V !== void 0 && (P += V);
        }
        if (!t.isBrowser)
          return P;
      });
      if (!t.isBrowser && y.length !== 0) {
        var A;
        return /* @__PURE__ */ e.createElement("style", (A = {}, A["data-emotion"] = x.key + " " + N.map(function(P) {
          return P.name;
        }).join(" "), A.dangerouslySetInnerHTML = {
          __html: y
        }, A.nonce = x.sheet.nonce, A));
      }
      return null;
    }, C = /* @__PURE__ */ t.withEmotionCache(function(k, S) {
      var x = !1, N = [], y = function() {
        for (var j = arguments.length, U = new Array(j), $ = 0; $ < j; $++)
          U[$] = arguments[$];
        var M = r.serializeStyles(U, S.registered);
        return N.push(M), n.registerStyles(S, M, !1), S.key + "-" + M.name;
      }, A = function() {
        for (var j = arguments.length, U = new Array(j), $ = 0; $ < j; $++)
          U[$] = arguments[$];
        return m(S.registered, y, f(U));
      }, P = {
        css: y,
        cx: A,
        theme: e.useContext(t.ThemeContext)
      }, E = k.children(P);
      return x = !0, /* @__PURE__ */ e.createElement(e.Fragment, null, /* @__PURE__ */ e.createElement(v, {
        cache: S,
        serializedArr: N
      }), E);
    });
    i.CacheProvider = t.CacheProvider, i.ThemeContext = t.ThemeContext, i.ThemeProvider = t.ThemeProvider, i.__unsafe_useEmotionCache = t.__unsafe_useEmotionCache, i.useTheme = t.useTheme, Object.defineProperty(i, "withEmotionCache", {
      enumerable: !0,
      get: function() {
        return t.withEmotionCache;
      }
    }), i.withTheme = t.withTheme, i.ClassNames = C, i.Global = l, i.createElement = o, i.css = u, i.jsx = o, i.keyframes = h;
  }(nm)), nm;
}
var sm = {}, om = {}, Ou = {}, Cv;
function q0() {
  if (Cv)
    return Ou;
  Cv = 1, Object.defineProperty(Ou, "__esModule", { value: !0 });
  var i = Dd();
  function e(r) {
    return r && r.__esModule ? r : { default: r };
  }
  var t = /* @__PURE__ */ e(i), n = function(r, s) {
    return t.default(r, s);
  };
  return Ou.default = n, Ou;
}
var Sv;
function nI() {
  return Sv || (Sv = 1, function(i) {
    var e = mi, t = Vo, n = kl(), r = Jo(), s = q0(), o = or, l = ts, u = Pl();
    function h(ee) {
      return ee && ee.__esModule ? ee : { default: ee };
    }
    var f = /* @__PURE__ */ h(t), m = /* @__PURE__ */ h(r), v = typeof document < "u", C = {}.hasOwnProperty, k = /* @__PURE__ */ e.createContext(
      // we're doing this to avoid preconstruct's dead code elimination in this one case
      // because this module is primarily intended for the browser and node
      // but it's also required in react native and similar environments sometimes
      // and we could have a special build just for that
      // but this is much easier and the native packages
      // might use a different theme context in the future anyway
      typeof HTMLElement < "u" ? /* @__PURE__ */ f.default({
        key: "css"
      }) : null
    );
    process.env.NODE_ENV !== "production" && (k.displayName = "EmotionCacheContext");
    var S = k.Provider, x = function() {
      return e.useContext(k);
    };
    i.withEmotionCache = function(te) {
      return /* @__PURE__ */ e.forwardRef(function(ne, z) {
        var se = e.useContext(k);
        return te(ne, se, z);
      });
    }, v || (i.withEmotionCache = function(te) {
      return function(ne) {
        var z = e.useContext(k);
        return z === null ? (z = f.default({
          key: "css"
        }), /* @__PURE__ */ e.createElement(k.Provider, {
          value: z
        }, te(ne, z))) : te(ne, z);
      };
    });
    var N = /* @__PURE__ */ e.createContext({});
    process.env.NODE_ENV !== "production" && (N.displayName = "EmotionThemeContext");
    var y = function() {
      return e.useContext(N);
    }, A = function(te, ne) {
      if (typeof ne == "function") {
        var z = ne(te);
        if (process.env.NODE_ENV !== "production" && (z == null || typeof z != "object" || Array.isArray(z)))
          throw new Error("[ThemeProvider] Please return an object from your theme function, i.e. theme={() => ({})}!");
        return z;
      }
      if (process.env.NODE_ENV !== "production" && (ne == null || typeof ne != "object" || Array.isArray(ne)))
        throw new Error("[ThemeProvider] Please make your theme prop a plain object");
      return n({}, te, ne);
    }, P = /* @__PURE__ */ m.default(function(ee) {
      return m.default(function(te) {
        return A(ee, te);
      });
    }), E = function(te) {
      var ne = e.useContext(N);
      return te.theme !== ne && (ne = P(ne)(te.theme)), /* @__PURE__ */ e.createElement(N.Provider, {
        value: ne
      }, te.children);
    };
    function V(ee) {
      var te = ee.displayName || ee.name || "Component", ne = function(ve, ue) {
        var ce = e.useContext(N);
        return /* @__PURE__ */ e.createElement(ee, n({
          theme: ce,
          ref: ue
        }, ve));
      }, z = /* @__PURE__ */ e.forwardRef(ne);
      return z.displayName = "WithTheme(" + te + ")", s.default(z, ee);
    }
    var j = function(te) {
      var ne = te.split(".");
      return ne[ne.length - 1];
    }, U = function(te) {
      var ne = /^\s+at\s+([A-Za-z0-9$.]+)\s/.exec(te);
      if (ne || (ne = /^([A-Za-z0-9$.]+)@/.exec(te), ne))
        return j(ne[1]);
    }, $ = /* @__PURE__ */ new Set(["renderWithHooks", "processChild", "finishClassComponent", "renderToString"]), M = function(te) {
      return te.replace(/\$/g, "-");
    }, D = function(te) {
      if (te)
        for (var ne = te.split(`
`), z = 0; z < ne.length; z++) {
          var se = U(ne[z]);
          if (se) {
            if ($.has(se))
              break;
            if (/^[A-Z]/.test(se))
              return M(se);
          }
        }
    }, J = "__EMOTION_TYPE_PLEASE_DO_NOT_USE__", H = "__EMOTION_LABEL_PLEASE_DO_NOT_USE__", Y = function(te, ne) {
      if (process.env.NODE_ENV !== "production" && typeof ne.css == "string" && // check if there is a css declaration
      ne.css.indexOf(":") !== -1)
        throw new Error("Strings are not allowed as css prop values, please wrap it in a css template literal from '@emotion/react' like this: css`" + ne.css + "`");
      var z = {};
      for (var se in ne)
        C.call(ne, se) && (z[se] = ne[se]);
      if (z[J] = te, process.env.NODE_ENV !== "production" && ne.css && (typeof ne.css != "object" || typeof ne.css.name != "string" || ne.css.name.indexOf("-") === -1)) {
        var ve = D(new Error().stack);
        ve && (z[H] = ve);
      }
      return z;
    }, le = function(te) {
      var ne = te.cache, z = te.serialized, se = te.isStringTag;
      o.registerStyles(ne, z, se);
      var ve = u.useInsertionEffectAlwaysWithSyncFallback(function() {
        return o.insertStyles(ne, z, se);
      });
      if (!v && ve !== void 0) {
        for (var ue, ce = z.name, he = z.next; he !== void 0; )
          ce += " " + he.name, he = he.next;
        return /* @__PURE__ */ e.createElement("style", (ue = {}, ue["data-emotion"] = ne.key + " " + ce, ue.dangerouslySetInnerHTML = {
          __html: ve
        }, ue.nonce = ne.sheet.nonce, ue));
      }
      return null;
    }, me = /* @__PURE__ */ i.withEmotionCache(function(ee, te, ne) {
      var z = ee.css;
      typeof z == "string" && te.registered[z] !== void 0 && (z = te.registered[z]);
      var se = ee[J], ve = [z], ue = "";
      typeof ee.className == "string" ? ue = o.getRegisteredStyles(te.registered, ve, ee.className) : ee.className != null && (ue = ee.className + " ");
      var ce = l.serializeStyles(ve, void 0, e.useContext(N));
      if (process.env.NODE_ENV !== "production" && ce.name.indexOf("-") === -1) {
        var he = ee[H];
        he && (ce = l.serializeStyles([ce, "label:" + he + ";"]));
      }
      ue += te.key + "-" + ce.name;
      var be = {};
      for (var Ee in ee)
        C.call(ee, Ee) && Ee !== "css" && Ee !== J && (process.env.NODE_ENV === "production" || Ee !== H) && (be[Ee] = ee[Ee]);
      return be.ref = ne, be.className = ue, /* @__PURE__ */ e.createElement(e.Fragment, null, /* @__PURE__ */ e.createElement(le, {
        cache: te,
        serialized: ce,
        isStringTag: typeof se == "string"
      }), /* @__PURE__ */ e.createElement(se, be));
    });
    process.env.NODE_ENV !== "production" && (me.displayName = "EmotionCssPropInternal"), i.CacheProvider = S, i.Emotion = me, i.ThemeContext = N, i.ThemeProvider = E, i.__unsafe_useEmotionCache = x, i.createEmotionProps = Y, i.hasOwnProperty = C, i.isBrowser = v, i.useTheme = y, i.withTheme = V;
  }(om)), om;
}
var Tv;
function iI() {
  return Tv || (Tv = 1, function(i) {
    Object.defineProperty(i, "__esModule", { value: !0 });
    var e = mi, t = nI();
    kl(), Jo(), Dd(), q0();
    var n = or, r = ts, s = Pl(), o = {
      name: "@emotion/react",
      version: "11.10.6",
      main: "dist/emotion-react.cjs.js",
      module: "dist/emotion-react.esm.js",
      browser: {
        "./dist/emotion-react.esm.js": "./dist/emotion-react.browser.esm.js"
      },
      exports: {
        ".": {
          module: {
            worker: "./dist/emotion-react.worker.esm.js",
            browser: "./dist/emotion-react.browser.esm.js",
            default: "./dist/emotion-react.esm.js"
          },
          default: "./dist/emotion-react.cjs.js"
        },
        "./jsx-runtime": {
          module: {
            worker: "./jsx-runtime/dist/emotion-react-jsx-runtime.worker.esm.js",
            browser: "./jsx-runtime/dist/emotion-react-jsx-runtime.browser.esm.js",
            default: "./jsx-runtime/dist/emotion-react-jsx-runtime.esm.js"
          },
          default: "./jsx-runtime/dist/emotion-react-jsx-runtime.cjs.js"
        },
        "./_isolated-hnrs": {
          module: {
            worker: "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.worker.esm.js",
            browser: "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.browser.esm.js",
            default: "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.esm.js"
          },
          default: "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.cjs.js"
        },
        "./jsx-dev-runtime": {
          module: {
            worker: "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.worker.esm.js",
            browser: "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.browser.esm.js",
            default: "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.esm.js"
          },
          default: "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.cjs.js"
        },
        "./package.json": "./package.json",
        "./types/css-prop": "./types/css-prop.d.ts",
        "./macro": "./macro.js"
      },
      types: "types/index.d.ts",
      files: [
        "src",
        "dist",
        "jsx-runtime",
        "jsx-dev-runtime",
        "_isolated-hnrs",
        "types/*.d.ts",
        "macro.js",
        "macro.d.ts",
        "macro.js.flow"
      ],
      sideEffects: !1,
      author: "Emotion Contributors",
      license: "MIT",
      scripts: {
        "test:typescript": "dtslint types"
      },
      dependencies: {
        "@babel/runtime": "^7.18.3",
        "@emotion/babel-plugin": "^11.10.6",
        "@emotion/cache": "^11.10.5",
        "@emotion/serialize": "^1.1.1",
        "@emotion/use-insertion-effect-with-fallbacks": "^1.0.0",
        "@emotion/utils": "^1.2.0",
        "@emotion/weak-memoize": "^0.3.0",
        "hoist-non-react-statics": "^3.3.1"
      },
      peerDependencies: {
        react: ">=16.8.0"
      },
      peerDependenciesMeta: {
        "@types/react": {
          optional: !0
        }
      },
      devDependencies: {
        "@definitelytyped/dtslint": "0.0.112",
        "@emotion/css": "11.10.6",
        "@emotion/css-prettifier": "1.1.1",
        "@emotion/server": "11.10.0",
        "@emotion/styled": "11.10.6",
        "html-tag-names": "^1.1.2",
        react: "16.14.0",
        "svg-tag-names": "^1.1.1",
        typescript: "^4.5.5"
      },
      repository: "https://github.com/emotion-js/emotion/tree/main/packages/react",
      publishConfig: {
        access: "public"
      },
      "umd:main": "dist/emotion-react.umd.min.js",
      preconstruct: {
        entrypoints: [
          "./index.js",
          "./jsx-runtime.js",
          "./jsx-dev-runtime.js",
          "./_isolated-hnrs.js"
        ],
        umdName: "emotionReact",
        exports: {
          envConditions: [
            "browser",
            "worker"
          ],
          extra: {
            "./types/css-prop": "./types/css-prop.d.ts",
            "./macro": "./macro.js"
          }
        }
      }
    }, l = function(E, V) {
      var j = arguments;
      if (V == null || !t.hasOwnProperty.call(V, "css"))
        return e.createElement.apply(void 0, j);
      var U = j.length, $ = new Array(U);
      $[0] = t.Emotion, $[1] = t.createEmotionProps(E, V);
      for (var M = 2; M < U; M++)
        $[M] = j[M];
      return e.createElement.apply(null, $);
    }, u = !1, h = /* @__PURE__ */ t.withEmotionCache(function(P, E) {
      process.env.NODE_ENV !== "production" && !u && // check for className as well since the user is
      // probably using the custom createElement which
      // means it will be turned into a className prop
      // $FlowFixMe I don't really want to add it to the type since it shouldn't be used
      (P.className || P.css) && (console.error("It looks like you're using the css prop on Global, did you mean to use the styles prop instead?"), u = !0);
      var V = P.styles, j = r.serializeStyles([V], void 0, e.useContext(t.ThemeContext));
      if (!t.isBrowser) {
        for (var U, $ = j.name, M = j.styles, D = j.next; D !== void 0; )
          $ += " " + D.name, M += D.styles, D = D.next;
        var J = E.compat === !0, H = E.insert("", {
          name: $,
          styles: M
        }, E.sheet, J);
        return J ? null : /* @__PURE__ */ e.createElement("style", (U = {}, U["data-emotion"] = E.key + "-global " + $, U.dangerouslySetInnerHTML = {
          __html: H
        }, U.nonce = E.sheet.nonce, U));
      }
      var Y = e.useRef();
      return s.useInsertionEffectWithLayoutFallback(function() {
        var le = E.key + "-global", me = new E.sheet.constructor({
          key: le,
          nonce: E.sheet.nonce,
          container: E.sheet.container,
          speedy: E.sheet.isSpeedy
        }), ee = !1, te = document.querySelector('style[data-emotion="' + le + " " + j.name + '"]');
        return E.sheet.tags.length && (me.before = E.sheet.tags[0]), te !== null && (ee = !0, te.setAttribute("data-emotion", le), me.hydrate([te])), Y.current = [me, ee], function() {
          me.flush();
        };
      }, [E]), s.useInsertionEffectWithLayoutFallback(function() {
        var le = Y.current, me = le[0], ee = le[1];
        if (ee) {
          le[1] = !1;
          return;
        }
        if (j.next !== void 0 && n.insertStyles(E, j.next, !0), me.tags.length) {
          var te = me.tags[me.tags.length - 1].nextElementSibling;
          me.before = te, me.flush();
        }
        E.insert("", j, me, !1);
      }, [E, j.name]), null;
    });
    process.env.NODE_ENV !== "production" && (h.displayName = "EmotionGlobal");
    function f() {
      for (var P = arguments.length, E = new Array(P), V = 0; V < P; V++)
        E[V] = arguments[V];
      return r.serializeStyles(E);
    }
    var m = function() {
      var E = f.apply(void 0, arguments), V = "animation-" + E.name;
      return {
        name: V,
        styles: "@keyframes " + V + "{" + E.styles + "}",
        anim: 1,
        toString: function() {
          return "_EMO_" + this.name + "_" + this.styles + "_EMO_";
        }
      };
    }, v = function P(E) {
      for (var V = E.length, j = 0, U = ""; j < V; j++) {
        var $ = E[j];
        if ($ != null) {
          var M = void 0;
          switch (typeof $) {
            case "boolean":
              break;
            case "object": {
              if (Array.isArray($))
                M = P($);
              else {
                process.env.NODE_ENV !== "production" && $.styles !== void 0 && $.name !== void 0 && console.error("You have passed styles created with `css` from `@emotion/react` package to the `cx`.\n`cx` is meant to compose class names (strings) so you should convert those styles to a class name by passing them to the `css` received from <ClassNames/> component."), M = "";
                for (var D in $)
                  $[D] && D && (M && (M += " "), M += D);
              }
              break;
            }
            default:
              M = $;
          }
          M && (U && (U += " "), U += M);
        }
      }
      return U;
    };
    function C(P, E, V) {
      var j = [], U = n.getRegisteredStyles(P, j, V);
      return j.length < 2 ? V : U + E(j);
    }
    var k = function(E) {
      var V = E.cache, j = E.serializedArr, U = s.useInsertionEffectAlwaysWithSyncFallback(function() {
        for (var M = "", D = 0; D < j.length; D++) {
          var J = n.insertStyles(V, j[D], !1);
          !t.isBrowser && J !== void 0 && (M += J);
        }
        if (!t.isBrowser)
          return M;
      });
      if (!t.isBrowser && U.length !== 0) {
        var $;
        return /* @__PURE__ */ e.createElement("style", ($ = {}, $["data-emotion"] = V.key + " " + j.map(function(M) {
          return M.name;
        }).join(" "), $.dangerouslySetInnerHTML = {
          __html: U
        }, $.nonce = V.sheet.nonce, $));
      }
      return null;
    }, S = /* @__PURE__ */ t.withEmotionCache(function(P, E) {
      var V = !1, j = [], U = function() {
        if (V && process.env.NODE_ENV !== "production")
          throw new Error("css can only be used during render");
        for (var H = arguments.length, Y = new Array(H), le = 0; le < H; le++)
          Y[le] = arguments[le];
        var me = r.serializeStyles(Y, E.registered);
        return j.push(me), n.registerStyles(E, me, !1), E.key + "-" + me.name;
      }, $ = function() {
        if (V && process.env.NODE_ENV !== "production")
          throw new Error("cx can only be used during render");
        for (var H = arguments.length, Y = new Array(H), le = 0; le < H; le++)
          Y[le] = arguments[le];
        return C(E.registered, U, v(Y));
      }, M = {
        css: U,
        cx: $,
        theme: e.useContext(t.ThemeContext)
      }, D = P.children(M);
      return V = !0, /* @__PURE__ */ e.createElement(e.Fragment, null, /* @__PURE__ */ e.createElement(k, {
        cache: E,
        serializedArr: j
      }), D);
    });
    if (process.env.NODE_ENV !== "production" && (S.displayName = "EmotionClassNames"), process.env.NODE_ENV !== "production") {
      var x = typeof document < "u", N = typeof jest < "u" || typeof vi < "u";
      if (x && !N) {
        var y = (
          // $FlowIgnore
          typeof globalThis < "u" ? globalThis : x ? window : et
        ), A = "__EMOTION_REACT_" + o.version.split(".")[0] + "__";
        y[A] && console.warn("You are loading @emotion/react when it is already loaded. Running multiple instances may cause problems. This can happen if multiple versions are used, or if multiple builds of the same version are used."), y[A] = !0;
      }
    }
    i.CacheProvider = t.CacheProvider, i.ThemeContext = t.ThemeContext, i.ThemeProvider = t.ThemeProvider, i.__unsafe_useEmotionCache = t.__unsafe_useEmotionCache, i.useTheme = t.useTheme, Object.defineProperty(i, "withEmotionCache", {
      enumerable: !0,
      get: function() {
        return t.withEmotionCache;
      }
    }), i.withTheme = t.withTheme, i.ClassNames = S, i.Global = h, i.createElement = l, i.css = f, i.jsx = l, i.keyframes = m;
  }(sm)), sm;
}
(function(i) {
  process.env.NODE_ENV === "production" ? i.exports = tI() : i.exports = iI();
})(C5);
var rI = Pl(), sI = E5, oI = function(e) {
  return e !== "theme";
}, xv = function(e) {
  return typeof e == "string" && // 96 is one less than the char code
  // for "a" so this is checking that
  // it's a lowercase character
  e.charCodeAt(0) > 96 ? sI : oI;
}, kv = function(e, t, n) {
  var r;
  if (t) {
    var s = t.shouldForwardProp;
    r = e.__emotion_forwardProp && s ? function(o) {
      return e.__emotion_forwardProp(o) && s(o);
    } : s;
  }
  return typeof r != "function" && n && (r = e.__emotion_forwardProp), r;
}, Av = `You have illegal escape sequence in your template literal, most likely inside content's property value.
Because you write your CSS inside a JavaScript string you actually have to do double escaping, so for example "content: '\\00d7';" should become "content: '\\\\00d7';".
You can read more about this here:
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#ES2018_revision_of_illegal_escape_sequences`, aI = function(e) {
  var t = e.cache, n = e.serialized, r = e.isStringTag;
  return or.registerStyles(t, n, r), rI.useInsertionEffectAlwaysWithSyncFallback(function() {
    return or.insertStyles(t, n, r);
  }), null;
}, lI = function i(e, t) {
  if (process.env.NODE_ENV !== "production" && e === void 0)
    throw new Error(`You are trying to create a styled element with an undefined component.
You may have forgotten to import it.`);
  var n = e.__emotion_real === e, r = n && e.__emotion_base || e, s, o;
  t !== void 0 && (s = t.label, o = t.target);
  var l = kv(e, t, n), u = l || xv(r), h = !u("as");
  return function() {
    var f = arguments, m = n && e.__emotion_styles !== void 0 ? e.__emotion_styles.slice(0) : [];
    if (s !== void 0 && m.push("label:" + s + ";"), f[0] == null || f[0].raw === void 0)
      m.push.apply(m, f);
    else {
      process.env.NODE_ENV !== "production" && f[0][0] === void 0 && console.error(Av), m.push(f[0][0]);
      for (var v = f.length, C = 1; C < v; C++)
        process.env.NODE_ENV !== "production" && f[0][C] === void 0 && console.error(Av), m.push(f[C], f[0][C]);
    }
    var k = Fi.withEmotionCache(function(S, x, N) {
      var y = h && S.as || r, A = "", P = [], E = S;
      if (S.theme == null) {
        E = {};
        for (var V in S)
          E[V] = S[V];
        E.theme = zP(Fi.ThemeContext);
      }
      typeof S.className == "string" ? A = or.getRegisteredStyles(x.registered, P, S.className) : S.className != null && (A = S.className + " ");
      var j = ts.serializeStyles(m.concat(P), x.registered, E);
      A += x.key + "-" + j.name, o !== void 0 && (A += " " + o);
      var U = h && l === void 0 ? xv(y) : u, $ = {};
      for (var M in S)
        h && M === "as" || // $FlowFixMe
        U(M) && ($[M] = S[M]);
      return $.className = A, $.ref = N, /* @__PURE__ */ Yf(WP, null, /* @__PURE__ */ Yf(aI, {
        cache: x,
        serialized: j,
        isStringTag: typeof y == "string"
      }), /* @__PURE__ */ Yf(y, $));
    });
    return k.displayName = s !== void 0 ? s : "Styled(" + (typeof r == "string" ? r : r.displayName || r.name || "Component") + ")", k.defaultProps = e.defaultProps, k.__emotion_real = k, k.__emotion_base = r, k.__emotion_styles = m, k.__emotion_forwardProp = l, Object.defineProperty(k, "toString", {
      value: function() {
        return o === void 0 && process.env.NODE_ENV !== "production" ? "NO_COMPONENT_SELECTOR" : "." + o;
      }
    }), k.withComponent = function(S, x) {
      return i(S, Ae({}, t, x, {
        shouldForwardProp: kv(k, x, !0)
      })).apply(void 0, m);
    }, k;
  };
};
const cI = lI;
var uI = [
  "a",
  "abbr",
  "address",
  "area",
  "article",
  "aside",
  "audio",
  "b",
  "base",
  "bdi",
  "bdo",
  "big",
  "blockquote",
  "body",
  "br",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "col",
  "colgroup",
  "data",
  "datalist",
  "dd",
  "del",
  "details",
  "dfn",
  "dialog",
  "div",
  "dl",
  "dt",
  "em",
  "embed",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hgroup",
  "hr",
  "html",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "keygen",
  "label",
  "legend",
  "li",
  "link",
  "main",
  "map",
  "mark",
  "marquee",
  "menu",
  "menuitem",
  "meta",
  "meter",
  "nav",
  "noscript",
  "object",
  "ol",
  "optgroup",
  "option",
  "output",
  "p",
  "param",
  "picture",
  "pre",
  "progress",
  "q",
  "rp",
  "rt",
  "ruby",
  "s",
  "samp",
  "script",
  "section",
  "select",
  "small",
  "source",
  "span",
  "strong",
  "style",
  "sub",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "time",
  "title",
  "tr",
  "track",
  "u",
  "ul",
  "var",
  "video",
  "wbr",
  // SVG
  "circle",
  "clipPath",
  "defs",
  "ellipse",
  "foreignObject",
  "g",
  "image",
  "line",
  "linearGradient",
  "mask",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "radialGradient",
  "rect",
  "stop",
  "svg",
  "text",
  "tspan"
], Hm = cI.bind();
uI.forEach(function(i) {
  Hm[i] = Hm(i);
});
const dI = Hm, hI = N5({
  key: "css",
  prepend: !0
});
function K0(i) {
  const {
    injectFirst: e,
    children: t
  } = i;
  return e ? /* @__PURE__ */ Jn(Fi.CacheProvider, {
    value: hI,
    children: t
  }) : t;
}
process.env.NODE_ENV !== "production" && (K0.propTypes = {
  /**
   * Your component tree.
   */
  children: Ue.node,
  /**
   * By default, the styles are injected last in the <head> element of the page.
   * As a result, they gain more specificity than any other style sheet.
   * If you want to override MUI's styles, set this prop.
   */
  injectFirst: Ue.bool
});
function fI(i) {
  return i == null || Object.keys(i).length === 0;
}
function Yu(i) {
  const {
    styles: e,
    defaultTheme: t = {}
  } = i, n = typeof e == "function" ? (r) => e(fI(r) ? t : r) : e;
  return /* @__PURE__ */ Jn(Fi.Global, {
    styles: n
  });
}
process.env.NODE_ENV !== "production" && (Yu.propTypes = {
  defaultTheme: Ue.object,
  styles: Ue.oneOfType([Ue.string, Ue.object, Ue.func])
});
/** @license MUI v5.11.0
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
function mI(i, e) {
  const t = dI(i, e);
  return process.env.NODE_ENV !== "production" ? (...n) => {
    const r = typeof i == "string" ? `"${i}"` : "component";
    return n.length === 0 ? console.error([`MUI: Seems like you called \`styled(${r})()\` without a \`style\` argument.`, 'You must provide a `styles` argument: `styled("div")(styleYouForgotToPass)`.'].join(`
`)) : n.some((s) => s === void 0) && console.error(`MUI: the styled(${r})(...args) API requires all its args to be defined.`), t(...n);
  } : t;
}
const gI = (i, e) => {
  Array.isArray(i.__emotion_styles) && (i.__emotion_styles = e(i.__emotion_styles));
}, pI = process.env.NODE_ENV !== "production" ? Ue.oneOfType([Ue.number, Ue.string, Ue.object, Ue.array]) : {}, ss = pI;
function ll(i, e) {
  return e ? ki(i, e, {
    clone: !1
    // No need to clone deep, it's way faster.
  }) : i;
}
const Pg = {
  xs: 0,
  // phone
  sm: 600,
  // tablet
  md: 900,
  // small laptop
  lg: 1200,
  // desktop
  xl: 1536
  // large screen
}, Pv = {
  // Sorted ASC by size. That's important.
  // It can't be configured as it's used statically for propTypes.
  keys: ["xs", "sm", "md", "lg", "xl"],
  up: (i) => `@media (min-width:${Pg[i]}px)`
};
function Pr(i, e, t) {
  const n = i.theme || {};
  if (Array.isArray(e)) {
    const s = n.breakpoints || Pv;
    return e.reduce((o, l, u) => (o[s.up(s.keys[u])] = t(e[u]), o), {});
  }
  if (typeof e == "object") {
    const s = n.breakpoints || Pv;
    return Object.keys(e).reduce((o, l) => {
      if (Object.keys(s.values || Pg).indexOf(l) !== -1) {
        const u = s.up(l);
        o[u] = t(e[l], l);
      } else {
        const u = l;
        o[u] = e[u];
      }
      return o;
    }, {});
  }
  return t(e);
}
function _I(i = {}) {
  var e;
  return ((e = i.keys) == null ? void 0 : e.reduce((n, r) => {
    const s = i.up(r);
    return n[s] = {}, n;
  }, {})) || {};
}
function vI(i, e) {
  return i.reduce((t, n) => {
    const r = t[n];
    return (!r || Object.keys(r).length === 0) && delete t[n], t;
  }, e);
}
function Bd(i, e, t = !0) {
  if (!e || typeof e != "string")
    return null;
  if (i && i.vars && t) {
    const n = `vars.${e}`.split(".").reduce((r, s) => r && r[s] ? r[s] : null, i);
    if (n != null)
      return n;
  }
  return e.split(".").reduce((n, r) => n && n[r] != null ? n[r] : null, i);
}
function _d(i, e, t, n = t) {
  let r;
  return typeof i == "function" ? r = i(t) : Array.isArray(i) ? r = i[t] || n : r = Bd(i, t) || n, e && (r = e(r, n, i)), r;
}
function ht(i) {
  const {
    prop: e,
    cssProperty: t = i.prop,
    themeKey: n,
    transform: r
  } = i, s = (o) => {
    if (o[e] == null)
      return null;
    const l = o[e], u = o.theme, h = Bd(u, n) || {};
    return Pr(o, l, (m) => {
      let v = _d(h, r, m);
      return m === v && typeof m == "string" && (v = _d(h, r, `${e}${m === "default" ? "" : ol(m)}`, m)), t === !1 ? v : {
        [t]: v
      };
    });
  };
  return s.propTypes = process.env.NODE_ENV !== "production" ? {
    [e]: ss
  } : {}, s.filterProps = [e], s;
}
function Vd(...i) {
  const e = i.reduce((n, r) => (r.filterProps.forEach((s) => {
    n[s] = r;
  }), n), {}), t = (n) => Object.keys(n).reduce((r, s) => e[s] ? ll(r, e[s](n)) : r, {});
  return t.propTypes = process.env.NODE_ENV !== "production" ? i.reduce((n, r) => Object.assign(n, r.propTypes), {}) : {}, t.filterProps = i.reduce((n, r) => n.concat(r.filterProps), []), t;
}
function wI(i) {
  const e = {};
  return (t) => (e[t] === void 0 && (e[t] = i(t)), e[t]);
}
const bI = {
  m: "margin",
  p: "padding"
}, yI = {
  t: "Top",
  r: "Right",
  b: "Bottom",
  l: "Left",
  x: ["Left", "Right"],
  y: ["Top", "Bottom"]
}, Iv = {
  marginX: "mx",
  marginY: "my",
  paddingX: "px",
  paddingY: "py"
}, EI = wI((i) => {
  if (i.length > 2)
    if (Iv[i])
      i = Iv[i];
    else
      return [i];
  const [e, t] = i.split(""), n = bI[e], r = yI[t] || "";
  return Array.isArray(r) ? r.map((s) => n + s) : [n + r];
}), Ld = ["m", "mt", "mr", "mb", "ml", "mx", "my", "margin", "marginTop", "marginRight", "marginBottom", "marginLeft", "marginX", "marginY", "marginInline", "marginInlineStart", "marginInlineEnd", "marginBlock", "marginBlockStart", "marginBlockEnd"], Fd = ["p", "pt", "pr", "pb", "pl", "px", "py", "padding", "paddingTop", "paddingRight", "paddingBottom", "paddingLeft", "paddingX", "paddingY", "paddingInline", "paddingInlineStart", "paddingInlineEnd", "paddingBlock", "paddingBlockStart", "paddingBlockEnd"], CI = [...Ld, ...Fd];
function Il(i, e, t, n) {
  var r;
  const s = (r = Bd(i, e, !1)) != null ? r : t;
  return typeof s == "number" ? (o) => typeof o == "string" ? o : (process.env.NODE_ENV !== "production" && typeof o != "number" && console.error(`MUI: Expected ${n} argument to be a number or a string, got ${o}.`), s * o) : Array.isArray(s) ? (o) => typeof o == "string" ? o : (process.env.NODE_ENV !== "production" && (Number.isInteger(o) ? o > s.length - 1 && console.error([`MUI: The value provided (${o}) overflows.`, `The supported values are: ${JSON.stringify(s)}.`, `${o} > ${s.length - 1}, you need to add the missing values.`].join(`
`)) : console.error([`MUI: The \`theme.${e}\` array type cannot be combined with non integer values.You should either use an integer value that can be used as index, or define the \`theme.${e}\` as a number.`].join(`
`))), s[o]) : typeof s == "function" ? s : (process.env.NODE_ENV !== "production" && console.error([`MUI: The \`theme.${e}\` value (${s}) is invalid.`, "It should be a number, an array or a function."].join(`
`)), () => {
  });
}
function G0(i) {
  return Il(i, "spacing", 8, "spacing");
}
function Rl(i, e) {
  if (typeof e == "string" || e == null)
    return e;
  const t = Math.abs(e), n = i(t);
  return e >= 0 ? n : typeof n == "number" ? -n : `-${n}`;
}
function SI(i, e) {
  return (t) => i.reduce((n, r) => (n[r] = Rl(e, t), n), {});
}
function TI(i, e, t, n) {
  if (e.indexOf(t) === -1)
    return null;
  const r = EI(t), s = SI(r, n), o = i[t];
  return Pr(i, o, s);
}
function Y0(i, e) {
  const t = G0(i.theme);
  return Object.keys(i).map((n) => TI(i, e, n, t)).reduce(ll, {});
}
function jt(i) {
  return Y0(i, Ld);
}
jt.propTypes = process.env.NODE_ENV !== "production" ? Ld.reduce((i, e) => (i[e] = ss, i), {}) : {};
jt.filterProps = Ld;
function Ut(i) {
  return Y0(i, Fd);
}
Ut.propTypes = process.env.NODE_ENV !== "production" ? Fd.reduce((i, e) => (i[e] = ss, i), {}) : {};
Ut.filterProps = Fd;
process.env.NODE_ENV !== "production" && CI.reduce((i, e) => (i[e] = ss, i), {});
function tr(i) {
  return typeof i != "number" ? i : `${i}px solid`;
}
const xI = ht({
  prop: "border",
  themeKey: "borders",
  transform: tr
}), kI = ht({
  prop: "borderTop",
  themeKey: "borders",
  transform: tr
}), AI = ht({
  prop: "borderRight",
  themeKey: "borders",
  transform: tr
}), PI = ht({
  prop: "borderBottom",
  themeKey: "borders",
  transform: tr
}), II = ht({
  prop: "borderLeft",
  themeKey: "borders",
  transform: tr
}), RI = ht({
  prop: "borderColor",
  themeKey: "palette"
}), OI = ht({
  prop: "borderTopColor",
  themeKey: "palette"
}), MI = ht({
  prop: "borderRightColor",
  themeKey: "palette"
}), NI = ht({
  prop: "borderBottomColor",
  themeKey: "palette"
}), DI = ht({
  prop: "borderLeftColor",
  themeKey: "palette"
}), $d = (i) => {
  if (i.borderRadius !== void 0 && i.borderRadius !== null) {
    const e = Il(i.theme, "shape.borderRadius", 4, "borderRadius"), t = (n) => ({
      borderRadius: Rl(e, n)
    });
    return Pr(i, i.borderRadius, t);
  }
  return null;
};
$d.propTypes = process.env.NODE_ENV !== "production" ? {
  borderRadius: ss
} : {};
$d.filterProps = ["borderRadius"];
Vd(xI, kI, AI, PI, II, RI, OI, MI, NI, DI, $d);
const zd = (i) => {
  if (i.gap !== void 0 && i.gap !== null) {
    const e = Il(i.theme, "spacing", 8, "gap"), t = (n) => ({
      gap: Rl(e, n)
    });
    return Pr(i, i.gap, t);
  }
  return null;
};
zd.propTypes = process.env.NODE_ENV !== "production" ? {
  gap: ss
} : {};
zd.filterProps = ["gap"];
const Wd = (i) => {
  if (i.columnGap !== void 0 && i.columnGap !== null) {
    const e = Il(i.theme, "spacing", 8, "columnGap"), t = (n) => ({
      columnGap: Rl(e, n)
    });
    return Pr(i, i.columnGap, t);
  }
  return null;
};
Wd.propTypes = process.env.NODE_ENV !== "production" ? {
  columnGap: ss
} : {};
Wd.filterProps = ["columnGap"];
const jd = (i) => {
  if (i.rowGap !== void 0 && i.rowGap !== null) {
    const e = Il(i.theme, "spacing", 8, "rowGap"), t = (n) => ({
      rowGap: Rl(e, n)
    });
    return Pr(i, i.rowGap, t);
  }
  return null;
};
jd.propTypes = process.env.NODE_ENV !== "production" ? {
  rowGap: ss
} : {};
jd.filterProps = ["rowGap"];
const BI = ht({
  prop: "gridColumn"
}), VI = ht({
  prop: "gridRow"
}), LI = ht({
  prop: "gridAutoFlow"
}), FI = ht({
  prop: "gridAutoColumns"
}), $I = ht({
  prop: "gridAutoRows"
}), zI = ht({
  prop: "gridTemplateColumns"
}), WI = ht({
  prop: "gridTemplateRows"
}), jI = ht({
  prop: "gridTemplateAreas"
}), UI = ht({
  prop: "gridArea"
});
Vd(zd, Wd, jd, BI, VI, LI, FI, $I, zI, WI, jI, UI);
function Do(i, e) {
  return e === "grey" ? e : i;
}
const HI = ht({
  prop: "color",
  themeKey: "palette",
  transform: Do
}), qI = ht({
  prop: "bgcolor",
  cssProperty: "backgroundColor",
  themeKey: "palette",
  transform: Do
}), KI = ht({
  prop: "backgroundColor",
  themeKey: "palette",
  transform: Do
});
Vd(HI, qI, KI);
function ci(i) {
  return i <= 1 && i !== 0 ? `${i * 100}%` : i;
}
const GI = ht({
  prop: "width",
  transform: ci
}), Ig = (i) => {
  if (i.maxWidth !== void 0 && i.maxWidth !== null) {
    const e = (t) => {
      var n, r, s;
      return {
        maxWidth: ((n = i.theme) == null || (r = n.breakpoints) == null || (s = r.values) == null ? void 0 : s[t]) || Pg[t] || ci(t)
      };
    };
    return Pr(i, i.maxWidth, e);
  }
  return null;
};
Ig.filterProps = ["maxWidth"];
const YI = ht({
  prop: "minWidth",
  transform: ci
}), JI = ht({
  prop: "height",
  transform: ci
}), XI = ht({
  prop: "maxHeight",
  transform: ci
}), ZI = ht({
  prop: "minHeight",
  transform: ci
});
ht({
  prop: "size",
  cssProperty: "width",
  transform: ci
});
ht({
  prop: "size",
  cssProperty: "height",
  transform: ci
});
const QI = ht({
  prop: "boxSizing"
});
Vd(GI, Ig, YI, JI, XI, ZI, QI);
const eR = {
  // borders
  border: {
    themeKey: "borders",
    transform: tr
  },
  borderTop: {
    themeKey: "borders",
    transform: tr
  },
  borderRight: {
    themeKey: "borders",
    transform: tr
  },
  borderBottom: {
    themeKey: "borders",
    transform: tr
  },
  borderLeft: {
    themeKey: "borders",
    transform: tr
  },
  borderColor: {
    themeKey: "palette"
  },
  borderTopColor: {
    themeKey: "palette"
  },
  borderRightColor: {
    themeKey: "palette"
  },
  borderBottomColor: {
    themeKey: "palette"
  },
  borderLeftColor: {
    themeKey: "palette"
  },
  borderRadius: {
    themeKey: "shape.borderRadius",
    style: $d
  },
  // palette
  color: {
    themeKey: "palette",
    transform: Do
  },
  bgcolor: {
    themeKey: "palette",
    cssProperty: "backgroundColor",
    transform: Do
  },
  backgroundColor: {
    themeKey: "palette",
    transform: Do
  },
  // spacing
  p: {
    style: Ut
  },
  pt: {
    style: Ut
  },
  pr: {
    style: Ut
  },
  pb: {
    style: Ut
  },
  pl: {
    style: Ut
  },
  px: {
    style: Ut
  },
  py: {
    style: Ut
  },
  padding: {
    style: Ut
  },
  paddingTop: {
    style: Ut
  },
  paddingRight: {
    style: Ut
  },
  paddingBottom: {
    style: Ut
  },
  paddingLeft: {
    style: Ut
  },
  paddingX: {
    style: Ut
  },
  paddingY: {
    style: Ut
  },
  paddingInline: {
    style: Ut
  },
  paddingInlineStart: {
    style: Ut
  },
  paddingInlineEnd: {
    style: Ut
  },
  paddingBlock: {
    style: Ut
  },
  paddingBlockStart: {
    style: Ut
  },
  paddingBlockEnd: {
    style: Ut
  },
  m: {
    style: jt
  },
  mt: {
    style: jt
  },
  mr: {
    style: jt
  },
  mb: {
    style: jt
  },
  ml: {
    style: jt
  },
  mx: {
    style: jt
  },
  my: {
    style: jt
  },
  margin: {
    style: jt
  },
  marginTop: {
    style: jt
  },
  marginRight: {
    style: jt
  },
  marginBottom: {
    style: jt
  },
  marginLeft: {
    style: jt
  },
  marginX: {
    style: jt
  },
  marginY: {
    style: jt
  },
  marginInline: {
    style: jt
  },
  marginInlineStart: {
    style: jt
  },
  marginInlineEnd: {
    style: jt
  },
  marginBlock: {
    style: jt
  },
  marginBlockStart: {
    style: jt
  },
  marginBlockEnd: {
    style: jt
  },
  // display
  displayPrint: {
    cssProperty: !1,
    transform: (i) => ({
      "@media print": {
        display: i
      }
    })
  },
  display: {},
  overflow: {},
  textOverflow: {},
  visibility: {},
  whiteSpace: {},
  // flexbox
  flexBasis: {},
  flexDirection: {},
  flexWrap: {},
  justifyContent: {},
  alignItems: {},
  alignContent: {},
  order: {},
  flex: {},
  flexGrow: {},
  flexShrink: {},
  alignSelf: {},
  justifyItems: {},
  justifySelf: {},
  // grid
  gap: {
    style: zd
  },
  rowGap: {
    style: jd
  },
  columnGap: {
    style: Wd
  },
  gridColumn: {},
  gridRow: {},
  gridAutoFlow: {},
  gridAutoColumns: {},
  gridAutoRows: {},
  gridTemplateColumns: {},
  gridTemplateRows: {},
  gridTemplateAreas: {},
  gridArea: {},
  // positions
  position: {},
  zIndex: {
    themeKey: "zIndex"
  },
  top: {},
  right: {},
  bottom: {},
  left: {},
  // shadows
  boxShadow: {
    themeKey: "shadows"
  },
  // sizing
  width: {
    transform: ci
  },
  maxWidth: {
    style: Ig
  },
  minWidth: {
    transform: ci
  },
  height: {
    transform: ci
  },
  maxHeight: {
    transform: ci
  },
  minHeight: {
    transform: ci
  },
  boxSizing: {},
  // typography
  fontFamily: {
    themeKey: "typography"
  },
  fontSize: {
    themeKey: "typography"
  },
  fontStyle: {
    themeKey: "typography"
  },
  fontWeight: {
    themeKey: "typography"
  },
  letterSpacing: {},
  textTransform: {},
  lineHeight: {},
  textAlign: {},
  typography: {
    cssProperty: !1,
    themeKey: "typography"
  }
}, Ud = eR;
function tR(...i) {
  const e = i.reduce((n, r) => n.concat(Object.keys(r)), []), t = new Set(e);
  return i.every((n) => t.size === Object.keys(n).length);
}
function nR(i, e) {
  return typeof i == "function" ? i(e) : i;
}
function iR() {
  function i(t, n, r, s) {
    const o = {
      [t]: n,
      theme: r
    }, l = s[t];
    if (!l)
      return {
        [t]: n
      };
    const {
      cssProperty: u = t,
      themeKey: h,
      transform: f,
      style: m
    } = l;
    if (n == null)
      return null;
    const v = Bd(r, h) || {};
    return m ? m(o) : Pr(o, n, (k) => {
      let S = _d(v, f, k);
      return k === S && typeof k == "string" && (S = _d(v, f, `${t}${k === "default" ? "" : ol(k)}`, k)), u === !1 ? S : {
        [u]: S
      };
    });
  }
  function e(t) {
    var n;
    const {
      sx: r,
      theme: s = {}
    } = t || {};
    if (!r)
      return null;
    const o = (n = s.unstable_sxConfig) != null ? n : Ud;
    function l(u) {
      let h = u;
      if (typeof u == "function")
        h = u(s);
      else if (typeof u != "object")
        return u;
      if (!h)
        return null;
      const f = _I(s.breakpoints), m = Object.keys(f);
      let v = f;
      return Object.keys(h).forEach((C) => {
        const k = nR(h[C], s);
        if (k != null)
          if (typeof k == "object")
            if (o[C])
              v = ll(v, i(C, k, s, o));
            else {
              const S = Pr({
                theme: s
              }, k, (x) => ({
                [C]: x
              }));
              tR(S, k) ? v[C] = e({
                sx: k,
                theme: s
              }) : v = ll(v, S);
            }
          else
            v = ll(v, i(C, k, s, o));
      }), vI(m, v);
    }
    return Array.isArray(r) ? r.map(l) : l(r);
  }
  return e;
}
const J0 = iR();
J0.filterProps = ["sx"];
const Ol = J0, rR = ["values", "unit", "step"], sR = (i) => {
  const e = Object.keys(i).map((t) => ({
    key: t,
    val: i[t]
  })) || [];
  return e.sort((t, n) => t.val - n.val), e.reduce((t, n) => Ae({}, t, {
    [n.key]: n.val
  }), {});
};
function X0(i) {
  const {
    // The breakpoint **start** at this value.
    // For instance with the first breakpoint xs: [xs, sm).
    values: e = {
      xs: 0,
      // phone
      sm: 600,
      // tablet
      md: 900,
      // small laptop
      lg: 1200,
      // desktop
      xl: 1536
      // large screen
    },
    unit: t = "px",
    step: n = 5
  } = i, r = $n(i, rR), s = sR(e), o = Object.keys(s);
  function l(v) {
    return `@media (min-width:${typeof e[v] == "number" ? e[v] : v}${t})`;
  }
  function u(v) {
    return `@media (max-width:${(typeof e[v] == "number" ? e[v] : v) - n / 100}${t})`;
  }
  function h(v, C) {
    const k = o.indexOf(C);
    return `@media (min-width:${typeof e[v] == "number" ? e[v] : v}${t}) and (max-width:${(k !== -1 && typeof e[o[k]] == "number" ? e[o[k]] : C) - n / 100}${t})`;
  }
  function f(v) {
    return o.indexOf(v) + 1 < o.length ? h(v, o[o.indexOf(v) + 1]) : l(v);
  }
  function m(v) {
    const C = o.indexOf(v);
    return C === 0 ? l(o[1]) : C === o.length - 1 ? u(o[C]) : h(v, o[o.indexOf(v) + 1]).replace("@media", "@media not all and");
  }
  return Ae({
    keys: o,
    values: s,
    up: l,
    down: u,
    between: h,
    only: f,
    not: m,
    unit: t
  }, r);
}
const oR = {
  borderRadius: 4
}, aR = oR;
function Z0(i = 8) {
  if (i.mui)
    return i;
  const e = G0({
    spacing: i
  }), t = (...n) => (process.env.NODE_ENV !== "production" && (n.length <= 4 || console.error(`MUI: Too many arguments provided, expected between 0 and 4, got ${n.length}`)), (n.length === 0 ? [1] : n).map((s) => {
    const o = e(s);
    return typeof o == "number" ? `${o}px` : o;
  }).join(" "));
  return t.mui = !0, t;
}
const lR = ["breakpoints", "palette", "spacing", "shape"];
function Rg(i = {}, ...e) {
  const {
    breakpoints: t = {},
    palette: n = {},
    spacing: r,
    shape: s = {}
  } = i, o = $n(i, lR), l = X0(t), u = Z0(r);
  let h = ki({
    breakpoints: l,
    direction: "ltr",
    components: {},
    // Inject component definitions.
    palette: Ae({
      mode: "light"
    }, n),
    spacing: u,
    shape: Ae({}, aR, s)
  }, o);
  return h = e.reduce((f, m) => ki(f, m), h), h.unstable_sxConfig = Ae({}, Ud, o?.unstable_sxConfig), h.unstable_sx = function(m) {
    return Ol({
      sx: m,
      theme: this
    });
  }, h;
}
const Q0 = /* @__PURE__ */ Ht.createContext(null);
process.env.NODE_ENV !== "production" && (Q0.displayName = "ThemeContext");
const ey = Q0;
function Og() {
  const i = Ht.useContext(ey);
  return process.env.NODE_ENV !== "production" && Ht.useDebugValue(i), i;
}
const cR = typeof Symbol == "function" && Symbol.for, uR = cR ? Symbol.for("mui.nested") : "__THEME_NESTED__";
function dR(i, e) {
  if (typeof e == "function") {
    const t = e(i);
    return process.env.NODE_ENV !== "production" && (t || console.error(["MUI: You should return an object from your theme function, i.e.", "<ThemeProvider theme={() => ({})} />"].join(`
`))), t;
  }
  return Ae({}, i, e);
}
function vd(i) {
  const {
    children: e,
    theme: t
  } = i, n = Og();
  process.env.NODE_ENV !== "production" && n === null && typeof t == "function" && console.error(["MUI: You are providing a theme function prop to the ThemeProvider component:", "<ThemeProvider theme={outerTheme => outerTheme} />", "", "However, no outer theme is present.", "Make sure a theme is already injected higher in the React tree or provide a theme object."].join(`
`));
  const r = Ht.useMemo(() => {
    const s = n === null ? t : dR(n, t);
    return s != null && (s[uR] = n !== null), s;
  }, [t, n]);
  return /* @__PURE__ */ Jn(ey.Provider, {
    value: r,
    children: e
  });
}
process.env.NODE_ENV !== "production" && (vd.propTypes = {
  /**
   * Your component tree.
   */
  children: Ue.node,
  /**
   * A theme object. You can provide a function to extend the outer theme.
   */
  theme: Ue.oneOfType([Ue.object, Ue.func]).isRequired
});
process.env.NODE_ENV !== "production" && process.env.NODE_ENV !== "production" && (vd.propTypes = L0(vd.propTypes));
function hR(i) {
  return Object.keys(i).length === 0;
}
function fR(i = null) {
  const e = Og();
  return !e || hR(e) ? i : e;
}
const mR = Rg();
function Mg(i = mR) {
  return fR(i);
}
const gR = ["variant"];
function Rv(i) {
  return i.length === 0;
}
function ty(i) {
  const {
    variant: e
  } = i, t = $n(i, gR);
  let n = e || "";
  return Object.keys(t).sort().forEach((r) => {
    r === "color" ? n += Rv(n) ? i[r] : ol(i[r]) : n += `${Rv(n) ? r : ol(r)}${ol(i[r].toString())}`;
  }), n;
}
const pR = ["name", "slot", "skipVariantsResolver", "skipSx", "overridesResolver"], _R = ["theme"], vR = ["theme"];
function Ha(i) {
  return Object.keys(i).length === 0;
}
function wR(i) {
  return typeof i == "string" && // 96 is one less than the char code
  // for "a" so this is checking that
  // it's a lowercase character
  i.charCodeAt(0) > 96;
}
const bR = (i, e) => e.components && e.components[i] && e.components[i].styleOverrides ? e.components[i].styleOverrides : null, yR = (i, e) => {
  let t = [];
  e && e.components && e.components[i] && e.components[i].variants && (t = e.components[i].variants);
  const n = {};
  return t.forEach((r) => {
    const s = ty(r.props);
    n[s] = r.style;
  }), n;
}, ER = (i, e, t, n) => {
  var r, s;
  const {
    ownerState: o = {}
  } = i, l = [], u = t == null || (r = t.components) == null || (s = r[n]) == null ? void 0 : s.variants;
  return u && u.forEach((h) => {
    let f = !0;
    Object.keys(h.props).forEach((m) => {
      o[m] !== h.props[m] && i[m] !== h.props[m] && (f = !1);
    }), f && l.push(e[ty(h.props)]);
  }), l;
};
function Ju(i) {
  return i !== "ownerState" && i !== "theme" && i !== "sx" && i !== "as";
}
const CR = Rg(), SR = (i) => i.charAt(0).toLowerCase() + i.slice(1);
function TR(i = {}) {
  const {
    defaultTheme: e = CR,
    rootShouldForwardProp: t = Ju,
    slotShouldForwardProp: n = Ju
  } = i, r = (s) => {
    const o = Ha(s.theme) ? e : s.theme;
    return Ol(Ae({}, s, {
      theme: o
    }));
  };
  return r.__mui_systemSx = !0, (s, o = {}) => {
    gI(s, (A) => A.filter((P) => !(P != null && P.__mui_systemSx)));
    const {
      name: l,
      slot: u,
      skipVariantsResolver: h,
      skipSx: f,
      overridesResolver: m
    } = o, v = $n(o, pR), C = h !== void 0 ? h : u && u !== "Root" || !1, k = f || !1;
    let S;
    process.env.NODE_ENV !== "production" && l && (S = `${l}-${SR(u || "Root")}`);
    let x = Ju;
    u === "Root" ? x = t : u ? x = n : wR(s) && (x = void 0);
    const N = mI(s, Ae({
      shouldForwardProp: x,
      label: S
    }, v)), y = (A, ...P) => {
      const E = P ? P.map(($) => typeof $ == "function" && $.__emotion_real !== $ ? (M) => {
        let {
          theme: D
        } = M, J = $n(M, _R);
        return $(Ae({
          theme: Ha(D) ? e : D
        }, J));
      } : $) : [];
      let V = A;
      l && m && E.push(($) => {
        const M = Ha($.theme) ? e : $.theme, D = bR(l, M);
        if (D) {
          const J = {};
          return Object.entries(D).forEach(([H, Y]) => {
            J[H] = typeof Y == "function" ? Y(Ae({}, $, {
              theme: M
            })) : Y;
          }), m($, J);
        }
        return null;
      }), l && !C && E.push(($) => {
        const M = Ha($.theme) ? e : $.theme;
        return ER($, yR(l, M), M, l);
      }), k || E.push(r);
      const j = E.length - P.length;
      if (Array.isArray(A) && j > 0) {
        const $ = new Array(j).fill("");
        V = [...A, ...$], V.raw = [...A.raw, ...$];
      } else
        typeof A == "function" && // On the server Emotion doesn't use React.forwardRef for creating components, so the created
        // component stays as a function. This condition makes sure that we do not interpolate functions
        // which are basically components used as a selectors.
        A.__emotion_real !== A && (V = ($) => {
          let {
            theme: M
          } = $, D = $n($, vR);
          return A(Ae({
            theme: Ha(M) ? e : M
          }, D));
        });
      const U = N(V, ...E);
      if (process.env.NODE_ENV !== "production") {
        let $;
        l && ($ = `${l}${u || ""}`), $ === void 0 && ($ = `Styled(${c5(s)})`), U.displayName = $;
      }
      return U;
    };
    return N.withConfig && (y.withConfig = N.withConfig), y;
  };
}
function xR(i) {
  const {
    theme: e,
    name: t,
    props: n
  } = i;
  return !e || !e.components || !e.components[t] || !e.components[t].defaultProps ? n : $0(e.components[t].defaultProps, n);
}
function kR({
  props: i,
  name: e,
  defaultTheme: t
}) {
  const n = Mg(t);
  return xR({
    theme: n,
    name: e,
    props: i
  });
}
function Ng(i, e = 0, t = 1) {
  return process.env.NODE_ENV !== "production" && (i < e || i > t) && console.error(`MUI: The value provided ${i} is out of range [${e}, ${t}].`), Math.min(Math.max(e, i), t);
}
function ny(i) {
  i = i.slice(1);
  const e = new RegExp(`.{1,${i.length >= 6 ? 2 : 1}}`, "g");
  let t = i.match(e);
  return t && t[0].length === 1 && (t = t.map((n) => n + n)), t ? `rgb${t.length === 4 ? "a" : ""}(${t.map((n, r) => r < 3 ? parseInt(n, 16) : Math.round(parseInt(n, 16) / 255 * 1e3) / 1e3).join(", ")})` : "";
}
function AR(i) {
  const e = i.toString(16);
  return e.length === 1 ? `0${e}` : e;
}
function ar(i) {
  if (i.type)
    return i;
  if (i.charAt(0) === "#")
    return ar(ny(i));
  const e = i.indexOf("("), t = i.substring(0, e);
  if (["rgb", "rgba", "hsl", "hsla", "color"].indexOf(t) === -1)
    throw new Error(process.env.NODE_ENV !== "production" ? `MUI: Unsupported \`${i}\` color.
The following formats are supported: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla(), color().` : Pi(9, i));
  let n = i.substring(e + 1, i.length - 1), r;
  if (t === "color") {
    if (n = n.split(" "), r = n.shift(), n.length === 4 && n[3].charAt(0) === "/" && (n[3] = n[3].slice(1)), ["srgb", "display-p3", "a98-rgb", "prophoto-rgb", "rec-2020"].indexOf(r) === -1)
      throw new Error(process.env.NODE_ENV !== "production" ? `MUI: unsupported \`${r}\` color space.
The following color spaces are supported: srgb, display-p3, a98-rgb, prophoto-rgb, rec-2020.` : Pi(10, r));
  } else
    n = n.split(",");
  return n = n.map((s) => parseFloat(s)), {
    type: t,
    values: n,
    colorSpace: r
  };
}
const PR = (i) => {
  const e = ar(i);
  return e.values.slice(0, 3).map((t, n) => e.type.indexOf("hsl") !== -1 && n !== 0 ? `${t}%` : t).join(" ");
}, Ti = (i, e) => {
  try {
    return PR(i);
  } catch {
    return e && process.env.NODE_ENV !== "production" && console.warn(e), i;
  }
};
function Ml(i) {
  const {
    type: e,
    colorSpace: t
  } = i;
  let {
    values: n
  } = i;
  return e.indexOf("rgb") !== -1 ? n = n.map((r, s) => s < 3 ? parseInt(r, 10) : r) : e.indexOf("hsl") !== -1 && (n[1] = `${n[1]}%`, n[2] = `${n[2]}%`), e.indexOf("color") !== -1 ? n = `${t} ${n.join(" ")}` : n = `${n.join(", ")}`, `${e}(${n})`;
}
function IR(i) {
  if (i.indexOf("#") === 0)
    return i;
  const {
    values: e
  } = ar(i);
  return `#${e.map((t, n) => AR(n === 3 ? Math.round(255 * t) : t)).join("")}`;
}
function iy(i) {
  i = ar(i);
  const {
    values: e
  } = i, t = e[0], n = e[1] / 100, r = e[2] / 100, s = n * Math.min(r, 1 - r), o = (h, f = (h + t / 30) % 12) => r - s * Math.max(Math.min(f - 3, 9 - f, 1), -1);
  let l = "rgb";
  const u = [Math.round(o(0) * 255), Math.round(o(8) * 255), Math.round(o(4) * 255)];
  return i.type === "hsla" && (l += "a", u.push(e[3])), Ml({
    type: l,
    values: u
  });
}
function wd(i) {
  i = ar(i);
  let e = i.type === "hsl" || i.type === "hsla" ? ar(iy(i)).values : i.values;
  return e = e.map((t) => (i.type !== "color" && (t /= 255), t <= 0.03928 ? t / 12.92 : ((t + 0.055) / 1.055) ** 2.4)), Number((0.2126 * e[0] + 0.7152 * e[1] + 0.0722 * e[2]).toFixed(3));
}
function qm(i, e) {
  const t = wd(i), n = wd(e);
  return (Math.max(t, n) + 0.05) / (Math.min(t, n) + 0.05);
}
function ry(i, e) {
  return i = ar(i), e = Ng(e), (i.type === "rgb" || i.type === "hsl") && (i.type += "a"), i.type === "color" ? i.values[3] = `/${e}` : i.values[3] = e, Ml(i);
}
function Mu(i, e, t) {
  try {
    return ry(i, e);
  } catch {
    return t && process.env.NODE_ENV !== "production" && console.warn(t), i;
  }
}
function Hd(i, e) {
  if (i = ar(i), e = Ng(e), i.type.indexOf("hsl") !== -1)
    i.values[2] *= 1 - e;
  else if (i.type.indexOf("rgb") !== -1 || i.type.indexOf("color") !== -1)
    for (let t = 0; t < 3; t += 1)
      i.values[t] *= 1 - e;
  return Ml(i);
}
function St(i, e, t) {
  try {
    return Hd(i, e);
  } catch {
    return t && process.env.NODE_ENV !== "production" && console.warn(t), i;
  }
}
function qd(i, e) {
  if (i = ar(i), e = Ng(e), i.type.indexOf("hsl") !== -1)
    i.values[2] += (100 - i.values[2]) * e;
  else if (i.type.indexOf("rgb") !== -1)
    for (let t = 0; t < 3; t += 1)
      i.values[t] += (255 - i.values[t]) * e;
  else if (i.type.indexOf("color") !== -1)
    for (let t = 0; t < 3; t += 1)
      i.values[t] += (1 - i.values[t]) * e;
  return Ml(i);
}
function Tt(i, e, t) {
  try {
    return qd(i, e);
  } catch {
    return t && process.env.NODE_ENV !== "production" && console.warn(t), i;
  }
}
function RR(i, e = 0.15) {
  return wd(i) > 0.5 ? Hd(i, e) : qd(i, e);
}
function il(i, e, t) {
  try {
    return il(i, e);
  } catch {
    return t && process.env.NODE_ENV !== "production" && console.warn(t), i;
  }
}
const OR = {};
function sy(i) {
  const e = Mg();
  return /* @__PURE__ */ Jn(Fi.ThemeContext.Provider, {
    value: typeof e == "object" ? e : OR,
    children: i.children
  });
}
process.env.NODE_ENV !== "production" && (sy.propTypes = {
  /**
   * Your component tree.
   */
  children: Ue.node
});
function gl(i) {
  const {
    children: e,
    theme: t
  } = i;
  return /* @__PURE__ */ Jn(vd, {
    theme: t,
    children: /* @__PURE__ */ Jn(sy, {
      children: e
    })
  });
}
process.env.NODE_ENV !== "production" && (gl.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * Your component tree.
   */
  children: Ue.node,
  /**
   * A theme object. You can provide a function to extend the outer theme.
   */
  theme: Ue.oneOfType([Ue.func, Ue.object]).isRequired
});
process.env.NODE_ENV !== "production" && process.env.NODE_ENV !== "production" && (gl.propTypes = L0(gl.propTypes));
const MR = (i, e, t, n = []) => {
  let r = i;
  e.forEach((s, o) => {
    o === e.length - 1 ? Array.isArray(r) ? r[Number(s)] = t : r && typeof r == "object" && (r[s] = t) : r && typeof r == "object" && (r[s] || (r[s] = n.includes(s) ? [] : {}), r = r[s]);
  });
}, NR = (i, e, t) => {
  function n(r, s = [], o = []) {
    Object.entries(r).forEach(([l, u]) => {
      (!t || t && !t([...s, l])) && u != null && (typeof u == "object" && Object.keys(u).length > 0 ? n(u, [...s, l], Array.isArray(u) ? [...o, l] : o) : e([...s, l], u, o));
    });
  }
  n(i);
}, DR = (i, e) => typeof e == "number" ? ["lineHeight", "fontWeight", "opacity", "zIndex"].some((n) => i.includes(n)) || i[i.length - 1].toLowerCase().indexOf("opacity") >= 0 ? e : `${e}px` : e;
function Ov(i, e) {
  const {
    prefix: t,
    shouldSkipGeneratingVar: n
  } = e || {}, r = {}, s = {};
  return NR(
    i,
    (o, l, u) => {
      if ((typeof l == "string" || typeof l == "number") && (!n || !n(o, l))) {
        const h = `--${t ? `${t}-` : ""}${o.join("-")}`;
        Object.assign(r, {
          [h]: DR(o, l)
        }), MR(s, o, `var(${h})`, u);
      }
    },
    (o) => o[0] === "vars"
    // skip 'vars/*' paths
  ), {
    css: r,
    vars: s
  };
}
const Dg = "mode", Bg = "color-scheme", oy = "data-color-scheme";
function BR(i) {
  const {
    defaultMode: e = "light",
    defaultLightColorScheme: t = "light",
    defaultDarkColorScheme: n = "dark",
    modeStorageKey: r = Dg,
    colorSchemeStorageKey: s = Bg,
    attribute: o = oy,
    colorSchemeNode: l = "document.documentElement"
  } = i || {};
  return /* @__PURE__ */ Jn("script", {
    // eslint-disable-next-line react/no-danger
    dangerouslySetInnerHTML: {
      __html: `(function() { try {
        var mode = localStorage.getItem('${r}') || '${e}';
        var cssColorScheme = mode;
        var colorScheme = '';
        if (mode === 'system') {
          // handle system mode
          var mql = window.matchMedia('(prefers-color-scheme: dark)');
          if (mql.matches) {
            cssColorScheme = 'dark';
            colorScheme = localStorage.getItem('${s}-dark') || '${n}';
          } else {
            cssColorScheme = 'light';
            colorScheme = localStorage.getItem('${s}-light') || '${t}';
          }
        }
        if (mode === 'light') {
          colorScheme = localStorage.getItem('${s}-light') || '${t}';
        }
        if (mode === 'dark') {
          colorScheme = localStorage.getItem('${s}-dark') || '${n}';
        }
        if (colorScheme) {
          ${l}.setAttribute('${o}', colorScheme);
        }
      } catch (e) {} })();`
    }
  }, "mui-color-scheme-init");
}
function Mv(i) {
  if (typeof window < "u" && i === "system")
    return window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light";
}
function ay(i, e) {
  if (i.mode === "light" || i.mode === "system" && i.systemMode === "light")
    return e("light");
  if (i.mode === "dark" || i.mode === "system" && i.systemMode === "dark")
    return e("dark");
}
function VR(i) {
  return ay(i, (e) => {
    if (e === "light")
      return i.lightColorScheme;
    if (e === "dark")
      return i.darkColorScheme;
  });
}
function am(i, e) {
  if (typeof window > "u")
    return;
  let t;
  try {
    t = localStorage.getItem(i) || void 0, t || localStorage.setItem(i, e);
  } catch {
  }
  return t || e;
}
function LR(i) {
  const {
    defaultMode: e = "light",
    defaultLightColorScheme: t,
    defaultDarkColorScheme: n,
    supportedColorSchemes: r = [],
    modeStorageKey: s = Dg,
    colorSchemeStorageKey: o = Bg,
    storageWindow: l = typeof window > "u" ? void 0 : window
  } = i, u = r.join(","), [h, f] = Ht.useState(() => {
    const x = am(s, e), N = am(`${o}-light`, t), y = am(`${o}-dark`, n);
    return {
      mode: x,
      systemMode: Mv(x),
      lightColorScheme: N,
      darkColorScheme: y
    };
  }), m = VR(h), v = Ht.useCallback((x) => {
    f((N) => {
      if (x === N.mode)
        return N;
      const y = x || e;
      try {
        localStorage.setItem(s, y);
      } catch {
      }
      return Ae({}, N, {
        mode: y,
        systemMode: Mv(y)
      });
    });
  }, [s, e]), C = Ht.useCallback((x) => {
    x ? typeof x == "string" ? x && !u.includes(x) ? console.error(`\`${x}\` does not exist in \`theme.colorSchemes\`.`) : f((N) => {
      const y = Ae({}, N);
      return ay(N, (A) => {
        try {
          localStorage.setItem(`${o}-${A}`, x);
        } catch {
        }
        A === "light" && (y.lightColorScheme = x), A === "dark" && (y.darkColorScheme = x);
      }), y;
    }) : f((N) => {
      const y = Ae({}, N), A = x.light === null ? t : x.light, P = x.dark === null ? n : x.dark;
      if (A)
        if (!u.includes(A))
          console.error(`\`${A}\` does not exist in \`theme.colorSchemes\`.`);
        else {
          y.lightColorScheme = A;
          try {
            localStorage.setItem(`${o}-light`, A);
          } catch {
          }
        }
      if (P)
        if (!u.includes(P))
          console.error(`\`${P}\` does not exist in \`theme.colorSchemes\`.`);
        else {
          y.darkColorScheme = P;
          try {
            localStorage.setItem(`${o}-dark`, P);
          } catch {
          }
        }
      return y;
    }) : f((N) => {
      try {
        localStorage.setItem(`${o}-light`, t), localStorage.setItem(`${o}-dark`, n);
      } catch {
      }
      return Ae({}, N, {
        lightColorScheme: t,
        darkColorScheme: n
      });
    });
  }, [u, o, t, n]), k = Ht.useCallback((x) => {
    h.mode === "system" && f((N) => Ae({}, N, {
      systemMode: x != null && x.matches ? "dark" : "light"
    }));
  }, [h.mode]), S = Ht.useRef(k);
  return S.current = k, Ht.useEffect(() => {
    const x = (...y) => S.current(...y), N = window.matchMedia("(prefers-color-scheme: dark)");
    return N.addListener(x), x(N), () => N.removeListener(x);
  }, []), Ht.useEffect(() => {
    const x = (N) => {
      const y = N.newValue;
      typeof N.key == "string" && N.key.startsWith(o) && (!y || u.match(y)) && (N.key.endsWith("light") && C({
        light: y
      }), N.key.endsWith("dark") && C({
        dark: y
      })), N.key === s && (!y || ["light", "dark", "system"].includes(y)) && v(y || e);
    };
    if (l)
      return l.addEventListener("storage", x), () => l.removeEventListener("storage", x);
  }, [C, v, s, o, u, e, l]), Ae({}, h, {
    colorScheme: m,
    setMode: v,
    setColorScheme: C
  });
}
const FR = ["colorSchemes", "components", "cssVarPrefix"], $R = "*{-webkit-transition:none!important;-moz-transition:none!important;-o-transition:none!important;-ms-transition:none!important;transition:none!important}";
function zR(i) {
  const {
    theme: e = {},
    attribute: t = oy,
    modeStorageKey: n = Dg,
    colorSchemeStorageKey: r = Bg,
    defaultMode: s = "light",
    defaultColorScheme: o,
    disableTransitionOnChange: l = !1,
    shouldSkipGeneratingVar: u,
    resolveTheme: h,
    excludeVariablesFromRoot: f
  } = i;
  (!e.colorSchemes || typeof o == "string" && !e.colorSchemes[o] || typeof o == "object" && !e.colorSchemes[o?.light] || typeof o == "object" && !e.colorSchemes[o?.dark]) && console.error(`MUI: \`${o}\` does not exist in \`theme.colorSchemes\`.`);
  const m = /* @__PURE__ */ Ht.createContext(void 0), v = () => {
    const N = Ht.useContext(m);
    if (!N)
      throw new Error(process.env.NODE_ENV !== "production" ? "MUI: `useColorScheme` must be called under <CssVarsProvider />" : Pi(19));
    return N;
  };
  function C({
    children: N,
    theme: y = e,
    modeStorageKey: A = n,
    colorSchemeStorageKey: P = r,
    attribute: E = t,
    defaultMode: V = s,
    defaultColorScheme: j = o,
    disableTransitionOnChange: U = l,
    storageWindow: $ = typeof window > "u" ? void 0 : window,
    documentNode: M = typeof document > "u" ? void 0 : document,
    colorSchemeNode: D = typeof document > "u" ? void 0 : document.documentElement,
    colorSchemeSelector: J = ":root",
    shouldSkipGeneratingVar: H = u,
    disableNestedContext: Y = !1,
    disableStyleSheetGeneration: le = !1
  }) {
    const me = Ht.useRef(!1), ee = Og(), te = Ht.useContext(m), ne = !!te && !Y, {
      colorSchemes: z = {},
      components: se = {},
      cssVarPrefix: ve
    } = y, ue = $n(y, FR), ce = Object.keys(z), he = typeof j == "string" ? j : j.light, be = typeof j == "string" ? j : j.dark, {
      mode: Ee,
      setMode: Pe,
      systemMode: Se,
      lightColorScheme: ye,
      darkColorScheme: De,
      colorScheme: q,
      setColorScheme: Ze
    } = LR({
      supportedColorSchemes: ce,
      defaultLightColorScheme: he,
      defaultDarkColorScheme: be,
      modeStorageKey: A,
      colorSchemeStorageKey: P,
      defaultMode: V,
      storageWindow: $
    });
    let de = Ee, Ye = q;
    ne && (de = te.mode, Ye = te.colorScheme);
    const nn = (() => de || (V === "system" ? s : V))(), rn = (() => Ye || (nn === "dark" ? be : he))(), {
      css: Qn,
      vars: zn
    } = Ov(ue, {
      prefix: ve,
      shouldSkipGeneratingVar: H
    }), Jt = Ae({}, ue, {
      components: se,
      colorSchemes: z,
      cssVarPrefix: ve,
      vars: zn,
      getColorSchemeSelector: (dn) => `[${E}="${dn}"] &`
    }), sn = {}, Wn = {};
    Object.entries(z).forEach(([dn, on]) => {
      const {
        css: On,
        vars: Mn
      } = Ov(on, {
        prefix: ve,
        shouldSkipGeneratingVar: H
      });
      Jt.vars = ki(Jt.vars, Mn), dn === rn && (Object.keys(on).forEach((ge) => {
        on[ge] && typeof on[ge] == "object" ? Jt[ge] = Ae({}, Jt[ge], on[ge]) : Jt[ge] = on[ge];
      }), Jt.palette && (Jt.palette.colorScheme = dn));
      const I = (() => typeof j == "string" ? j : V === "dark" ? j.dark : j.light)();
      if (dn === I) {
        if (f) {
          const ge = {};
          f(ve).forEach((xe) => {
            ge[xe] = On[xe], delete On[xe];
          }), sn[`[${E}="${dn}"]`] = ge;
        }
        sn[`${J}, [${E}="${dn}"]`] = On;
      } else
        Wn[`${J === ":root" ? "" : J}[${E}="${dn}"]`] = On;
    }), Ht.useEffect(() => {
      Ye && D && D.setAttribute(E, Ye);
    }, [Ye, E, D]), Ht.useEffect(() => {
      let dn;
      if (U && me.current && M) {
        const on = M.createElement("style");
        on.appendChild(M.createTextNode($R)), M.head.appendChild(on), window.getComputedStyle(M.body), dn = setTimeout(() => {
          M.head.removeChild(on);
        }, 1);
      }
      return () => {
        clearTimeout(dn);
      };
    }, [Ye, U, M]), Ht.useEffect(() => (me.current = !0, () => {
      me.current = !1;
    }), []);
    const gi = Ht.useMemo(() => ({
      mode: de,
      systemMode: Se,
      setMode: Pe,
      lightColorScheme: ye,
      darkColorScheme: De,
      colorScheme: Ye,
      setColorScheme: Ze,
      allColorSchemes: ce
    }), [ce, Ye, De, ye, de, Ze, Pe, Se]);
    let jn = !0;
    (le || ne && ee?.cssVarPrefix === ve) && (jn = !1);
    const Un = /* @__PURE__ */ x1(Ht.Fragment, {
      children: [jn && /* @__PURE__ */ x1(Ht.Fragment, {
        children: [/* @__PURE__ */ Jn(Yu, {
          styles: {
            [J]: Qn
          }
        }), /* @__PURE__ */ Jn(Yu, {
          styles: sn
        }), /* @__PURE__ */ Jn(Yu, {
          styles: Wn
        })]
      }), /* @__PURE__ */ Jn(gl, {
        theme: h ? h(Jt) : Jt,
        children: N
      })]
    });
    return ne ? Un : /* @__PURE__ */ Jn(m.Provider, {
      value: gi,
      children: Un
    });
  }
  process.env.NODE_ENV !== "production" && (C.propTypes = {
    /**
     * The body attribute name to attach colorScheme.
     */
    attribute: Ue.string,
    /**
     * The component tree.
     */
    children: Ue.node,
    /**
     * The node used to attach the color-scheme attribute
     */
    colorSchemeNode: Ue.any,
    /**
     * The CSS selector for attaching the generated custom properties
     */
    colorSchemeSelector: Ue.string,
    /**
     * localStorage key used to store `colorScheme`
     */
    colorSchemeStorageKey: Ue.string,
    /**
     * The initial color scheme used.
     */
    defaultColorScheme: Ue.oneOfType([Ue.string, Ue.object]),
    /**
     * The initial mode used.
     */
    defaultMode: Ue.string,
    /**
     * If `true`, the provider creates its own context and generate stylesheet as if it is a root `CssVarsProvider`.
     */
    disableNestedContext: Ue.bool,
    /**
     * If `true`, the style sheet won't be generated.
     *
     * This is useful for controlling nested CssVarsProvider behavior.
     */
    disableStyleSheetGeneration: Ue.bool,
    /**
     * Disable CSS transitions when switching between modes or color schemes
     */
    disableTransitionOnChange: Ue.bool,
    /**
     * The document to attach the attribute to
     */
    documentNode: Ue.any,
    /**
     * The key in the local storage used to store current color scheme.
     */
    modeStorageKey: Ue.string,
    /**
     * A function to determine if the key, value should be attached as CSS Variable
     */
    shouldSkipGeneratingVar: Ue.func,
    /**
     * The window that attaches the 'storage' event listener
     * @default window
     */
    storageWindow: Ue.any,
    /**
     * The calculated theme object that will be passed through context.
     */
    theme: Ue.object
  });
  const k = typeof o == "string" ? o : o.light, S = typeof o == "string" ? o : o.dark;
  return {
    CssVarsProvider: C,
    useColorScheme: v,
    getInitColorSchemeScript: (N) => BR(Ae({
      attribute: t,
      colorSchemeStorageKey: r,
      defaultMode: s,
      defaultLightColorScheme: k,
      defaultDarkColorScheme: S,
      modeStorageKey: n
    }, N))
  };
}
function WR(i = "") {
  function e(...n) {
    if (!n.length)
      return "";
    const r = n[0];
    return typeof r == "string" && !r.match(/(#|\(|\)|(-?(\d*\.)?\d+)(px|em|%|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc))/) ? `, var(--${i ? `${i}-` : ""}${r}${e(...n.slice(1))})` : `, ${r}`;
  }
  return (n, ...r) => `var(--${i ? `${i}-` : ""}${n}${e(...r)})`;
}
const jR = ["defaultProps", "mixins", "overrides", "palette", "props", "styleOverrides"], UR = ["type", "mode"];
function HR(i) {
  process.env.NODE_ENV !== "production" && console.warn(["MUI: adaptV4Theme() is deprecated.", "Follow the upgrade guide on https://mui.com/r/migration-v4#theme."].join(`
`));
  const {
    defaultProps: e = {},
    mixins: t = {},
    overrides: n = {},
    palette: r = {},
    props: s = {},
    styleOverrides: o = {}
  } = i, l = $n(i, jR), u = Ae({}, l, {
    components: {}
  });
  Object.keys(e).forEach((S) => {
    const x = u.components[S] || {};
    x.defaultProps = e[S], u.components[S] = x;
  }), Object.keys(s).forEach((S) => {
    const x = u.components[S] || {};
    x.defaultProps = s[S], u.components[S] = x;
  }), Object.keys(o).forEach((S) => {
    const x = u.components[S] || {};
    x.styleOverrides = o[S], u.components[S] = x;
  }), Object.keys(n).forEach((S) => {
    const x = u.components[S] || {};
    x.styleOverrides = n[S], u.components[S] = x;
  }), u.spacing = Z0(i.spacing);
  const h = X0(i.breakpoints || {}), f = u.spacing;
  u.mixins = Ae({
    gutters: (S = {}) => Ae({
      paddingLeft: f(2),
      paddingRight: f(2)
    }, S, {
      [h.up("sm")]: Ae({
        paddingLeft: f(3),
        paddingRight: f(3)
      }, S[h.up("sm")])
    })
  }, t);
  const {
    type: m,
    mode: v
  } = r, C = $n(r, UR), k = v || m || "light";
  return u.palette = Ae({
    // theme.palette.text.hint
    text: {
      hint: k === "dark" ? "rgba(255, 255, 255, 0.5)" : "rgba(0, 0, 0, 0.38)"
    },
    mode: k,
    type: k
  }, C), u;
}
function qR(i, e) {
  return Ae({
    toolbar: {
      minHeight: 56,
      [i.up("xs")]: {
        "@media (orientation: landscape)": {
          minHeight: 48
        }
      },
      [i.up("sm")]: {
        minHeight: 64
      }
    }
  }, e);
}
const KR = {
  black: "#000",
  white: "#fff"
}, pl = KR, GR = {
  50: "#fafafa",
  100: "#f5f5f5",
  200: "#eeeeee",
  300: "#e0e0e0",
  400: "#bdbdbd",
  500: "#9e9e9e",
  600: "#757575",
  700: "#616161",
  800: "#424242",
  900: "#212121",
  A100: "#f5f5f5",
  A200: "#eeeeee",
  A400: "#bdbdbd",
  A700: "#616161"
}, YR = GR, JR = {
  50: "#f3e5f5",
  100: "#e1bee7",
  200: "#ce93d8",
  300: "#ba68c8",
  400: "#ab47bc",
  500: "#9c27b0",
  600: "#8e24aa",
  700: "#7b1fa2",
  800: "#6a1b9a",
  900: "#4a148c",
  A100: "#ea80fc",
  A200: "#e040fb",
  A400: "#d500f9",
  A700: "#aa00ff"
}, bo = JR, XR = {
  50: "#ffebee",
  100: "#ffcdd2",
  200: "#ef9a9a",
  300: "#e57373",
  400: "#ef5350",
  500: "#f44336",
  600: "#e53935",
  700: "#d32f2f",
  800: "#c62828",
  900: "#b71c1c",
  A100: "#ff8a80",
  A200: "#ff5252",
  A400: "#ff1744",
  A700: "#d50000"
}, yo = XR, ZR = {
  50: "#fff3e0",
  100: "#ffe0b2",
  200: "#ffcc80",
  300: "#ffb74d",
  400: "#ffa726",
  500: "#ff9800",
  600: "#fb8c00",
  700: "#f57c00",
  800: "#ef6c00",
  900: "#e65100",
  A100: "#ffd180",
  A200: "#ffab40",
  A400: "#ff9100",
  A700: "#ff6d00"
}, qa = ZR, QR = {
  50: "#e3f2fd",
  100: "#bbdefb",
  200: "#90caf9",
  300: "#64b5f6",
  400: "#42a5f5",
  500: "#2196f3",
  600: "#1e88e5",
  700: "#1976d2",
  800: "#1565c0",
  900: "#0d47a1",
  A100: "#82b1ff",
  A200: "#448aff",
  A400: "#2979ff",
  A700: "#2962ff"
}, Eo = QR, eO = {
  50: "#e1f5fe",
  100: "#b3e5fc",
  200: "#81d4fa",
  300: "#4fc3f7",
  400: "#29b6f6",
  500: "#03a9f4",
  600: "#039be5",
  700: "#0288d1",
  800: "#0277bd",
  900: "#01579b",
  A100: "#80d8ff",
  A200: "#40c4ff",
  A400: "#00b0ff",
  A700: "#0091ea"
}, Co = eO, tO = {
  50: "#e8f5e9",
  100: "#c8e6c9",
  200: "#a5d6a7",
  300: "#81c784",
  400: "#66bb6a",
  500: "#4caf50",
  600: "#43a047",
  700: "#388e3c",
  800: "#2e7d32",
  900: "#1b5e20",
  A100: "#b9f6ca",
  A200: "#69f0ae",
  A400: "#00e676",
  A700: "#00c853"
}, So = tO, nO = ["mode", "contrastThreshold", "tonalOffset"], Nv = {
  // The colors used to style the text.
  text: {
    // The most important text.
    primary: "rgba(0, 0, 0, 0.87)",
    // Secondary text.
    secondary: "rgba(0, 0, 0, 0.6)",
    // Disabled text have even lower visual prominence.
    disabled: "rgba(0, 0, 0, 0.38)"
  },
  // The color used to divide different elements.
  divider: "rgba(0, 0, 0, 0.12)",
  // The background colors used to style the surfaces.
  // Consistency between these values is important.
  background: {
    paper: pl.white,
    default: pl.white
  },
  // The colors used to style the action elements.
  action: {
    // The color of an active action like an icon button.
    active: "rgba(0, 0, 0, 0.54)",
    // The color of an hovered action.
    hover: "rgba(0, 0, 0, 0.04)",
    hoverOpacity: 0.04,
    // The color of a selected action.
    selected: "rgba(0, 0, 0, 0.08)",
    selectedOpacity: 0.08,
    // The color of a disabled action.
    disabled: "rgba(0, 0, 0, 0.26)",
    // The background color of a disabled action.
    disabledBackground: "rgba(0, 0, 0, 0.12)",
    disabledOpacity: 0.38,
    focus: "rgba(0, 0, 0, 0.12)",
    focusOpacity: 0.12,
    activatedOpacity: 0.12
  }
}, lm = {
  text: {
    primary: pl.white,
    secondary: "rgba(255, 255, 255, 0.7)",
    disabled: "rgba(255, 255, 255, 0.5)",
    icon: "rgba(255, 255, 255, 0.5)"
  },
  divider: "rgba(255, 255, 255, 0.12)",
  background: {
    paper: "#121212",
    default: "#121212"
  },
  action: {
    active: pl.white,
    hover: "rgba(255, 255, 255, 0.08)",
    hoverOpacity: 0.08,
    selected: "rgba(255, 255, 255, 0.16)",
    selectedOpacity: 0.16,
    disabled: "rgba(255, 255, 255, 0.3)",
    disabledBackground: "rgba(255, 255, 255, 0.12)",
    disabledOpacity: 0.38,
    focus: "rgba(255, 255, 255, 0.12)",
    focusOpacity: 0.12,
    activatedOpacity: 0.24
  }
};
function Dv(i, e, t, n) {
  const r = n.light || n, s = n.dark || n * 1.5;
  i[e] || (i.hasOwnProperty(t) ? i[e] = i[t] : e === "light" ? i.light = qd(i.main, r) : e === "dark" && (i.dark = Hd(i.main, s)));
}
function iO(i = "light") {
  return i === "dark" ? {
    main: Eo[200],
    light: Eo[50],
    dark: Eo[400]
  } : {
    main: Eo[700],
    light: Eo[400],
    dark: Eo[800]
  };
}
function rO(i = "light") {
  return i === "dark" ? {
    main: bo[200],
    light: bo[50],
    dark: bo[400]
  } : {
    main: bo[500],
    light: bo[300],
    dark: bo[700]
  };
}
function sO(i = "light") {
  return i === "dark" ? {
    main: yo[500],
    light: yo[300],
    dark: yo[700]
  } : {
    main: yo[700],
    light: yo[400],
    dark: yo[800]
  };
}
function oO(i = "light") {
  return i === "dark" ? {
    main: Co[400],
    light: Co[300],
    dark: Co[700]
  } : {
    main: Co[700],
    light: Co[500],
    dark: Co[900]
  };
}
function aO(i = "light") {
  return i === "dark" ? {
    main: So[400],
    light: So[300],
    dark: So[700]
  } : {
    main: So[800],
    light: So[500],
    dark: So[900]
  };
}
function lO(i = "light") {
  return i === "dark" ? {
    main: qa[400],
    light: qa[300],
    dark: qa[700]
  } : {
    main: "#ed6c02",
    // closest to orange[800] that pass 3:1.
    light: qa[500],
    dark: qa[900]
  };
}
function cO(i) {
  const {
    mode: e = "light",
    contrastThreshold: t = 3,
    tonalOffset: n = 0.2
  } = i, r = $n(i, nO), s = i.primary || iO(e), o = i.secondary || rO(e), l = i.error || sO(e), u = i.info || oO(e), h = i.success || aO(e), f = i.warning || lO(e);
  function m(S) {
    const x = qm(S, lm.text.primary) >= t ? lm.text.primary : Nv.text.primary;
    if (process.env.NODE_ENV !== "production") {
      const N = qm(S, x);
      N < 3 && console.error([`MUI: The contrast ratio of ${N}:1 for ${x} on ${S}`, "falls below the WCAG recommended absolute minimum contrast ratio of 3:1.", "https://www.w3.org/TR/2008/REC-WCAG20-20081211/#visual-audio-contrast-contrast"].join(`
`));
    }
    return x;
  }
  const v = ({
    color: S,
    name: x,
    mainShade: N = 500,
    lightShade: y = 300,
    darkShade: A = 700
  }) => {
    if (S = Ae({}, S), !S.main && S[N] && (S.main = S[N]), !S.hasOwnProperty("main"))
      throw new Error(process.env.NODE_ENV !== "production" ? `MUI: The color${x ? ` (${x})` : ""} provided to augmentColor(color) is invalid.
The color object needs to have a \`main\` property or a \`${N}\` property.` : Pi(11, x ? ` (${x})` : "", N));
    if (typeof S.main != "string")
      throw new Error(process.env.NODE_ENV !== "production" ? `MUI: The color${x ? ` (${x})` : ""} provided to augmentColor(color) is invalid.
\`color.main\` should be a string, but \`${JSON.stringify(S.main)}\` was provided instead.

Did you intend to use one of the following approaches?

import { green } from "@mui/material/colors";

const theme1 = createTheme({ palette: {
  primary: green,
} });

const theme2 = createTheme({ palette: {
  primary: { main: green[500] },
} });` : Pi(12, x ? ` (${x})` : "", JSON.stringify(S.main)));
    return Dv(S, "light", y, n), Dv(S, "dark", A, n), S.contrastText || (S.contrastText = m(S.main)), S;
  }, C = {
    dark: lm,
    light: Nv
  };
  return process.env.NODE_ENV !== "production" && (C[e] || console.error(`MUI: The palette mode \`${e}\` is not supported.`)), ki(Ae({
    // A collection of common colors.
    common: Ae({}, pl),
    // prevent mutable object.
    // The palette mode, can be light or dark.
    mode: e,
    // The colors used to represent primary interface elements for a user.
    primary: v({
      color: s,
      name: "primary"
    }),
    // The colors used to represent secondary interface elements for a user.
    secondary: v({
      color: o,
      name: "secondary",
      mainShade: "A400",
      lightShade: "A200",
      darkShade: "A700"
    }),
    // The colors used to represent interface elements that the user should be made aware of.
    error: v({
      color: l,
      name: "error"
    }),
    // The colors used to represent potentially dangerous actions or important messages.
    warning: v({
      color: f,
      name: "warning"
    }),
    // The colors used to present information to the user that is neutral and not necessarily important.
    info: v({
      color: u,
      name: "info"
    }),
    // The colors used to indicate the successful completion of an action that user triggered.
    success: v({
      color: h,
      name: "success"
    }),
    // The grey colors.
    grey: YR,
    // Used by `getContrastText()` to maximize the contrast between
    // the background and the text.
    contrastThreshold: t,
    // Takes a background color and returns the text color that maximizes the contrast.
    getContrastText: m,
    // Generate a rich color object.
    augmentColor: v,
    // Used by the functions below to shift a color's luminance by approximately
    // two indexes within its tonal palette.
    // E.g., shift from Red 500 to Red 300 or Red 700.
    tonalOffset: n
  }, C[e]), r);
}
const uO = ["fontFamily", "fontSize", "fontWeightLight", "fontWeightRegular", "fontWeightMedium", "fontWeightBold", "htmlFontSize", "allVariants", "pxToRem"];
function dO(i) {
  return Math.round(i * 1e5) / 1e5;
}
const Bv = {
  textTransform: "uppercase"
}, Vv = '"Roboto", "Helvetica", "Arial", sans-serif';
function Vg(i, e) {
  const t = typeof e == "function" ? e(i) : e, {
    fontFamily: n = Vv,
    // The default font size of the Material Specification.
    fontSize: r = 14,
    // px
    fontWeightLight: s = 300,
    fontWeightRegular: o = 400,
    fontWeightMedium: l = 500,
    fontWeightBold: u = 700,
    // Tell MUI what's the font-size on the html element.
    // 16px is the default font-size used by browsers.
    htmlFontSize: h = 16,
    // Apply the CSS properties to all the variants.
    allVariants: f,
    pxToRem: m
  } = t, v = $n(t, uO);
  process.env.NODE_ENV !== "production" && (typeof r != "number" && console.error("MUI: `fontSize` is required to be a number."), typeof h != "number" && console.error("MUI: `htmlFontSize` is required to be a number."));
  const C = r / 14, k = m || ((N) => `${N / h * C}rem`), S = (N, y, A, P, E) => Ae({
    fontFamily: n,
    fontWeight: N,
    fontSize: k(y),
    // Unitless following https://meyerweb.com/eric/thoughts/2006/02/08/unitless-line-heights/
    lineHeight: A
  }, n === Vv ? {
    letterSpacing: `${dO(P / y)}em`
  } : {}, E, f), x = {
    h1: S(s, 96, 1.167, -1.5),
    h2: S(s, 60, 1.2, -0.5),
    h3: S(o, 48, 1.167, 0),
    h4: S(o, 34, 1.235, 0.25),
    h5: S(o, 24, 1.334, 0),
    h6: S(l, 20, 1.6, 0.15),
    subtitle1: S(o, 16, 1.75, 0.15),
    subtitle2: S(l, 14, 1.57, 0.1),
    body1: S(o, 16, 1.5, 0.15),
    body2: S(o, 14, 1.43, 0.15),
    button: S(l, 14, 1.75, 0.4, Bv),
    caption: S(o, 12, 1.66, 0.4),
    overline: S(o, 12, 2.66, 1, Bv)
  };
  return ki(Ae({
    htmlFontSize: h,
    pxToRem: k,
    fontFamily: n,
    fontSize: r,
    fontWeightLight: s,
    fontWeightRegular: o,
    fontWeightMedium: l,
    fontWeightBold: u
  }, x), v, {
    clone: !1
    // No need to clone deep
  });
}
const hO = 0.2, fO = 0.14, mO = 0.12;
function Vt(...i) {
  return [`${i[0]}px ${i[1]}px ${i[2]}px ${i[3]}px rgba(0,0,0,${hO})`, `${i[4]}px ${i[5]}px ${i[6]}px ${i[7]}px rgba(0,0,0,${fO})`, `${i[8]}px ${i[9]}px ${i[10]}px ${i[11]}px rgba(0,0,0,${mO})`].join(",");
}
const gO = ["none", Vt(0, 2, 1, -1, 0, 1, 1, 0, 0, 1, 3, 0), Vt(0, 3, 1, -2, 0, 2, 2, 0, 0, 1, 5, 0), Vt(0, 3, 3, -2, 0, 3, 4, 0, 0, 1, 8, 0), Vt(0, 2, 4, -1, 0, 4, 5, 0, 0, 1, 10, 0), Vt(0, 3, 5, -1, 0, 5, 8, 0, 0, 1, 14, 0), Vt(0, 3, 5, -1, 0, 6, 10, 0, 0, 1, 18, 0), Vt(0, 4, 5, -2, 0, 7, 10, 1, 0, 2, 16, 1), Vt(0, 5, 5, -3, 0, 8, 10, 1, 0, 3, 14, 2), Vt(0, 5, 6, -3, 0, 9, 12, 1, 0, 3, 16, 2), Vt(0, 6, 6, -3, 0, 10, 14, 1, 0, 4, 18, 3), Vt(0, 6, 7, -4, 0, 11, 15, 1, 0, 4, 20, 3), Vt(0, 7, 8, -4, 0, 12, 17, 2, 0, 5, 22, 4), Vt(0, 7, 8, -4, 0, 13, 19, 2, 0, 5, 24, 4), Vt(0, 7, 9, -4, 0, 14, 21, 2, 0, 5, 26, 4), Vt(0, 8, 9, -5, 0, 15, 22, 2, 0, 6, 28, 5), Vt(0, 8, 10, -5, 0, 16, 24, 2, 0, 6, 30, 5), Vt(0, 8, 11, -5, 0, 17, 26, 2, 0, 6, 32, 5), Vt(0, 9, 11, -5, 0, 18, 28, 2, 0, 7, 34, 6), Vt(0, 9, 12, -6, 0, 19, 29, 2, 0, 7, 36, 6), Vt(0, 10, 13, -6, 0, 20, 31, 3, 0, 8, 38, 7), Vt(0, 10, 13, -6, 0, 21, 33, 3, 0, 8, 40, 7), Vt(0, 10, 14, -6, 0, 22, 35, 3, 0, 8, 42, 7), Vt(0, 11, 14, -7, 0, 23, 36, 3, 0, 9, 44, 8), Vt(0, 11, 15, -7, 0, 24, 38, 3, 0, 9, 46, 8)], pO = gO, _O = ["duration", "easing", "delay"], ly = {
  // This is the most common easing curve.
  easeInOut: "cubic-bezier(0.4, 0, 0.2, 1)",
  // Objects enter the screen at full velocity from off-screen and
  // slowly decelerate to a resting point.
  easeOut: "cubic-bezier(0.0, 0, 0.2, 1)",
  // Objects leave the screen at full velocity. They do not decelerate when off-screen.
  easeIn: "cubic-bezier(0.4, 0, 1, 1)",
  // The sharp curve is used by objects that may return to the screen at any time.
  sharp: "cubic-bezier(0.4, 0, 0.6, 1)"
}, cy = {
  shortest: 150,
  shorter: 200,
  short: 250,
  // most basic recommended timing
  standard: 300,
  // this is to be used in complex animations
  complex: 375,
  // recommended when something is entering screen
  enteringScreen: 225,
  // recommended when something is leaving screen
  leavingScreen: 195
};
function Lv(i) {
  return `${Math.round(i)}ms`;
}
function vO(i) {
  if (!i)
    return 0;
  const e = i / 36;
  return Math.round((4 + 15 * e ** 0.25 + e / 5) * 10);
}
function wO(i) {
  const e = Ae({}, ly, i.easing), t = Ae({}, cy, i.duration);
  return Ae({
    getAutoHeightDuration: vO,
    create: (r = ["all"], s = {}) => {
      const {
        duration: o = t.standard,
        easing: l = e.easeInOut,
        delay: u = 0
      } = s, h = $n(s, _O);
      if (process.env.NODE_ENV !== "production") {
        const f = (v) => typeof v == "string", m = (v) => !isNaN(parseFloat(v));
        !f(r) && !Array.isArray(r) && console.error('MUI: Argument "props" must be a string or Array.'), !m(o) && !f(o) && console.error(`MUI: Argument "duration" must be a number or a string but found ${o}.`), f(l) || console.error('MUI: Argument "easing" must be a string.'), !m(u) && !f(u) && console.error('MUI: Argument "delay" must be a number or a string.'), Object.keys(h).length !== 0 && console.error(`MUI: Unrecognized argument(s) [${Object.keys(h).join(",")}].`);
      }
      return (Array.isArray(r) ? r : [r]).map((f) => `${f} ${typeof o == "string" ? o : Lv(o)} ${l} ${typeof u == "string" ? u : Lv(u)}`).join(",");
    }
  }, i, {
    easing: e,
    duration: t
  });
}
const bO = {
  mobileStepper: 1e3,
  fab: 1050,
  speedDial: 1050,
  appBar: 1100,
  drawer: 1200,
  modal: 1300,
  snackbar: 1400,
  tooltip: 1500
}, yO = bO, EO = ["breakpoints", "mixins", "spacing", "palette", "transitions", "typography", "shape"];
function Lo(i = {}, ...e) {
  const {
    mixins: t = {},
    palette: n = {},
    transitions: r = {},
    typography: s = {}
  } = i, o = $n(i, EO);
  if (i.vars)
    throw new Error(process.env.NODE_ENV !== "production" ? "MUI: `vars` is a private field used for CSS variables support.\nPlease use another name." : Pi(18));
  const l = cO(n), u = Rg(i);
  let h = ki(u, {
    mixins: qR(u.breakpoints, t),
    palette: l,
    // Don't use [...shadows] until you've verified its transpiled code is not invoking the iterator protocol.
    shadows: pO.slice(),
    typography: Vg(l, s),
    transitions: wO(r),
    zIndex: Ae({}, yO)
  });
  if (h = ki(h, o), h = e.reduce((f, m) => ki(f, m), h), process.env.NODE_ENV !== "production") {
    const f = ["active", "checked", "completed", "disabled", "error", "expanded", "focused", "focusVisible", "required", "selected"], m = (v, C) => {
      let k;
      for (k in v) {
        const S = v[k];
        if (f.indexOf(k) !== -1 && Object.keys(S).length > 0) {
          if (process.env.NODE_ENV !== "production") {
            const x = m5("", k);
            console.error([`MUI: The \`${C}\` component increases the CSS specificity of the \`${k}\` internal state.`, "You can not override it like this: ", JSON.stringify(v, null, 2), "", `Instead, you need to use the '&.${x}' syntax:`, JSON.stringify({
              root: {
                [`&.${x}`]: S
              }
            }, null, 2), "", "https://mui.com/r/state-classes-guide"].join(`
`));
          }
          v[k] = {};
        }
      }
    };
    Object.keys(h.components).forEach((v) => {
      const C = h.components[v].styleOverrides;
      C && v.indexOf("Mui") === 0 && m(C, v);
    });
  }
  return h.unstable_sxConfig = Ae({}, Ud, o?.unstable_sxConfig), h.unstable_sx = function(m) {
    return Ol({
      sx: m,
      theme: this
    });
  }, h;
}
let Fv = !1;
function CO(...i) {
  return process.env.NODE_ENV !== "production" && (Fv || (Fv = !0, console.error(["MUI: the createMuiTheme function was renamed to createTheme.", "", "You should use `import { createTheme } from '@mui/material/styles'`"].join(`
`)))), Lo(...i);
}
function SO(i, ...e) {
  return Lo(ki({
    unstable_strictMode: !0
  }, i), ...e);
}
let $v = !1;
function TO(i) {
  return $v || (console.warn(["MUI: createStyles from @mui/material/styles is deprecated.", "Please use @mui/styles/createStyles"].join(`
`)), $v = !0), i;
}
function zv(i) {
  return String(parseFloat(i)).length === String(i).length;
}
function uy(i) {
  return String(i).match(/[\d.\-+]*\s*(.*)/)[1] || "";
}
function Xr(i) {
  return parseFloat(i);
}
function xO(i) {
  return (e, t) => {
    const n = uy(e);
    if (n === t)
      return e;
    let r = Xr(e);
    n !== "px" && (n === "em" || n === "rem") && (r = Xr(e) * Xr(i));
    let s = r;
    if (t !== "px")
      if (t === "em")
        s = r / Xr(i);
      else if (t === "rem")
        s = r / Xr(i);
      else
        return e;
    return parseFloat(s.toFixed(5)) + t;
  };
}
function kO({
  size: i,
  grid: e
}) {
  const t = i - i % e, n = t + e;
  return i - t < n - i ? t : n;
}
function AO({
  lineHeight: i,
  pixels: e,
  htmlFontSize: t
}) {
  return e / (i * t);
}
function PO({
  cssProperty: i,
  min: e,
  max: t,
  unit: n = "rem",
  breakpoints: r = [600, 900, 1200],
  transform: s = null
}) {
  const o = {
    [i]: `${e}${n}`
  }, l = (t - e) / r[r.length - 1];
  return r.forEach((u) => {
    let h = e + l * u;
    s !== null && (h = s(h)), o[`@media (min-width:${u}px)`] = {
      [i]: `${Math.round(h * 1e4) / 1e4}${n}`
    };
  }), o;
}
function IO(i, e = {}) {
  const {
    breakpoints: t = ["sm", "md", "lg"],
    disableAlign: n = !1,
    factor: r = 2,
    variants: s = ["h1", "h2", "h3", "h4", "h5", "h6", "subtitle1", "subtitle2", "body1", "body2", "caption", "button", "overline"]
  } = e, o = Ae({}, i);
  o.typography = Ae({}, o.typography);
  const l = o.typography, u = xO(l.htmlFontSize), h = t.map((f) => o.breakpoints.values[f]);
  return s.forEach((f) => {
    const m = l[f], v = parseFloat(u(m.fontSize, "rem"));
    if (v <= 1)
      return;
    const C = v, k = 1 + (C - 1) / r;
    let {
      lineHeight: S
    } = m;
    if (!zv(S) && !n)
      throw new Error(process.env.NODE_ENV !== "production" ? `MUI: Unsupported non-unitless line height with grid alignment.
Use unitless line heights instead.` : Pi(6));
    zv(S) || (S = parseFloat(u(S, "rem")) / parseFloat(v));
    let x = null;
    n || (x = (N) => kO({
      size: N,
      grid: AO({
        pixels: 4,
        lineHeight: S,
        htmlFontSize: l.htmlFontSize
      })
    })), l[f] = Ae({}, m, PO({
      cssProperty: "fontSize",
      min: k,
      max: C,
      unit: "rem",
      breakpoints: h,
      transform: x
    }));
  }), o;
}
const RO = Lo(), Lg = RO;
function OO() {
  const i = Mg(Lg);
  return process.env.NODE_ENV !== "production" && Ht.useDebugValue(i), i;
}
function MO({
  props: i,
  name: e
}) {
  return kR({
    props: i,
    name: e,
    defaultTheme: Lg
  });
}
const NO = (i) => Ju(i) && i !== "classes", DO = TR({
  defaultTheme: Lg,
  rootShouldForwardProp: NO
}), Wv = DO;
function BO() {
  throw new Error(process.env.NODE_ENV !== "production" ? `MUI: makeStyles is no longer exported from @mui/material/styles.
You have to import it from @mui/styles.
See https://mui.com/r/migration-v4/#mui-material-styles for more details.` : Pi(14));
}
function VO() {
  throw new Error(process.env.NODE_ENV !== "production" ? `MUI: withStyles is no longer exported from @mui/material/styles.
You have to import it from @mui/styles.
See https://mui.com/r/migration-v4/#mui-material-styles for more details.` : Pi(15));
}
function LO() {
  throw new Error(process.env.NODE_ENV !== "production" ? `MUI: withTheme is no longer exported from @mui/material/styles.
You have to import it from @mui/styles.
See https://mui.com/r/migration-v4/#mui-material-styles for more details.` : Pi(16));
}
const FO = (i) => {
  let e;
  return i < 1 ? e = 5.11916 * i ** 2 : e = 4.5 * Math.log(i + 1) + 2, (e / 100).toFixed(2);
}, dy = FO, $O = ["colorSchemes", "cssVarPrefix"], zO = ["palette"], WO = [...Array(25)].map((i, e) => {
  if (e === 0)
    return;
  const t = dy(e);
  return `linear-gradient(rgba(255 255 255 / ${t}), rgba(255 255 255 / ${t}))`;
});
function jO(i, e) {
  e.forEach((t) => {
    i[t] || (i[t] = {});
  });
}
function Q(i, e, t) {
  !i[e] && t && (i[e] = t);
}
const Zi = (i) => {
  try {
    return i();
  } catch {
  }
}, UO = (i = "mui") => WR(i);
function hy(i = {}, ...e) {
  var t, n, r, s, o, l;
  const {
    colorSchemes: u = {},
    cssVarPrefix: h = "mui"
  } = i, f = $n(i, $O), m = UO(h), v = Lo(Ae({}, f, u.light && {
    palette: (t = u.light) == null ? void 0 : t.palette
  })), {
    palette: C
  } = v, k = $n(v, zO), {
    palette: S
  } = Lo({
    palette: Ae({
      mode: "dark"
    }, (n = u.dark) == null ? void 0 : n.palette)
  });
  let x = Ae({}, k, {
    cssVarPrefix: h,
    getCssVar: m,
    colorSchemes: Ae({}, u, {
      light: Ae({}, u.light, {
        palette: C,
        opacity: Ae({
          inputPlaceholder: 0.42,
          inputUnderline: 0.42,
          switchTrackDisabled: 0.12,
          switchTrack: 0.38
        }, (r = u.light) == null ? void 0 : r.opacity),
        overlays: ((s = u.light) == null ? void 0 : s.overlays) || []
      }),
      dark: Ae({}, u.dark, {
        palette: S,
        opacity: Ae({
          inputPlaceholder: 0.5,
          inputUnderline: 0.7,
          switchTrackDisabled: 0.2,
          switchTrack: 0.3
        }, (o = u.dark) == null ? void 0 : o.opacity),
        overlays: ((l = u.dark) == null ? void 0 : l.overlays) || WO
      })
    })
  });
  return Object.keys(x.colorSchemes).forEach((N) => {
    const y = x.colorSchemes[N].palette;
    if (N === "light" ? (Q(y.common, "background", "#fff"), Q(y.common, "onBackground", "#000")) : (Q(y.common, "background", "#000"), Q(y.common, "onBackground", "#fff")), jO(y, ["Alert", "AppBar", "Avatar", "Chip", "FilledInput", "LinearProgress", "Skeleton", "Slider", "SnackbarContent", "SpeedDialAction", "StepConnector", "StepContent", "Switch", "TableCell", "Tooltip"]), N === "light") {
      Q(y.Alert, "errorColor", St(y.error.light, 0.6)), Q(y.Alert, "infoColor", St(y.info.light, 0.6)), Q(y.Alert, "successColor", St(y.success.light, 0.6)), Q(y.Alert, "warningColor", St(y.warning.light, 0.6)), Q(y.Alert, "errorFilledBg", m("palette-error-main")), Q(y.Alert, "infoFilledBg", m("palette-info-main")), Q(y.Alert, "successFilledBg", m("palette-success-main")), Q(y.Alert, "warningFilledBg", m("palette-warning-main")), Q(y.Alert, "errorFilledColor", Zi(() => C.getContrastText(y.error.main))), Q(y.Alert, "infoFilledColor", Zi(() => C.getContrastText(y.info.main))), Q(y.Alert, "successFilledColor", Zi(() => C.getContrastText(y.success.main))), Q(y.Alert, "warningFilledColor", Zi(() => C.getContrastText(y.warning.main))), Q(y.Alert, "errorStandardBg", Tt(y.error.light, 0.9)), Q(y.Alert, "infoStandardBg", Tt(y.info.light, 0.9)), Q(y.Alert, "successStandardBg", Tt(y.success.light, 0.9)), Q(y.Alert, "warningStandardBg", Tt(y.warning.light, 0.9)), Q(y.Alert, "errorIconColor", m("palette-error-main")), Q(y.Alert, "infoIconColor", m("palette-info-main")), Q(y.Alert, "successIconColor", m("palette-success-main")), Q(y.Alert, "warningIconColor", m("palette-warning-main")), Q(y.AppBar, "defaultBg", m("palette-grey-100")), Q(y.Avatar, "defaultBg", m("palette-grey-400")), Q(y.Chip, "defaultBorder", m("palette-grey-400")), Q(y.Chip, "defaultAvatarColor", m("palette-grey-700")), Q(y.Chip, "defaultIconColor", m("palette-grey-700")), Q(y.FilledInput, "bg", "rgba(0, 0, 0, 0.06)"), Q(y.FilledInput, "hoverBg", "rgba(0, 0, 0, 0.09)"), Q(y.FilledInput, "disabledBg", "rgba(0, 0, 0, 0.12)"), Q(y.LinearProgress, "primaryBg", Tt(y.primary.main, 0.62)), Q(y.LinearProgress, "secondaryBg", Tt(y.secondary.main, 0.62)), Q(y.LinearProgress, "errorBg", Tt(y.error.main, 0.62)), Q(y.LinearProgress, "infoBg", Tt(y.info.main, 0.62)), Q(y.LinearProgress, "successBg", Tt(y.success.main, 0.62)), Q(y.LinearProgress, "warningBg", Tt(y.warning.main, 0.62)), Q(y.Skeleton, "bg", `rgba(${m("palette-text-primaryChannel")} / 0.11)`), Q(y.Slider, "primaryTrack", Tt(y.primary.main, 0.62)), Q(y.Slider, "secondaryTrack", Tt(y.secondary.main, 0.62)), Q(y.Slider, "errorTrack", Tt(y.error.main, 0.62)), Q(y.Slider, "infoTrack", Tt(y.info.main, 0.62)), Q(y.Slider, "successTrack", Tt(y.success.main, 0.62)), Q(y.Slider, "warningTrack", Tt(y.warning.main, 0.62));
      const A = il(y.background.default, 0.8);
      Q(y.SnackbarContent, "bg", A), Q(y.SnackbarContent, "color", Zi(() => C.getContrastText(A))), Q(y.SpeedDialAction, "fabHoverBg", il(y.background.paper, 0.15)), Q(y.StepConnector, "border", m("palette-grey-400")), Q(y.StepContent, "border", m("palette-grey-400")), Q(y.Switch, "defaultColor", m("palette-common-white")), Q(y.Switch, "defaultDisabledColor", m("palette-grey-100")), Q(y.Switch, "primaryDisabledColor", Tt(y.primary.main, 0.62)), Q(y.Switch, "secondaryDisabledColor", Tt(y.secondary.main, 0.62)), Q(y.Switch, "errorDisabledColor", Tt(y.error.main, 0.62)), Q(y.Switch, "infoDisabledColor", Tt(y.info.main, 0.62)), Q(y.Switch, "successDisabledColor", Tt(y.success.main, 0.62)), Q(y.Switch, "warningDisabledColor", Tt(y.warning.main, 0.62)), Q(y.TableCell, "border", Tt(Mu(y.divider, 1), 0.88)), Q(y.Tooltip, "bg", Mu(y.grey[700], 0.92));
    } else {
      Q(y.Alert, "errorColor", Tt(y.error.light, 0.6)), Q(y.Alert, "infoColor", Tt(y.info.light, 0.6)), Q(y.Alert, "successColor", Tt(y.success.light, 0.6)), Q(y.Alert, "warningColor", Tt(y.warning.light, 0.6)), Q(y.Alert, "errorFilledBg", m("palette-error-dark")), Q(y.Alert, "infoFilledBg", m("palette-info-dark")), Q(y.Alert, "successFilledBg", m("palette-success-dark")), Q(y.Alert, "warningFilledBg", m("palette-warning-dark")), Q(y.Alert, "errorFilledColor", Zi(() => S.getContrastText(y.error.dark))), Q(y.Alert, "infoFilledColor", Zi(() => S.getContrastText(y.info.dark))), Q(y.Alert, "successFilledColor", Zi(() => S.getContrastText(y.success.dark))), Q(y.Alert, "warningFilledColor", Zi(() => S.getContrastText(y.warning.dark))), Q(y.Alert, "errorStandardBg", St(y.error.light, 0.9)), Q(y.Alert, "infoStandardBg", St(y.info.light, 0.9)), Q(y.Alert, "successStandardBg", St(y.success.light, 0.9)), Q(y.Alert, "warningStandardBg", St(y.warning.light, 0.9)), Q(y.Alert, "errorIconColor", m("palette-error-main")), Q(y.Alert, "infoIconColor", m("palette-info-main")), Q(y.Alert, "successIconColor", m("palette-success-main")), Q(y.Alert, "warningIconColor", m("palette-warning-main")), Q(y.AppBar, "defaultBg", m("palette-grey-900")), Q(y.AppBar, "darkBg", m("palette-background-paper")), Q(y.AppBar, "darkColor", m("palette-text-primary")), Q(y.Avatar, "defaultBg", m("palette-grey-600")), Q(y.Chip, "defaultBorder", m("palette-grey-700")), Q(y.Chip, "defaultAvatarColor", m("palette-grey-300")), Q(y.Chip, "defaultIconColor", m("palette-grey-300")), Q(y.FilledInput, "bg", "rgba(255, 255, 255, 0.09)"), Q(y.FilledInput, "hoverBg", "rgba(255, 255, 255, 0.13)"), Q(y.FilledInput, "disabledBg", "rgba(255, 255, 255, 0.12)"), Q(y.LinearProgress, "primaryBg", St(y.primary.main, 0.5)), Q(y.LinearProgress, "secondaryBg", St(y.secondary.main, 0.5)), Q(y.LinearProgress, "errorBg", St(y.error.main, 0.5)), Q(y.LinearProgress, "infoBg", St(y.info.main, 0.5)), Q(y.LinearProgress, "successBg", St(y.success.main, 0.5)), Q(y.LinearProgress, "warningBg", St(y.warning.main, 0.5)), Q(y.Skeleton, "bg", `rgba(${m("palette-text-primaryChannel")} / 0.13)`), Q(y.Slider, "primaryTrack", St(y.primary.main, 0.5)), Q(y.Slider, "secondaryTrack", St(y.secondary.main, 0.5)), Q(y.Slider, "errorTrack", St(y.error.main, 0.5)), Q(y.Slider, "infoTrack", St(y.info.main, 0.5)), Q(y.Slider, "successTrack", St(y.success.main, 0.5)), Q(y.Slider, "warningTrack", St(y.warning.main, 0.5));
      const A = il(y.background.default, 0.98);
      Q(y.SnackbarContent, "bg", A), Q(y.SnackbarContent, "color", Zi(() => S.getContrastText(A))), Q(y.SpeedDialAction, "fabHoverBg", il(y.background.paper, 0.15)), Q(y.StepConnector, "border", m("palette-grey-600")), Q(y.StepContent, "border", m("palette-grey-600")), Q(y.Switch, "defaultColor", m("palette-grey-300")), Q(y.Switch, "defaultDisabledColor", m("palette-grey-600")), Q(y.Switch, "primaryDisabledColor", St(y.primary.main, 0.55)), Q(y.Switch, "secondaryDisabledColor", St(y.secondary.main, 0.55)), Q(y.Switch, "errorDisabledColor", St(y.error.main, 0.55)), Q(y.Switch, "infoDisabledColor", St(y.info.main, 0.55)), Q(y.Switch, "successDisabledColor", St(y.success.main, 0.55)), Q(y.Switch, "warningDisabledColor", St(y.warning.main, 0.55)), Q(y.TableCell, "border", St(Mu(y.divider, 1), 0.68)), Q(y.Tooltip, "bg", Mu(y.grey[700], 0.92));
    }
    Q(y.background, "defaultChannel", Ti(y.background.default, "MUI: The value of `palette.background.default` should be one of these formats: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla(), color().")), Q(y.common, "backgroundChannel", Ti(y.common.background, "MUI: The value of `palette.common.background` should be one of these formats: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla(), color().")), Q(y.common, "onBackgroundChannel", Ti(y.common.onBackground, "MUI: The value of `palette.common.onBackground` should be one of these formats: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla(), color().")), Q(y, "dividerChannel", Ti(y.divider, "MUI: The value of `palette.divider` should be one of these formats: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla(), color().")), Object.keys(y).forEach((A) => {
      const P = y[A];
      P && typeof P == "object" && (P.main && Q(y[A], "mainChannel", Ti(P.main)), P.light && Q(y[A], "lightChannel", Ti(P.light)), P.dark && Q(y[A], "darkChannel", Ti(P.dark)), P.contrastText && Q(y[A], "contrastTextChannel", Ti(P.contrastText)), A === "text" && (Q(y[A], "primaryChannel", Ti(P.primary, "MUI: The value of `palette.text.primary` should be one of these formats: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla(), color().")), Q(y[A], "secondaryChannel", Ti(P.secondary, "MUI: The value of `palette.text.secondary` should be one of these formats: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla(), color()."))), A === "action" && (P.active && Q(y[A], "activeChannel", Ti(P.active, "MUI: The value of `palette.action.active` should be one of these formats: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla(), color().")), P.selected && Q(y[A], "selectedChannel", Ti(P.selected, "MUI: The value of `palette.action.selected` should be one of these formats: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla(), color()."))));
    });
  }), x = e.reduce((N, y) => ki(N, y), x), x.unstable_sxConfig = Ae({}, Ud, f?.unstable_sxConfig), x.unstable_sx = function(y) {
    return Ol({
      sx: y,
      theme: this
    });
  }, x;
}
const HO = (i) => [...[...Array(24)].map((e, t) => `--${i ? `${i}-` : ""}overlays-${t + 1}`), `--${i ? `${i}-` : ""}palette-AppBar-darkBg`, `--${i ? `${i}-` : ""}palette-AppBar-darkColor`], fy = HO, my = (i) => {
  var e;
  return !!i[0].match(/(typography|mixins|breakpoints|direction|transitions)/) || i[0] === "palette" && !!((e = i[1]) != null && e.match(/(mode|contrastThreshold|tonalOffset)/));
}, qO = hy(), {
  CssVarsProvider: KO,
  useColorScheme: GO,
  getInitColorSchemeScript: YO
} = zR({
  theme: qO,
  attribute: "data-mui-color-scheme",
  modeStorageKey: "mui-mode",
  colorSchemeStorageKey: "mui-color-scheme",
  defaultColorScheme: {
    light: "light",
    dark: "dark"
  },
  resolveTheme: (i) => {
    const e = Ae({}, i, {
      typography: Vg(i.palette, i.typography)
    });
    return e.unstable_sx = function(n) {
      return Ol({
        sx: n,
        theme: this
      });
    }, e;
  },
  shouldSkipGeneratingVar: my,
  excludeVariablesFromRoot: fy
});
function JO() {
  throw new Error(process.env.NODE_ENV !== "production" ? "MUI: The `experimental_sx` has been moved to `theme.unstable_sx`.For more details, see https://github.com/mui/material-ui/pull/35150." : Pi(20));
}
const XO = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Experimental_CssVarsProvider: KO,
  StyledEngineProvider: K0,
  ThemeProvider: gl,
  adaptV4Theme: HR,
  alpha: ry,
  createMuiTheme: CO,
  createStyles: TO,
  createTheme: Lo,
  css: Fi.css,
  darken: Hd,
  decomposeColor: ar,
  duration: cy,
  easing: ly,
  emphasize: RR,
  experimentalStyled: Wv,
  experimental_extendTheme: hy,
  experimental_sx: JO,
  getContrastRatio: qm,
  getInitColorSchemeScript: YO,
  getLuminance: wd,
  getOverlayAlpha: dy,
  hexToRgb: ny,
  hslToRgb: iy,
  keyframes: Fi.keyframes,
  lighten: qd,
  makeStyles: BO,
  private_createTypography: Vg,
  private_excludeVariablesFromRoot: fy,
  recomposeColor: Ml,
  responsiveFontSizes: IO,
  rgbToHex: IR,
  shouldSkipGeneratingVar: my,
  styled: Wv,
  unstable_createMuiStrictModeTheme: SO,
  unstable_getUnit: uy,
  unstable_toUnitless: Xr,
  useColorScheme: GO,
  useTheme: OO,
  useThemeProps: MO,
  withStyles: VO,
  withTheme: LO
}, Symbol.toStringTag, { value: "Module" })), ZO = /* @__PURE__ */ HP(XO);
var gy = {}, Kd = {}, py = {}, Nl = {};
Object.defineProperty(Nl, "__esModule", { value: !0 });
Nl.assert = void 0;
function QO(i, e) {
  if (!i)
    throw new Error(e);
}
Nl.assert = QO;
var Dl = {};
Object.defineProperty(Dl, "__esModule", { value: !0 });
Dl.typeGuard = void 0;
function e3(i, e) {
  return e;
}
Dl.typeGuard = e3;
(function(i) {
  Object.defineProperty(i, "__esModule", { value: !0 }), i.classnames = void 0;
  const e = Nl, t = Dl, n = (r) => {
    const s = r.length;
    let o = 0, l = "";
    for (; o < s; o++) {
      const u = r[o];
      if (u == null)
        continue;
      let h;
      switch (typeof u) {
        case "boolean":
          break;
        case "object": {
          if (Array.isArray(u))
            h = (0, i.classnames)(u);
          else {
            (0, e.assert)(!(0, t.typeGuard)(u, !1)), process.env.NODE_ENV !== "production" && u.styles !== void 0 && u.name !== void 0 && console.error("You have passed styles created with `css` from `@emotion/react` package to the `cx`.\n`cx` is meant to compose class names (strings) so you should convert those styles to a class name by passing them to the `css` received from <ClassNames/> component."), h = "";
            for (const f in u)
              u[f] && f && (h && (h += " "), h += f);
          }
          break;
        }
        default:
          h = u;
      }
      h && (l && (l += " "), l += h);
    }
    return l;
  };
  i.classnames = n;
})(py);
var Gd = {};
Object.defineProperty(Gd, "__esModule", { value: !0 });
Gd.useGuaranteedMemo = void 0;
const t3 = mi;
function n3(i, e) {
  const t = (0, t3.useRef)();
  return (!t.current || e.length !== t.current.prevDeps.length || t.current.prevDeps.map((n, r) => n === e[r]).indexOf(!1) >= 0) && (t.current = {
    v: i(),
    prevDeps: [...e]
  }), t.current.v;
}
Gd.useGuaranteedMemo = n3;
var xi = {}, i3 = et && et.__createBinding || (Object.create ? function(i, e, t, n) {
  n === void 0 && (n = t);
  var r = Object.getOwnPropertyDescriptor(e, t);
  (!r || ("get" in r ? !e.__esModule : r.writable || r.configurable)) && (r = { enumerable: !0, get: function() {
    return e[t];
  } }), Object.defineProperty(i, n, r);
} : function(i, e, t, n) {
  n === void 0 && (n = t), i[n] = e[t];
}), r3 = et && et.__setModuleDefault || (Object.create ? function(i, e) {
  Object.defineProperty(i, "default", { enumerable: !0, value: e });
} : function(i, e) {
  i.default = e;
}), s3 = et && et.__importStar || function(i) {
  if (i && i.__esModule)
    return i;
  var e = {};
  if (i != null)
    for (var t in i)
      t !== "default" && Object.prototype.hasOwnProperty.call(i, t) && i3(e, i, t);
  return r3(e, i), e;
}, o3 = et && et.__importDefault || function(i) {
  return i && i.__esModule ? i : { default: i };
};
Object.defineProperty(xi, "__esModule", { value: !0 });
xi.TssCacheProvider = xi.useTssEmotionCache = xi.getTssDefaultEmotionCache = xi.getDoExistsTssDefaultEmotionCacheMemoizedValue = void 0;
const bd = s3(mi), a3 = o3(Vo), { getDoExistsTssDefaultEmotionCacheMemoizedValue: l3, getTssDefaultEmotionCache: _y, reactContext: vy } = (() => {
  const i = "__tss-react_context", e = (
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    bd.createContext
  );
  let t = e["__tss-react_context"];
  if (t === void 0) {
    const { getTssDefaultEmotionCache: n, getDoExistsTssDefaultEmotionCacheMemoizedValue: r } = (() => {
      let s;
      function o(l) {
        const { doReset: u = !1 } = l ?? {};
        return u && (s = void 0), s === void 0 && (s = (0, a3.default)({ key: "tss" })), s;
      }
      return {
        getTssDefaultEmotionCache: o,
        getDoExistsTssDefaultEmotionCacheMemoizedValue: () => s !== void 0
      };
    })();
    t = {
      getTssDefaultEmotionCache: n,
      getDoExistsTssDefaultEmotionCacheMemoizedValue: r,
      reactContext: (0, bd.createContext)(void 0)
    }, Object.defineProperty(e, i, {
      configurable: !1,
      enumerable: !1,
      writable: !1,
      value: t
    });
  }
  return t;
})();
xi.getDoExistsTssDefaultEmotionCacheMemoizedValue = l3;
xi.getTssDefaultEmotionCache = _y;
function c3() {
  const i = (0, bd.useContext)(vy);
  return i ?? _y();
}
xi.useTssEmotionCache = c3;
function u3(i) {
  const { children: e, value: t } = i;
  return bd.default.createElement(vy.Provider, { value: t }, e);
}
xi.TssCacheProvider = u3;
var Yd = {};
Object.defineProperty(Yd, "__esModule", { value: !0 });
Yd.matchCSSObject = void 0;
function d3(i) {
  return i instanceof Object && !("styles" in i) && !("length" in i) && !("__emotion_styles" in i);
}
Yd.matchCSSObject = d3;
(function(i) {
  Object.defineProperty(i, "__esModule", { value: !0 }), i.useCssAndCx = i.createCssAndCx = void 0;
  const e = py, t = ts, n = or, r = Gd, s = xi, o = Yd;
  i.createCssAndCx = (() => {
    function h(m, v, C) {
      const k = [], S = (0, n.getRegisteredStyles)(m, k, C);
      return k.length < 2 ? C : S + v(k);
    }
    function f(m) {
      const { cache: v } = m, C = (...S) => {
        const x = (0, t.serializeStyles)(S, v.registered);
        (0, n.insertStyles)(v, x, !1);
        const N = `${v.key}-${x.name}`;
        e: {
          const y = S[0];
          if (!(0, o.matchCSSObject)(y))
            break e;
          u.saveClassNameCSSObjectMapping(v, N, y);
        }
        return N;
      };
      return { css: C, cx: (...S) => {
        const x = (0, e.classnames)(S), N = u.fixClassName(v, x, C);
        return h(v.registered, C, N);
      } };
    }
    return { createCssAndCx: f };
  })().createCssAndCx;
  function l() {
    const h = (0, s.useTssEmotionCache)(), { css: f, cx: m } = (0, r.useGuaranteedMemo)(() => (0, i.createCssAndCx)({ cache: h }), [h]);
    return { css: f, cx: m };
  }
  i.useCssAndCx = l;
  const u = (() => {
    const h = /* @__PURE__ */ new WeakMap();
    return {
      saveClassNameCSSObjectMapping: (f, m, v) => {
        let C = h.get(f);
        C === void 0 && (C = /* @__PURE__ */ new Map(), h.set(f, C)), C.set(m, v);
      },
      fixClassName: (() => {
        function f(m) {
          let v = !1;
          return m.map(([C, k]) => {
            if (k === void 0)
              return C;
            let S;
            if (v)
              S = {
                "&&": k
              };
            else {
              S = C;
              for (const x in k)
                if (x.startsWith("@media")) {
                  v = !0;
                  break;
                }
            }
            return S;
          });
        }
        return (m, v, C) => {
          const k = h.get(m);
          return (0, e.classnames)(f(v.split(" ").map((S) => [
            S,
            k?.get(S)
          ])).map((S) => typeof S == "string" ? S : C(S)));
        };
      })()
    };
  })();
})(Kd);
var Vs = {}, Bl = {};
Object.defineProperty(Bl, "__esModule", { value: !0 });
Bl.objectKeys = void 0;
function h3(i) {
  return Object.keys(i);
}
Bl.objectKeys = h3;
var Vl = {};
Object.defineProperty(Vl, "__esModule", { value: !0 });
Vl.getDependencyArrayRef = void 0;
function f3(i) {
  if (!(i instanceof Object) || typeof i == "function")
    return i;
  const e = [];
  for (const t in i) {
    const n = i[t], r = typeof n;
    if (!(r === "string" || r === "number" && !isNaN(n) || r === "boolean" || n === void 0 || n === null))
      return i;
    e.push(`${t}:${r}_${n}`);
  }
  return "xSqLiJdLMd9s" + e.join("|");
}
Vl.getDependencyArrayRef = f3;
Object.defineProperty(Vs, "__esModule", { value: !0 });
Vs.useMergedClasses = Vs.mergeClasses = void 0;
const jv = Bl, m3 = Vl, g3 = Kd, p3 = mi;
function wy(i, e, t) {
  if (!(e instanceof Object))
    return i;
  const n = {};
  return (0, jv.objectKeys)(i).forEach((r) => n[r] = t(i[r], e[r])), (0, jv.objectKeys)(e).forEach((r) => {
    if (r in i)
      return;
    const s = e[r];
    typeof s == "string" && (n[r] = s);
  }), n;
}
Vs.mergeClasses = wy;
function _3(i, e) {
  const { cx: t } = (0, g3.useCssAndCx)();
  return (0, p3.useMemo)(() => wy(i, e, t), [i, (0, m3.getDependencyArrayRef)(e), t]);
}
Vs.useMergedClasses = _3;
var Ll = {}, Jd = {};
Object.defineProperty(Jd, "__esModule", { value: !0 });
Jd.objectFromEntries = void 0;
Jd.objectFromEntries = Object.fromEntries ? Object.fromEntries : (i) => {
  if (!i || !i[Symbol.iterator])
    throw new Error("Object.fromEntries() requires a single iterable argument");
  const e = {};
  return Object.keys(i).forEach((t) => {
    const [n, r] = i[t];
    e[n] = r;
  }), e;
};
Object.defineProperty(Ll, "__esModule", { value: !0 });
Ll.createMakeStyles = void 0;
const Nu = mi, v3 = Jd, Uv = Bl, Hv = Kd, Du = Vl, w3 = Dl, b3 = xi, y3 = Nl, qv = Vs;
let E3 = 0;
function C3(i) {
  const { useTheme: e } = i;
  function t(r) {
    const { name: s, uniqId: o = E3++ } = r ?? {}, l = typeof s != "object" ? s : Object.keys(s)[0];
    return function(u) {
      const h = typeof u == "function" ? u : () => u;
      return function(m, v) {
        var C, k;
        const S = e(), { css: x, cx: N } = (0, Hv.useCssAndCx)(), y = (0, b3.useTssEmotionCache)();
        let A = (0, Nu.useMemo)(() => {
          const E = {}, V = typeof Proxy < "u" && new Proxy({}, {
            get: ($, M) => (typeof M == "symbol" && (0, y3.assert)(!1), E[M] = `${y.key}-${o}${l !== void 0 ? `-${l}` : ""}-${M}-ref`)
          }), j = h(S, m, V || {}), U = (0, v3.objectFromEntries)((0, Uv.objectKeys)(j).map(($) => {
            const M = j[$];
            return M.label || (M.label = `${l !== void 0 ? `${l}-` : ""}${$}`), [
              $,
              `${x(M)}${(0, w3.typeGuard)($, $ in E) ? ` ${E[$]}` : ""}`
            ];
          }));
          return (0, Uv.objectKeys)(E).forEach(($) => {
            $ in U || (U[$] = E[$]);
          }), U;
        }, [y, x, N, S, (0, Du.getDependencyArrayRef)(m)]);
        const P = v?.props.classes;
        A = (0, Nu.useMemo)(() => (0, qv.mergeClasses)(A, P, N), [A, (0, Du.getDependencyArrayRef)(P), N]);
        {
          let E;
          try {
            E = l !== void 0 ? (k = (C = S.components) === null || C === void 0 ? void 0 : C[l]) === null || k === void 0 ? void 0 : k.styleOverrides : void 0;
          } catch {
          }
          const V = (0, Nu.useMemo)(() => {
            if (!E)
              return;
            const j = {};
            for (const U in E) {
              const $ = E[U];
              $ instanceof Object && (j[U] = x(typeof $ == "function" ? $(Object.assign({ theme: S, ownerState: v?.ownerState }, v?.props)) : $));
            }
            return j;
          }, [
            E === void 0 ? void 0 : JSON.stringify(E),
            (0, Du.getDependencyArrayRef)(v?.props),
            (0, Du.getDependencyArrayRef)(v?.ownerState),
            x
          ]);
          A = (0, Nu.useMemo)(() => (0, qv.mergeClasses)(A, V, N), [A, V, N]);
        }
        return {
          classes: A,
          theme: S,
          css: x,
          cx: N
        };
      };
    };
  }
  function n() {
    const r = e(), { css: s, cx: o } = (0, Hv.useCssAndCx)();
    return { theme: r, css: s, cx: o };
  }
  return { makeStyles: t, useStyles: n };
}
Ll.createMakeStyles = C3;
var Xd = {}, Zd = {};
Object.defineProperty(Zd, "__esModule", { value: !0 });
Zd.capitalize = void 0;
function S3(i) {
  return i.charAt(0).toUpperCase() + i.slice(1);
}
Zd.capitalize = S3;
var T3 = et && et.__createBinding || (Object.create ? function(i, e, t, n) {
  n === void 0 && (n = t);
  var r = Object.getOwnPropertyDescriptor(e, t);
  (!r || ("get" in r ? !e.__esModule : r.writable || r.configurable)) && (r = { enumerable: !0, get: function() {
    return e[t];
  } }), Object.defineProperty(i, n, r);
} : function(i, e, t, n) {
  n === void 0 && (n = t), i[n] = e[t];
}), x3 = et && et.__setModuleDefault || (Object.create ? function(i, e) {
  Object.defineProperty(i, "default", { enumerable: !0, value: e });
} : function(i, e) {
  i.default = e;
}), k3 = et && et.__importStar || function(i) {
  if (i && i.__esModule)
    return i;
  var e = {};
  if (i != null)
    for (var t in i)
      t !== "default" && Object.prototype.hasOwnProperty.call(i, t) && T3(e, i, t);
  return x3(e, i), e;
}, Kv = et && et.__rest || function(i, e) {
  var t = {};
  for (var n in i)
    Object.prototype.hasOwnProperty.call(i, n) && e.indexOf(n) < 0 && (t[n] = i[n]);
  if (i != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, n = Object.getOwnPropertySymbols(i); r < n.length; r++)
      e.indexOf(n[r]) < 0 && Object.prototype.propertyIsEnumerable.call(i, n[r]) && (t[n[r]] = i[n[r]]);
  return t;
};
Object.defineProperty(Xd, "__esModule", { value: !0 });
Xd.createWithStyles = void 0;
const cm = k3(mi), A3 = Ll, P3 = Zd;
function I3(i) {
  const { useTheme: e } = i, { makeStyles: t } = (0, A3.createMakeStyles)({ useTheme: e });
  function n(r, s, o) {
    const l = typeof r == "string" ? (() => {
      const m = r, v = function(C) {
        var { children: k } = C, S = Kv(C, ["children"]);
        return (0, cm.createElement)(m, S, k);
      };
      return Object.defineProperty(v, "name", {
        value: (0, P3.capitalize)(m)
      }), v;
    })() : r, u = (() => {
      const { name: m } = l;
      return typeof m == "string" ? m : void 0;
    })(), h = t(o)(typeof s == "function" ? (m, v, C) => Gv(s(m, v, C)) : Gv(s)), f = (0, cm.forwardRef)(function(m, v) {
      const { className: C, classes: k } = m, S = Kv(m, ["className", "classes"]), { classes: x, cx: N } = h(m, { props: m });
      return cm.default.createElement(l, Object.assign({ ref: v, className: N(x.root, C) }, typeof r == "string" ? {} : { classes: x }, S));
    });
    return u !== void 0 && Object.defineProperty(f, "name", {
      value: `${u}WithStyles`
    }), f;
  }
  return { withStyles: n };
}
Xd.createWithStyles = I3;
function Gv(i) {
  const e = {}, t = {};
  return Object.keys(i).forEach((n) => (n.startsWith("@media") ? t : e)[n] = i[n]), Object.keys(t).forEach((n) => {
    const r = t[n];
    Object.keys(r).forEach((s) => {
      var o;
      return e[s] = Object.assign(Object.assign({}, (o = e[s]) !== null && o !== void 0 ? o : {}), { [n]: r[s] });
    });
  }), e;
}
var Qd = {}, R3 = et && et.__createBinding || (Object.create ? function(i, e, t, n) {
  n === void 0 && (n = t);
  var r = Object.getOwnPropertyDescriptor(e, t);
  (!r || ("get" in r ? !e.__esModule : r.writable || r.configurable)) && (r = { enumerable: !0, get: function() {
    return e[t];
  } }), Object.defineProperty(i, n, r);
} : function(i, e, t, n) {
  n === void 0 && (n = t), i[n] = e[t];
}), O3 = et && et.__setModuleDefault || (Object.create ? function(i, e) {
  Object.defineProperty(i, "default", { enumerable: !0, value: e });
} : function(i, e) {
  i.default = e;
}), M3 = et && et.__importStar || function(i) {
  if (i && i.__esModule)
    return i;
  var e = {};
  if (i != null)
    for (var t in i)
      t !== "default" && Object.prototype.hasOwnProperty.call(i, t) && R3(e, i, t);
  return O3(e, i), e;
}, N3 = et && et.__importDefault || function(i) {
  return i && i.__esModule ? i : { default: i };
};
Object.defineProperty(Qd, "__esModule", { value: !0 });
Qd.GlobalStyles = void 0;
const D3 = N3(mi), Yv = M3(Fi);
function B3(i) {
  const { styles: e } = i;
  return D3.default.createElement(Yv.Global, { styles: Yv.css(e) });
}
Qd.GlobalStyles = B3;
(function(i) {
  Object.defineProperty(i, "__esModule", { value: !0 }), i.createMakeAndWithStyles = i.TssCacheProvider = i.getTssDefaultEmotionCache = i.GlobalStyles = i.keyframes = i.createWithStyles = i.createMakeStyles = i.useMergedClasses = i.useCssAndCx = void 0;
  var e = Kd;
  Object.defineProperty(i, "useCssAndCx", { enumerable: !0, get: function() {
    return e.useCssAndCx;
  } });
  var t = Vs;
  Object.defineProperty(i, "useMergedClasses", { enumerable: !0, get: function() {
    return t.useMergedClasses;
  } });
  const n = Ll;
  Object.defineProperty(i, "createMakeStyles", { enumerable: !0, get: function() {
    return n.createMakeStyles;
  } });
  const r = Xd;
  Object.defineProperty(i, "createWithStyles", { enumerable: !0, get: function() {
    return r.createWithStyles;
  } });
  var s = Fi;
  Object.defineProperty(i, "keyframes", { enumerable: !0, get: function() {
    return s.keyframes;
  } });
  var o = Qd;
  Object.defineProperty(i, "GlobalStyles", { enumerable: !0, get: function() {
    return o.GlobalStyles;
  } });
  var l = xi;
  Object.defineProperty(i, "getTssDefaultEmotionCache", { enumerable: !0, get: function() {
    return l.getTssDefaultEmotionCache;
  } }), Object.defineProperty(i, "TssCacheProvider", { enumerable: !0, get: function() {
    return l.TssCacheProvider;
  } });
  function u(h) {
    return Object.assign(Object.assign({}, (0, n.createMakeStyles)(h)), (0, r.createWithStyles)(h));
  }
  i.createMakeAndWithStyles = u;
})(gy);
var Fg, Bu;
Object.defineProperty(Rs, "__esModule", { value: !0 });
Rs.useStyles = Rs.withStyles = Fg = Rs.makeStyles = void 0;
const V3 = ZO, L3 = gy;
Bu = (0, L3.createMakeAndWithStyles)({
  useTheme: V3.useTheme
}), Fg = Rs.makeStyles = Bu.makeStyles, Rs.withStyles = Bu.withStyles, Rs.useStyles = Bu.useStyles;
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function F3() {
  try {
    return navigator.userAgent.toLowerCase();
  } catch {
    return "";
  }
}
const Cs = F3(), qe = {
  isMac: by(Cs),
  isWindows: $3(Cs),
  isGecko: z3(Cs),
  isSafari: W3(Cs),
  isiOS: j3(Cs),
  isAndroid: U3(Cs),
  isBlink: H3(Cs),
  features: {
    isRegExpUnicodePropertySupported: q3()
  }
};
function by(i) {
  return i.indexOf("macintosh") > -1;
}
function $3(i) {
  return i.indexOf("windows") > -1;
}
function z3(i) {
  return !!i.match(/gecko\/\d+/);
}
function W3(i) {
  return i.indexOf(" applewebkit/") > -1 && i.indexOf("chrome") === -1;
}
function j3(i) {
  return !!i.match(/iphone|ipad/i) || by(i) && navigator.maxTouchPoints > 0;
}
function U3(i) {
  return i.indexOf("android") > -1;
}
function H3(i) {
  return i.indexOf("chrome/") > -1 && i.indexOf("edge/") < 0;
}
function q3() {
  let i = !1;
  try {
    i = "ć".search(new RegExp("[\\p{L}]", "u")) === 0;
  } catch {
  }
  return i;
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function yy(i, e, t, n) {
  t = t || function(u, h) {
    return u === h;
  };
  const r = Array.isArray(i) ? i : Array.prototype.slice.call(i), s = Array.isArray(e) ? e : Array.prototype.slice.call(e), o = K3(r, s, t);
  return n ? Y3(o, s.length) : G3(s, o);
}
function K3(i, e, t) {
  const n = Jv(i, e, t);
  if (n === -1)
    return { firstIndex: -1, lastIndexOld: -1, lastIndexNew: -1 };
  const r = Xv(i, n), s = Xv(e, n), o = Jv(r, s, t), l = i.length - o, u = e.length - o;
  return { firstIndex: n, lastIndexOld: l, lastIndexNew: u };
}
function Jv(i, e, t) {
  for (let n = 0; n < Math.max(i.length, e.length); n++)
    if (i[n] === void 0 || e[n] === void 0 || !t(i[n], e[n]))
      return n;
  return -1;
}
function Xv(i, e) {
  return i.slice(e).reverse();
}
function G3(i, e) {
  const t = [], { firstIndex: n, lastIndexOld: r, lastIndexNew: s } = e;
  return s - n > 0 && t.push({
    index: n,
    type: "insert",
    values: i.slice(n, s)
  }), r - n > 0 && t.push({
    index: n + (s - n),
    type: "delete",
    howMany: r - n
  }), t;
}
function Y3(i, e) {
  const { firstIndex: t, lastIndexOld: n, lastIndexNew: r } = i;
  if (t === -1)
    return Array(e).fill("equal");
  let s = [];
  return t > 0 && (s = s.concat(Array(t).fill("equal"))), r - t > 0 && (s = s.concat(Array(r - t).fill("insert"))), n - t > 0 && (s = s.concat(Array(n - t).fill("delete"))), r < e && (s = s.concat(Array(e - r).fill("equal"))), s;
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function cl(i, e, t) {
  t = t || function(S, x) {
    return S === x;
  };
  const n = i.length, r = e.length;
  if (n > 200 || r > 200 || n + r > 300)
    return cl.fastDiff(i, e, t, !0);
  let s, o;
  if (r < n) {
    const S = i;
    i = e, e = S, s = "delete", o = "insert";
  } else
    s = "insert", o = "delete";
  const l = i.length, u = e.length, h = u - l, f = {}, m = {};
  function v(S) {
    const x = (m[S - 1] !== void 0 ? m[S - 1] : -1) + 1, N = m[S + 1] !== void 0 ? m[S + 1] : -1, y = x > N ? -1 : 1;
    f[S + y] && (f[S] = f[S + y].slice(0)), f[S] || (f[S] = []), f[S].push(x > N ? s : o);
    let A = Math.max(x, N), P = A - S;
    for (; P < l && A < u && t(i[P], e[A]); )
      P++, A++, f[S].push("equal");
    return A;
  }
  let C = 0, k;
  do {
    for (k = -C; k < h; k++)
      m[k] = v(k);
    for (k = h + C; k > h; k--)
      m[k] = v(k);
    m[h] = v(h), C++;
  } while (m[h] !== u);
  return f[h].slice(1);
}
cl.fastDiff = yy;
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function Zv() {
  return function i() {
    i.called = !0;
  };
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class Ir {
  /**
   * @param source The emitter.
   * @param name The event name.
   */
  constructor(e, t) {
    this.source = e, this.name = t, this.path = [], this.stop = Zv(), this.off = Zv();
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const An = new Array(256).fill("").map((i, e) => ("0" + e.toString(16)).slice(-2));
function Rr() {
  const i = Math.random() * 4294967296 >>> 0, e = Math.random() * 4294967296 >>> 0, t = Math.random() * 4294967296 >>> 0, n = Math.random() * 4294967296 >>> 0;
  return "e" + An[i >> 0 & 255] + An[i >> 8 & 255] + An[i >> 16 & 255] + An[i >> 24 & 255] + An[e >> 0 & 255] + An[e >> 8 & 255] + An[e >> 16 & 255] + An[e >> 24 & 255] + An[t >> 0 & 255] + An[t >> 8 & 255] + An[t >> 16 & 255] + An[t >> 24 & 255] + An[n >> 0 & 255] + An[n >> 8 & 255] + An[n >> 16 & 255] + An[n >> 24 & 255];
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const Os = {
  get(i = "normal") {
    return typeof i != "number" ? this[i] || this.normal : i;
  },
  highest: 1e5,
  high: 1e3,
  normal: 0,
  low: -1e3,
  lowest: -1e5
};
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function J3(i, e) {
  const t = Os.get(e.priority);
  for (let n = 0; n < i.length; n++)
    if (Os.get(i[n].priority) < t) {
      i.splice(n, 0, e);
      return;
    }
  i.push(e);
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const X3 = "https://ckeditor.com/docs/ckeditor5/latest/support/error-codes.html";
class B extends Error {
  /**
   * Creates an instance of the CKEditorError class.
   *
   * @param errorName The error id in an `error-name` format. A link to this error documentation page will be added
   * to the thrown error's `message`.
   * @param context A context of the error by which the {@link module:watchdog/watchdog~Watchdog watchdog}
   * is able to determine which editor crashed. It should be an editor instance or a property connected to it. It can be also
   * a `null` value if the editor should not be restarted in case of the error (e.g. during the editor initialization).
   * The error context should be checked using the `areConnectedThroughProperties( editor, context )` utility
   * to check if the object works as the context.
   * @param data Additional data describing the error. A stringified version of this object
   * will be appended to the error message, so the data are quickly visible in the console. The original
   * data object will also be later available under the {@link #data} property.
   */
  constructor(e, t, n) {
    super(Z3(e, n)), this.name = "CKEditorError", this.context = t, this.data = n;
  }
  /**
   * Checks if the error is of the `CKEditorError` type.
   */
  is(e) {
    return e === "CKEditorError";
  }
  /**
   * A utility that ensures that the thrown error is a {@link module:utils/ckeditorerror~CKEditorError} one.
   * It is useful when combined with the {@link module:watchdog/watchdog~Watchdog} feature, which can restart the editor in case
   * of a {@link module:utils/ckeditorerror~CKEditorError} error.
   *
   * @param err The error to rethrow.
   * @param context An object connected through properties with the editor instance. This context will be used
   * by the watchdog to verify which editor should be restarted.
   */
  static rethrowUnexpectedError(e, t) {
    if (e.is && e.is("CKEditorError"))
      throw e;
    const n = new B(e.message, t);
    throw n.stack = e.stack, n;
  }
}
function Yt(i, e) {
  console.warn(...Q3(i, e));
}
function Ey(i) {
  return `
Read more: ${X3}#error-${i}`;
}
function Z3(i, e) {
  const t = /* @__PURE__ */ new WeakSet(), r = e ? ` ${JSON.stringify(e, (o, l) => {
    if (typeof l == "object" && l !== null) {
      if (t.has(l))
        return `[object ${l.constructor.name}]`;
      t.add(l);
    }
    return l;
  })}` : "", s = Ey(i);
  return i + r + s;
}
function Q3(i, e) {
  const t = Ey(i);
  return e ? [i, e, t] : [i, t];
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const e4 = "37.1.0";
/* istanbul ignore next -- @preserve */
const Qv = typeof window == "object" ? window : global;
/* istanbul ignore next -- @preserve */
if (Qv.CKEDITOR_VERSION)
  throw new B("ckeditor-duplicated-modules", null);
Qv.CKEDITOR_VERSION = e4;
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const Io = Symbol("listeningTo"), Km = Symbol("emitterId"), Sr = Symbol("delegations"), Cy = kt(Object);
function kt(i) {
  if (!i)
    return Cy;
  class e extends i {
    on(n, r, s) {
      this.listenTo(this, n, r, s);
    }
    once(n, r, s) {
      let o = !1;
      const l = (u, ...h) => {
        o || (o = !0, u.off(), r.call(this, u, ...h));
      };
      this.listenTo(this, n, l, s);
    }
    off(n, r) {
      this.stopListening(this, n, r);
    }
    listenTo(n, r, s, o = {}) {
      let l, u;
      this[Io] || (this[Io] = {});
      const h = this[Io];
      um(n) || Sy(n);
      const f = um(n);
      (l = h[f]) || (l = h[f] = {
        emitter: n,
        callbacks: {}
      }), (u = l.callbacks[r]) || (u = l.callbacks[r] = []), u.push(s), r4(this, n, r, s, o);
    }
    stopListening(n, r, s) {
      const o = this[Io];
      let l = n && um(n);
      const u = o && l ? o[l] : void 0, h = u && r ? u.callbacks[r] : void 0;
      if (!(!o || n && !u || r && !h))
        if (s)
          dm(this, n, r, s), h.indexOf(s) !== -1 && (h.length === 1 ? delete u.callbacks[r] : dm(this, n, r, s));
        else if (h) {
          for (; s = h.pop(); )
            dm(this, n, r, s);
          delete u.callbacks[r];
        } else if (u) {
          for (r in u.callbacks)
            this.stopListening(n, r);
          delete o[l];
        } else {
          for (l in o)
            this.stopListening(o[l].emitter);
          delete this[Io];
        }
    }
    fire(n, ...r) {
      try {
        const s = n instanceof Ir ? n : new Ir(this, n), o = s.name;
        let l = xy(this, o);
        if (s.path.push(this), l) {
          const h = [s, ...r];
          l = Array.from(l);
          for (let f = 0; f < l.length && (l[f].callback.apply(this, h), s.off.called && (delete s.off.called, this._removeEventListener(o, l[f].callback)), !s.stop.called); f++)
            ;
        }
        const u = this[Sr];
        if (u) {
          const h = u.get(o), f = u.get("*");
          h && ew(h, s, r), f && ew(f, s, r);
        }
        return s.return;
      } catch (s) {
        /* istanbul ignore next -- @preserve */
        B.rethrowUnexpectedError(s, this);
      }
    }
    delegate(...n) {
      return {
        to: (r, s) => {
          this[Sr] || (this[Sr] = /* @__PURE__ */ new Map()), n.forEach((o) => {
            const l = this[Sr].get(o);
            l ? l.set(r, s) : this[Sr].set(o, /* @__PURE__ */ new Map([[r, s]]));
          });
        }
      };
    }
    stopDelegating(n, r) {
      if (this[Sr])
        if (!n)
          this[Sr].clear();
        else if (!r)
          this[Sr].delete(n);
        else {
          const s = this[Sr].get(n);
          s && s.delete(r);
        }
    }
    _addEventListener(n, r, s) {
      i4(this, n);
      const o = Gm(this, n), l = Os.get(s.priority), u = {
        callback: r,
        priority: l
      };
      for (const h of o)
        J3(h, u);
    }
    _removeEventListener(n, r) {
      const s = Gm(this, n);
      for (const o of s)
        for (let l = 0; l < o.length; l++)
          o[l].callback == r && (o.splice(l, 1), l--);
    }
  }
  return e;
}
[
  "on",
  "once",
  "off",
  "listenTo",
  "stopListening",
  "fire",
  "delegate",
  "stopDelegating",
  "_addEventListener",
  "_removeEventListener"
].forEach((i) => {
  kt[i] = Cy.prototype[i];
});
function t4(i, e) {
  const t = i[Io];
  return t && t[e] ? t[e].emitter : null;
}
function Sy(i, e) {
  i[Km] || (i[Km] = e || Rr());
}
function um(i) {
  return i[Km];
}
function Ty(i) {
  return i._events || Object.defineProperty(i, "_events", {
    value: {}
  }), i._events;
}
function n4() {
  return {
    callbacks: [],
    childEvents: []
  };
}
function i4(i, e) {
  const t = Ty(i);
  if (t[e])
    return;
  let n = e, r = null;
  const s = [];
  for (; n !== "" && !t[n]; )
    t[n] = n4(), s.push(t[n]), r && t[n].childEvents.push(r), r = n, n = n.substr(0, n.lastIndexOf(":"));
  if (n !== "") {
    for (const o of s)
      o.callbacks = t[n].callbacks.slice();
    t[n].childEvents.push(r);
  }
}
function Gm(i, e) {
  const t = Ty(i)[e];
  if (!t)
    return [];
  let n = [t.callbacks];
  for (let r = 0; r < t.childEvents.length; r++) {
    const s = Gm(i, t.childEvents[r]);
    n = n.concat(s);
  }
  return n;
}
function xy(i, e) {
  let t;
  return !i._events || !(t = i._events[e]) || !t.callbacks.length ? e.indexOf(":") > -1 ? xy(i, e.substr(0, e.lastIndexOf(":"))) : null : t.callbacks;
}
function ew(i, e, t) {
  for (let [n, r] of i) {
    r ? typeof r == "function" && (r = r(e.name)) : r = e.name;
    const s = new Ir(e.source, r);
    s.path = [...e.path], n.fire(s, ...t);
  }
}
function r4(i, e, t, n, r) {
  e._addEventListener ? e._addEventListener(t, n, r) : i._addEventListener.call(e, t, n, r);
}
function dm(i, e, t, n) {
  e._removeEventListener ? e._removeEventListener(t, n) : i._removeEventListener.call(e, t, n);
}
var s4 = typeof global == "object" && global && global.Object === Object && global;
const ky = s4;
var o4 = typeof self == "object" && self && self.Object === Object && self, a4 = ky || o4 || Function("return this")();
const ji = a4;
var l4 = ji.Symbol;
const lr = l4;
var Ay = Object.prototype, c4 = Ay.hasOwnProperty, u4 = Ay.toString, Ka = lr ? lr.toStringTag : void 0;
function d4(i) {
  var e = c4.call(i, Ka), t = i[Ka];
  try {
    i[Ka] = void 0;
    var n = !0;
  } catch {
  }
  var r = u4.call(i);
  return n && (e ? i[Ka] = t : delete i[Ka]), r;
}
var h4 = Object.prototype, f4 = h4.toString;
function m4(i) {
  return f4.call(i);
}
var g4 = "[object Null]", p4 = "[object Undefined]", tw = lr ? lr.toStringTag : void 0;
function os(i) {
  return i == null ? i === void 0 ? p4 : g4 : tw && tw in Object(i) ? d4(i) : m4(i);
}
function Ii(i) {
  return i != null && typeof i == "object";
}
var _4 = "[object Symbol]";
function eh(i) {
  return typeof i == "symbol" || Ii(i) && os(i) == _4;
}
function v4(i, e) {
  for (var t = -1, n = i == null ? 0 : i.length, r = Array(n); ++t < n; )
    r[t] = e(i[t], t, i);
  return r;
}
var w4 = Array.isArray;
const Fn = w4;
var b4 = 1 / 0, nw = lr ? lr.prototype : void 0, iw = nw ? nw.toString : void 0;
function Py(i) {
  if (typeof i == "string")
    return i;
  if (Fn(i))
    return v4(i, Py) + "";
  if (eh(i))
    return iw ? iw.call(i) : "";
  var e = i + "";
  return e == "0" && 1 / i == -b4 ? "-0" : e;
}
var y4 = /\s/;
function E4(i) {
  for (var e = i.length; e-- && y4.test(i.charAt(e)); )
    ;
  return e;
}
var C4 = /^\s+/;
function S4(i) {
  return i && i.slice(0, E4(i) + 1).replace(C4, "");
}
function Lt(i) {
  var e = typeof i;
  return i != null && (e == "object" || e == "function");
}
var rw = 0 / 0, T4 = /^[-+]0x[0-9a-f]+$/i, x4 = /^0b[01]+$/i, k4 = /^0o[0-7]+$/i, A4 = parseInt;
function sw(i) {
  if (typeof i == "number")
    return i;
  if (eh(i))
    return rw;
  if (Lt(i)) {
    var e = typeof i.valueOf == "function" ? i.valueOf() : i;
    i = Lt(e) ? e + "" : e;
  }
  if (typeof i != "string")
    return i === 0 ? i : +i;
  i = S4(i);
  var t = x4.test(i);
  return t || k4.test(i) ? A4(i.slice(2), t ? 2 : 8) : T4.test(i) ? rw : +i;
}
function Ps(i) {
  return i;
}
var P4 = "[object AsyncFunction]", I4 = "[object Function]", R4 = "[object GeneratorFunction]", O4 = "[object Proxy]";
function Ls(i) {
  if (!Lt(i))
    return !1;
  var e = os(i);
  return e == I4 || e == R4 || e == P4 || e == O4;
}
var M4 = ji["__core-js_shared__"];
const hm = M4;
var ow = function() {
  var i = /[^.]+$/.exec(hm && hm.keys && hm.keys.IE_PROTO || "");
  return i ? "Symbol(src)_1." + i : "";
}();
function N4(i) {
  return !!ow && ow in i;
}
var D4 = Function.prototype, B4 = D4.toString;
function zs(i) {
  if (i != null) {
    try {
      return B4.call(i);
    } catch {
    }
    try {
      return i + "";
    } catch {
    }
  }
  return "";
}
var V4 = /[\\^$.*+?()[\]{}|]/g, L4 = /^\[object .+?Constructor\]$/, F4 = Function.prototype, $4 = Object.prototype, z4 = F4.toString, W4 = $4.hasOwnProperty, j4 = RegExp(
  "^" + z4.call(W4).replace(V4, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function U4(i) {
  if (!Lt(i) || N4(i))
    return !1;
  var e = Ls(i) ? j4 : L4;
  return e.test(zs(i));
}
function H4(i, e) {
  return i?.[e];
}
function Ws(i, e) {
  var t = H4(i, e);
  return U4(t) ? t : void 0;
}
var q4 = Ws(ji, "WeakMap");
const Ym = q4;
var aw = Object.create, K4 = function() {
  function i() {
  }
  return function(e) {
    if (!Lt(e))
      return {};
    if (aw)
      return aw(e);
    i.prototype = e;
    var t = new i();
    return i.prototype = void 0, t;
  };
}();
const G4 = K4;
function Y4(i, e, t) {
  switch (t.length) {
    case 0:
      return i.call(e);
    case 1:
      return i.call(e, t[0]);
    case 2:
      return i.call(e, t[0], t[1]);
    case 3:
      return i.call(e, t[0], t[1], t[2]);
  }
  return i.apply(e, t);
}
function Iy(i, e) {
  var t = -1, n = i.length;
  for (e || (e = Array(n)); ++t < n; )
    e[t] = i[t];
  return e;
}
var J4 = 800, X4 = 16, Z4 = Date.now;
function Q4(i) {
  var e = 0, t = 0;
  return function() {
    var n = Z4(), r = X4 - (n - t);
    if (t = n, r > 0) {
      if (++e >= J4)
        return arguments[0];
    } else
      e = 0;
    return i.apply(void 0, arguments);
  };
}
function eM(i) {
  return function() {
    return i;
  };
}
var tM = function() {
  try {
    var i = Ws(Object, "defineProperty");
    return i({}, "", {}), i;
  } catch {
  }
}();
const yd = tM;
var nM = yd ? function(i, e) {
  return yd(i, "toString", {
    configurable: !0,
    enumerable: !1,
    value: eM(e),
    writable: !0
  });
} : Ps;
const iM = nM;
var rM = Q4(iM);
const sM = rM;
function oM(i, e) {
  for (var t = -1, n = i == null ? 0 : i.length; ++t < n && e(i[t], t, i) !== !1; )
    ;
  return i;
}
var aM = 9007199254740991, lM = /^(?:0|[1-9]\d*)$/;
function $g(i, e) {
  var t = typeof i;
  return e = e ?? aM, !!e && (t == "number" || t != "symbol" && lM.test(i)) && i > -1 && i % 1 == 0 && i < e;
}
function zg(i, e, t) {
  e == "__proto__" && yd ? yd(i, e, {
    configurable: !0,
    enumerable: !0,
    value: t,
    writable: !0
  }) : i[e] = t;
}
function Fl(i, e) {
  return i === e || i !== i && e !== e;
}
var cM = Object.prototype, uM = cM.hasOwnProperty;
function Wg(i, e, t) {
  var n = i[e];
  (!(uM.call(i, e) && Fl(n, t)) || t === void 0 && !(e in i)) && zg(i, e, t);
}
function Xo(i, e, t, n) {
  var r = !t;
  t || (t = {});
  for (var s = -1, o = e.length; ++s < o; ) {
    var l = e[s], u = n ? n(t[l], i[l], l, t, i) : void 0;
    u === void 0 && (u = i[l]), r ? zg(t, l, u) : Wg(t, l, u);
  }
  return t;
}
var lw = Math.max;
function dM(i, e, t) {
  return e = lw(e === void 0 ? i.length - 1 : e, 0), function() {
    for (var n = arguments, r = -1, s = lw(n.length - e, 0), o = Array(s); ++r < s; )
      o[r] = n[e + r];
    r = -1;
    for (var l = Array(e + 1); ++r < e; )
      l[r] = n[r];
    return l[e] = t(o), Y4(i, this, l);
  };
}
function hM(i, e) {
  return sM(dM(i, e, Ps), i + "");
}
var fM = 9007199254740991;
function Ry(i) {
  return typeof i == "number" && i > -1 && i % 1 == 0 && i <= fM;
}
function th(i) {
  return i != null && Ry(i.length) && !Ls(i);
}
function mM(i, e, t) {
  if (!Lt(t))
    return !1;
  var n = typeof e;
  return (n == "number" ? th(t) && $g(e, t.length) : n == "string" && e in t) ? Fl(t[e], i) : !1;
}
function Oy(i) {
  return hM(function(e, t) {
    var n = -1, r = t.length, s = r > 1 ? t[r - 1] : void 0, o = r > 2 ? t[2] : void 0;
    for (s = i.length > 3 && typeof s == "function" ? (r--, s) : void 0, o && mM(t[0], t[1], o) && (s = r < 3 ? void 0 : s, r = 1), e = Object(e); ++n < r; ) {
      var l = t[n];
      l && i(e, l, n, s);
    }
    return e;
  });
}
var gM = Object.prototype;
function jg(i) {
  var e = i && i.constructor, t = typeof e == "function" && e.prototype || gM;
  return i === t;
}
function pM(i, e) {
  for (var t = -1, n = Array(i); ++t < i; )
    n[t] = e(t);
  return n;
}
var _M = "[object Arguments]";
function cw(i) {
  return Ii(i) && os(i) == _M;
}
var My = Object.prototype, vM = My.hasOwnProperty, wM = My.propertyIsEnumerable, bM = cw(function() {
  return arguments;
}()) ? cw : function(i) {
  return Ii(i) && vM.call(i, "callee") && !wM.call(i, "callee");
};
const Jm = bM;
function yM() {
  return !1;
}
var Ny = typeof exports == "object" && exports && !exports.nodeType && exports, uw = Ny && typeof module == "object" && module && !module.nodeType && module, EM = uw && uw.exports === Ny, dw = EM ? ji.Buffer : void 0, CM = dw ? dw.isBuffer : void 0, SM = CM || yM;
const _l = SM;
var TM = "[object Arguments]", xM = "[object Array]", kM = "[object Boolean]", AM = "[object Date]", PM = "[object Error]", IM = "[object Function]", RM = "[object Map]", OM = "[object Number]", MM = "[object Object]", NM = "[object RegExp]", DM = "[object Set]", BM = "[object String]", VM = "[object WeakMap]", LM = "[object ArrayBuffer]", FM = "[object DataView]", $M = "[object Float32Array]", zM = "[object Float64Array]", WM = "[object Int8Array]", jM = "[object Int16Array]", UM = "[object Int32Array]", HM = "[object Uint8Array]", qM = "[object Uint8ClampedArray]", KM = "[object Uint16Array]", GM = "[object Uint32Array]", Ot = {};
Ot[$M] = Ot[zM] = Ot[WM] = Ot[jM] = Ot[UM] = Ot[HM] = Ot[qM] = Ot[KM] = Ot[GM] = !0;
Ot[TM] = Ot[xM] = Ot[LM] = Ot[kM] = Ot[FM] = Ot[AM] = Ot[PM] = Ot[IM] = Ot[RM] = Ot[OM] = Ot[MM] = Ot[NM] = Ot[DM] = Ot[BM] = Ot[VM] = !1;
function YM(i) {
  return Ii(i) && Ry(i.length) && !!Ot[os(i)];
}
function Ug(i) {
  return function(e) {
    return i(e);
  };
}
var Dy = typeof exports == "object" && exports && !exports.nodeType && exports, ul = Dy && typeof module == "object" && module && !module.nodeType && module, JM = ul && ul.exports === Dy, fm = JM && ky.process, XM = function() {
  try {
    var i = ul && ul.require && ul.require("util").types;
    return i || fm && fm.binding && fm.binding("util");
  } catch {
  }
}();
const Fo = XM;
var hw = Fo && Fo.isTypedArray, ZM = hw ? Ug(hw) : YM;
const Hg = ZM;
var QM = Object.prototype, e6 = QM.hasOwnProperty;
function By(i, e) {
  var t = Fn(i), n = !t && Jm(i), r = !t && !n && _l(i), s = !t && !n && !r && Hg(i), o = t || n || r || s, l = o ? pM(i.length, String) : [], u = l.length;
  for (var h in i)
    (e || e6.call(i, h)) && !(o && // Safari 9 has enumerable `arguments.length` in strict mode.
    (h == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    r && (h == "offset" || h == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    s && (h == "buffer" || h == "byteLength" || h == "byteOffset") || // Skip index properties.
    $g(h, u))) && l.push(h);
  return l;
}
function Vy(i, e) {
  return function(t) {
    return i(e(t));
  };
}
var t6 = Vy(Object.keys, Object);
const n6 = t6;
var i6 = Object.prototype, r6 = i6.hasOwnProperty;
function s6(i) {
  if (!jg(i))
    return n6(i);
  var e = [];
  for (var t in Object(i))
    r6.call(i, t) && t != "constructor" && e.push(t);
  return e;
}
function qg(i) {
  return th(i) ? By(i) : s6(i);
}
function o6(i) {
  var e = [];
  if (i != null)
    for (var t in Object(i))
      e.push(t);
  return e;
}
var a6 = Object.prototype, l6 = a6.hasOwnProperty;
function c6(i) {
  if (!Lt(i))
    return o6(i);
  var e = jg(i), t = [];
  for (var n in i)
    n == "constructor" && (e || !l6.call(i, n)) || t.push(n);
  return t;
}
function Zo(i) {
  return th(i) ? By(i, !0) : c6(i);
}
var u6 = Oy(function(i, e) {
  Xo(e, Zo(e), i);
});
const Ly = u6;
var d6 = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, h6 = /^\w*$/;
function f6(i, e) {
  if (Fn(i))
    return !1;
  var t = typeof i;
  return t == "number" || t == "symbol" || t == "boolean" || i == null || eh(i) ? !0 : h6.test(i) || !d6.test(i) || e != null && i in Object(e);
}
var m6 = Ws(Object, "create");
const vl = m6;
function g6() {
  this.__data__ = vl ? vl(null) : {}, this.size = 0;
}
function p6(i) {
  var e = this.has(i) && delete this.__data__[i];
  return this.size -= e ? 1 : 0, e;
}
var _6 = "__lodash_hash_undefined__", v6 = Object.prototype, w6 = v6.hasOwnProperty;
function b6(i) {
  var e = this.__data__;
  if (vl) {
    var t = e[i];
    return t === _6 ? void 0 : t;
  }
  return w6.call(e, i) ? e[i] : void 0;
}
var y6 = Object.prototype, E6 = y6.hasOwnProperty;
function C6(i) {
  var e = this.__data__;
  return vl ? e[i] !== void 0 : E6.call(e, i);
}
var S6 = "__lodash_hash_undefined__";
function T6(i, e) {
  var t = this.__data__;
  return this.size += this.has(i) ? 0 : 1, t[i] = vl && e === void 0 ? S6 : e, this;
}
function Fs(i) {
  var e = -1, t = i == null ? 0 : i.length;
  for (this.clear(); ++e < t; ) {
    var n = i[e];
    this.set(n[0], n[1]);
  }
}
Fs.prototype.clear = g6;
Fs.prototype.delete = p6;
Fs.prototype.get = b6;
Fs.prototype.has = C6;
Fs.prototype.set = T6;
function x6() {
  this.__data__ = [], this.size = 0;
}
function nh(i, e) {
  for (var t = i.length; t--; )
    if (Fl(i[t][0], e))
      return t;
  return -1;
}
var k6 = Array.prototype, A6 = k6.splice;
function P6(i) {
  var e = this.__data__, t = nh(e, i);
  if (t < 0)
    return !1;
  var n = e.length - 1;
  return t == n ? e.pop() : A6.call(e, t, 1), --this.size, !0;
}
function I6(i) {
  var e = this.__data__, t = nh(e, i);
  return t < 0 ? void 0 : e[t][1];
}
function R6(i) {
  return nh(this.__data__, i) > -1;
}
function O6(i, e) {
  var t = this.__data__, n = nh(t, i);
  return n < 0 ? (++this.size, t.push([i, e])) : t[n][1] = e, this;
}
function Mr(i) {
  var e = -1, t = i == null ? 0 : i.length;
  for (this.clear(); ++e < t; ) {
    var n = i[e];
    this.set(n[0], n[1]);
  }
}
Mr.prototype.clear = x6;
Mr.prototype.delete = P6;
Mr.prototype.get = I6;
Mr.prototype.has = R6;
Mr.prototype.set = O6;
var M6 = Ws(ji, "Map");
const wl = M6;
function N6() {
  this.size = 0, this.__data__ = {
    hash: new Fs(),
    map: new (wl || Mr)(),
    string: new Fs()
  };
}
function D6(i) {
  var e = typeof i;
  return e == "string" || e == "number" || e == "symbol" || e == "boolean" ? i !== "__proto__" : i === null;
}
function ih(i, e) {
  var t = i.__data__;
  return D6(e) ? t[typeof e == "string" ? "string" : "hash"] : t.map;
}
function B6(i) {
  var e = ih(this, i).delete(i);
  return this.size -= e ? 1 : 0, e;
}
function V6(i) {
  return ih(this, i).get(i);
}
function L6(i) {
  return ih(this, i).has(i);
}
function F6(i, e) {
  var t = ih(this, i), n = t.size;
  return t.set(i, e), this.size += t.size == n ? 0 : 1, this;
}
function Nr(i) {
  var e = -1, t = i == null ? 0 : i.length;
  for (this.clear(); ++e < t; ) {
    var n = i[e];
    this.set(n[0], n[1]);
  }
}
Nr.prototype.clear = N6;
Nr.prototype.delete = B6;
Nr.prototype.get = V6;
Nr.prototype.has = L6;
Nr.prototype.set = F6;
var $6 = "Expected a function";
function Kg(i, e) {
  if (typeof i != "function" || e != null && typeof e != "function")
    throw new TypeError($6);
  var t = function() {
    var n = arguments, r = e ? e.apply(this, n) : n[0], s = t.cache;
    if (s.has(r))
      return s.get(r);
    var o = i.apply(this, n);
    return t.cache = s.set(r, o) || s, o;
  };
  return t.cache = new (Kg.Cache || Nr)(), t;
}
Kg.Cache = Nr;
var z6 = 500;
function W6(i) {
  var e = Kg(i, function(n) {
    return t.size === z6 && t.clear(), n;
  }), t = e.cache;
  return e;
}
var j6 = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, U6 = /\\(\\)?/g, H6 = W6(function(i) {
  var e = [];
  return i.charCodeAt(0) === 46 && e.push(""), i.replace(j6, function(t, n, r, s) {
    e.push(r ? s.replace(U6, "$1") : n || t);
  }), e;
});
const q6 = H6;
function Fy(i) {
  return i == null ? "" : Py(i);
}
function Gg(i, e) {
  return Fn(i) ? i : f6(i, e) ? [i] : q6(Fy(i));
}
var K6 = 1 / 0;
function Yg(i) {
  if (typeof i == "string" || eh(i))
    return i;
  var e = i + "";
  return e == "0" && 1 / i == -K6 ? "-0" : e;
}
function $y(i, e) {
  e = Gg(e, i);
  for (var t = 0, n = e.length; i != null && t < n; )
    i = i[Yg(e[t++])];
  return t && t == n ? i : void 0;
}
function Ed(i, e, t) {
  var n = i == null ? void 0 : $y(i, e);
  return n === void 0 ? t : n;
}
function zy(i, e) {
  for (var t = -1, n = e.length, r = i.length; ++t < n; )
    i[r + t] = e[t];
  return i;
}
var G6 = Vy(Object.getPrototypeOf, Object);
const Jg = G6;
var Y6 = "[object Object]", J6 = Function.prototype, X6 = Object.prototype, Wy = J6.toString, Z6 = X6.hasOwnProperty, Q6 = Wy.call(Object);
function ui(i) {
  if (!Ii(i) || os(i) != Y6)
    return !1;
  var e = Jg(i);
  if (e === null)
    return !0;
  var t = Z6.call(e, "constructor") && e.constructor;
  return typeof t == "function" && t instanceof t && Wy.call(t) == Q6;
}
function jy(i, e, t) {
  var n = -1, r = i.length;
  e < 0 && (e = -e > r ? 0 : r + e), t = t > r ? r : t, t < 0 && (t += r), r = e > t ? 0 : t - e >>> 0, e >>>= 0;
  for (var s = Array(r); ++n < r; )
    s[n] = i[n + e];
  return s;
}
function e7(i, e, t) {
  var n = i.length;
  return t = t === void 0 ? n : t, !e && t >= n ? i : jy(i, e, t);
}
var t7 = "\\ud800-\\udfff", n7 = "\\u0300-\\u036f", i7 = "\\ufe20-\\ufe2f", r7 = "\\u20d0-\\u20ff", s7 = n7 + i7 + r7, o7 = "\\ufe0e\\ufe0f", a7 = "\\u200d", l7 = RegExp("[" + a7 + t7 + s7 + o7 + "]");
function Uy(i) {
  return l7.test(i);
}
function c7(i) {
  return i.split("");
}
var Hy = "\\ud800-\\udfff", u7 = "\\u0300-\\u036f", d7 = "\\ufe20-\\ufe2f", h7 = "\\u20d0-\\u20ff", f7 = u7 + d7 + h7, m7 = "\\ufe0e\\ufe0f", g7 = "[" + Hy + "]", Xm = "[" + f7 + "]", Zm = "\\ud83c[\\udffb-\\udfff]", p7 = "(?:" + Xm + "|" + Zm + ")", qy = "[^" + Hy + "]", Ky = "(?:\\ud83c[\\udde6-\\uddff]){2}", Gy = "[\\ud800-\\udbff][\\udc00-\\udfff]", _7 = "\\u200d", Yy = p7 + "?", Jy = "[" + m7 + "]?", v7 = "(?:" + _7 + "(?:" + [qy, Ky, Gy].join("|") + ")" + Jy + Yy + ")*", w7 = Jy + Yy + v7, b7 = "(?:" + [qy + Xm + "?", Xm, Ky, Gy, g7].join("|") + ")", y7 = RegExp(Zm + "(?=" + Zm + ")|" + b7 + w7, "g");
function E7(i) {
  return i.match(y7) || [];
}
function C7(i) {
  return Uy(i) ? E7(i) : c7(i);
}
function S7(i) {
  return function(e) {
    e = Fy(e);
    var t = Uy(e) ? C7(e) : void 0, n = t ? t[0] : e.charAt(0), r = t ? e7(t, 1).join("") : e.slice(1);
    return n[i]() + r;
  };
}
var T7 = S7("toUpperCase");
const x7 = T7;
function k7() {
  this.__data__ = new Mr(), this.size = 0;
}
function A7(i) {
  var e = this.__data__, t = e.delete(i);
  return this.size = e.size, t;
}
function P7(i) {
  return this.__data__.get(i);
}
function I7(i) {
  return this.__data__.has(i);
}
var R7 = 200;
function O7(i, e) {
  var t = this.__data__;
  if (t instanceof Mr) {
    var n = t.__data__;
    if (!wl || n.length < R7 - 1)
      return n.push([i, e]), this.size = ++t.size, this;
    t = this.__data__ = new Nr(n);
  }
  return t.set(i, e), this.size = t.size, this;
}
function rr(i) {
  var e = this.__data__ = new Mr(i);
  this.size = e.size;
}
rr.prototype.clear = k7;
rr.prototype.delete = A7;
rr.prototype.get = P7;
rr.prototype.has = I7;
rr.prototype.set = O7;
function M7(i, e) {
  return i && Xo(e, qg(e), i);
}
function N7(i, e) {
  return i && Xo(e, Zo(e), i);
}
var Xy = typeof exports == "object" && exports && !exports.nodeType && exports, fw = Xy && typeof module == "object" && module && !module.nodeType && module, D7 = fw && fw.exports === Xy, mw = D7 ? ji.Buffer : void 0, gw = mw ? mw.allocUnsafe : void 0;
function Zy(i, e) {
  if (e)
    return i.slice();
  var t = i.length, n = gw ? gw(t) : new i.constructor(t);
  return i.copy(n), n;
}
function B7(i, e) {
  for (var t = -1, n = i == null ? 0 : i.length, r = 0, s = []; ++t < n; ) {
    var o = i[t];
    e(o, t, i) && (s[r++] = o);
  }
  return s;
}
function Qy() {
  return [];
}
var V7 = Object.prototype, L7 = V7.propertyIsEnumerable, pw = Object.getOwnPropertySymbols, F7 = pw ? function(i) {
  return i == null ? [] : (i = Object(i), B7(pw(i), function(e) {
    return L7.call(i, e);
  }));
} : Qy;
const Xg = F7;
function $7(i, e) {
  return Xo(i, Xg(i), e);
}
var z7 = Object.getOwnPropertySymbols, W7 = z7 ? function(i) {
  for (var e = []; i; )
    zy(e, Xg(i)), i = Jg(i);
  return e;
} : Qy;
const eE = W7;
function j7(i, e) {
  return Xo(i, eE(i), e);
}
function tE(i, e, t) {
  var n = e(i);
  return Fn(i) ? n : zy(n, t(i));
}
function Qm(i) {
  return tE(i, qg, Xg);
}
function U7(i) {
  return tE(i, Zo, eE);
}
var H7 = Ws(ji, "DataView");
const eg = H7;
var q7 = Ws(ji, "Promise");
const tg = q7;
var K7 = Ws(ji, "Set");
const ng = K7;
var _w = "[object Map]", G7 = "[object Object]", vw = "[object Promise]", ww = "[object Set]", bw = "[object WeakMap]", yw = "[object DataView]", Y7 = zs(eg), J7 = zs(wl), X7 = zs(tg), Z7 = zs(ng), Q7 = zs(Ym), ks = os;
(eg && ks(new eg(new ArrayBuffer(1))) != yw || wl && ks(new wl()) != _w || tg && ks(tg.resolve()) != vw || ng && ks(new ng()) != ww || Ym && ks(new Ym()) != bw) && (ks = function(i) {
  var e = os(i), t = e == G7 ? i.constructor : void 0, n = t ? zs(t) : "";
  if (n)
    switch (n) {
      case Y7:
        return yw;
      case J7:
        return _w;
      case X7:
        return vw;
      case Z7:
        return ww;
      case Q7:
        return bw;
    }
  return e;
});
const bl = ks;
var eN = Object.prototype, tN = eN.hasOwnProperty;
function nN(i) {
  var e = i.length, t = new i.constructor(e);
  return e && typeof i[0] == "string" && tN.call(i, "index") && (t.index = i.index, t.input = i.input), t;
}
var iN = ji.Uint8Array;
const Cd = iN;
function Zg(i) {
  var e = new i.constructor(i.byteLength);
  return new Cd(e).set(new Cd(i)), e;
}
function rN(i, e) {
  var t = e ? Zg(i.buffer) : i.buffer;
  return new i.constructor(t, i.byteOffset, i.byteLength);
}
var sN = /\w*$/;
function oN(i) {
  var e = new i.constructor(i.source, sN.exec(i));
  return e.lastIndex = i.lastIndex, e;
}
var Ew = lr ? lr.prototype : void 0, Cw = Ew ? Ew.valueOf : void 0;
function aN(i) {
  return Cw ? Object(Cw.call(i)) : {};
}
function nE(i, e) {
  var t = e ? Zg(i.buffer) : i.buffer;
  return new i.constructor(t, i.byteOffset, i.length);
}
var lN = "[object Boolean]", cN = "[object Date]", uN = "[object Map]", dN = "[object Number]", hN = "[object RegExp]", fN = "[object Set]", mN = "[object String]", gN = "[object Symbol]", pN = "[object ArrayBuffer]", _N = "[object DataView]", vN = "[object Float32Array]", wN = "[object Float64Array]", bN = "[object Int8Array]", yN = "[object Int16Array]", EN = "[object Int32Array]", CN = "[object Uint8Array]", SN = "[object Uint8ClampedArray]", TN = "[object Uint16Array]", xN = "[object Uint32Array]";
function kN(i, e, t) {
  var n = i.constructor;
  switch (e) {
    case pN:
      return Zg(i);
    case lN:
    case cN:
      return new n(+i);
    case _N:
      return rN(i, t);
    case vN:
    case wN:
    case bN:
    case yN:
    case EN:
    case CN:
    case SN:
    case TN:
    case xN:
      return nE(i, t);
    case uN:
      return new n();
    case dN:
    case mN:
      return new n(i);
    case hN:
      return oN(i);
    case fN:
      return new n();
    case gN:
      return aN(i);
  }
}
function iE(i) {
  return typeof i.constructor == "function" && !jg(i) ? G4(Jg(i)) : {};
}
var AN = "[object Map]";
function PN(i) {
  return Ii(i) && bl(i) == AN;
}
var Sw = Fo && Fo.isMap, IN = Sw ? Ug(Sw) : PN;
const RN = IN;
var ON = "[object Set]";
function MN(i) {
  return Ii(i) && bl(i) == ON;
}
var Tw = Fo && Fo.isSet, NN = Tw ? Ug(Tw) : MN;
const DN = NN;
var BN = 1, VN = 2, LN = 4, rE = "[object Arguments]", FN = "[object Array]", $N = "[object Boolean]", zN = "[object Date]", WN = "[object Error]", sE = "[object Function]", jN = "[object GeneratorFunction]", UN = "[object Map]", HN = "[object Number]", oE = "[object Object]", qN = "[object RegExp]", KN = "[object Set]", GN = "[object String]", YN = "[object Symbol]", JN = "[object WeakMap]", XN = "[object ArrayBuffer]", ZN = "[object DataView]", QN = "[object Float32Array]", eD = "[object Float64Array]", tD = "[object Int8Array]", nD = "[object Int16Array]", iD = "[object Int32Array]", rD = "[object Uint8Array]", sD = "[object Uint8ClampedArray]", oD = "[object Uint16Array]", aD = "[object Uint32Array]", It = {};
It[rE] = It[FN] = It[XN] = It[ZN] = It[$N] = It[zN] = It[QN] = It[eD] = It[tD] = It[nD] = It[iD] = It[UN] = It[HN] = It[oE] = It[qN] = It[KN] = It[GN] = It[YN] = It[rD] = It[sD] = It[oD] = It[aD] = !0;
It[WN] = It[sE] = It[JN] = !1;
function Bo(i, e, t, n, r, s) {
  var o, l = e & BN, u = e & VN, h = e & LN;
  if (t && (o = r ? t(i, n, r, s) : t(i)), o !== void 0)
    return o;
  if (!Lt(i))
    return i;
  var f = Fn(i);
  if (f) {
    if (o = nN(i), !l)
      return Iy(i, o);
  } else {
    var m = bl(i), v = m == sE || m == jN;
    if (_l(i))
      return Zy(i, l);
    if (m == oE || m == rE || v && !r) {
      if (o = u || v ? {} : iE(i), !l)
        return u ? j7(i, N7(o, i)) : $7(i, M7(o, i));
    } else {
      if (!It[m])
        return r ? i : {};
      o = kN(i, m, l);
    }
  }
  s || (s = new rr());
  var C = s.get(i);
  if (C)
    return C;
  s.set(i, o), DN(i) ? i.forEach(function(x) {
    o.add(Bo(x, e, t, x, i, s));
  }) : RN(i) && i.forEach(function(x, N) {
    o.set(N, Bo(x, e, t, N, i, s));
  });
  var k = h ? u ? U7 : Qm : u ? Zo : qg, S = f ? void 0 : k(i);
  return oM(S || i, function(x, N) {
    S && (N = x, x = i[N]), Wg(o, N, Bo(x, e, t, N, i, s));
  }), o;
}
var lD = 4;
function aE(i) {
  return Bo(i, lD);
}
var cD = 1, uD = 4;
function js(i) {
  return Bo(i, cD | uD);
}
var dD = 1, hD = 4;
function Qg(i, e) {
  return e = typeof e == "function" ? e : void 0, Bo(i, dD | hD, e);
}
var fD = "__lodash_hash_undefined__";
function mD(i) {
  return this.__data__.set(i, fD), this;
}
function gD(i) {
  return this.__data__.has(i);
}
function Sd(i) {
  var e = -1, t = i == null ? 0 : i.length;
  for (this.__data__ = new Nr(); ++e < t; )
    this.add(i[e]);
}
Sd.prototype.add = Sd.prototype.push = mD;
Sd.prototype.has = gD;
function pD(i, e) {
  for (var t = -1, n = i == null ? 0 : i.length; ++t < n; )
    if (e(i[t], t, i))
      return !0;
  return !1;
}
function _D(i, e) {
  return i.has(e);
}
var vD = 1, wD = 2;
function lE(i, e, t, n, r, s) {
  var o = t & vD, l = i.length, u = e.length;
  if (l != u && !(o && u > l))
    return !1;
  var h = s.get(i), f = s.get(e);
  if (h && f)
    return h == e && f == i;
  var m = -1, v = !0, C = t & wD ? new Sd() : void 0;
  for (s.set(i, e), s.set(e, i); ++m < l; ) {
    var k = i[m], S = e[m];
    if (n)
      var x = o ? n(S, k, m, e, i, s) : n(k, S, m, i, e, s);
    if (x !== void 0) {
      if (x)
        continue;
      v = !1;
      break;
    }
    if (C) {
      if (!pD(e, function(N, y) {
        if (!_D(C, y) && (k === N || r(k, N, t, n, s)))
          return C.push(y);
      })) {
        v = !1;
        break;
      }
    } else if (!(k === S || r(k, S, t, n, s))) {
      v = !1;
      break;
    }
  }
  return s.delete(i), s.delete(e), v;
}
function bD(i) {
  var e = -1, t = Array(i.size);
  return i.forEach(function(n, r) {
    t[++e] = [r, n];
  }), t;
}
function yD(i) {
  var e = -1, t = Array(i.size);
  return i.forEach(function(n) {
    t[++e] = n;
  }), t;
}
var ED = 1, CD = 2, SD = "[object Boolean]", TD = "[object Date]", xD = "[object Error]", kD = "[object Map]", AD = "[object Number]", PD = "[object RegExp]", ID = "[object Set]", RD = "[object String]", OD = "[object Symbol]", MD = "[object ArrayBuffer]", ND = "[object DataView]", xw = lr ? lr.prototype : void 0, mm = xw ? xw.valueOf : void 0;
function DD(i, e, t, n, r, s, o) {
  switch (t) {
    case ND:
      if (i.byteLength != e.byteLength || i.byteOffset != e.byteOffset)
        return !1;
      i = i.buffer, e = e.buffer;
    case MD:
      return !(i.byteLength != e.byteLength || !s(new Cd(i), new Cd(e)));
    case SD:
    case TD:
    case AD:
      return Fl(+i, +e);
    case xD:
      return i.name == e.name && i.message == e.message;
    case PD:
    case RD:
      return i == e + "";
    case kD:
      var l = bD;
    case ID:
      var u = n & ED;
      if (l || (l = yD), i.size != e.size && !u)
        return !1;
      var h = o.get(i);
      if (h)
        return h == e;
      n |= CD, o.set(i, e);
      var f = lE(l(i), l(e), n, r, s, o);
      return o.delete(i), f;
    case OD:
      if (mm)
        return mm.call(i) == mm.call(e);
  }
  return !1;
}
var BD = 1, VD = Object.prototype, LD = VD.hasOwnProperty;
function FD(i, e, t, n, r, s) {
  var o = t & BD, l = Qm(i), u = l.length, h = Qm(e), f = h.length;
  if (u != f && !o)
    return !1;
  for (var m = u; m--; ) {
    var v = l[m];
    if (!(o ? v in e : LD.call(e, v)))
      return !1;
  }
  var C = s.get(i), k = s.get(e);
  if (C && k)
    return C == e && k == i;
  var S = !0;
  s.set(i, e), s.set(e, i);
  for (var x = o; ++m < u; ) {
    v = l[m];
    var N = i[v], y = e[v];
    if (n)
      var A = o ? n(y, N, v, e, i, s) : n(N, y, v, i, e, s);
    if (!(A === void 0 ? N === y || r(N, y, t, n, s) : A)) {
      S = !1;
      break;
    }
    x || (x = v == "constructor");
  }
  if (S && !x) {
    var P = i.constructor, E = e.constructor;
    P != E && "constructor" in i && "constructor" in e && !(typeof P == "function" && P instanceof P && typeof E == "function" && E instanceof E) && (S = !1);
  }
  return s.delete(i), s.delete(e), S;
}
var $D = 1, kw = "[object Arguments]", Aw = "[object Array]", Vu = "[object Object]", zD = Object.prototype, Pw = zD.hasOwnProperty;
function WD(i, e, t, n, r, s) {
  var o = Fn(i), l = Fn(e), u = o ? Aw : bl(i), h = l ? Aw : bl(e);
  u = u == kw ? Vu : u, h = h == kw ? Vu : h;
  var f = u == Vu, m = h == Vu, v = u == h;
  if (v && _l(i)) {
    if (!_l(e))
      return !1;
    o = !0, f = !1;
  }
  if (v && !f)
    return s || (s = new rr()), o || Hg(i) ? lE(i, e, t, n, r, s) : DD(i, e, u, t, n, r, s);
  if (!(t & $D)) {
    var C = f && Pw.call(i, "__wrapped__"), k = m && Pw.call(e, "__wrapped__");
    if (C || k) {
      var S = C ? i.value() : i, x = k ? e.value() : e;
      return s || (s = new rr()), r(S, x, t, n, s);
    }
  }
  return v ? (s || (s = new rr()), FD(i, e, t, n, r, s)) : !1;
}
function ep(i, e, t, n, r) {
  return i === e ? !0 : i == null || e == null || !Ii(i) && !Ii(e) ? i !== i && e !== e : WD(i, e, t, n, ep, r);
}
function jD(i) {
  return function(e, t, n) {
    for (var r = -1, s = Object(e), o = n(e), l = o.length; l--; ) {
      var u = o[i ? l : ++r];
      if (t(s[u], u, s) === !1)
        break;
    }
    return e;
  };
}
var UD = jD();
const HD = UD;
var qD = function() {
  return ji.Date.now();
};
const gm = qD;
var KD = "Expected a function", GD = Math.max, YD = Math.min;
function $o(i, e, t) {
  var n, r, s, o, l, u, h = 0, f = !1, m = !1, v = !0;
  if (typeof i != "function")
    throw new TypeError(KD);
  e = sw(e) || 0, Lt(t) && (f = !!t.leading, m = "maxWait" in t, s = m ? GD(sw(t.maxWait) || 0, e) : s, v = "trailing" in t ? !!t.trailing : v);
  function C(V) {
    var j = n, U = r;
    return n = r = void 0, h = V, o = i.apply(U, j), o;
  }
  function k(V) {
    return h = V, l = setTimeout(N, e), f ? C(V) : o;
  }
  function S(V) {
    var j = V - u, U = V - h, $ = e - j;
    return m ? YD($, s - U) : $;
  }
  function x(V) {
    var j = V - u, U = V - h;
    return u === void 0 || j >= e || j < 0 || m && U >= s;
  }
  function N() {
    var V = gm();
    if (x(V))
      return y(V);
    l = setTimeout(N, S(V));
  }
  function y(V) {
    return l = void 0, v && n ? C(V) : (n = r = void 0, o);
  }
  function A() {
    l !== void 0 && clearTimeout(l), h = 0, n = u = r = l = void 0;
  }
  function P() {
    return l === void 0 ? o : y(gm());
  }
  function E() {
    var V = gm(), j = x(V);
    if (n = arguments, r = this, u = V, j) {
      if (l === void 0)
        return k(u);
      if (m)
        return clearTimeout(l), l = setTimeout(N, e), C(u);
    }
    return l === void 0 && (l = setTimeout(N, e)), o;
  }
  return E.cancel = A, E.flush = P, E;
}
function ig(i, e, t) {
  (t !== void 0 && !Fl(i[e], t) || t === void 0 && !(e in i)) && zg(i, e, t);
}
function JD(i) {
  return Ii(i) && th(i);
}
function rg(i, e) {
  if (!(e === "constructor" && typeof i[e] == "function") && e != "__proto__")
    return i[e];
}
function XD(i) {
  return Xo(i, Zo(i));
}
function ZD(i, e, t, n, r, s, o) {
  var l = rg(i, t), u = rg(e, t), h = o.get(u);
  if (h) {
    ig(i, t, h);
    return;
  }
  var f = s ? s(l, u, t + "", i, e, o) : void 0, m = f === void 0;
  if (m) {
    var v = Fn(u), C = !v && _l(u), k = !v && !C && Hg(u);
    f = u, v || C || k ? Fn(l) ? f = l : JD(l) ? f = Iy(l) : C ? (m = !1, f = Zy(u, !0)) : k ? (m = !1, f = nE(u, !0)) : f = [] : ui(u) || Jm(u) ? (f = l, Jm(l) ? f = XD(l) : (!Lt(l) || Ls(l)) && (f = iE(u))) : m = !1;
  }
  m && (o.set(u, f), r(f, u, n, s, o), o.delete(u)), ig(i, t, f);
}
function cE(i, e, t, n, r) {
  i !== e && HD(e, function(s, o) {
    if (r || (r = new rr()), Lt(s))
      ZD(i, e, o, t, cE, n, r);
    else {
      var l = n ? n(rg(i, o), s, o + "", i, e, r) : void 0;
      l === void 0 && (l = s), ig(i, o, l);
    }
  }, Zo);
}
function QD(i) {
  var e = i == null ? 0 : i.length;
  return e ? i[e - 1] : void 0;
}
var eB = "[object String]";
function Iw(i) {
  return typeof i == "string" || !Fn(i) && Ii(i) && os(i) == eB;
}
function tB(i, e) {
  return e.length < 2 ? i : $y(i, jy(e, 0, -1));
}
function Dr(i) {
  return Ii(i) && i.nodeType === 1 && !ui(i);
}
function Rw(i, e) {
  return ep(i, e);
}
function nB(i, e, t) {
  t = typeof t == "function" ? t : void 0;
  var n = t ? t(i, e) : void 0;
  return n === void 0 ? ep(i, e, void 0, t) : !!n;
}
var iB = Oy(function(i, e, t) {
  cE(i, e, t);
});
const uE = iB;
function rB(i, e) {
  return e = Gg(e, i), i = tB(i, e), i == null || delete i[Yg(QD(e))];
}
function sB(i, e, t, n) {
  if (!Lt(i))
    return i;
  e = Gg(e, i);
  for (var r = -1, s = e.length, o = s - 1, l = i; l != null && ++r < s; ) {
    var u = Yg(e[r]), h = t;
    if (u === "__proto__" || u === "constructor" || u === "prototype")
      return i;
    if (r != o) {
      var f = l[u];
      h = n ? n(f, u, l) : void 0, h === void 0 && (h = Lt(f) ? f : $g(e[r + 1]) ? [] : {});
    }
    Wg(l, u, h), l = l[u];
  }
  return i;
}
function oB(i, e, t) {
  return i == null ? i : sB(i, e, t);
}
var aB = "Expected a function";
function tp(i, e, t) {
  var n = !0, r = !0;
  if (typeof i != "function")
    throw new TypeError(aB);
  return Lt(t) && (n = "leading" in t ? !!t.leading : n, r = "trailing" in t ? !!t.trailing : r), $o(i, e, {
    leading: n,
    maxWait: e,
    trailing: r
  });
}
function lB(i, e) {
  return i == null ? !0 : rB(i, e);
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const Td = Symbol("observableProperties"), rh = Symbol("boundObservables"), xd = Symbol("boundProperties"), To = Symbol("decoratedMethods"), Ow = Symbol("decoratedOriginal"), dE = Nt(kt());
function Nt(i) {
  if (!i)
    return dE;
  class e extends i {
    set(n, r) {
      if (Lt(n)) {
        Object.keys(n).forEach((o) => {
          this.set(o, n[o]);
        }, this);
        return;
      }
      pm(this);
      const s = this[Td];
      if (n in this && !s.has(n))
        throw new B("observable-set-cannot-override", this);
      Object.defineProperty(this, n, {
        enumerable: !0,
        configurable: !0,
        get() {
          return s.get(n);
        },
        set(o) {
          const l = s.get(n);
          let u = this.fire(`set:${n}`, n, o, l);
          u === void 0 && (u = o), (l !== u || !s.has(n)) && (s.set(n, u), this.fire(`change:${n}`, n, u, l));
        }
      }), this[n] = r;
    }
    bind(...n) {
      if (!n.length || !Mw(n))
        throw new B("observable-bind-wrong-properties", this);
      if (new Set(n).size !== n.length)
        throw new B("observable-bind-duplicate-properties", this);
      pm(this);
      const r = this[xd];
      n.forEach((o) => {
        if (r.has(o))
          throw new B("observable-bind-rebind", this);
      });
      const s = /* @__PURE__ */ new Map();
      return n.forEach((o) => {
        const l = { property: o, to: [] };
        r.set(o, l), s.set(o, l);
      }), {
        to: cB,
        toMany: uB,
        _observable: this,
        _bindProperties: n,
        _to: [],
        _bindings: s
      };
    }
    unbind(...n) {
      if (!this[Td])
        return;
      const r = this[xd], s = this[rh];
      if (n.length) {
        if (!Mw(n))
          throw new B("observable-unbind-wrong-properties", this);
        n.forEach((o) => {
          const l = r.get(o);
          l && (l.to.forEach(([u, h]) => {
            const f = s.get(u), m = f[h];
            m.delete(l), m.size || delete f[h], Object.keys(f).length || (s.delete(u), this.stopListening(u, "change"));
          }), r.delete(o));
        });
      } else
        s.forEach((o, l) => {
          this.stopListening(l, "change");
        }), s.clear(), r.clear();
    }
    decorate(n) {
      pm(this);
      const r = this[n];
      if (!r)
        throw new B("observablemixin-cannot-decorate-undefined", this, { object: this, methodName: n });
      this.on(n, (s, o) => {
        s.return = r.apply(this, o);
      }), this[n] = function(...s) {
        return this.fire(n, s);
      }, this[n][Ow] = r, this[To] || (this[To] = []), this[To].push(n);
    }
    // Override the EmitterMixin stopListening method to be able to clean (and restore) decorated methods.
    // This is needed in case of:
    //  1. Have x.foo() decorated.
    //  2. Call x.stopListening()
    //  3. Call x.foo(). Problem: nothing happens (the original foo() method is not executed)
    stopListening(n, r, s) {
      if (!n && this[To]) {
        for (const o of this[To])
          this[o] = this[o][Ow];
        delete this[To];
      }
      super.stopListening(n, r, s);
    }
  }
  return e;
}
[
  "set",
  "bind",
  "unbind",
  "decorate",
  "on",
  "once",
  "off",
  "listenTo",
  "stopListening",
  "fire",
  "delegate",
  "stopDelegating",
  "_addEventListener",
  "_removeEventListener"
].forEach((i) => {
  Nt[i] = dE.prototype[i];
});
function pm(i) {
  i[Td] || (Object.defineProperty(i, Td, {
    value: /* @__PURE__ */ new Map()
  }), Object.defineProperty(i, rh, {
    value: /* @__PURE__ */ new Map()
  }), Object.defineProperty(i, xd, {
    value: /* @__PURE__ */ new Map()
  }));
}
function cB(...i) {
  const e = hB(...i), t = Array.from(this._bindings.keys()), n = t.length;
  if (!e.callback && e.to.length > 1)
    throw new B("observable-bind-to-no-callback", this);
  if (n > 1 && e.callback)
    throw new B("observable-bind-to-extra-callback", this);
  e.to.forEach((r) => {
    if (r.properties.length && r.properties.length !== n)
      throw new B("observable-bind-to-properties-length", this);
    r.properties.length || (r.properties = this._bindProperties);
  }), this._to = e.to, e.callback && (this._bindings.get(t[0]).callback = e.callback), gB(this._observable, this._to), mB(this), this._bindProperties.forEach((r) => {
    hE(this._observable, r);
  });
}
function uB(i, e, t) {
  if (this._bindings.size > 1)
    throw new B("observable-bind-to-many-not-one-binding", this);
  this.to(
    ...dB(i, e),
    // ...using given callback to parse attribute values.
    t
  );
}
function dB(i, e) {
  const t = i.map((n) => [n, e]);
  return Array.prototype.concat.apply([], t);
}
function Mw(i) {
  return i.every((e) => typeof e == "string");
}
function hB(...i) {
  if (!i.length)
    throw new B("observable-bind-to-parse-error", null);
  const e = { to: [] };
  let t;
  return typeof i[i.length - 1] == "function" && (e.callback = i.pop()), i.forEach((n) => {
    if (typeof n == "string")
      t.properties.push(n);
    else if (typeof n == "object")
      t = { observable: n, properties: [] }, e.to.push(t);
    else
      throw new B("observable-bind-to-parse-error", null);
  }), e;
}
function fB(i, e, t, n) {
  const r = i[rh], s = r.get(t), o = s || {};
  o[n] || (o[n] = /* @__PURE__ */ new Set()), o[n].add(e), s || r.set(t, o);
}
function mB(i) {
  let e;
  i._bindings.forEach((t, n) => {
    i._to.forEach((r) => {
      e = r.properties[t.callback ? 0 : i._bindProperties.indexOf(n)], t.to.push([r.observable, e]), fB(i._observable, t, r.observable, e);
    });
  });
}
function hE(i, e) {
  const n = i[xd].get(e);
  let r;
  n.callback ? r = n.callback.apply(i, n.to.map((s) => s[0][s[1]])) : (r = n.to[0], r = r[0][r[1]]), Object.prototype.hasOwnProperty.call(i, e) ? i[e] = r : i.set(e, r);
}
function gB(i, e) {
  e.forEach((t) => {
    const n = i[rh];
    let r;
    n.get(t.observable) || i.listenTo(t.observable, "change", (s, o) => {
      r = n.get(t.observable)[o], r && r.forEach((l) => {
        hE(i, l.property);
      });
    });
  });
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class pB {
  constructor() {
    this._replacedElements = [];
  }
  /**
   * Hides the `element` and, if specified, inserts the the given element next to it.
   *
   * The effect of this method can be reverted by {@link #restore}.
   *
   * @param element The element to replace.
   * @param newElement The replacement element. If not passed, then the `element` will just be hidden.
   */
  replace(e, t) {
    this._replacedElements.push({ element: e, newElement: t }), e.style.display = "none", t && e.parentNode.insertBefore(t, e.nextSibling);
  }
  /**
   * Restores what {@link #replace} did.
   */
  restore() {
    this._replacedElements.forEach(({ element: e, newElement: t }) => {
      e.style.display = "", t && t.remove();
    }), this._replacedElements = [];
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function sg(i) {
  let e = 0;
  for (const t of i)
    e++;
  return e;
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function Pn(i, e) {
  const t = Math.min(i.length, e.length);
  for (let n = 0; n < t; n++)
    if (i[n] != e[n])
      return n;
  return i.length == e.length ? "same" : i.length < e.length ? "prefix" : "extension";
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function di(i) {
  return !!(i && i[Symbol.iterator]);
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function _B(i, e, t = {}, n = []) {
  const r = t && t.xmlns, s = r ? i.createElementNS(r, e) : i.createElement(e);
  for (const o in t)
    s.setAttribute(o, t[o]);
  (Iw(n) || !di(n)) && (n = [n]);
  for (let o of n)
    Iw(o) && (o = i.createTextNode(o)), s.appendChild(o);
  return s;
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class fE {
  /**
   * Creates an instance of the {@link ~Config} class.
   *
   * @param configurations The initial configurations to be set. Usually, provided by the user.
   * @param defaultConfigurations The default configurations. Usually, provided by the system.
   */
  constructor(e, t) {
    this._config = {}, t && this.define(Nw(t)), e && this._setObjectToTarget(this._config, e);
  }
  set(e, t) {
    this._setToTarget(this._config, e, t);
  }
  define(e, t) {
    this._setToTarget(this._config, e, t, !0);
  }
  /**
   * Gets the value for a configuration entry.
   *
   * ```ts
   * config.get( 'name' );
   * ```
   *
   * Deep configurations can be retrieved by separating each part with a dot.
   *
   * ```ts
   * config.get( 'toolbar.collapsed' );
   * ```
   *
   * @param name The configuration name. Configuration names are case-sensitive.
   * @returns The configuration value or `undefined` if the configuration entry was not found.
   */
  get(e) {
    return this._getFromSource(this._config, e);
  }
  /**
   * Iterates over all top level configuration names.
   */
  *names() {
    for (const e of Object.keys(this._config))
      yield e;
  }
  /**
   * Saves passed configuration to the specified target (nested object).
   *
   * @param target Nested config object.
   * @param name The configuration name or an object from which take properties as
   * configuration entries. Configuration names are case-sensitive.
   * @param value The configuration value. Used if a name is passed.
   * @param isDefine Define if passed configuration should overwrite existing one.
   */
  _setToTarget(e, t, n, r = !1) {
    if (ui(t)) {
      this._setObjectToTarget(e, t, r);
      return;
    }
    const s = t.split(".");
    t = s.pop();
    for (const o of s)
      ui(e[o]) || (e[o] = {}), e = e[o];
    if (ui(n)) {
      ui(e[t]) || (e[t] = {}), e = e[t], this._setObjectToTarget(e, n, r);
      return;
    }
    r && typeof e[t] < "u" || (e[t] = n);
  }
  /**
   * Get specified configuration from specified source (nested object).
   *
   * @param source level of nested object.
   * @param name The configuration name. Configuration names are case-sensitive.
   * @returns The configuration value or `undefined` if the configuration entry was not found.
   */
  _getFromSource(e, t) {
    const n = t.split(".");
    t = n.pop();
    for (const r of n) {
      if (!ui(e[r])) {
        e = null;
        break;
      }
      e = e[r];
    }
    return e ? Nw(e[t]) : void 0;
  }
  /**
   * Iterates through passed object and calls {@link #_setToTarget} method with object key and value for each property.
   *
   * @param target Nested config object.
   * @param configuration Configuration data set
   * @param isDefine Defines if passed configuration is default configuration or not.
   */
  _setObjectToTarget(e, t, n) {
    Object.keys(t).forEach((r) => {
      this._setToTarget(e, r, t[r], n);
    });
  }
}
function Nw(i) {
  return Qg(i, vB);
}
function vB(i) {
  return Dr(i) ? i : void 0;
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function ns(i) {
  if (i) {
    if (i.defaultView)
      return i instanceof i.defaultView.Document;
    if (i.ownerDocument && i.ownerDocument.defaultView)
      return i instanceof i.ownerDocument.defaultView.Node;
  }
  return !1;
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function kd(i) {
  const e = Object.prototype.toString.apply(i);
  return e == "[object Window]" || e == "[object global]";
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const mE = as(kt());
function as(i) {
  if (!i)
    return mE;
  class e extends i {
    listenTo(n, r, s, o = {}) {
      if (ns(n) || kd(n)) {
        const l = {
          capture: !!o.useCapture,
          passive: !!o.usePassive
        }, u = this._getProxyEmitter(n, l) || new wB(n, l);
        this.listenTo(u, r, s, o);
      } else
        super.listenTo(n, r, s, o);
    }
    stopListening(n, r, s) {
      if (ns(n) || kd(n)) {
        const o = this._getAllProxyEmitters(n);
        for (const l of o)
          this.stopListening(l, r, s);
      } else
        super.stopListening(n, r, s);
    }
    /**
     * Retrieves ProxyEmitter instance for given DOM Node residing in this Host and given options.
     *
     * @param node DOM Node of the ProxyEmitter.
     * @param options Additional options.
     * @param options.useCapture Indicates that events of this type will be dispatched to the registered
     * listener before being dispatched to any EventTarget beneath it in the DOM tree.
     * @param options.usePassive Indicates that the function specified by listener will never call preventDefault()
     * and prevents blocking browser's main thread by this event handler.
     * @returns ProxyEmitter instance bound to the DOM Node.
     */
    _getProxyEmitter(n, r) {
      return t4(this, gE(n, r));
    }
    /**
     * Retrieves all the ProxyEmitter instances for given DOM Node residing in this Host.
     *
     * @param node DOM Node of the ProxyEmitter.
     */
    _getAllProxyEmitters(n) {
      return [
        { capture: !1, passive: !1 },
        { capture: !1, passive: !0 },
        { capture: !0, passive: !1 },
        { capture: !0, passive: !0 }
      ].map((r) => this._getProxyEmitter(n, r)).filter((r) => !!r);
    }
  }
  return e;
}
[
  "_getProxyEmitter",
  "_getAllProxyEmitters",
  "on",
  "once",
  "off",
  "listenTo",
  "stopListening",
  "fire",
  "delegate",
  "stopDelegating",
  "_addEventListener",
  "_removeEventListener"
].forEach((i) => {
  as[i] = mE.prototype[i];
});
class wB extends kt() {
  /**
   * @param node DOM Node that fires events.
   * @param options Additional options.
   * @param options.useCapture Indicates that events of this type will be dispatched to the registered
   * listener before being dispatched to any EventTarget beneath it in the DOM tree.
   * @param options.usePassive Indicates that the function specified by listener will never call preventDefault()
   * and prevents blocking browser's main thread by this event handler.
   */
  constructor(e, t) {
    super(), Sy(this, gE(e, t)), this._domNode = e, this._options = t;
  }
  /**
   * Registers a callback function to be executed when an event is fired.
   *
   * It attaches a native DOM listener to the DOM Node. When fired,
   * a corresponding Emitter event will also fire with DOM Event object as an argument.
   *
   * **Note**: This is automatically called by the
   * {@link module:utils/emittermixin~Emitter#listenTo `Emitter#listenTo()`}.
   *
   * @param event The name of the event.
   */
  attach(e) {
    if (this._domListeners && this._domListeners[e])
      return;
    const t = this._createDomListener(e);
    this._domNode.addEventListener(e, t, this._options), this._domListeners || (this._domListeners = {}), this._domListeners[e] = t;
  }
  /**
   * Stops executing the callback on the given event.
   *
   * **Note**: This is automatically called by the
   * {@link module:utils/emittermixin~Emitter#stopListening `Emitter#stopListening()`}.
   *
   * @param event The name of the event.
   */
  detach(e) {
    let t;
    this._domListeners[e] && (!(t = this._events[e]) || !t.callbacks.length) && this._domListeners[e].removeListener();
  }
  /**
   * Adds callback to emitter for given event.
   *
   * @internal
   * @param event The name of the event.
   * @param callback The function to be called on event.
   * @param options Additional options.
   */
  _addEventListener(e, t, n) {
    this.attach(e), kt().prototype._addEventListener.call(this, e, t, n);
  }
  /**
   * Removes callback from emitter for given event.
   *
   * @internal
   * @param event The name of the event.
   * @param callback The function to stop being called.
   */
  _removeEventListener(e, t) {
    kt().prototype._removeEventListener.call(this, e, t), this.detach(e);
  }
  /**
   * Creates a native DOM listener callback. When the native DOM event
   * is fired it will fire corresponding event on this ProxyEmitter.
   * Note: A native DOM Event is passed as an argument.
   *
   * @param event The name of the event.
   * @returns The DOM listener callback.
   */
  _createDomListener(e) {
    const t = (n) => {
      this.fire(e, n);
    };
    return t.removeListener = () => {
      this._domNode.removeEventListener(e, t, this._options), delete this._domListeners[e];
    }, t;
  }
}
function bB(i) {
  return i["data-ck-expando"] || (i["data-ck-expando"] = Rr());
}
function gE(i, e) {
  let t = bB(i);
  for (const n of Object.keys(e).sort())
    e[n] && (t += "-" + n);
  return t;
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
let og;
try {
  og = { window, document };
} catch {
  /* istanbul ignore next -- @preserve */
  og = { window: {}, document: {} };
}
const Ke = og;
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function pE(i) {
  const e = [];
  let t = i;
  for (; t && t.nodeType != Node.DOCUMENT_NODE; )
    e.unshift(t), t = t.parentNode;
  return e;
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function sh(i) {
  return i instanceof HTMLTextAreaElement ? i.value : i.innerHTML;
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function qt(i) {
  return Object.prototype.toString.call(i) == "[object Text]";
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function oh(i) {
  return Object.prototype.toString.apply(i) == "[object Range]";
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function _E(i) {
  const e = i.ownerDocument.defaultView.getComputedStyle(i);
  return {
    top: parseInt(e.borderTopWidth, 10),
    right: parseInt(e.borderRightWidth, 10),
    bottom: parseInt(e.borderBottomWidth, 10),
    left: parseInt(e.borderLeftWidth, 10)
  };
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const vE = ["top", "right", "bottom", "left", "width", "height"];
class pt {
  /**
   * Creates an instance of rect.
   *
   * ```ts
   * // Rect of an HTMLElement.
   * const rectA = new Rect( document.body );
   *
   * // Rect of a DOM Range.
   * const rectB = new Rect( document.getSelection().getRangeAt( 0 ) );
   *
   * // Rect of a window (web browser viewport).
   * const rectC = new Rect( window );
   *
   * // Rect out of an object.
   * const rectD = new Rect( { top: 0, right: 10, bottom: 10, left: 0, width: 10, height: 10 } );
   *
   * // Rect out of another Rect instance.
   * const rectE = new Rect( rectD );
   *
   * // Rect out of a ClientRect.
   * const rectF = new Rect( document.body.getClientRects().item( 0 ) );
   * ```
   *
   * **Note**: By default a rect of an HTML element includes its CSS borders and scrollbars (if any)
   * ant the rect of a `window` includes scrollbars too. Use {@link #excludeScrollbarsAndBorders}
   * to get the inner part of the rect.
   *
   * @param source A source object to create the rect.
   */
  constructor(e) {
    const t = oh(e);
    if (Object.defineProperty(this, "_source", {
      // If the source is a Rect instance, copy it's #_source.
      value: e._source || e,
      writable: !0,
      enumerable: !1
    }), wE(e) || t)
      if (t) {
        const n = pt.getDomRangeRects(e);
        Lu(this, pt.getBoundingRect(n));
      } else
        Lu(this, e.getBoundingClientRect());
    else if (kd(e)) {
      const { innerWidth: n, innerHeight: r } = e;
      Lu(this, {
        top: 0,
        right: n,
        bottom: r,
        left: 0,
        width: n,
        height: r
      });
    } else
      Lu(this, e);
  }
  /**
   * Returns a clone of the rect.
   *
   * @returns A cloned rect.
   */
  clone() {
    return new pt(this);
  }
  /**
   * Moves the rect so that its upper–left corner lands in desired `[ x, y ]` location.
   *
   * @param x Desired horizontal location.
   * @param y Desired vertical location.
   * @returns A rect which has been moved.
   */
  moveTo(e, t) {
    return this.top = t, this.right = e + this.width, this.bottom = t + this.height, this.left = e, this;
  }
  /**
   * Moves the rect in–place by a dedicated offset.
   *
   * @param x A horizontal offset.
   * @param y A vertical offset
   * @returns A rect which has been moved.
   */
  moveBy(e, t) {
    return this.top += t, this.right += e, this.left += e, this.bottom += t, this;
  }
  /**
   * Returns a new rect a a result of intersection with another rect.
   */
  getIntersection(e) {
    const t = {
      top: Math.max(this.top, e.top),
      right: Math.min(this.right, e.right),
      bottom: Math.min(this.bottom, e.bottom),
      left: Math.max(this.left, e.left),
      width: 0,
      height: 0
    };
    return t.width = t.right - t.left, t.height = t.bottom - t.top, t.width < 0 || t.height < 0 ? null : new pt(t);
  }
  /**
   * Returns the area of intersection with another rect.
   *
   * @returns Area of intersection.
   */
  getIntersectionArea(e) {
    const t = this.getIntersection(e);
    return t ? t.getArea() : 0;
  }
  /**
   * Returns the area of the rect.
   */
  getArea() {
    return this.width * this.height;
  }
  /**
   * Returns a new rect, a part of the original rect, which is actually visible to the user,
   * e.g. an original rect cropped by parent element rects which have `overflow` set in CSS
   * other than `"visible"`.
   *
   * If there's no such visible rect, which is when the rect is limited by one or many of
   * the ancestors, `null` is returned.
   *
   * @returns A visible rect instance or `null`, if there's none.
   */
  getVisible() {
    const e = this._source;
    let t = this.clone();
    if (!Dw(e)) {
      let n = e.parentNode || e.commonAncestorContainer;
      for (; n && !Dw(n); ) {
        const r = new pt(n), s = t.getIntersection(r);
        if (s)
          s.getArea() < t.getArea() && (t = s);
        else
          return null;
        n = n.parentNode;
      }
    }
    return t;
  }
  /**
   * Checks if all property values ({@link #top}, {@link #left}, {@link #right},
   * {@link #bottom}, {@link #width} and {@link #height}) are the equal in both rect
   * instances.
   *
   * @param anotherRect A rect instance to compare with.
   * @returns `true` when Rects are equal. `false` otherwise.
   */
  isEqual(e) {
    for (const t of vE)
      if (this[t] !== e[t])
        return !1;
    return !0;
  }
  /**
   * Checks whether a rect fully contains another rect instance.
   *
   * @param anotherRect
   * @returns `true` if contains, `false` otherwise.
   */
  contains(e) {
    const t = this.getIntersection(e);
    return !!(t && t.isEqual(e));
  }
  /**
   * Excludes scrollbars and CSS borders from the rect.
   *
   * * Borders are removed when {@link #_source} is an HTML element.
   * * Scrollbars are excluded from HTML elements and the `window`.
   *
   * @returns A rect which has been updated.
   */
  excludeScrollbarsAndBorders() {
    const e = this._source;
    let t, n, r;
    if (kd(e))
      t = e.innerWidth - e.document.documentElement.clientWidth, n = e.innerHeight - e.document.documentElement.clientHeight, r = e.getComputedStyle(e.document.documentElement).direction;
    else {
      const s = _E(e);
      t = e.offsetWidth - e.clientWidth - s.left - s.right, n = e.offsetHeight - e.clientHeight - s.top - s.bottom, r = e.ownerDocument.defaultView.getComputedStyle(e).direction, this.left += s.left, this.top += s.top, this.right -= s.right, this.bottom -= s.bottom, this.width = this.right - this.left, this.height = this.bottom - this.top;
    }
    return this.width -= t, r === "ltr" ? this.right -= t : this.left += t, this.height -= n, this.bottom -= n, this;
  }
  /**
   * Returns an array of rects of the given native DOM Range.
   *
   * @param range A native DOM range.
   * @returns DOM Range rects.
   */
  static getDomRangeRects(e) {
    const t = [], n = Array.from(e.getClientRects());
    if (n.length)
      for (const r of n)
        t.push(new pt(r));
    else {
      let r = e.startContainer;
      qt(r) && (r = r.parentNode);
      const s = new pt(r.getBoundingClientRect());
      s.right = s.left, s.width = 0, t.push(s);
    }
    return t;
  }
  /**
   * Returns a bounding rectangle that contains all the given `rects`.
   *
   * @param rects A list of rectangles that should be contained in the result rectangle.
   * @returns Bounding rectangle or `null` if no `rects` were given.
   */
  static getBoundingRect(e) {
    const t = {
      left: Number.POSITIVE_INFINITY,
      top: Number.POSITIVE_INFINITY,
      right: Number.NEGATIVE_INFINITY,
      bottom: Number.NEGATIVE_INFINITY,
      width: 0,
      height: 0
    };
    let n = 0;
    for (const r of e)
      n++, t.left = Math.min(t.left, r.left), t.top = Math.min(t.top, r.top), t.right = Math.max(t.right, r.right), t.bottom = Math.max(t.bottom, r.bottom);
    return n == 0 ? null : (t.width = t.right - t.left, t.height = t.bottom - t.top, new pt(t));
  }
}
function Lu(i, e) {
  for (const t of vE)
    i[t] = e[t];
}
function Dw(i) {
  return wE(i) ? i === i.ownerDocument.body : !1;
}
function wE(i) {
  return i !== null && typeof i == "object" && i.nodeType === 1 && typeof i.getBoundingClientRect == "function";
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class xt {
  /**
   * Creates an instance of the `ResizeObserver` class.
   *
   * @param element A DOM element that is to be observed for resizing. Note that
   * the element must be visible (i.e. not detached from DOM) for the observer to work.
   * @param callback A function called when the observed element was resized. It passes
   * the [`ResizeObserverEntry`](https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserverEntry)
   * object with information about the resize event.
   */
  constructor(e, t) {
    xt._observerInstance || xt._createObserver(), this._element = e, this._callback = t, xt._addElementCallback(e, t), xt._observerInstance.observe(e);
  }
  /**
   * Destroys the observer which disables the `callback` passed to the {@link #constructor}.
   */
  destroy() {
    xt._deleteElementCallback(this._element, this._callback);
  }
  /**
   * Registers a new resize callback for the DOM element.
   */
  static _addElementCallback(e, t) {
    xt._elementCallbacks || (xt._elementCallbacks = /* @__PURE__ */ new Map());
    let n = xt._elementCallbacks.get(e);
    n || (n = /* @__PURE__ */ new Set(), xt._elementCallbacks.set(e, n)), n.add(t);
  }
  /**
   * Removes a resize callback from the DOM element. If no callbacks are left
   * for the element, it removes the element from the native observer.
   */
  static _deleteElementCallback(e, t) {
    const n = xt._getElementCallbacks(e);
    n && (n.delete(t), n.size || (xt._elementCallbacks.delete(e), xt._observerInstance.unobserve(e))), xt._elementCallbacks && !xt._elementCallbacks.size && (xt._observerInstance = null, xt._elementCallbacks = null);
  }
  /**
   * Returns are registered resize callbacks for the DOM element.
   */
  static _getElementCallbacks(e) {
    return xt._elementCallbacks ? xt._elementCallbacks.get(e) : null;
  }
  /**
   * Creates the single native observer shared across all `ResizeObserver` instances.
   */
  static _createObserver() {
    xt._observerInstance = new Ke.window.ResizeObserver((e) => {
      for (const t of e) {
        const n = xt._getElementCallbacks(t.target);
        if (n)
          for (const r of n)
            r(t);
      }
    });
  }
}
xt._observerInstance = null;
xt._elementCallbacks = null;
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function Bw(i, e) {
  i instanceof HTMLTextAreaElement && (i.value = e), i.innerHTML = e;
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function $l(i) {
  return (e) => e + i;
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function Fu(i) {
  let e = 0;
  for (; i.previousSibling; )
    i = i.previousSibling, e++;
  return e;
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function bE(i, e, t) {
  i.insertBefore(t, i.childNodes[e] || null);
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function Mo(i) {
  return i && i.nodeType === Node.COMMENT_NODE;
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function $s(i) {
  return !!(i && i.getClientRects && i.getClientRects().length);
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function yB(i) {
  return !i || !i.parentNode || i.offsetParent === Ke.document.body ? null : i.offsetParent;
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function yE({ element: i, target: e, positions: t, limiter: n, fitInViewport: r, viewportOffsetConfig: s }) {
  Ls(e) && (e = e()), Ls(n) && (n = n());
  const o = yB(i), l = new pt(i), u = new pt(e);
  let h;
  const f = r && EB(s) || null, m = { targetRect: u, elementRect: l, positionedElementAncestor: o, viewportRect: f };
  if (!n && !r)
    h = new ag(t[0], m);
  else {
    const v = n && new pt(n).getVisible();
    Object.assign(m, { limiterRect: v, viewportRect: f }), h = CB(t, m) || new ag(t[0], m);
  }
  return h;
}
function EB(i) {
  i = Object.assign({ top: 0, bottom: 0, left: 0, right: 0 }, i);
  const e = new pt(Ke.window);
  return e.top += i.top, e.height -= i.top, e.bottom -= i.bottom, e.height -= i.bottom, e;
}
function CB(i, e) {
  const { elementRect: t } = e, n = t.getArea(), r = i.map((l) => new ag(l, e)).filter((l) => !!l.name);
  let s = 0, o = null;
  for (const l of r) {
    const { limiterIntersectionArea: u, viewportIntersectionArea: h } = l;
    if (u === n)
      return l;
    const f = h ** 2 + u ** 2;
    f > s && (s = f, o = l);
  }
  return o;
}
function SB(i, e) {
  const t = EE(new pt(e)), n = _E(e);
  let r = 0, s = 0;
  r -= t.left, s -= t.top, r += e.scrollLeft, s += e.scrollTop, r -= n.left, s -= n.top, i.moveBy(r, s);
}
function EE(i) {
  const { scrollX: e, scrollY: t } = Ke.window;
  return i.clone().moveBy(e, t);
}
class ag {
  /**
   * Creates an instance of the {@link module:utils/dom/position~PositionObject} class.
   *
   * @param positioningFunction function The function that defines the expected
   * coordinates the positioned element should move to.
   * @param options options object.
   * @param options.elementRect The positioned element rect.
   * @param options.targetRect The target element rect.
   * @param options.viewportRect The viewport rect.
   * @param options.limiterRect The limiter rect.
   * @param options.positionedElementAncestor Nearest element ancestor element which CSS position is not "static".
   */
  constructor(e, t) {
    const n = e(t.targetRect, t.elementRect, t.viewportRect);
    if (!n)
      return;
    const { left: r, top: s, name: o, config: l } = n;
    this.name = o, this.config = l, this._positioningFunctionCorrdinates = { left: r, top: s }, this._options = t;
  }
  /**
   * The left value in pixels in the CSS `position: absolute` coordinate system.
   * Set it on the positioned element in DOM to move it to the position.
   */
  get left() {
    return this._absoluteRect.left;
  }
  /**
   * The top value in pixels in the CSS `position: absolute` coordinate system.
   * Set it on the positioned element in DOM to move it to the position.
   */
  get top() {
    return this._absoluteRect.top;
  }
  /**
   * An intersection area between positioned element and limiter within viewport constraints.
   */
  get limiterIntersectionArea() {
    const e = this._options.limiterRect;
    if (e) {
      const t = this._options.viewportRect;
      if (t) {
        const n = e.getIntersection(t);
        if (n)
          return n.getIntersectionArea(this._rect);
      } else
        return e.getIntersectionArea(this._rect);
    }
    return 0;
  }
  /**
   * An intersection area between positioned element and viewport.
   */
  get viewportIntersectionArea() {
    const e = this._options.viewportRect;
    return e ? e.getIntersectionArea(this._rect) : 0;
  }
  /**
   * An already positioned element rect. A clone of the element rect passed to the constructor
   * but placed in the viewport according to the positioning function.
   */
  get _rect() {
    return this._cachedRect ? this._cachedRect : (this._cachedRect = this._options.elementRect.clone().moveTo(this._positioningFunctionCorrdinates.left, this._positioningFunctionCorrdinates.top), this._cachedRect);
  }
  /**
   * An already absolutely positioned element rect. See ({@link #_rect}).
   */
  get _absoluteRect() {
    return this._cachedAbsoluteRect ? this._cachedAbsoluteRect : (this._cachedAbsoluteRect = EE(this._rect), this._options.positionedElementAncestor && SB(this._cachedAbsoluteRect, this._options.positionedElementAncestor), this._cachedAbsoluteRect);
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function Vw(i) {
  const e = i.parentNode;
  e && e.removeChild(i);
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function TB({ target: i, viewportOffset: e = 0, ancestorOffset: t = 0, alignToTop: n, forceScroll: r }) {
  const s = np(i);
  let o = s, l = null;
  for (; o; ) {
    let u;
    o == s ? u = Lw(i) : u = Lw(l), kB({
      parent: u,
      getRect: () => Fw(i, o),
      alignToTop: n,
      ancestorOffset: t,
      forceScroll: r
    });
    const h = Fw(i, o);
    if (xB({
      window: o,
      rect: h,
      viewportOffset: e,
      alignToTop: n,
      forceScroll: r
    }), o.parent != o) {
      if (l = o.frameElement, o = o.parent, !l)
        return;
    } else
      o = null;
  }
}
function xB({ window: i, rect: e, alignToTop: t, forceScroll: n, viewportOffset: r }) {
  const s = e.clone().moveBy(0, r), o = e.clone().moveBy(0, -r), l = new pt(i).excludeScrollbarsAndBorders(), u = [o, s], h = t && n, f = u.every((S) => l.contains(S));
  let { scrollX: m, scrollY: v } = i;
  const C = m, k = v;
  h ? v -= l.top - e.top + r : f || (SE(o, l) ? v -= l.top - e.top + r : CE(s, l) && (t ? v += e.top - l.top - r : v += e.bottom - l.bottom + r)), f || (TE(e, l) ? m -= l.left - e.left + r : xE(e, l) && (m += e.right - l.right + r)), (m != C || v !== k) && i.scrollTo(m, v);
}
function kB({ parent: i, getRect: e, alignToTop: t, forceScroll: n, ancestorOffset: r = 0 }) {
  const s = np(i), o = t && n;
  let l, u, h;
  for (; i != s.document.body; )
    u = e(), l = new pt(i).excludeScrollbarsAndBorders(), h = l.contains(u), o ? i.scrollTop -= l.top - u.top + r : h || (SE(u, l) ? i.scrollTop -= l.top - u.top + r : CE(u, l) && (t ? i.scrollTop += u.top - l.top - r : i.scrollTop += u.bottom - l.bottom + r)), h || (TE(u, l) ? i.scrollLeft -= l.left - u.left + r : xE(u, l) && (i.scrollLeft += u.right - l.right + r)), i = i.parentNode;
}
function CE(i, e) {
  return i.bottom > e.bottom;
}
function SE(i, e) {
  return i.top < e.top;
}
function TE(i, e) {
  return i.left < e.left;
}
function xE(i, e) {
  return i.right > e.right;
}
function np(i) {
  return oh(i) ? i.startContainer.ownerDocument.defaultView : i.ownerDocument.defaultView;
}
function Lw(i) {
  if (oh(i)) {
    let e = i.commonAncestorContainer;
    return qt(e) && (e = e.parentNode), e;
  } else
    return i.parentNode;
}
function Fw(i, e) {
  const t = np(i), n = new pt(i);
  if (t === e)
    return n;
  {
    let r = t;
    for (; r != e; ) {
      const s = r.frameElement, o = new pt(s).excludeScrollbarsAndBorders();
      n.moveBy(o.left, o.top), r = r.parent;
    }
  }
  return n;
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const AB = {
  ctrl: "⌃",
  cmd: "⌘",
  alt: "⌥",
  shift: "⇧"
}, PB = {
  ctrl: "Ctrl+",
  alt: "Alt+",
  shift: "Shift+"
}, tt = NB(), IB = Object.fromEntries(Object.entries(tt).map(([i, e]) => [e, i.charAt(0).toUpperCase() + i.slice(1)]));
function zo(i) {
  let e;
  if (typeof i == "string") {
    if (e = tt[i.toLowerCase()], !e)
      throw new B("keyboard-unknown-key", null, { key: i });
  } else
    e = i.keyCode + (i.altKey ? tt.alt : 0) + (i.ctrlKey ? tt.ctrl : 0) + (i.shiftKey ? tt.shift : 0) + (i.metaKey ? tt.cmd : 0);
  return e;
}
function ip(i) {
  return typeof i == "string" && (i = DB(i)), i.map((e) => typeof e == "string" ? OB(e) : e).reduce((e, t) => t + e, 0);
}
function $w(i) {
  let e = ip(i);
  return Object.entries(qe.isMac ? AB : PB).reduce((r, [s, o]) => (e & tt[s] && (e &= ~tt[s], r += o), r), "") + (e ? IB[e] : "");
}
function RB(i) {
  return i == tt.arrowright || i == tt.arrowleft || i == tt.arrowup || i == tt.arrowdown;
}
function kE(i, e) {
  const t = e === "ltr";
  switch (i) {
    case tt.arrowleft:
      return t ? "left" : "right";
    case tt.arrowright:
      return t ? "right" : "left";
    case tt.arrowup:
      return "up";
    case tt.arrowdown:
      return "down";
  }
}
function OB(i) {
  if (i.endsWith("!"))
    return zo(i.slice(0, -1));
  const e = zo(i);
  return qe.isMac && e == tt.ctrl ? tt.cmd : e;
}
function MB(i, e) {
  const t = kE(i, e);
  return t === "down" || t === "right";
}
function NB() {
  const i = {
    arrowleft: 37,
    arrowup: 38,
    arrowright: 39,
    arrowdown: 40,
    backspace: 8,
    delete: 46,
    enter: 13,
    space: 32,
    esc: 27,
    tab: 9,
    // The idea about these numbers is that they do not collide with any real key codes, so we can use them
    // like bit masks.
    ctrl: 1114112,
    shift: 2228224,
    alt: 4456448,
    cmd: 8912896
  };
  for (let e = 65; e <= 90; e++) {
    const t = String.fromCharCode(e);
    i[t.toLowerCase()] = e;
  }
  for (let e = 48; e <= 57; e++)
    i[e - 48] = e;
  for (let e = 112; e <= 123; e++)
    i["f" + (e - 111)] = e;
  for (const e of "`-=[];',./\\")
    i[e] = e.charCodeAt(0);
  return i;
}
function DB(i) {
  return i.split("+").map((e) => e.trim());
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const BB = [
  "ar",
  "ara",
  "fa",
  "per",
  "fas",
  "he",
  "heb",
  "ku",
  "kur",
  "ug",
  "uig"
  // Uighur, Uyghur
];
function zw(i) {
  return BB.includes(i) ? "rtl" : "ltr";
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function In(i) {
  return Array.isArray(i) ? i : [i];
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
/* istanbul ignore else -- @preserve */
Ke.window.CKEDITOR_TRANSLATIONS || (Ke.window.CKEDITOR_TRANSLATIONS = {});
function VB(i, e, t = 1) {
  if (typeof t != "number")
    throw new B("translation-service-quantity-not-a-number", null, { quantity: t });
  const n = FB();
  n === 1 && (i = Object.keys(Ke.window.CKEDITOR_TRANSLATIONS)[0]);
  const r = e.id || e.string;
  if (n === 0 || !LB(i, r))
    return t !== 1 ? e.plural : e.string;
  const s = Ke.window.CKEDITOR_TRANSLATIONS[i].dictionary, o = Ke.window.CKEDITOR_TRANSLATIONS[i].getPluralForm || ((h) => h === 1 ? 0 : 1), l = s[r];
  if (typeof l == "string")
    return l;
  const u = Number(o(t));
  return l[u];
}
function LB(i, e) {
  return !!Ke.window.CKEDITOR_TRANSLATIONS[i] && !!Ke.window.CKEDITOR_TRANSLATIONS[i].dictionary[e];
}
function FB() {
  return Object.keys(Ke.window.CKEDITOR_TRANSLATIONS).length;
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class $B {
  /**
   * Creates a new instance of the locale class. Learn more about
   * {@glink features/ui-language configuring the language of the editor}.
   *
   * @param options Locale configuration.
   * @param options.uiLanguage The editor UI language code in the
   * [ISO 639-1](https://en.wikipedia.org/wiki/ISO_639-1) format. See {@link #uiLanguage}.
   * @param options.contentLanguage The editor content language code in the
   * [ISO 639-1](https://en.wikipedia.org/wiki/ISO_639-1) format. If not specified, the same as `options.language`.
   * See {@link #contentLanguage}.
   */
  constructor({ uiLanguage: e = "en", contentLanguage: t } = {}) {
    this.uiLanguage = e, this.contentLanguage = t || this.uiLanguage, this.uiLanguageDirection = zw(this.uiLanguage), this.contentLanguageDirection = zw(this.contentLanguage), this.t = (n, r) => this._t(n, r);
  }
  /**
   * The editor UI language code in the [ISO 639-1](https://en.wikipedia.org/wiki/ISO_639-1) format.
   *
   * **Note**: This property was deprecated. Please use {@link #uiLanguage} and {@link #contentLanguage}
   * properties instead.
   *
   * @deprecated
   */
  get language() {
    return console.warn("locale-deprecated-language-property: The Locale#language property has been deprecated and will be removed in the near future. Please use #uiLanguage and #contentLanguage properties instead."), this.uiLanguage;
  }
  /**
   * An unbound version of the {@link #t} method.
   */
  _t(e, t = []) {
    t = In(t), typeof e == "string" && (e = { string: e });
    const r = !!e.plural ? t[0] : 1, s = VB(this.uiLanguage, e, r);
    return zB(s, t);
  }
}
function zB(i, e) {
  return i.replace(/%(\d+)/g, (t, n) => n < e.length ? e[n] : t);
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class Br extends kt() {
  constructor(e = {}, t = {}) {
    super();
    const n = di(e);
    if (n || (t = e), this._items = [], this._itemMap = /* @__PURE__ */ new Map(), this._idProperty = t.idProperty || "id", this._bindToExternalToInternalMap = /* @__PURE__ */ new WeakMap(), this._bindToInternalToExternalMap = /* @__PURE__ */ new WeakMap(), this._skippedIndexesFromExternal = [], n)
      for (const r of e)
        this._items.push(r), this._itemMap.set(this._getItemIdBeforeAdding(r), r);
  }
  /**
   * The number of items available in the collection.
   */
  get length() {
    return this._items.length;
  }
  /**
   * Returns the first item from the collection or null when collection is empty.
   */
  get first() {
    return this._items[0] || null;
  }
  /**
   * Returns the last item from the collection or null when collection is empty.
   */
  get last() {
    return this._items[this.length - 1] || null;
  }
  /**
   * Adds an item into the collection.
   *
   * If the item does not have an id, then it will be automatically generated and set on the item.
   *
   * @param item
   * @param index The position of the item in the collection. The item
   * is pushed to the collection when `index` not specified.
   * @fires add
   * @fires change
   */
  add(e, t) {
    return this.addMany([e], t);
  }
  /**
   * Adds multiple items into the collection.
   *
   * Any item not containing an id will get an automatically generated one.
   *
   * @param items
   * @param index The position of the insertion. Items will be appended if no `index` is specified.
   * @fires add
   * @fires change
   */
  addMany(e, t) {
    if (t === void 0)
      t = this._items.length;
    else if (t > this._items.length || t < 0)
      throw new B("collection-add-item-invalid-index", this);
    let n = 0;
    for (const r of e) {
      const s = this._getItemIdBeforeAdding(r), o = t + n;
      this._items.splice(o, 0, r), this._itemMap.set(s, r), this.fire("add", r, o), n++;
    }
    return this.fire("change", {
      added: e,
      removed: [],
      index: t
    }), this;
  }
  /**
   * Gets an item by its ID or index.
   *
   * @param idOrIndex The item ID or index in the collection.
   * @returns The requested item or `null` if such item does not exist.
   */
  get(e) {
    let t;
    if (typeof e == "string")
      t = this._itemMap.get(e);
    else if (typeof e == "number")
      t = this._items[e];
    else
      throw new B("collection-get-invalid-arg", this);
    return t || null;
  }
  /**
   * Returns a Boolean indicating whether the collection contains an item.
   *
   * @param itemOrId The item or its ID in the collection.
   * @returns `true` if the collection contains the item, `false` otherwise.
   */
  has(e) {
    if (typeof e == "string")
      return this._itemMap.has(e);
    {
      const t = this._idProperty, n = e[t];
      return n && this._itemMap.has(n);
    }
  }
  /**
   * Gets an index of an item in the collection.
   * When an item is not defined in the collection, the index will equal -1.
   *
   * @param itemOrId The item or its ID in the collection.
   * @returns The index of a given item.
   */
  getIndex(e) {
    let t;
    return typeof e == "string" ? t = this._itemMap.get(e) : t = e, t ? this._items.indexOf(t) : -1;
  }
  /**
   * Removes an item from the collection.
   *
   * @param subject The item to remove, its ID or index in the collection.
   * @returns The removed item.
   * @fires remove
   * @fires change
   */
  remove(e) {
    const [t, n] = this._remove(e);
    return this.fire("change", {
      added: [],
      removed: [t],
      index: n
    }), t;
  }
  /**
   * Executes the callback for each item in the collection and composes an array or values returned by this callback.
   *
   * @typeParam U The result type of the callback.
   * @param callback
   * @param ctx Context in which the `callback` will be called.
   * @returns The result of mapping.
   */
  map(e, t) {
    return this._items.map(e, t);
  }
  /**
   * Finds the first item in the collection for which the `callback` returns a true value.
   *
   * @param callback
   * @param ctx Context in which the `callback` will be called.
   * @returns The item for which `callback` returned a true value.
   */
  find(e, t) {
    return this._items.find(e, t);
  }
  /**
   * Returns an array with items for which the `callback` returned a true value.
   *
   * @param callback
   * @param ctx Context in which the `callback` will be called.
   * @returns The array with matching items.
   */
  filter(e, t) {
    return this._items.filter(e, t);
  }
  /**
   * Removes all items from the collection and destroys the binding created using
   * {@link #bindTo}.
   *
   * @fires remove
   * @fires change
   */
  clear() {
    this._bindToCollection && (this.stopListening(this._bindToCollection), this._bindToCollection = null);
    const e = Array.from(this._items);
    for (; this.length; )
      this._remove(0);
    this.fire("change", {
      added: [],
      removed: e,
      index: 0
    });
  }
  /**
   * Binds and synchronizes the collection with another one.
   *
   * The binding can be a simple factory:
   *
   * ```ts
   * class FactoryClass {
   * 	public label: string;
   *
   * 	constructor( data: { label: string } ) {
   * 		this.label = data.label;
   * 	}
   * }
   *
   * const source = new Collection<{ label: string }>( { idProperty: 'label' } );
   * const target = new Collection<FactoryClass>();
   *
   * target.bindTo( source ).as( FactoryClass );
   *
   * source.add( { label: 'foo' } );
   * source.add( { label: 'bar' } );
   *
   * console.log( target.length ); // 2
   * console.log( target.get( 1 ).label ); // 'bar'
   *
   * source.remove( 0 );
   * console.log( target.length ); // 1
   * console.log( target.get( 0 ).label ); // 'bar'
   * ```
   *
   * or the factory driven by a custom callback:
   *
   * ```ts
   * class FooClass {
   * 	public label: string;
   *
   * 	constructor( data: { label: string } ) {
   * 		this.label = data.label;
   * 	}
   * }
   *
   * class BarClass {
   * 	public label: string;
   *
   * 	constructor( data: { label: string } ) {
   * 		this.label = data.label;
   * 	}
   * }
   *
   * const source = new Collection<{ label: string }>( { idProperty: 'label' } );
   * const target = new Collection<FooClass | BarClass>();
   *
   * target.bindTo( source ).using( ( item ) => {
   * 	if ( item.label == 'foo' ) {
   * 		return new FooClass( item );
   * 	} else {
   * 		return new BarClass( item );
   * 	}
   * } );
   *
   * source.add( { label: 'foo' } );
   * source.add( { label: 'bar' } );
   *
   * console.log( target.length ); // 2
   * console.log( target.get( 0 ) instanceof FooClass ); // true
   * console.log( target.get( 1 ) instanceof BarClass ); // true
   * ```
   *
   * or the factory out of property name:
   *
   * ```ts
   * const source = new Collection<{ nested: { value: string } }>();
   * const target = new Collection<{ value: string }>();
   *
   * target.bindTo( source ).using( 'nested' );
   *
   * source.add( { nested: { value: 'foo' } } );
   * source.add( { nested: { value: 'bar' } } );
   *
   * console.log( target.length ); // 2
   * console.log( target.get( 0 ).value ); // 'foo'
   * console.log( target.get( 1 ).value ); // 'bar'
   * ```
   *
   * It's possible to skip specified items by returning null value:
   *
   * ```ts
   * const source = new Collection<{ hidden: boolean }>();
   * const target = new Collection<{ hidden: boolean }>();
   *
   * target.bindTo( source ).using( item => {
   * 	if ( item.hidden ) {
   * 		return null;
   * 	}
   *
   * 	return item;
   * } );
   *
   * source.add( { hidden: true } );
   * source.add( { hidden: false } );
   *
   * console.log( source.length ); // 2
   * console.log( target.length ); // 1
   * ```
   *
   * **Note**: {@link #clear} can be used to break the binding.
   *
   * @typeParam S The type of `externalCollection` element.
   * @param externalCollection A collection to be bound.
   * @returns The binding chain object.
   */
  bindTo(e) {
    if (this._bindToCollection)
      throw new B("collection-bind-to-rebind", this);
    return this._bindToCollection = e, {
      as: (t) => {
        this._setUpBindToBinding((n) => new t(n));
      },
      using: (t) => {
        typeof t == "function" ? this._setUpBindToBinding(t) : this._setUpBindToBinding((n) => n[t]);
      }
    };
  }
  /**
   * Finalizes and activates a binding initiated by {@link #bindTo}.
   *
   * @param factory A function which produces collection items.
   */
  _setUpBindToBinding(e) {
    const t = this._bindToCollection, n = (r, s, o) => {
      const l = t._bindToCollection == this, u = t._bindToInternalToExternalMap.get(s);
      if (l && u)
        this._bindToExternalToInternalMap.set(s, u), this._bindToInternalToExternalMap.set(u, s);
      else {
        const h = e(s);
        if (!h) {
          this._skippedIndexesFromExternal.push(o);
          return;
        }
        let f = o;
        for (const m of this._skippedIndexesFromExternal)
          o > m && f--;
        for (const m of t._skippedIndexesFromExternal)
          f >= m && f++;
        this._bindToExternalToInternalMap.set(s, h), this._bindToInternalToExternalMap.set(h, s), this.add(h, f);
        for (let m = 0; m < t._skippedIndexesFromExternal.length; m++)
          f <= t._skippedIndexesFromExternal[m] && t._skippedIndexesFromExternal[m]++;
      }
    };
    for (const r of t)
      n(null, r, t.getIndex(r));
    this.listenTo(t, "add", n), this.listenTo(t, "remove", (r, s, o) => {
      const l = this._bindToExternalToInternalMap.get(s);
      l && this.remove(l), this._skippedIndexesFromExternal = this._skippedIndexesFromExternal.reduce((u, h) => (o < h && u.push(h - 1), o > h && u.push(h), u), []);
    });
  }
  /**
   * Returns an unique id property for a given `item`.
   *
   * The method will generate new id and assign it to the `item` if it doesn't have any.
   *
   * @param item Item to be added.
   */
  _getItemIdBeforeAdding(e) {
    const t = this._idProperty;
    let n;
    if (t in e) {
      if (n = e[t], typeof n != "string")
        throw new B("collection-add-invalid-id", this);
      if (this.get(n))
        throw new B("collection-add-item-already-exists", this);
    } else
      e[t] = n = Rr();
    return n;
  }
  /**
   * Core {@link #remove} method implementation shared in other functions.
   *
   * In contrast this method **does not** fire the {@link #event:change} event.
   *
   * @param subject The item to remove, its id or index in the collection.
   * @returns Returns an array with the removed item and its index.
   * @fires remove
   */
  _remove(e) {
    let t, n, r, s = !1;
    const o = this._idProperty;
    if (typeof e == "string" ? (n = e, r = this._itemMap.get(n), s = !r, r && (t = this._items.indexOf(r))) : typeof e == "number" ? (t = e, r = this._items[t], s = !r, r && (n = r[o])) : (r = e, n = r[o], t = this._items.indexOf(r), s = t == -1 || !this._itemMap.get(n)), s)
      throw new B("collection-remove-404", this);
    this._items.splice(t, 1), this._itemMap.delete(n);
    const l = this._bindToInternalToExternalMap.get(r);
    return this._bindToInternalToExternalMap.delete(r), this._bindToExternalToInternalMap.delete(l), this.fire("remove", r, t), [r, t];
  }
  /**
   * Iterable interface.
   */
  [Symbol.iterator]() {
    return this._items[Symbol.iterator]();
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function Rn(i) {
  const e = i.next();
  return e.done ? null : e.value;
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class hi extends as(Nt()) {
  constructor() {
    super(), this._elements = /* @__PURE__ */ new Set(), this._nextEventLoopTimeout = null, this.set("isFocused", !1), this.set("focusedElement", null);
  }
  /**
   * Starts tracking the specified element.
   */
  add(e) {
    if (this._elements.has(e))
      throw new B("focustracker-add-element-already-exist", this);
    this.listenTo(e, "focus", () => this._focus(e), { useCapture: !0 }), this.listenTo(e, "blur", () => this._blur(), { useCapture: !0 }), this._elements.add(e);
  }
  /**
   * Stops tracking the specified element and stops listening on this element.
   */
  remove(e) {
    e === this.focusedElement && this._blur(), this._elements.has(e) && (this.stopListening(e), this._elements.delete(e));
  }
  /**
   * Destroys the focus tracker by:
   * - Disabling all event listeners attached to tracked elements.
   * - Removing all tracked elements that were previously added.
   */
  destroy() {
    this.stopListening();
  }
  /**
   * Stores currently focused element and set {@link #isFocused} as `true`.
   */
  _focus(e) {
    clearTimeout(this._nextEventLoopTimeout), this.focusedElement = e, this.isFocused = !0;
  }
  /**
   * Clears currently focused element and set {@link #isFocused} as `false`.
   * This method uses `setTimeout` to change order of fires `blur` and `focus` events.
   */
  _blur() {
    clearTimeout(this._nextEventLoopTimeout), this._nextEventLoopTimeout = setTimeout(() => {
      this.focusedElement = null, this.isFocused = !1;
    }, 0);
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class cr {
  /**
   * Creates an instance of the keystroke handler.
   */
  constructor() {
    this._listener = new (as())();
  }
  /**
   * Starts listening for `keydown` events from a given emitter.
   */
  listenTo(e) {
    this._listener.listenTo(e, "keydown", (t, n) => {
      this._listener.fire("_keydown:" + zo(n), n);
    });
  }
  /**
   * Registers a handler for the specified keystroke.
   *
   * @param keystroke Keystroke defined in a format accepted by
   * the {@link module:utils/keyboard~parseKeystroke} function.
   * @param callback A function called with the
   * {@link module:engine/view/observer/keyobserver~KeyEventData key event data} object and
   * a helper function to call both `preventDefault()` and `stopPropagation()` on the underlying event.
   * @param options Additional options.
   * @param options.priority The priority of the keystroke
   * callback. The higher the priority value the sooner the callback will be executed. Keystrokes having the same priority
   * are called in the order they were added.
   */
  set(e, t, n = {}) {
    const r = ip(e), s = n.priority;
    this._listener.listenTo(this._listener, "_keydown:" + r, (o, l) => {
      t(l, () => {
        l.preventDefault(), l.stopPropagation(), o.stop();
      }), o.return = !0;
    }, { priority: s });
  }
  /**
   * Triggers a keystroke handler for a specified key combination, if such a keystroke was {@link #set defined}.
   *
   * @param keyEvtData Key event data.
   * @returns Whether the keystroke was handled.
   */
  press(e) {
    return !!this._listener.fire("_keydown:" + zo(e), e);
  }
  /**
   * Stops listening to `keydown` events from the given emitter.
   */
  stopListening(e) {
    this._listener.stopListening(e);
  }
  /**
   * Destroys the keystroke handler.
   */
  destroy() {
    this.stopListening();
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function WB(i) {
  const e = /* @__PURE__ */ new Map();
  for (const t in i)
    e.set(t, i[t]);
  return e;
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function Or(i) {
  return di(i) ? new Map(i) : WB(i);
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const jB = 1e4;
function UB(i, e, t, n) {
  if (Math.max(e.length, i.length) > jB)
    return i.slice(0, t).concat(e).concat(i.slice(t + n, i.length));
  {
    const r = Array.from(i);
    return r.splice(t, n, ...e), r;
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function HB(i) {
  return !!i && i.length == 1 && /[\u0300-\u036f\u1ab0-\u1aff\u1dc0-\u1dff\u20d0-\u20ff\ufe20-\ufe2f]/.test(i);
}
function qB(i) {
  return !!i && i.length == 1 && /[\ud800-\udbff]/.test(i);
}
function KB(i) {
  return !!i && i.length == 1 && /[\udc00-\udfff]/.test(i);
}
function rp(i, e) {
  return qB(i.charAt(e - 1)) && KB(i.charAt(e));
}
function sp(i, e) {
  return HB(i.charAt(e));
}
const GB = YB();
function AE(i, e) {
  const t = String(i).matchAll(GB);
  return Array.from(t).some((n) => n.index < e && e < n.index + n[0].length);
}
function YB() {
  const i = [
    // Emoji Tag Sequence (ETS)
    /\p{Emoji}[\u{E0020}-\u{E007E}]+\u{E007F}/u,
    // Emoji Keycap Sequence
    /\p{Emoji}\u{FE0F}?\u{20E3}/u,
    // Emoji Presentation Sequence
    /\p{Emoji}\u{FE0F}/u,
    // Single-Character Emoji / Emoji Modifier Sequence
    /(?=\p{General_Category=Other_Symbol})\p{Emoji}\p{Emoji_Modifier}*/u
  ], e = /\p{Regional_Indicator}{2}/u.source, t = "(?:" + i.map((r) => r.source).join("|") + ")", n = `${e}|${t}(?:‍${t})*`;
  return new RegExp(n, "ug");
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class fe extends Nt() {
  /**
   * @inheritDoc
   */
  constructor(e) {
    super(), this._disableStack = /* @__PURE__ */ new Set(), this.editor = e, this.set("isEnabled", !0);
  }
  /**
   * Disables the plugin.
   *
   * Plugin may be disabled by multiple features or algorithms (at once). When disabling a plugin, unique id should be passed
   * (e.g. feature name). The same identifier should be used when {@link #clearForceDisabled enabling back} the plugin.
   * The plugin becomes enabled only after all features {@link #clearForceDisabled enabled it back}.
   *
   * Disabling and enabling a plugin:
   *
   * ```ts
   * plugin.isEnabled; // -> true
   * plugin.forceDisabled( 'MyFeature' );
   * plugin.isEnabled; // -> false
   * plugin.clearForceDisabled( 'MyFeature' );
   * plugin.isEnabled; // -> true
   * ```
   *
   * Plugin disabled by multiple features:
   *
   * ```ts
   * plugin.forceDisabled( 'MyFeature' );
   * plugin.forceDisabled( 'OtherFeature' );
   * plugin.clearForceDisabled( 'MyFeature' );
   * plugin.isEnabled; // -> false
   * plugin.clearForceDisabled( 'OtherFeature' );
   * plugin.isEnabled; // -> true
   * ```
   *
   * Multiple disabling with the same identifier is redundant:
   *
   * ```ts
   * plugin.forceDisabled( 'MyFeature' );
   * plugin.forceDisabled( 'MyFeature' );
   * plugin.clearForceDisabled( 'MyFeature' );
   * plugin.isEnabled; // -> true
   * ```
   *
   * **Note:** some plugins or algorithms may have more complex logic when it comes to enabling or disabling certain plugins,
   * so the plugin might be still disabled after {@link #clearForceDisabled} was used.
   *
   * @param id Unique identifier for disabling. Use the same id when {@link #clearForceDisabled enabling back} the plugin.
   */
  forceDisabled(e) {
    this._disableStack.add(e), this._disableStack.size == 1 && (this.on("set:isEnabled", Ww, { priority: "highest" }), this.isEnabled = !1);
  }
  /**
   * Clears forced disable previously set through {@link #forceDisabled}. See {@link #forceDisabled}.
   *
   * @param id Unique identifier, equal to the one passed in {@link #forceDisabled} call.
   */
  clearForceDisabled(e) {
    this._disableStack.delete(e), this._disableStack.size == 0 && (this.off("set:isEnabled", Ww), this.isEnabled = !0);
  }
  /**
   * @inheritDoc
   */
  destroy() {
    this.stopListening();
  }
  /**
   * @inheritDoc
   */
  static get isContextPlugin() {
    return !1;
  }
}
function Ww(i) {
  i.return = !1, i.stop();
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class Pt extends Nt() {
  /**
   * Creates a new `Command` instance.
   *
   * @param editor The editor on which this command will be used.
   */
  constructor(e) {
    super(), this.editor = e, this.set("value", void 0), this.set("isEnabled", !1), this._affectsData = !0, this._disableStack = /* @__PURE__ */ new Set(), this.decorate("execute"), this.listenTo(this.editor.model.document, "change", () => {
      this.refresh();
    }), this.on("execute", (t) => {
      this.isEnabled || t.stop();
    }, { priority: "high" }), this.listenTo(e, "change:isReadOnly", (t, n, r) => {
      r && this.affectsData ? this.forceDisabled("readOnlyMode") : this.clearForceDisabled("readOnlyMode");
    });
  }
  /**
   * A flag indicating whether a command execution changes the editor data or not.
   *
   * Commands with `affectsData` set to `false` will not be automatically disabled in
   * the {@link module:core/editor/editor~Editor#isReadOnly read-only mode} and
   * {@glink features/read-only#related-features other editor modes} with restricted user write permissions.
   *
   * **Note:** You do not have to set it for your every command. It is `true` by default.
   *
   * @default true
   */
  get affectsData() {
    return this._affectsData;
  }
  set affectsData(e) {
    this._affectsData = e;
  }
  /**
   * Refreshes the command. The command should update its {@link #isEnabled} and {@link #value} properties
   * in this method.
   *
   * This method is automatically called when
   * {@link module:engine/model/document~Document#event:change any changes are applied to the document}.
   */
  refresh() {
    this.isEnabled = !0;
  }
  /**
   * Disables the command.
   *
   * Command may be disabled by multiple features or algorithms (at once). When disabling a command, unique id should be passed
   * (e.g. the feature name). The same identifier should be used when {@link #clearForceDisabled enabling back} the command.
   * The command becomes enabled only after all features {@link #clearForceDisabled enabled it back}.
   *
   * Disabling and enabling a command:
   *
   * ```ts
   * command.isEnabled; // -> true
   * command.forceDisabled( 'MyFeature' );
   * command.isEnabled; // -> false
   * command.clearForceDisabled( 'MyFeature' );
   * command.isEnabled; // -> true
   * ```
   *
   * Command disabled by multiple features:
   *
   * ```ts
   * command.forceDisabled( 'MyFeature' );
   * command.forceDisabled( 'OtherFeature' );
   * command.clearForceDisabled( 'MyFeature' );
   * command.isEnabled; // -> false
   * command.clearForceDisabled( 'OtherFeature' );
   * command.isEnabled; // -> true
   * ```
   *
   * Multiple disabling with the same identifier is redundant:
   *
   * ```ts
   * command.forceDisabled( 'MyFeature' );
   * command.forceDisabled( 'MyFeature' );
   * command.clearForceDisabled( 'MyFeature' );
   * command.isEnabled; // -> true
   * ```
   *
   * **Note:** some commands or algorithms may have more complex logic when it comes to enabling or disabling certain commands,
   * so the command might be still disabled after {@link #clearForceDisabled} was used.
   *
   * @param id Unique identifier for disabling. Use the same id when {@link #clearForceDisabled enabling back} the command.
   */
  forceDisabled(e) {
    this._disableStack.add(e), this._disableStack.size == 1 && (this.on("set:isEnabled", jw, { priority: "highest" }), this.isEnabled = !1);
  }
  /**
   * Clears forced disable previously set through {@link #forceDisabled}. See {@link #forceDisabled}.
   *
   * @param id Unique identifier, equal to the one passed in {@link #forceDisabled} call.
   */
  clearForceDisabled(e) {
    this._disableStack.delete(e), this._disableStack.size == 0 && (this.off("set:isEnabled", jw), this.refresh());
  }
  /**
   * Executes the command.
   *
   * A command may accept parameters. They will be passed from {@link module:core/editor/editor~Editor#execute `editor.execute()`}
   * to the command.
   *
   * The `execute()` method will automatically abort when the command is disabled ({@link #isEnabled} is `false`).
   * This behavior is implemented by a high priority listener to the {@link #event:execute} event.
   *
   * In order to see how to disable a command from "outside" see the {@link #isEnabled} documentation.
   *
   * This method may return a value, which would be forwarded all the way down to the
   * {@link module:core/editor/editor~Editor#execute `editor.execute()`}.
   *
   * @fires execute
   */
  execute(...e) {
  }
  /**
   * Destroys the command.
   */
  destroy() {
    this.stopListening();
  }
}
function jw(i) {
  i.return = !1, i.stop();
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class PE extends kt() {
  /**
   * Creates an instance of the plugin collection class.
   * Allows loading and initializing plugins and their dependencies.
   * Allows providing a list of already loaded plugins. These plugins will not be destroyed along with this collection.
   *
   * @param availablePlugins Plugins (constructors) which the collection will be able to use
   * when {@link module:core/plugincollection~PluginCollection#init} is used with the plugin names (strings, instead of constructors).
   * Usually, the editor will pass its built-in plugins to the collection so they can later be
   * used in `config.plugins` or `config.removePlugins` by names.
   * @param contextPlugins A list of already initialized plugins represented by a `[ PluginConstructor, pluginInstance ]` pair.
   */
  constructor(e, t = [], n = []) {
    super(), this._plugins = /* @__PURE__ */ new Map(), this._context = e, this._availablePlugins = /* @__PURE__ */ new Map();
    for (const r of t)
      r.pluginName && this._availablePlugins.set(r.pluginName, r);
    this._contextPlugins = /* @__PURE__ */ new Map();
    for (const [r, s] of n)
      this._contextPlugins.set(r, s), this._contextPlugins.set(s, r), r.pluginName && this._availablePlugins.set(r.pluginName, r);
  }
  /**
   * Iterable interface.
   *
   * Returns `[ PluginConstructor, pluginInstance ]` pairs.
   */
  *[Symbol.iterator]() {
    for (const e of this._plugins)
      typeof e[0] == "function" && (yield e);
  }
  /**
   * Gets the plugin instance by its constructor or name.
   *
   * ```ts
   * // Check if 'Clipboard' plugin was loaded.
   * if ( editor.plugins.has( 'ClipboardPipeline' ) ) {
   * 	// Get clipboard plugin instance
   * 	const clipboard = editor.plugins.get( 'ClipboardPipeline' );
   *
   * 	this.listenTo( clipboard, 'inputTransformation', ( evt, data ) => {
   * 		// Do something on clipboard input.
   * 	} );
   * }
   * ```
   *
   * **Note**: This method will throw an error if a plugin is not loaded. Use `{@link #has editor.plugins.has()}`
   * to check if a plugin is available.
   *
   * @param key The plugin constructor or {@link module:core/plugin~PluginStaticMembers#pluginName name}.
   */
  get(e) {
    const t = this._plugins.get(e);
    if (!t) {
      let n = e;
      throw typeof e == "function" && (n = e.pluginName || e.name), new B("plugincollection-plugin-not-loaded", this._context, { plugin: n });
    }
    return t;
  }
  /**
   * Checks if a plugin is loaded.
   *
   * ```ts
   * // Check if the 'Clipboard' plugin was loaded.
   * if ( editor.plugins.has( 'ClipboardPipeline' ) ) {
   * 	// Now use the clipboard plugin instance:
   * 	const clipboard = editor.plugins.get( 'ClipboardPipeline' );
   *
   * 	// ...
   * }
   * ```
   *
   * @param key The plugin constructor or {@link module:core/plugin~PluginStaticMembers#pluginName name}.
   */
  has(e) {
    return this._plugins.has(e);
  }
  /**
   * Initializes a set of plugins and adds them to the collection.
   *
   * @param plugins An array of {@link module:core/plugin~PluginInterface plugin constructors}
   * or {@link module:core/plugin~PluginStaticMembers#pluginName plugin names}.
   * @param pluginsToRemove Names of the plugins or plugin constructors
   * that should not be loaded (despite being specified in the `plugins` array).
   * @param pluginsSubstitutions An array of {@link module:core/plugin~PluginInterface plugin constructors}
   * that will be used to replace plugins of the same names that were passed in `plugins` or that are in their dependency tree.
   * A useful option for replacing built-in plugins while creating tests (for mocking their APIs). Plugins that will be replaced
   * must follow these rules:
   *   * The new plugin must be a class.
   *   * The new plugin must be named.
   *   * Both plugins must not depend on other plugins.
   * @returns A promise which gets resolved once all plugins are loaded and available in the collection.
   */
  init(e, t = [], n = []) {
    const r = this, s = this._context;
    C(e), S(e);
    const o = e.filter((V) => !m(V, t)), l = [...k(o)];
    E(l, n);
    const u = A(l);
    return P(u, "init").then(() => P(u, "afterInit")).then(() => u);
    function h(V) {
      return typeof V == "function";
    }
    function f(V) {
      return h(V) && !!V.isContextPlugin;
    }
    function m(V, j) {
      return j.some((U) => U === V || v(V) === U || v(U) === V);
    }
    function v(V) {
      return h(V) ? V.pluginName || V.name : V;
    }
    function C(V, j = /* @__PURE__ */ new Set()) {
      V.forEach((U) => {
        h(U) && (j.has(U) || (j.add(U), U.pluginName && !r._availablePlugins.has(U.pluginName) && r._availablePlugins.set(U.pluginName, U), U.requires && C(U.requires, j)));
      });
    }
    function k(V, j = /* @__PURE__ */ new Set()) {
      return V.map((U) => h(U) ? U : r._availablePlugins.get(U)).reduce((U, $) => j.has($) ? U : (j.add($), $.requires && (S($.requires, $), k($.requires, j).forEach((M) => U.add(M))), U.add($)), /* @__PURE__ */ new Set());
    }
    function S(V, j = null) {
      V.map((U) => h(U) ? U : r._availablePlugins.get(U) || U).forEach((U) => {
        x(U, j), N(U, j), y(U, j);
      });
    }
    function x(V, j) {
      if (!h(V))
        throw j ? new B("plugincollection-soft-required", s, { missingPlugin: V, requiredBy: v(j) }) : new B("plugincollection-plugin-not-found", s, { plugin: V });
    }
    function N(V, j) {
      if (f(j) && !f(V))
        throw new B("plugincollection-context-required", s, { plugin: v(V), requiredBy: v(j) });
    }
    function y(V, j) {
      if (j && m(V, t))
        throw new B("plugincollection-required", s, { plugin: v(V), requiredBy: v(j) });
    }
    function A(V) {
      return V.map((j) => {
        let U = r._contextPlugins.get(j);
        return U = U || new j(s), r._add(j, U), U;
      });
    }
    function P(V, j) {
      return V.reduce((U, $) => !$[j] || r._contextPlugins.has($) ? U : U.then($[j].bind($)), Promise.resolve());
    }
    function E(V, j) {
      for (const U of j) {
        if (typeof U != "function")
          throw new B("plugincollection-replace-plugin-invalid-type", null, { pluginItem: U });
        const $ = U.pluginName;
        if (!$)
          throw new B("plugincollection-replace-plugin-missing-name", null, { pluginItem: U });
        if (U.requires && U.requires.length)
          throw new B("plugincollection-plugin-for-replacing-cannot-have-dependencies", null, { pluginName: $ });
        const M = r._availablePlugins.get($);
        if (!M)
          throw new B("plugincollection-plugin-for-replacing-not-exist", null, { pluginName: $ });
        const D = V.indexOf(M);
        if (D === -1) {
          if (r._contextPlugins.has(M))
            return;
          throw new B("plugincollection-plugin-for-replacing-not-loaded", null, { pluginName: $ });
        }
        if (M.requires && M.requires.length)
          throw new B("plugincollection-replaced-plugin-cannot-have-dependencies", null, { pluginName: $ });
        V.splice(D, 1, U), r._availablePlugins.set($, U);
      }
    }
  }
  /**
   * Destroys all loaded plugins.
   */
  destroy() {
    const e = [];
    for (const [, t] of this)
      typeof t.destroy == "function" && !this._contextPlugins.has(t) && e.push(t.destroy());
    return Promise.all(e);
  }
  /**
   * Adds the plugin to the collection. Exposed mainly for testing purposes.
   *
   * @param PluginConstructor The plugin constructor.
   * @param plugin The instance of the plugin.
   */
  _add(e, t) {
    this._plugins.set(e, t);
    const n = e.pluginName;
    if (n) {
      if (this._plugins.has(n))
        throw new B("plugincollection-plugin-name-conflict", null, { pluginName: n, plugin1: this._plugins.get(n).constructor, plugin2: e });
      this._plugins.set(n, t);
    }
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class zl {
  /**
   * Creates a context instance with a given configuration.
   *
   * Usually not to be used directly. See the static {@link module:core/context~Context.create `create()`} method.
   *
   * @param config The context configuration.
   */
  constructor(e) {
    this._contextOwner = null, this.config = new fE(e, this.constructor.defaultConfig);
    const t = this.constructor.builtinPlugins;
    this.config.define("plugins", t), this.plugins = new PE(this, t);
    const n = this.config.get("language") || {};
    this.locale = new $B({
      uiLanguage: typeof n == "string" ? n : n.ui,
      contentLanguage: this.config.get("language.content")
    }), this.t = this.locale.t, this.editors = new Br();
  }
  /**
   * Loads and initializes plugins specified in the configuration.
   *
   * @returns A promise which resolves once the initialization is completed, providing an array of loaded plugins.
   */
  initPlugins() {
    const e = this.config.get("plugins") || [], t = this.config.get("substitutePlugins") || [];
    for (const n of e.concat(t)) {
      if (typeof n != "function")
        throw new B("context-initplugins-constructor-only", null, { Plugin: n });
      if (n.isContextPlugin !== !0)
        throw new B("context-initplugins-invalid-plugin", null, { Plugin: n });
    }
    return this.plugins.init(e, [], t);
  }
  /**
   * Destroys the context instance and all editors used with the context,
   * releasing all resources used by the context.
   *
   * @returns A promise that resolves once the context instance is fully destroyed.
   */
  destroy() {
    return Promise.all(Array.from(this.editors, (e) => e.destroy())).then(() => this.plugins.destroy());
  }
  /**
   * Adds a reference to the editor which is used with this context.
   *
   * When the given editor has created the context, the reference to this editor will be stored
   * as a {@link ~Context#_contextOwner}.
   *
   * This method should only be used by the editor.
   *
   * @internal
   * @param isContextOwner Stores the given editor as a context owner.
   */
  _addEditor(e, t) {
    if (this._contextOwner)
      throw new B("context-addeditor-private-context");
    this.editors.add(e), t && (this._contextOwner = e);
  }
  /**
   * Removes a reference to the editor which was used with this context.
   * When the context was created by the given editor, the context will be destroyed.
   *
   * This method should only be used by the editor.
   *
   * @internal
   * @return A promise that resolves once the editor is removed from the context or when the context was destroyed.
   */
  _removeEditor(e) {
    return this.editors.has(e) && this.editors.remove(e), this._contextOwner === e ? this.destroy() : Promise.resolve();
  }
  /**
   * Returns the context configuration which will be copied to the editors created using this context.
   *
   * The configuration returned by this method has the plugins configuration removed &mdash; plugins are shared with all editors
   * through another mechanism.
   *
   * This method should only be used by the editor.
   *
   * @internal
   * @returns Configuration as a plain object.
   */
  _getEditorConfig() {
    const e = {};
    for (const t of this.config.names())
      ["plugins", "removePlugins", "extraPlugins"].includes(t) || (e[t] = this.config.get(t));
    return e;
  }
  /**
   * Creates and initializes a new context instance.
   *
   * ```ts
   * const commonConfig = { ... }; // Configuration for all the plugins and editors.
   * const editorPlugins = [ ... ]; // Regular plugins here.
   *
   * Context
   * 	.create( {
   * 		// Only context plugins here.
   * 		plugins: [ ... ],
   *
   * 		// Configure the language for all the editors (it cannot be overwritten).
   * 		language: { ... },
   *
   * 		// Configuration for context plugins.
   * 		comments: { ... },
   * 		...
   *
   * 		// Default configuration for editor plugins.
   * 		toolbar: { ... },
   * 		image: { ... },
   * 		...
   * 	} )
   * 	.then( context => {
   * 		const promises = [];
   *
   * 		promises.push( ClassicEditor.create(
   * 			document.getElementById( 'editor1' ),
   * 			{
   * 				editorPlugins,
   * 				context
   * 			}
   * 		) );
   *
   * 		promises.push( ClassicEditor.create(
   * 			document.getElementById( 'editor2' ),
   * 			{
   * 				editorPlugins,
   * 				context,
   * 				toolbar: { ... } // You can overwrite the configuration of the context.
   * 			}
   * 		) );
   *
   * 		return Promise.all( promises );
   * 	} );
   * ```
   *
   * @param config The context configuration.
   * @returns A promise resolved once the context is ready. The promise resolves with the created context instance.
   */
  static create(e) {
    return new Promise((t) => {
      const n = new this(e);
      t(n.initPlugins().then(() => n));
    });
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const Xu = /* @__PURE__ */ new WeakMap();
function Wl({ view: i, element: e, text: t, isDirectHost: n = !0, keepOnFocus: r = !1 }) {
  const s = i.document;
  Xu.has(s) || (Xu.set(s, /* @__PURE__ */ new Map()), s.registerPostFixer((o) => _m(s, o)), s.on("change:isComposing", () => {
    i.change((o) => _m(s, o));
  }, { priority: "high" })), Xu.get(s).set(e, {
    text: t,
    isDirectHost: n,
    keepOnFocus: r,
    hostElement: n ? e : null
  }), i.change((o) => _m(s, o));
}
function JB(i, e) {
  return e.hasClass("ck-placeholder") ? !1 : (i.addClass("ck-placeholder", e), !0);
}
function XB(i, e) {
  return e.hasClass("ck-placeholder") ? (i.removeClass("ck-placeholder", e), !0) : !1;
}
function ZB(i, e) {
  if (!i.isAttached() || Array.from(i.getChildren()).some((o) => !o.is("uiElement")))
    return !1;
  const n = i.document, s = n.selection.anchor;
  return n.isComposing && s && s.parent === i ? !1 : e || !n.isFocused ? !0 : !!s && s.parent !== i;
}
function _m(i, e) {
  const t = Xu.get(i), n = [];
  let r = !1;
  for (const [s, o] of t)
    o.isDirectHost && (n.push(s), Uw(e, s, o) && (r = !0));
  for (const [s, o] of t) {
    if (o.isDirectHost)
      continue;
    const l = QB(s);
    l && (n.includes(l) || (o.hostElement = l, Uw(e, s, o) && (r = !0)));
  }
  return r;
}
function Uw(i, e, t) {
  const { text: n, isDirectHost: r, hostElement: s } = t;
  let o = !1;
  return s.getAttribute("data-placeholder") !== n && (i.setAttribute("data-placeholder", n, s), o = !0), (r || e.childCount == 1) && ZB(s, t.keepOnFocus) ? JB(i, s) && (o = !0) : XB(i, s) && (o = !0), o;
}
function QB(i) {
  if (i.childCount) {
    const e = i.getChild(0);
    if (e.is("element") && !e.is("uiElement") && !e.is("attributeElement"))
      return e;
  }
  return null;
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
let Us = class {
  /* istanbul ignore next -- @preserve */
  is() {
    throw new Error("is() method is abstract");
  }
};
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
let Hs = class extends kt(Us) {
  /**
   * Creates a tree view node.
   *
   * @param document The document instance to which this node belongs.
   */
  constructor(e) {
    super(), this.document = e, this.parent = null;
  }
  /**
   * Index of the node in the parent element or null if the node has no parent.
   *
   * Accessing this property throws an error if this node's parent element does not contain it.
   * This means that view tree got broken.
   */
  get index() {
    let e;
    if (!this.parent)
      return null;
    if ((e = this.parent.getChildIndex(this)) == -1)
      throw new B("view-node-not-found-in-parent", this);
    return e;
  }
  /**
   * Node's next sibling, or `null` if it is the last child.
   */
  get nextSibling() {
    const e = this.index;
    return e !== null && this.parent.getChild(e + 1) || null;
  }
  /**
   * Node's previous sibling, or `null` if it is the first child.
   */
  get previousSibling() {
    const e = this.index;
    return e !== null && this.parent.getChild(e - 1) || null;
  }
  /**
   * Top-most ancestor of the node. If the node has no parent it is the root itself.
   */
  get root() {
    let e = this;
    for (; e.parent; )
      e = e.parent;
    return e;
  }
  /**
   * Returns true if the node is in a tree rooted in the document (is a descendant of one of its roots).
   */
  isAttached() {
    return this.root.is("rootElement");
  }
  /**
   * Gets a path to the node. The path is an array containing indices of consecutive ancestors of this node,
   * beginning from {@link module:engine/view/node~Node#root root}, down to this node's index.
   *
   * ```ts
   * const abc = downcastWriter.createText( 'abc' );
   * const foo = downcastWriter.createText( 'foo' );
   * const h1 = downcastWriter.createElement( 'h1', null, downcastWriter.createText( 'header' ) );
   * const p = downcastWriter.createElement( 'p', null, [ abc, foo ] );
   * const div = downcastWriter.createElement( 'div', null, [ h1, p ] );
   * foo.getPath(); // Returns [ 1, 3 ]. `foo` is in `p` which is in `div`. `p` starts at offset 1, while `foo` at 3.
   * h1.getPath(); // Returns [ 0 ].
   * div.getPath(); // Returns [].
   * ```
   *
   * @returns The path.
   */
  getPath() {
    const e = [];
    let t = this;
    for (; t.parent; )
      e.unshift(t.index), t = t.parent;
    return e;
  }
  /**
   * Returns ancestors array of this node.
   *
   * @param options Options object.
   * @param options.includeSelf When set to `true` this node will be also included in parent's array.
   * @param options.parentFirst When set to `true`, array will be sorted from node's parent to root element,
   * otherwise root element will be the first item in the array.
   * @returns Array with ancestors.
   */
  getAncestors(e = {}) {
    const t = [];
    let n = e.includeSelf ? this : this.parent;
    for (; n; )
      t[e.parentFirst ? "push" : "unshift"](n), n = n.parent;
    return t;
  }
  /**
   * Returns a {@link module:engine/view/element~Element} or {@link module:engine/view/documentfragment~DocumentFragment}
   * which is a common ancestor of both nodes.
   *
   * @param node The second node.
   * @param options Options object.
   * @param options.includeSelf When set to `true` both nodes will be considered "ancestors" too.
   * Which means that if e.g. node A is inside B, then their common ancestor will be B.
   */
  getCommonAncestor(e, t = {}) {
    const n = this.getAncestors(t), r = e.getAncestors(t);
    let s = 0;
    for (; n[s] == r[s] && n[s]; )
      s++;
    return s === 0 ? null : n[s - 1];
  }
  /**
   * Returns whether this node is before given node. `false` is returned if nodes are in different trees (for example,
   * in different {@link module:engine/view/documentfragment~DocumentFragment}s).
   *
   * @param node Node to compare with.
   */
  isBefore(e) {
    if (this == e || this.root !== e.root)
      return !1;
    const t = this.getPath(), n = e.getPath(), r = Pn(t, n);
    switch (r) {
      case "prefix":
        return !0;
      case "extension":
        return !1;
      default:
        return t[r] < n[r];
    }
  }
  /**
   * Returns whether this node is after given node. `false` is returned if nodes are in different trees (for example,
   * in different {@link module:engine/view/documentfragment~DocumentFragment}s).
   *
   * @param node Node to compare with.
   */
  isAfter(e) {
    return this == e || this.root !== e.root ? !1 : !this.isBefore(e);
  }
  /**
   * Removes node from parent.
   *
   * @internal
   */
  _remove() {
    this.parent._removeChildren(this.index);
  }
  /**
   * @internal
   * @param type Type of the change.
   * @param node Changed node.
   * @fires change
   */
  _fireChange(e, t) {
    this.fire(`change:${e}`, t), this.parent && this.parent._fireChange(e, t);
  }
  /**
   * Custom toJSON method to solve child-parent circular dependencies.
   *
   * @returns Clone of this object with the parent property removed.
   */
  toJSON() {
    const e = aE(this);
    return delete e.parent, e;
  }
};
Hs.prototype.is = function(i) {
  return i === "node" || i === "view:node";
};
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
let Bt = class lg extends Hs {
  /**
   * Creates a tree view text node.
   *
   * @see module:engine/view/downcastwriter~DowncastWriter#createText
   * @internal
   * @param document The document instance to which this text node belongs.
   * @param data The text's data.
   */
  constructor(e, t) {
    super(e), this._textData = t;
  }
  /**
   * The text content.
   */
  get data() {
    return this._textData;
  }
  /**
   * The `_data` property is controlled by a getter and a setter.
   *
   * The getter is required when using the addition assignment operator on protected property:
   *
   * ```ts
   * const foo = downcastWriter.createText( 'foo' );
   * const bar = downcastWriter.createText( 'bar' );
   *
   * foo._data += bar.data;   // executes: `foo._data = foo._data + bar.data`
   * console.log( foo.data ); // prints: 'foobar'
   * ```
   *
   * If the protected getter didn't exist, `foo._data` will return `undefined` and result of the merge will be invalid.
   *
   * The setter sets data and fires the {@link module:engine/view/node~Node#event:change:text change event}.
   *
   * @internal
   */
  get _data() {
    return this.data;
  }
  set _data(e) {
    this._fireChange("text", this), this._textData = e;
  }
  /**
   * Checks if this text node is similar to other text node.
   * Both nodes should have the same data to be considered as similar.
   *
   * @param otherNode Node to check if it is same as this node.
   */
  isSimilar(e) {
    return e instanceof lg ? this === e || this.data === e.data : !1;
  }
  /**
   * Clones this node.
   *
   * @internal
   * @returns Text node that is a clone of this node.
   */
  _clone() {
    return new lg(this.document, this.data);
  }
};
Bt.prototype.is = function(i) {
  return i === "$text" || i === "view:$text" || // This are legacy values kept for backward compatibility.
  i === "text" || i === "view:text" || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
  i === "node" || i === "view:node";
};
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
let er = class extends Us {
  /**
   * Creates a text proxy.
   *
   * @internal
   * @param textNode Text node which part is represented by this text proxy.
   * @param offsetInText Offset in {@link module:engine/view/textproxy~TextProxy#textNode text node}
   * from which the text proxy starts.
   * @param length Text proxy length, that is how many text node's characters, starting from `offsetInText` it represents.
   * @constructor
   */
  constructor(e, t, n) {
    if (super(), this.textNode = e, t < 0 || t > e.data.length)
      throw new B("view-textproxy-wrong-offsetintext", this);
    if (n < 0 || t + n > e.data.length)
      throw new B("view-textproxy-wrong-length", this);
    this.data = e.data.substring(t, t + n), this.offsetInText = t;
  }
  /**
   * Offset size of this node.
   */
  get offsetSize() {
    return this.data.length;
  }
  /**
   * Flag indicating whether `TextProxy` instance covers only part of the original {@link module:engine/view/text~Text text node}
   * (`true`) or the whole text node (`false`).
   *
   * This is `false` when text proxy starts at the very beginning of {@link module:engine/view/textproxy~TextProxy#textNode textNode}
   * ({@link module:engine/view/textproxy~TextProxy#offsetInText offsetInText} equals `0`) and text proxy sizes is equal to
   * text node size.
   */
  get isPartial() {
    return this.data.length !== this.textNode.data.length;
  }
  /**
   * Parent of this text proxy, which is same as parent of text node represented by this text proxy.
   */
  get parent() {
    return this.textNode.parent;
  }
  /**
   * Root of this text proxy, which is same as root of text node represented by this text proxy.
   */
  get root() {
    return this.textNode.root;
  }
  /**
   * {@link module:engine/view/document~Document View document} that owns this text proxy, or `null` if the text proxy is inside
   * {@link module:engine/view/documentfragment~DocumentFragment document fragment}.
   */
  get document() {
    return this.textNode.document;
  }
  /**
   * Returns ancestors array of this text proxy.
   *
   * @param options Options object.
   * @param options.includeSelf When set to `true`, textNode will be also included in parent's array.
   * @param options.parentFirst When set to `true`, array will be sorted from text proxy parent to
   * root element, otherwise root element will be the first item in the array.
   * @returns Array with ancestors.
   */
  getAncestors(e = {}) {
    const t = [];
    let n = e.includeSelf ? this.textNode : this.parent;
    for (; n !== null; )
      t[e.parentFirst ? "push" : "unshift"](n), n = n.parent;
    return t;
  }
};
er.prototype.is = function(i) {
  return i === "$textProxy" || i === "view:$textProxy" || // This are legacy values kept for backward compatibility.
  i === "textProxy" || i === "view:textProxy";
};
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class ah {
  /**
   * Creates new instance of Matcher.
   *
   * @param pattern Match patterns. See {@link module:engine/view/matcher~Matcher#add add method} for more information.
   */
  constructor(...e) {
    this._patterns = [], this.add(...e);
  }
  /**
   * Adds pattern or patterns to matcher instance.
   *
   * ```ts
   * // String.
   * matcher.add( 'div' );
   *
   * // Regular expression.
   * matcher.add( /^\w/ );
   *
   * // Single class.
   * matcher.add( {
   * 	classes: 'foobar'
   * } );
   * ```
   *
   * See {@link module:engine/view/matcher~MatcherPattern} for more examples.
   *
   * Multiple patterns can be added in one call:
   *
   * ```ts
   * matcher.add( 'div', { classes: 'foobar' } );
   * ```
   *
   * @param pattern Object describing pattern details. If string or regular expression
   * is provided it will be used to match element's name. Pattern can be also provided in a form
   * of a function - then this function will be called with each {@link module:engine/view/element~Element element} as a parameter.
   * Function's return value will be stored under `match` key of the object returned from
   * {@link module:engine/view/matcher~Matcher#match match} or {@link module:engine/view/matcher~Matcher#matchAll matchAll} methods.
   */
  add(...e) {
    for (let t of e)
      (typeof t == "string" || t instanceof RegExp) && (t = { name: t }), this._patterns.push(t);
  }
  /**
   * Matches elements for currently stored patterns. Returns match information about first found
   * {@link module:engine/view/element~Element element}, otherwise returns `null`.
   *
   * Example of returned object:
   *
   * ```ts
   * {
   * 	element: <instance of found element>,
   * 	pattern: <pattern used to match found element>,
   * 	match: {
   * 		name: true,
   * 		attributes: [ 'title', 'href' ],
   * 		classes: [ 'foo' ],
   * 		styles: [ 'color', 'position' ]
   * 	}
   * }
   * ```
   *
   * @see module:engine/view/matcher~Matcher#add
   * @see module:engine/view/matcher~Matcher#matchAll
   * @param element View element to match against stored patterns.
   */
  match(...e) {
    for (const t of e)
      for (const n of this._patterns) {
        const r = Hw(t, n);
        if (r)
          return {
            element: t,
            pattern: n,
            match: r
          };
      }
    return null;
  }
  /**
   * Matches elements for currently stored patterns. Returns array of match information with all found
   * {@link module:engine/view/element~Element elements}. If no element is found - returns `null`.
   *
   * @see module:engine/view/matcher~Matcher#add
   * @see module:engine/view/matcher~Matcher#match
   * @param element View element to match against stored patterns.
   * @returns Array with match information about found elements or `null`. For more information
   * see {@link module:engine/view/matcher~Matcher#match match method} description.
   */
  matchAll(...e) {
    const t = [];
    for (const n of e)
      for (const r of this._patterns) {
        const s = Hw(n, r);
        s && t.push({
          element: n,
          pattern: r,
          match: s
        });
      }
    return t.length > 0 ? t : null;
  }
  /**
   * Returns the name of the element to match if there is exactly one pattern added to the matcher instance
   * and it matches element name defined by `string` (not `RegExp`). Otherwise, returns `null`.
   *
   * @returns Element name trying to match.
   */
  getElementName() {
    if (this._patterns.length !== 1)
      return null;
    const e = this._patterns[0], t = e.name;
    return typeof e != "function" && t && !(t instanceof RegExp) ? t : null;
  }
}
function Hw(i, e) {
  if (typeof e == "function")
    return e(i);
  const t = {};
  return e.name && (t.name = eV(e.name, i.name), !t.name) || e.attributes && (t.attributes = rV(e.attributes, i), !t.attributes) || e.classes && (t.classes = sV(e.classes, i), !t.classes) || e.styles && (t.styles = oV(e.styles, i), !t.styles) ? null : t;
}
function eV(i, e) {
  return i instanceof RegExp ? !!e.match(i) : i === e;
}
function op(i, e, t) {
  const n = tV(i), r = Array.from(e), s = [];
  if (n.forEach(([o, l]) => {
    r.forEach((u) => {
      nV(o, u) && iV(l, u, t) && s.push(u);
    });
  }), !(!n.length || s.length < n.length))
    return s;
}
function tV(i) {
  return Array.isArray(i) ? i.map((e) => ui(e) ? ((e.key === void 0 || e.value === void 0) && Yt("matcher-pattern-missing-key-or-value", e), [e.key, e.value]) : [e, !0]) : ui(i) ? Object.entries(i) : [[i, !0]];
}
function nV(i, e) {
  return i === !0 || i === e || i instanceof RegExp && e.match(i);
}
function iV(i, e, t) {
  if (i === !0)
    return !0;
  const n = t(e);
  return i === n || i instanceof RegExp && !!String(n).match(i);
}
function rV(i, e) {
  const t = new Set(e.getAttributeKeys());
  return ui(i) ? (i.style !== void 0 && Yt("matcher-pattern-deprecated-attributes-style-key", i), i.class !== void 0 && Yt("matcher-pattern-deprecated-attributes-class-key", i)) : (t.delete("style"), t.delete("class")), op(i, t, (n) => e.getAttribute(n));
}
function sV(i, e) {
  return op(
    i,
    e.getClassNames(),
    /* istanbul ignore next -- @preserve */
    () => {
    }
  );
}
function oV(i, e) {
  return op(i, e.getStyleNames(!0), (t) => e.getStyle(t));
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class aV {
  /**
   * Creates Styles instance.
   */
  constructor(e) {
    this._styles = {}, this._styleProcessor = e;
  }
  /**
   * Returns true if style map has no styles set.
   */
  get isEmpty() {
    const e = Object.entries(this._styles);
    return !Array.from(e).length;
  }
  /**
   * Number of styles defined.
   */
  get size() {
    return this.isEmpty ? 0 : this.getStyleNames().length;
  }
  /**
   * Set styles map to a new value.
   *
   * ```ts
   * styles.setTo( 'border:1px solid blue;margin-top:1px;' );
   * ```
   */
  setTo(e) {
    this.clear();
    const t = Array.from(cV(e).entries());
    for (const [n, r] of t)
      this._styleProcessor.toNormalizedForm(n, r, this._styles);
  }
  /**
   * Checks if a given style is set.
   *
   * ```ts
   * styles.setTo( 'margin-left:1px;' );
   *
   * styles.has( 'margin-left' );    // -> true
   * styles.has( 'padding' );        // -> false
   * ```
   *
   * **Note**: This check supports normalized style names.
   *
   * ```ts
   * // Enable 'margin' shorthand processing:
   * editor.data.addStyleProcessorRules( addMarginRules );
   *
   * styles.setTo( 'margin:2px;' );
   *
   * styles.has( 'margin' );         // -> true
   * styles.has( 'margin-top' );     // -> true
   * styles.has( 'margin-left' );    // -> true
   *
   * styles.remove( 'margin-top' );
   *
   * styles.has( 'margin' );         // -> false
   * styles.has( 'margin-top' );     // -> false
   * styles.has( 'margin-left' );    // -> true
   * ```
   *
   * @param name Style name.
   */
  has(e) {
    if (this.isEmpty)
      return !1;
    const n = this._styleProcessor.getReducedForm(e, this._styles).find(([r]) => r === e);
    return Array.isArray(n);
  }
  set(e, t) {
    if (Lt(e))
      for (const [n, r] of Object.entries(e))
        this._styleProcessor.toNormalizedForm(n, r, this._styles);
    else
      this._styleProcessor.toNormalizedForm(e, t, this._styles);
  }
  /**
   * Removes given style.
   *
   * ```ts
   * styles.setTo( 'background:#f00;margin-right:2px;' );
   *
   * styles.remove( 'background' );
   *
   * styles.toString();   // -> 'margin-right:2px;'
   * ```
   *
   * ***Note**:* This method uses {@link module:engine/controller/datacontroller~DataController#addStyleProcessorRules
   * enabled style processor rules} to normalize passed values.
   *
   * ```ts
   * // Enable 'margin' shorthand processing:
   * editor.data.addStyleProcessorRules( addMarginRules );
   *
   * styles.setTo( 'margin:1px' );
   *
   * styles.remove( 'margin-top' );
   * styles.remove( 'margin-right' );
   *
   * styles.toString(); // -> 'margin-bottom:1px;margin-left:1px;'
   * ```
   *
   * @param name Style name.
   */
  remove(e) {
    const t = cg(e);
    lB(this._styles, t), delete this._styles[e], this._cleanEmptyObjectsOnPath(t);
  }
  /**
   * Returns a normalized style object or a single value.
   *
   * ```ts
   * // Enable 'margin' shorthand processing:
   * editor.data.addStyleProcessorRules( addMarginRules );
   *
   * const styles = new Styles();
   * styles.setTo( 'margin:1px 2px 3em;' );
   *
   * styles.getNormalized( 'margin' );
   * // will log:
   * // {
   * //     top: '1px',
   * //     right: '2px',
   * //     bottom: '3em',
   * //     left: '2px'     // normalized value from margin shorthand
   * // }
   *
   * styles.getNormalized( 'margin-left' ); // -> '2px'
   * ```
   *
   * **Note**: This method will only return normalized styles if a style processor was defined.
   *
   * @param name Style name.
   */
  getNormalized(e) {
    return this._styleProcessor.getNormalized(e, this._styles);
  }
  /**
   * Returns a normalized style string. Styles are sorted by name.
   *
   * ```ts
   * styles.set( 'margin' , '1px' );
   * styles.set( 'background', '#f00' );
   *
   * styles.toString(); // -> 'background:#f00;margin:1px;'
   * ```
   *
   * **Note**: This method supports normalized styles if defined.
   *
   * ```ts
   * // Enable 'margin' shorthand processing:
   * editor.data.addStyleProcessorRules( addMarginRules );
   *
   * styles.set( 'margin' , '1px' );
   * styles.set( 'background', '#f00' );
   * styles.remove( 'margin-top' );
   * styles.remove( 'margin-right' );
   *
   * styles.toString(); // -> 'background:#f00;margin-bottom:1px;margin-left:1px;'
   * ```
   */
  toString() {
    return this.isEmpty ? "" : this._getStylesEntries().map((e) => e.join(":")).sort().join(";") + ";";
  }
  /**
   * Returns property as a value string or undefined if property is not set.
   *
   * ```ts
   * // Enable 'margin' shorthand processing:
   * editor.data.addStyleProcessorRules( addMarginRules );
   *
   * const styles = new Styles();
   * styles.setTo( 'margin:1px;' );
   * styles.set( 'margin-bottom', '3em' );
   *
   * styles.getAsString( 'margin' ); // -> 'margin: 1px 1px 3em;'
   * ```
   *
   * Note, however, that all sub-values must be set for the longhand property name to return a value:
   *
   * ```ts
   * const styles = new Styles();
   * styles.setTo( 'margin:1px;' );
   * styles.remove( 'margin-bottom' );
   *
   * styles.getAsString( 'margin' ); // -> undefined
   * ```
   *
   * In the above scenario, it is not possible to return a `margin` value, so `undefined` is returned.
   * Instead, you should use:
   *
   * ```ts
   * const styles = new Styles();
   * styles.setTo( 'margin:1px;' );
   * styles.remove( 'margin-bottom' );
   *
   * for ( const styleName of styles.getStyleNames() ) {
   * 	console.log( styleName, styles.getAsString( styleName ) );
   * }
   * // 'margin-top', '1px'
   * // 'margin-right', '1px'
   * // 'margin-left', '1px'
   * ```
   *
   * In general, it is recommend to iterate over style names like in the example above. This way, you will always get all
   * the currently set style values. So, if all the 4 margin values would be set
   * the for-of loop above would yield only `'margin'`, `'1px'`:
   *
   * ```ts
   * const styles = new Styles();
   * styles.setTo( 'margin:1px;' );
   *
   * for ( const styleName of styles.getStyleNames() ) {
   * 	console.log( styleName, styles.getAsString( styleName ) );
   * }
   * // 'margin', '1px'
   * ```
   *
   * **Note**: To get a normalized version of a longhand property use the {@link #getNormalized `#getNormalized()`} method.
   */
  getAsString(e) {
    if (this.isEmpty)
      return;
    if (this._styles[e] && !Lt(this._styles[e]))
      return this._styles[e];
    const n = this._styleProcessor.getReducedForm(e, this._styles).find(([r]) => r === e);
    if (Array.isArray(n))
      return n[1];
  }
  /**
   * Returns all style properties names as they would appear when using {@link #toString `#toString()`}.
   *
   * When `expand` is set to true and there's a shorthand style property set, it will also return all equivalent styles:
   *
   * ```ts
   * stylesMap.setTo( 'margin: 1em' )
   * ```
   *
   * will be expanded to:
   *
   * ```ts
   * [ 'margin', 'margin-top', 'margin-right', 'margin-bottom', 'margin-left' ]
   * ```
   *
   * @param expand Expand shorthand style properties and all return equivalent style representations.
   */
  getStyleNames(e = !1) {
    return this.isEmpty ? [] : e ? this._styleProcessor.getStyleNames(this._styles) : this._getStylesEntries().map(([n]) => n);
  }
  /**
   * Removes all styles.
   */
  clear() {
    this._styles = {};
  }
  /**
   * Returns normalized styles entries for further processing.
   */
  _getStylesEntries() {
    const e = [], t = Object.keys(this._styles);
    for (const n of t)
      e.push(...this._styleProcessor.getReducedForm(n, this._styles));
    return e;
  }
  /**
   * Removes empty objects upon removing an entry from internal object.
   */
  _cleanEmptyObjectsOnPath(e) {
    const t = e.split(".");
    if (!(t.length > 1))
      return;
    const r = t.splice(0, t.length - 1).join("."), s = Ed(this._styles, r);
    if (!s)
      return;
    !Array.from(Object.keys(s)).length && this.remove(r);
  }
}
class lV {
  /**
   * Creates StylesProcessor instance.
   *
   * @internal
   */
  constructor() {
    this._normalizers = /* @__PURE__ */ new Map(), this._extractors = /* @__PURE__ */ new Map(), this._reducers = /* @__PURE__ */ new Map(), this._consumables = /* @__PURE__ */ new Map();
  }
  /**
   * Parse style string value to a normalized object and appends it to styles object.
   *
   * ```ts
   * const styles = {};
   *
   * stylesProcessor.toNormalizedForm( 'margin', '1px', styles );
   *
   * // styles will consist: { margin: { top: '1px', right: '1px', bottom: '1px', left: '1px; } }
   * ```
   *
   * **Note**: To define normalizer callbacks use {@link #setNormalizer}.
   *
   * @param name Name of style property.
   * @param propertyValue Value of style property.
   * @param styles Object holding normalized styles.
   */
  toNormalizedForm(e, t, n) {
    if (Lt(t)) {
      vm(n, cg(e), t);
      return;
    }
    if (this._normalizers.has(e)) {
      const r = this._normalizers.get(e), { path: s, value: o } = r(t);
      vm(n, s, o);
    } else
      vm(n, e, t);
  }
  /**
   * Returns a normalized version of a style property.
   *
   * ```ts
   * const styles = {
   * 	margin: { top: '1px', right: '1px', bottom: '1px', left: '1px; },
   * 	background: { color: '#f00' }
   * };
   *
   * stylesProcessor.getNormalized( 'background' );
   * // will return: { color: '#f00' }
   *
   * stylesProcessor.getNormalized( 'margin-top' );
   * // will return: '1px'
   * ```
   *
   * **Note**: In some cases extracting single value requires defining an extractor callback {@link #setExtractor}.
   *
   * @param name Name of style property.
   * @param styles Object holding normalized styles.
   */
  getNormalized(e, t) {
    if (!e)
      return uE({}, t);
    if (t[e] !== void 0)
      return t[e];
    if (this._extractors.has(e)) {
      const n = this._extractors.get(e);
      if (typeof n == "string")
        return Ed(t, n);
      const r = n(e, t);
      if (r)
        return r;
    }
    return Ed(t, cg(e));
  }
  /**
   * Returns a reduced form of style property form normalized object.
   *
   * For default margin reducer, the below code:
   *
   * ```ts
   * stylesProcessor.getReducedForm( 'margin', {
   * 	margin: { top: '1px', right: '1px', bottom: '2px', left: '1px; }
   * } );
   * ```
   *
   * will return:
   *
   * ```ts
   * [
   * 	[ 'margin', '1px 1px 2px' ]
   * ]
   * ```
   *
   * because it might be represented as a shorthand 'margin' value. However if one of margin long hand values is missing it should return:
   *
   * ```ts
   * [
   * 	[ 'margin-top', '1px' ],
   * 	[ 'margin-right', '1px' ],
   * 	[ 'margin-bottom', '2px' ]
   * 	// the 'left' value is missing - cannot use 'margin' shorthand.
   * ]
   * ```
   *
   * **Note**: To define reducer callbacks use {@link #setReducer}.
   *
   * @param name Name of style property.
   */
  getReducedForm(e, t) {
    const n = this.getNormalized(e, t);
    return n === void 0 ? [] : this._reducers.has(e) ? this._reducers.get(e)(n) : [[e, n]];
  }
  /**
   * Return all style properties. Also expand shorthand properties (e.g. `margin`, `background`) if respective extractor is available.
   *
   * @param styles Object holding normalized styles.
   */
  getStyleNames(e) {
    const t = Array.from(this._consumables.keys()).filter((r) => {
      const s = this.getNormalized(r, e);
      return s && typeof s == "object" ? Object.keys(s).length : s;
    }), n = /* @__PURE__ */ new Set([
      ...t,
      ...Object.keys(e)
    ]);
    return Array.from(n.values());
  }
  /**
   * Returns related style names.
   *
   * ```ts
   * stylesProcessor.getRelatedStyles( 'margin' );
   * // will return: [ 'margin-top', 'margin-right', 'margin-bottom', 'margin-left' ];
   *
   * stylesProcessor.getRelatedStyles( 'margin-top' );
   * // will return: [ 'margin' ];
   * ```
   *
   * **Note**: To define new style relations load an existing style processor or use
   * {@link module:engine/view/stylesmap~StylesProcessor#setStyleRelation `StylesProcessor.setStyleRelation()`}.
   */
  getRelatedStyles(e) {
    return this._consumables.get(e) || [];
  }
  /**
   * Adds a normalizer method for a style property.
   *
   * A normalizer returns describing how the value should be normalized.
   *
   * For instance 'margin' style is a shorthand for four margin values:
   *
   * - 'margin-top'
   * - 'margin-right'
   * - 'margin-bottom'
   * - 'margin-left'
   *
   * and can be written in various ways if some values are equal to others. For instance `'margin: 1px 2em;'` is a shorthand for
   * `'margin-top: 1px;margin-right: 2em;margin-bottom: 1px;margin-left: 2em'`.
   *
   * A normalizer should parse various margin notations as a single object:
   *
   * ```ts
   * const styles = {
   * 	margin: {
   * 		top: '1px',
   * 		right: '2em',
   * 		bottom: '1px',
   * 		left: '2em'
   * 	}
   * };
   * ```
   *
   * Thus a normalizer for 'margin' style should return an object defining style path and value to store:
   *
   * ```ts
   * const returnValue = {
   * 	path: 'margin',
   * 	value: {
   * 		top: '1px',
   * 		right: '2em',
   * 		bottom: '1px',
   * 		left: '2em'
   * 	}
   * };
   * ```
   *
   * Additionally to fully support all margin notations there should be also defined 4 normalizers for longhand margin notations. Below
   * is an example for 'margin-top' style property normalizer:
   *
   * ```ts
   * stylesProcessor.setNormalizer( 'margin-top', valueString => {
   * 	return {
   * 		path: 'margin.top',
   * 		value: valueString
   * 	}
   * } );
   * ```
   */
  setNormalizer(e, t) {
    this._normalizers.set(e, t);
  }
  /**
   * Adds a extractor callback for a style property.
   *
   * Most normalized style values are stored as one level objects. It is assumed that `'margin-top'` style will be stored as:
   *
   * ```ts
   * const styles = {
   * 	margin: {
   * 		top: 'value'
   * 	}
   * }
   * ```
   *
   * However, some styles can have conflicting notations and thus it might be harder to extract a style value from shorthand. For instance
   * the 'border-top-style' can be defined using `'border-top:solid'`, `'border-style:solid none none none'` or by `'border:solid'`
   * shorthands. The default border styles processors stores styles as:
   *
   * ```ts
   * const styles = {
   * 	border: {
   * 		style: {
   * 			top: 'solid'
   * 		}
   * 	}
   * }
   * ```
   *
   * as it is better to modify border style independently from other values. On the other part the output of the border might be
   * desired as `border-top`, `border-left`, etc notation.
   *
   * In the above example an extractor should return a side border value that combines style, color and width:
   *
   * ```ts
   * styleProcessor.setExtractor( 'border-top', styles => {
   * 	return {
   * 		color: styles.border.color.top,
   * 		style: styles.border.style.top,
   * 		width: styles.border.width.top
   * 	}
   * } );
   * ```
   *
   * @param callbackOrPath Callback that return a requested value or path string for single values.
   */
  setExtractor(e, t) {
    this._extractors.set(e, t);
  }
  /**
   * Adds a reducer callback for a style property.
   *
   * Reducer returns a minimal notation for given style name. For longhand properties it is not required to write a reducer as
   * by default the direct value from style path is taken.
   *
   * For shorthand styles a reducer should return minimal style notation either by returning single name-value tuple or multiple tuples
   * if a shorthand cannot be used. For instance for a margin shorthand a reducer might return:
   *
   * ```ts
   * const marginShortHandTuple = [
   * 	[ 'margin', '1px 1px 2px' ]
   * ];
   * ```
   *
   * or a longhand tuples for defined values:
   *
   * ```ts
   * // Considering margin.bottom and margin.left are undefined.
   * const marginLonghandsTuples = [
   * 	[ 'margin-top', '1px' ],
   * 	[ 'margin-right', '1px' ]
   * ];
   * ```
   *
   * A reducer obtains a normalized style value:
   *
   * ```ts
   * // Simplified reducer that always outputs 4 values which are always present:
   * stylesProcessor.setReducer( 'margin', margin => {
   * 	return [
   * 		[ 'margin', `${ margin.top } ${ margin.right } ${ margin.bottom } ${ margin.left }` ]
   * 	]
   * } );
   * ```
   */
  setReducer(e, t) {
    this._reducers.set(e, t);
  }
  /**
   * Defines a style shorthand relation to other style notations.
   *
   * ```ts
   * stylesProcessor.setStyleRelation( 'margin', [
   * 	'margin-top',
   * 	'margin-right',
   * 	'margin-bottom',
   * 	'margin-left'
   * ] );
   * ```
   *
   * This enables expanding of style names for shorthands. For instance, if defined,
   * {@link module:engine/conversion/viewconsumable~ViewConsumable view consumable} items are automatically created
   * for long-hand margin style notation alongside the `'margin'` item.
   *
   * This means that when an element being converted has a style `margin`, a converter for `margin-left` will work just
   * fine since the view consumable will contain a consumable `margin-left` item (thanks to the relation) and
   * `element.getStyle( 'margin-left' )` will work as well assuming that the style processor was correctly configured.
   * However, once `margin-left` is consumed, `margin` will not be consumable anymore.
   */
  setStyleRelation(e, t) {
    this._mapStyleNames(e, t);
    for (const n of t)
      this._mapStyleNames(n, [e]);
  }
  /**
   * Set two-way binding of style names.
   */
  _mapStyleNames(e, t) {
    this._consumables.has(e) || this._consumables.set(e, []), this._consumables.get(e).push(...t);
  }
}
function cV(i) {
  let e = null, t = 0, n = 0, r = null;
  const s = /* @__PURE__ */ new Map();
  if (i === "")
    return s;
  i.charAt(i.length - 1) != ";" && (i = i + ";");
  for (let o = 0; o < i.length; o++) {
    const l = i.charAt(o);
    if (e === null)
      switch (l) {
        case ":":
          r || (r = i.substr(t, o - t), n = o + 1);
          break;
        case '"':
        case "'":
          e = l;
          break;
        case ";": {
          const u = i.substr(n, o - n);
          r && s.set(r.trim(), u.trim()), r = null, t = o + 1;
          break;
        }
      }
    else
      l === e && (e = null);
  }
  return s;
}
function cg(i) {
  return i.replace("-", ".");
}
function vm(i, e, t) {
  let n = t;
  Lt(t) && (n = uE({}, Ed(i, e), t)), oB(i, e, n);
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
let $i = class IE extends Hs {
  /**
   * Creates a view element.
   *
   * Attributes can be passed in various formats:
   *
   * ```ts
   * new Element( viewDocument, 'div', { class: 'editor', contentEditable: 'true' } ); // object
   * new Element( viewDocument, 'div', [ [ 'class', 'editor' ], [ 'contentEditable', 'true' ] ] ); // map-like iterator
   * new Element( viewDocument, 'div', mapOfAttributes ); // map
   * ```
   *
   * @internal
   * @param document The document instance to which this element belongs.
   * @param name Node name.
   * @param attrs Collection of attributes.
   * @param children A list of nodes to be inserted into created element.
   */
  constructor(e, t, n, r) {
    if (super(e), this._unsafeAttributesToRender = [], this._customProperties = /* @__PURE__ */ new Map(), this.name = t, this._attrs = uV(n), this._children = [], r && this._insertChild(0, r), this._classes = /* @__PURE__ */ new Set(), this._attrs.has("class")) {
      const s = this._attrs.get("class");
      qw(this._classes, s), this._attrs.delete("class");
    }
    this._styles = new aV(this.document.stylesProcessor), this._attrs.has("style") && (this._styles.setTo(this._attrs.get("style")), this._attrs.delete("style"));
  }
  /**
   * Number of element's children.
   */
  get childCount() {
    return this._children.length;
  }
  /**
   * Is `true` if there are no nodes inside this element, `false` otherwise.
   */
  get isEmpty() {
    return this._children.length === 0;
  }
  /**
   * Gets child at the given index.
   *
   * @param index Index of child.
   * @returns Child node.
   */
  getChild(e) {
    return this._children[e];
  }
  /**
   * Gets index of the given child node. Returns `-1` if child node is not found.
   *
   * @param node Child node.
   * @returns Index of the child node.
   */
  getChildIndex(e) {
    return this._children.indexOf(e);
  }
  /**
   * Gets child nodes iterator.
   *
   * @returns Child nodes iterator.
   */
  getChildren() {
    return this._children[Symbol.iterator]();
  }
  /**
   * Returns an iterator that contains the keys for attributes. Order of inserting attributes is not preserved.
   *
   * @returns Keys for attributes.
   */
  *getAttributeKeys() {
    this._classes.size > 0 && (yield "class"), this._styles.isEmpty || (yield "style"), yield* this._attrs.keys();
  }
  /**
   * Returns iterator that iterates over this element's attributes.
   *
   * Attributes are returned as arrays containing two items. First one is attribute key and second is attribute value.
   * This format is accepted by native `Map` object and also can be passed in `Node` constructor.
   */
  *getAttributes() {
    yield* this._attrs.entries(), this._classes.size > 0 && (yield ["class", this.getAttribute("class")]), this._styles.isEmpty || (yield ["style", this.getAttribute("style")]);
  }
  /**
   * Gets attribute by key. If attribute is not present - returns undefined.
   *
   * @param key Attribute key.
   * @returns Attribute value.
   */
  getAttribute(e) {
    if (e == "class")
      return this._classes.size > 0 ? [...this._classes].join(" ") : void 0;
    if (e == "style") {
      const t = this._styles.toString();
      return t == "" ? void 0 : t;
    }
    return this._attrs.get(e);
  }
  /**
   * Returns a boolean indicating whether an attribute with the specified key exists in the element.
   *
   * @param key Attribute key.
   * @returns `true` if attribute with the specified key exists in the element, `false` otherwise.
   */
  hasAttribute(e) {
    return e == "class" ? this._classes.size > 0 : e == "style" ? !this._styles.isEmpty : this._attrs.has(e);
  }
  /**
   * Checks if this element is similar to other element.
   * Both elements should have the same name and attributes to be considered as similar. Two similar elements
   * can contain different set of children nodes.
   */
  isSimilar(e) {
    if (!(e instanceof IE))
      return !1;
    if (this === e)
      return !0;
    if (this.name != e.name || this._attrs.size !== e._attrs.size || this._classes.size !== e._classes.size || this._styles.size !== e._styles.size)
      return !1;
    for (const [t, n] of this._attrs)
      if (!e._attrs.has(t) || e._attrs.get(t) !== n)
        return !1;
    for (const t of this._classes)
      if (!e._classes.has(t))
        return !1;
    for (const t of this._styles.getStyleNames())
      if (!e._styles.has(t) || e._styles.getAsString(t) !== this._styles.getAsString(t))
        return !1;
    return !0;
  }
  /**
   * Returns true if class is present.
   * If more then one class is provided - returns true only when all classes are present.
   *
   * ```ts
   * element.hasClass( 'foo' ); // Returns true if 'foo' class is present.
   * element.hasClass( 'foo', 'bar' ); // Returns true if 'foo' and 'bar' classes are both present.
   * ```
   */
  hasClass(...e) {
    for (const t of e)
      if (!this._classes.has(t))
        return !1;
    return !0;
  }
  /**
   * Returns iterator that contains all class names.
   */
  getClassNames() {
    return this._classes.keys();
  }
  /**
   * Returns style value for the given property mae.
   * If the style does not exist `undefined` is returned.
   *
   * **Note**: This method can work with normalized style names if
   * {@link module:engine/controller/datacontroller~DataController#addStyleProcessorRules a particular style processor rule is enabled}.
   * See {@link module:engine/view/stylesmap~StylesMap#getAsString `StylesMap#getAsString()`} for details.
   *
   * For an element with style set to `'margin:1px'`:
   *
   * ```ts
   * // Enable 'margin' shorthand processing:
   * editor.data.addStyleProcessorRules( addMarginRules );
   *
   * const element = view.change( writer => {
   * 	const element = writer.createElement();
   * 	writer.setStyle( 'margin', '1px' );
   * 	writer.setStyle( 'margin-bottom', '3em' );
   *
   * 	return element;
   * } );
   *
   * element.getStyle( 'margin' ); // -> 'margin: 1px 1px 3em;'
   * ```
   */
  getStyle(e) {
    return this._styles.getAsString(e);
  }
  /**
   * Returns a normalized style object or single style value.
   *
   * For an element with style set to: margin:1px 2px 3em;
   *
   * ```ts
   * element.getNormalizedStyle( 'margin' ) );
   * ```
   *
   * will return:
   *
   * ```ts
   * {
   * 	top: '1px',
   * 	right: '2px',
   * 	bottom: '3em',
   * 	left: '2px'    // a normalized value from margin shorthand
   * }
   * ```
   *
   * and reading for single style value:
   *
   * ```ts
   * styles.getNormalizedStyle( 'margin-left' );
   * ```
   *
   * Will return a `2px` string.
   *
   * **Note**: This method will return normalized values only if
   * {@link module:engine/controller/datacontroller~DataController#addStyleProcessorRules a particular style processor rule is enabled}.
   * See {@link module:engine/view/stylesmap~StylesMap#getNormalized `StylesMap#getNormalized()`} for details.
   *
   * @param property Name of CSS property
   */
  getNormalizedStyle(e) {
    return this._styles.getNormalized(e);
  }
  /**
   * Returns iterator that contains all style names.
   *
   * @param expand Expand shorthand style properties and return all equivalent style representations.
   */
  getStyleNames(e) {
    return this._styles.getStyleNames(e);
  }
  /**
   * Returns true if style keys are present.
   * If more then one style property is provided - returns true only when all properties are present.
   *
   * ```ts
   * element.hasStyle( 'color' ); // Returns true if 'border-top' style is present.
   * element.hasStyle( 'color', 'border-top' ); // Returns true if 'color' and 'border-top' styles are both present.
   * ```
   */
  hasStyle(...e) {
    for (const t of e)
      if (!this._styles.has(t))
        return !1;
    return !0;
  }
  /**
   * Returns ancestor element that match specified pattern.
   * Provided patterns should be compatible with {@link module:engine/view/matcher~Matcher Matcher} as it is used internally.
   *
   * @see module:engine/view/matcher~Matcher
   * @param patterns Patterns used to match correct ancestor. See {@link module:engine/view/matcher~Matcher}.
   * @returns Found element or `null` if no matching ancestor was found.
   */
  findAncestor(...e) {
    const t = new ah(...e);
    let n = this.parent;
    for (; n && !n.is("documentFragment"); ) {
      if (t.match(n))
        return n;
      n = n.parent;
    }
    return null;
  }
  /**
   * Returns the custom property value for the given key.
   */
  getCustomProperty(e) {
    return this._customProperties.get(e);
  }
  /**
   * Returns an iterator which iterates over this element's custom properties.
   * Iterator provides `[ key, value ]` pairs for each stored property.
   */
  *getCustomProperties() {
    yield* this._customProperties.entries();
  }
  /**
   * Returns identity string based on element's name, styles, classes and other attributes.
   * Two elements that {@link #isSimilar are similar} will have same identity string.
   * It has the following format:
   *
   * ```ts
   * 'name class="class1,class2" style="style1:value1;style2:value2" attr1="val1" attr2="val2"'
   * ```
   *
   * For example:
   *
   * ```ts
   * const element = writer.createContainerElement( 'foo', {
   * 	banana: '10',
   * 	apple: '20',
   * 	style: 'color: red; border-color: white;',
   * 	class: 'baz'
   * } );
   *
   * // returns 'foo class="baz" style="border-color:white;color:red" apple="20" banana="10"'
   * element.getIdentity();
   * ```
   *
   * **Note**: Classes, styles and other attributes are sorted alphabetically.
   */
  getIdentity() {
    const e = Array.from(this._classes).sort().join(","), t = this._styles.toString(), n = Array.from(this._attrs).map((r) => `${r[0]}="${r[1]}"`).sort().join(" ");
    return this.name + (e == "" ? "" : ` class="${e}"`) + (t ? ` style="${t}"` : "") + (n == "" ? "" : ` ${n}`);
  }
  /**
   * Decides whether an unsafe attribute is whitelisted and should be rendered in the editing pipeline even though filtering mechanisms
   * like {@link module:engine/view/domconverter~DomConverter#shouldRenderAttribute} say it should not.
   *
   * Unsafe attribute names can be specified when creating an element via {@link module:engine/view/downcastwriter~DowncastWriter}.
   *
   * @param attributeName The name of the attribute to be checked.
   */
  shouldRenderUnsafeAttribute(e) {
    return this._unsafeAttributesToRender.includes(e);
  }
  /**
   * Clones provided element.
   *
   * @internal
   * @param deep If set to `true` clones element and all its children recursively. When set to `false`,
   * element will be cloned without any children.
   * @returns Clone of this element.
   */
  _clone(e = !1) {
    const t = [];
    if (e)
      for (const r of this.getChildren())
        t.push(r._clone(e));
    const n = new this.constructor(this.document, this.name, this._attrs, t);
    return n._classes = new Set(this._classes), n._styles.set(this._styles.getNormalized()), n._customProperties = new Map(this._customProperties), n.getFillerOffset = this.getFillerOffset, n._unsafeAttributesToRender = this._unsafeAttributesToRender, n;
  }
  /**
   * {@link module:engine/view/element~Element#_insertChild Insert} a child node or a list of child nodes at the end of this node
   * and sets the parent of these nodes to this element.
   *
   * @see module:engine/view/downcastwriter~DowncastWriter#insert
   * @internal
   * @param items Items to be inserted.
   * @fires change
   * @returns Number of appended nodes.
   */
  _appendChild(e) {
    return this._insertChild(this.childCount, e);
  }
  /**
   * Inserts a child node or a list of child nodes on the given index and sets the parent of these nodes to
   * this element.
   *
   * @internal
   * @see module:engine/view/downcastwriter~DowncastWriter#insert
   * @param index Position where nodes should be inserted.
   * @param items Items to be inserted.
   * @fires change
   * @returns Number of inserted nodes.
   */
  _insertChild(e, t) {
    this._fireChange("children", this);
    let n = 0;
    const r = dV(this.document, t);
    for (const s of r)
      s.parent !== null && s._remove(), s.parent = this, s.document = this.document, this._children.splice(e, 0, s), e++, n++;
    return n;
  }
  /**
   * Removes number of child nodes starting at the given index and set the parent of these nodes to `null`.
   *
   * @see module:engine/view/downcastwriter~DowncastWriter#remove
   * @internal
   * @param index Number of the first node to remove.
   * @param howMany Number of nodes to remove.
   * @fires change
   * @returns The array of removed nodes.
   */
  _removeChildren(e, t = 1) {
    this._fireChange("children", this);
    for (let n = e; n < e + t; n++)
      this._children[n].parent = null;
    return this._children.splice(e, t);
  }
  /**
   * Adds or overwrite attribute with a specified key and value.
   *
   * @see module:engine/view/downcastwriter~DowncastWriter#setAttribute
   * @internal
   * @param key Attribute key.
   * @param value Attribute value.
   * @fires change
   */
  _setAttribute(e, t) {
    const n = String(t);
    this._fireChange("attributes", this), e == "class" ? qw(this._classes, n) : e == "style" ? this._styles.setTo(n) : this._attrs.set(e, n);
  }
  /**
   * Removes attribute from the element.
   *
   * @see module:engine/view/downcastwriter~DowncastWriter#removeAttribute
   * @internal
   * @param key Attribute key.
   * @returns Returns true if an attribute existed and has been removed.
   * @fires change
   */
  _removeAttribute(e) {
    return this._fireChange("attributes", this), e == "class" ? this._classes.size > 0 ? (this._classes.clear(), !0) : !1 : e == "style" ? this._styles.isEmpty ? !1 : (this._styles.clear(), !0) : this._attrs.delete(e);
  }
  /**
   * Adds specified class.
   *
   * ```ts
   * element._addClass( 'foo' ); // Adds 'foo' class.
   * element._addClass( [ 'foo', 'bar' ] ); // Adds 'foo' and 'bar' classes.
   * ```
   *
   * @see module:engine/view/downcastwriter~DowncastWriter#addClass
   * @internal
   * @fires change
   */
  _addClass(e) {
    this._fireChange("attributes", this);
    for (const t of In(e))
      this._classes.add(t);
  }
  /**
   * Removes specified class.
   *
   * ```ts
   * element._removeClass( 'foo' );  // Removes 'foo' class.
   * element._removeClass( [ 'foo', 'bar' ] ); // Removes both 'foo' and 'bar' classes.
   * ```
   *
   * @see module:engine/view/downcastwriter~DowncastWriter#removeClass
   * @internal
   * @fires change
   */
  _removeClass(e) {
    this._fireChange("attributes", this);
    for (const t of In(e))
      this._classes.delete(t);
  }
  _setStyle(e, t) {
    this._fireChange("attributes", this), typeof e != "string" ? this._styles.set(e) : this._styles.set(e, t);
  }
  /**
   * Removes specified style.
   *
   * ```ts
   * element._removeStyle( 'color' );  // Removes 'color' style.
   * element._removeStyle( [ 'color', 'border-top' ] ); // Removes both 'color' and 'border-top' styles.
   * ```
   *
   * **Note**: This method can work with normalized style names if
   * {@link module:engine/controller/datacontroller~DataController#addStyleProcessorRules a particular style processor rule is enabled}.
   * See {@link module:engine/view/stylesmap~StylesMap#remove `StylesMap#remove()`} for details.
   *
   * @see module:engine/view/downcastwriter~DowncastWriter#removeStyle
   * @internal
   * @fires change
   */
  _removeStyle(e) {
    this._fireChange("attributes", this);
    for (const t of In(e))
      this._styles.remove(t);
  }
  /**
   * Sets a custom property. Unlike attributes, custom properties are not rendered to the DOM,
   * so they can be used to add special data to elements.
   *
   * @see module:engine/view/downcastwriter~DowncastWriter#setCustomProperty
   * @internal
   */
  _setCustomProperty(e, t) {
    this._customProperties.set(e, t);
  }
  /**
   * Removes the custom property stored under the given key.
   *
   * @see module:engine/view/downcastwriter~DowncastWriter#removeCustomProperty
   * @internal
   * @returns Returns true if property was removed.
   */
  _removeCustomProperty(e) {
    return this._customProperties.delete(e);
  }
};
$i.prototype.is = function(i, e) {
  return e ? e === this.name && (i === "element" || i === "view:element") : i === "element" || i === "view:element" || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
  i === "node" || i === "view:node";
};
function uV(i) {
  const e = Or(i);
  for (const [t, n] of e)
    n === null ? e.delete(t) : typeof n != "string" && e.set(t, String(n));
  return e;
}
function qw(i, e) {
  const t = e.split(/\s+/);
  i.clear(), t.forEach((n) => i.add(n));
}
function dV(i, e) {
  return typeof e == "string" ? [new Bt(i, e)] : (di(e) || (e = [e]), Array.from(e).map((t) => typeof t == "string" ? new Bt(i, t) : t instanceof er ? new Bt(i, t.data) : t));
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class yl extends $i {
  /**
   * Creates a container element.
   *
   * @see module:engine/view/downcastwriter~DowncastWriter#createContainerElement
   * @see module:engine/view/element~Element
   * @internal
   * @param document The document instance to which this element belongs.
   * @param name Node name.
   * @param attrs Collection of attributes.
   * @param children A list of nodes to be inserted into created element.
   */
  constructor(e, t, n, r) {
    super(e, t, n, r), this.getFillerOffset = RE;
  }
}
yl.prototype.is = function(i, e) {
  return e ? e === this.name && (i === "containerElement" || i === "view:containerElement" || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
  i === "element" || i === "view:element") : i === "containerElement" || i === "view:containerElement" || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
  i === "element" || i === "view:element" || i === "node" || i === "view:node";
};
function RE() {
  const i = [...this.getChildren()], e = i[this.childCount - 1];
  if (e && e.is("element", "br"))
    return this.childCount;
  for (const t of i)
    if (!t.is("uiElement"))
      return null;
  return this.childCount;
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class lh extends Nt(yl) {
  /**
   * Creates an editable element.
   *
   * @see module:engine/view/downcastwriter~DowncastWriter#createEditableElement
   * @internal
   * @param document The document instance to which this element belongs.
   * @param name Node name.
   * @param attrs Collection of attributes.
   * @param children A list of nodes to be inserted into created element.
   */
  constructor(e, t, n, r) {
    super(e, t, n, r), this.set("isReadOnly", !1), this.set("isFocused", !1), this.bind("isReadOnly").to(e), this.bind("isFocused").to(e, "isFocused", (s) => s && e.selection.editableElement == this), this.listenTo(e.selection, "change", () => {
      this.isFocused = e.isFocused && e.selection.editableElement == this;
    });
  }
  destroy() {
    this.stopListening();
  }
}
lh.prototype.is = function(i, e) {
  return e ? e === this.name && (i === "editableElement" || i === "view:editableElement" || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
  i === "containerElement" || i === "view:containerElement" || i === "element" || i === "view:element") : i === "editableElement" || i === "view:editableElement" || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
  i === "containerElement" || i === "view:containerElement" || i === "element" || i === "view:element" || i === "node" || i === "view:node";
};
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const Kw = Symbol("rootName");
class OE extends lh {
  /**
   * Creates root editable element.
   *
   * @param document The document instance to which this element belongs.
   * @param name Node name.
   */
  constructor(e, t) {
    super(e, t), this.rootName = "main";
  }
  /**
   * Name of this root inside {@link module:engine/view/document~Document} that is an owner of this root. If no
   * other name is set, `main` name is used.
   *
   * @readonly
   */
  get rootName() {
    return this.getCustomProperty(Kw);
  }
  set rootName(e) {
    this._setCustomProperty(Kw, e);
  }
  /**
   * Overrides old element name and sets new one.
   * This is needed because view roots are created before they are attached to the DOM.
   * The name of the root element is temporary at this stage. It has to be changed when the
   * view root element is attached to the DOM element.
   *
   * @internal
   * @param name The new name of element.
   */
  set _name(e) {
    this.name = e;
  }
}
OE.prototype.is = function(i, e) {
  return e ? e === this.name && (i === "rootElement" || i === "view:rootElement" || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
  i === "editableElement" || i === "view:editableElement" || i === "containerElement" || i === "view:containerElement" || i === "element" || i === "view:element") : i === "rootElement" || i === "view:rootElement" || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
  i === "editableElement" || i === "view:editableElement" || i === "containerElement" || i === "view:containerElement" || i === "element" || i === "view:element" || i === "node" || i === "view:node";
};
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
let Is = class {
  /**
   * Creates a range iterator. All parameters are optional, but you have to specify either `boundaries` or `startPosition`.
   *
   * @param options Object with configuration.
   */
  constructor(e = {}) {
    if (!e.boundaries && !e.startPosition)
      throw new B("view-tree-walker-no-start-position", null);
    if (e.direction && e.direction != "forward" && e.direction != "backward")
      throw new B("view-tree-walker-unknown-direction", e.startPosition, { direction: e.direction });
    this.boundaries = e.boundaries || null, e.startPosition ? this._position = _e._createAt(e.startPosition) : this._position = _e._createAt(e.boundaries[e.direction == "backward" ? "end" : "start"]), this.direction = e.direction || "forward", this.singleCharacters = !!e.singleCharacters, this.shallow = !!e.shallow, this.ignoreElementEnd = !!e.ignoreElementEnd, this._boundaryStartParent = this.boundaries ? this.boundaries.start.parent : null, this._boundaryEndParent = this.boundaries ? this.boundaries.end.parent : null;
  }
  /**
   * Iterable interface.
   */
  [Symbol.iterator]() {
    return this;
  }
  /**
   * Iterator position. If start position is not defined then position depends on {@link #direction}. If direction is
   * `'forward'` position starts form the beginning, when direction is `'backward'` position starts from the end.
   */
  get position() {
    return this._position;
  }
  /**
   * Moves {@link #position} in the {@link #direction} skipping values as long as the callback function returns `true`.
   *
   * For example:
   *
   * ```ts
   * walker.skip( value => value.type == 'text' ); // <p>{}foo</p> -> <p>foo[]</p>
   * walker.skip( value => true ); // Move the position to the end: <p>{}foo</p> -> <p>foo</p>[]
   * walker.skip( value => false ); // Do not move the position.
   * ```
   *
   * @param skip Callback function. Gets {@link module:engine/view/treewalker~TreeWalkerValue} and should
   * return `true` if the value should be skipped or `false` if not.
   */
  skip(e) {
    let t, n;
    do
      n = this.position, t = this.next();
    while (!t.done && e(t.value));
    t.done || (this._position = n);
  }
  /**
   * Gets the next tree walker's value.
   *
   * @returns Object implementing iterator interface, returning
   * information about taken step.
   */
  next() {
    return this.direction == "forward" ? this._next() : this._previous();
  }
  /**
   * Makes a step forward in view. Moves the {@link #position} to the next position and returns the encountered value.
   */
  _next() {
    let e = this.position.clone();
    const t = this.position, n = e.parent;
    if (n.parent === null && e.offset === n.childCount)
      return { done: !0, value: void 0 };
    if (n === this._boundaryEndParent && e.offset == this.boundaries.end.offset)
      return { done: !0, value: void 0 };
    let r;
    if (n instanceof Bt) {
      if (e.isAtEnd)
        return this._position = _e._createAfter(n), this._next();
      r = n.data[e.offset];
    } else
      r = n.getChild(e.offset);
    if (r instanceof $i)
      return this.shallow ? e.offset++ : e = new _e(r, 0), this._position = e, this._formatReturnValue("elementStart", r, t, e, 1);
    if (r instanceof Bt) {
      if (this.singleCharacters)
        return e = new _e(r, 0), this._position = e, this._next();
      {
        let s = r.data.length, o;
        return r == this._boundaryEndParent ? (s = this.boundaries.end.offset, o = new er(r, 0, s), e = _e._createAfter(o)) : (o = new er(r, 0, r.data.length), e.offset++), this._position = e, this._formatReturnValue("text", o, t, e, s);
      }
    } else if (typeof r == "string") {
      let s;
      this.singleCharacters ? s = 1 : s = (n === this._boundaryEndParent ? this.boundaries.end.offset : n.data.length) - e.offset;
      const o = new er(n, e.offset, s);
      return e.offset += s, this._position = e, this._formatReturnValue("text", o, t, e, s);
    } else
      return e = _e._createAfter(n), this._position = e, this.ignoreElementEnd ? this._next() : this._formatReturnValue("elementEnd", n, t, e);
  }
  /**
   * Makes a step backward in view. Moves the {@link #position} to the previous position and returns the encountered value.
   */
  _previous() {
    let e = this.position.clone();
    const t = this.position, n = e.parent;
    if (n.parent === null && e.offset === 0)
      return { done: !0, value: void 0 };
    if (n == this._boundaryStartParent && e.offset == this.boundaries.start.offset)
      return { done: !0, value: void 0 };
    let r;
    if (n instanceof Bt) {
      if (e.isAtStart)
        return this._position = _e._createBefore(n), this._previous();
      r = n.data[e.offset - 1];
    } else
      r = n.getChild(e.offset - 1);
    if (r instanceof $i)
      return this.shallow ? (e.offset--, this._position = e, this._formatReturnValue("elementStart", r, t, e, 1)) : (e = new _e(r, r.childCount), this._position = e, this.ignoreElementEnd ? this._previous() : this._formatReturnValue("elementEnd", r, t, e));
    if (r instanceof Bt) {
      if (this.singleCharacters)
        return e = new _e(r, r.data.length), this._position = e, this._previous();
      {
        let s = r.data.length, o;
        if (r == this._boundaryStartParent) {
          const l = this.boundaries.start.offset;
          o = new er(r, l, r.data.length - l), s = o.data.length, e = _e._createBefore(o);
        } else
          o = new er(r, 0, r.data.length), e.offset--;
        return this._position = e, this._formatReturnValue("text", o, t, e, s);
      }
    } else if (typeof r == "string") {
      let s;
      if (this.singleCharacters)
        s = 1;
      else {
        const l = n === this._boundaryStartParent ? this.boundaries.start.offset : 0;
        s = e.offset - l;
      }
      e.offset -= s;
      const o = new er(n, e.offset, s);
      return this._position = e, this._formatReturnValue("text", o, t, e, s);
    } else
      return e = _e._createBefore(n), this._position = e, this._formatReturnValue("elementStart", n, t, e, 1);
  }
  /**
   * Format returned data and adjust `previousPosition` and `nextPosition` if reach the bound of the {@link module:engine/view/text~Text}.
   *
   * @param type Type of step.
   * @param item Item between old and new position.
   * @param previousPosition Previous position of iterator.
   * @param nextPosition Next position of iterator.
   * @param length Length of the item.
   */
  _formatReturnValue(e, t, n, r, s) {
    return t instanceof er && (t.offsetInText + t.data.length == t.textNode.data.length && (this.direction == "forward" && !(this.boundaries && this.boundaries.end.isEqual(this.position)) ? (r = _e._createAfter(t.textNode), this._position = r) : n = _e._createAfter(t.textNode)), t.offsetInText === 0 && (this.direction == "backward" && !(this.boundaries && this.boundaries.start.isEqual(this.position)) ? (r = _e._createBefore(t.textNode), this._position = r) : n = _e._createBefore(t.textNode))), {
      done: !1,
      value: {
        type: e,
        item: t,
        previousPosition: n,
        nextPosition: r,
        length: s
      }
    };
  }
};
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
let _e = class Tr extends Us {
  /**
   * Creates a position.
   *
   * @param parent Position parent.
   * @param offset Position offset.
   */
  constructor(e, t) {
    super(), this.parent = e, this.offset = t;
  }
  /**
   * Node directly after the position. Equals `null` when there is no node after position or position is located
   * inside text node.
   */
  get nodeAfter() {
    return this.parent.is("$text") ? null : this.parent.getChild(this.offset) || null;
  }
  /**
   * Node directly before the position. Equals `null` when there is no node before position or position is located
   * inside text node.
   */
  get nodeBefore() {
    return this.parent.is("$text") ? null : this.parent.getChild(this.offset - 1) || null;
  }
  /**
   * Is `true` if position is at the beginning of its {@link module:engine/view/position~Position#parent parent}, `false` otherwise.
   */
  get isAtStart() {
    return this.offset === 0;
  }
  /**
   * Is `true` if position is at the end of its {@link module:engine/view/position~Position#parent parent}, `false` otherwise.
   */
  get isAtEnd() {
    const e = this.parent.is("$text") ? this.parent.data.length : this.parent.childCount;
    return this.offset === e;
  }
  /**
   * Position's root, that is the root of the position's parent element.
   */
  get root() {
    return this.parent.root;
  }
  /**
   * {@link module:engine/view/editableelement~EditableElement EditableElement} instance that contains this position, or `null` if
   * position is not inside an editable element.
   */
  get editableElement() {
    let e = this.parent;
    for (; !(e instanceof lh); )
      if (e.parent)
        e = e.parent;
      else
        return null;
    return e;
  }
  /**
   * Returns a new instance of Position with offset incremented by `shift` value.
   *
   * @param shift How position offset should get changed. Accepts negative values.
   * @returns Shifted position.
   */
  getShiftedBy(e) {
    const t = Tr._createAt(this), n = t.offset + e;
    return t.offset = n < 0 ? 0 : n, t;
  }
  /**
   * Gets the farthest position which matches the callback using
   * {@link module:engine/view/treewalker~TreeWalker TreeWalker}.
   *
   * For example:
   *
   * ```ts
   * getLastMatchingPosition( value => value.type == 'text' ); // <p>{}foo</p> -> <p>foo[]</p>
   * getLastMatchingPosition( value => value.type == 'text', { direction: 'backward' } ); // <p>foo[]</p> -> <p>{}foo</p>
   * getLastMatchingPosition( value => false ); // Do not move the position.
   * ```
   *
   * @param skip Callback function. Gets {@link module:engine/view/treewalker~TreeWalkerValue} and should
   * return `true` if the value should be skipped or `false` if not.
   * @param options Object with configuration options. See {@link module:engine/view/treewalker~TreeWalker}.
   * @returns The position after the last item which matches the `skip` callback test.
   */
  getLastMatchingPosition(e, t = {}) {
    t.startPosition = this;
    const n = new Is(t);
    return n.skip(e), n.position;
  }
  /**
   * Returns ancestors array of this position, that is this position's parent and it's ancestors.
   *
   * @returns Array with ancestors.
   */
  getAncestors() {
    return this.parent.is("documentFragment") ? [this.parent] : this.parent.getAncestors({ includeSelf: !0 });
  }
  /**
   * Returns a {@link module:engine/view/node~Node} or {@link module:engine/view/documentfragment~DocumentFragment}
   * which is a common ancestor of both positions.
   */
  getCommonAncestor(e) {
    const t = this.getAncestors(), n = e.getAncestors();
    let r = 0;
    for (; t[r] == n[r] && t[r]; )
      r++;
    return r === 0 ? null : t[r - 1];
  }
  /**
   * Checks whether this position equals given position.
   *
   * @param otherPosition Position to compare with.
   * @returns True if positions are same.
   */
  isEqual(e) {
    return this.parent == e.parent && this.offset == e.offset;
  }
  /**
   * Checks whether this position is located before given position. When method returns `false` it does not mean that
   * this position is after give one. Two positions may be located inside separate roots and in that situation this
   * method will still return `false`.
   *
   * @see module:engine/view/position~Position#isAfter
   * @see module:engine/view/position~Position#compareWith
   * @param otherPosition Position to compare with.
   * @returns Returns `true` if this position is before given position.
   */
  isBefore(e) {
    return this.compareWith(e) == "before";
  }
  /**
   * Checks whether this position is located after given position. When method returns `false` it does not mean that
   * this position is before give one. Two positions may be located inside separate roots and in that situation this
   * method will still return `false`.
   *
   * @see module:engine/view/position~Position#isBefore
   * @see module:engine/view/position~Position#compareWith
   * @param otherPosition Position to compare with.
   * @returns Returns `true` if this position is after given position.
   */
  isAfter(e) {
    return this.compareWith(e) == "after";
  }
  /**
   * Checks whether this position is before, after or in same position that other position. Two positions may be also
   * different when they are located in separate roots.
   *
   * @param otherPosition Position to compare with.
   */
  compareWith(e) {
    if (this.root !== e.root)
      return "different";
    if (this.isEqual(e))
      return "same";
    const t = this.parent.is("node") ? this.parent.getPath() : [], n = e.parent.is("node") ? e.parent.getPath() : [];
    t.push(this.offset), n.push(e.offset);
    const r = Pn(t, n);
    switch (r) {
      case "prefix":
        return "before";
      case "extension":
        return "after";
      default:
        return t[r] < n[r] ? "before" : "after";
    }
  }
  /**
   * Creates a {@link module:engine/view/treewalker~TreeWalker TreeWalker} instance with this positions as a start position.
   *
   * @param options Object with configuration options. See {@link module:engine/view/treewalker~TreeWalker}
   */
  getWalker(e = {}) {
    return e.startPosition = this, new Is(e);
  }
  /**
   * Clones this position.
   */
  clone() {
    return new Tr(this.parent, this.offset);
  }
  /**
   * Creates position at the given location. The location can be specified as:
   *
   * * a {@link module:engine/view/position~Position position},
   * * parent element and offset (offset defaults to `0`),
   * * parent element and `'end'` (sets position at the end of that element),
   * * {@link module:engine/view/item~Item view item} and `'before'` or `'after'` (sets position before or after given view item).
   *
   * This method is a shortcut to other constructors such as:
   *
   * * {@link module:engine/view/position~Position._createBefore},
   * * {@link module:engine/view/position~Position._createAfter}.
   *
   * @internal
   * @param offset Offset or one of the flags. Used only when first parameter is a {@link module:engine/view/item~Item view item}.
   */
  static _createAt(e, t) {
    if (e instanceof Tr)
      return new this(e.parent, e.offset);
    {
      const n = e;
      if (t == "end")
        t = n.is("$text") ? n.data.length : n.childCount;
      else {
        if (t == "before")
          return this._createBefore(n);
        if (t == "after")
          return this._createAfter(n);
        if (t !== 0 && !t)
          throw new B("view-createpositionat-offset-required", n);
      }
      return new Tr(n, t);
    }
  }
  /**
   * Creates a new position after given view item.
   *
   * @internal
   * @param item View item after which the position should be located.
   */
  static _createAfter(e) {
    if (e.is("$textProxy"))
      return new Tr(e.textNode, e.offsetInText + e.data.length);
    if (!e.parent)
      throw new B("view-position-after-root", e, { root: e });
    return new Tr(e.parent, e.index + 1);
  }
  /**
   * Creates a new position before given view item.
   *
   * @internal
   * @param item View item before which the position should be located.
   */
  static _createBefore(e) {
    if (e.is("$textProxy"))
      return new Tr(e.textNode, e.offsetInText);
    if (!e.parent)
      throw new B("view-position-before-root", e, { root: e });
    return new Tr(e.parent, e.index);
  }
};
_e.prototype.is = function(i) {
  return i === "position" || i === "view:position";
};
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
let We = class Zr extends Us {
  /**
   * Creates a range spanning from `start` position to `end` position.
   *
   * **Note:** Constructor creates it's own {@link module:engine/view/position~Position} instances basing on passed values.
   *
   * @param start Start position.
   * @param end End position. If not set, range will be collapsed at the `start` position.
   */
  constructor(e, t = null) {
    super(), this.start = e.clone(), this.end = t ? t.clone() : e.clone();
  }
  /**
   * Iterable interface.
   *
   * Iterates over all {@link module:engine/view/item~Item view items} that are in this range and returns
   * them together with additional information like length or {@link module:engine/view/position~Position positions},
   * grouped as {@link module:engine/view/treewalker~TreeWalkerValue}.
   *
   * This iterator uses {@link module:engine/view/treewalker~TreeWalker TreeWalker} with `boundaries` set to this range and
   * `ignoreElementEnd` option
   * set to `true`.
   */
  *[Symbol.iterator]() {
    yield* new Is({ boundaries: this, ignoreElementEnd: !0 });
  }
  /**
   * Returns whether the range is collapsed, that is it start and end positions are equal.
   */
  get isCollapsed() {
    return this.start.isEqual(this.end);
  }
  /**
   * Returns whether this range is flat, that is if {@link module:engine/view/range~Range#start start} position and
   * {@link module:engine/view/range~Range#end end} position are in the same {@link module:engine/view/position~Position#parent parent}.
   */
  get isFlat() {
    return this.start.parent === this.end.parent;
  }
  /**
   * Range root element.
   */
  get root() {
    return this.start.root;
  }
  /**
   * Creates a maximal range that has the same content as this range but is expanded in both ways (at the beginning
   * and at the end).
   *
   * For example:
   *
   * ```html
   * <p>Foo</p><p><b>{Bar}</b></p> -> <p>Foo</p>[<p><b>Bar</b>]</p>
   * <p><b>foo</b>{bar}<span></span></p> -> <p><b>foo[</b>bar<span></span>]</p>
   * ```
   *
   * Note that in the sample above:
   *
   * - `<p>` have type of {@link module:engine/view/containerelement~ContainerElement},
   * - `<b>` have type of {@link module:engine/view/attributeelement~AttributeElement},
   * - `<span>` have type of {@link module:engine/view/uielement~UIElement}.
   *
   * @returns Enlarged range.
   */
  getEnlarged() {
    let e = this.start.getLastMatchingPosition($u, { direction: "backward" }), t = this.end.getLastMatchingPosition($u);
    return e.parent.is("$text") && e.isAtStart && (e = _e._createBefore(e.parent)), t.parent.is("$text") && t.isAtEnd && (t = _e._createAfter(t.parent)), new Zr(e, t);
  }
  /**
   * Creates a minimum range that has the same content as this range but is trimmed in both ways (at the beginning
   * and at the end).
   *
   * For example:
   *
   * ```html
   * <p>Foo</p>[<p><b>Bar</b>]</p> -> <p>Foo</p><p><b>{Bar}</b></p>
   * <p><b>foo[</b>bar<span></span>]</p> -> <p><b>foo</b>{bar}<span></span></p>
   * ```
   *
   * Note that in the sample above:
   *
   * - `<p>` have type of {@link module:engine/view/containerelement~ContainerElement},
   * - `<b>` have type of {@link module:engine/view/attributeelement~AttributeElement},
   * - `<span>` have type of {@link module:engine/view/uielement~UIElement}.
   *
   * @returns Shrunk range.
   */
  getTrimmed() {
    let e = this.start.getLastMatchingPosition($u);
    if (e.isAfter(this.end) || e.isEqual(this.end))
      return new Zr(e, e);
    let t = this.end.getLastMatchingPosition($u, { direction: "backward" });
    const n = e.nodeAfter, r = t.nodeBefore;
    return n && n.is("$text") && (e = new _e(n, 0)), r && r.is("$text") && (t = new _e(r, r.data.length)), new Zr(e, t);
  }
  /**
   * Two ranges are equal if their start and end positions are equal.
   *
   * @param otherRange Range to compare with.
   * @returns `true` if ranges are equal, `false` otherwise
   */
  isEqual(e) {
    return this == e || this.start.isEqual(e.start) && this.end.isEqual(e.end);
  }
  /**
   * Checks whether this range contains given {@link module:engine/view/position~Position position}.
   *
   * @param position Position to check.
   * @returns `true` if given {@link module:engine/view/position~Position position} is contained in this range, `false` otherwise.
   */
  containsPosition(e) {
    return e.isAfter(this.start) && e.isBefore(this.end);
  }
  /**
   * Checks whether this range contains given {@link module:engine/view/range~Range range}.
   *
   * @param otherRange Range to check.
   * @param loose Whether the check is loose or strict. If the check is strict (`false`), compared range cannot
   * start or end at the same position as this range boundaries. If the check is loose (`true`), compared range can start, end or
   * even be equal to this range. Note that collapsed ranges are always compared in strict mode.
   * @returns `true` if given {@link module:engine/view/range~Range range} boundaries are contained by this range, `false`
   * otherwise.
   */
  containsRange(e, t = !1) {
    e.isCollapsed && (t = !1);
    const n = this.containsPosition(e.start) || t && this.start.isEqual(e.start), r = this.containsPosition(e.end) || t && this.end.isEqual(e.end);
    return n && r;
  }
  /**
   * Computes which part(s) of this {@link module:engine/view/range~Range range} is not a part of given
   * {@link module:engine/view/range~Range range}.
   * Returned array contains zero, one or two {@link module:engine/view/range~Range ranges}.
   *
   * Examples:
   *
   * ```ts
   * let foo = downcastWriter.createText( 'foo' );
   * let img = downcastWriter.createContainerElement( 'img' );
   * let bar = downcastWriter.createText( 'bar' );
   * let p = downcastWriter.createContainerElement( 'p', null, [ foo, img, bar ] );
   *
   * let range = view.createRange( view.createPositionAt( foo, 2 ), view.createPositionAt( bar, 1 ); // "o", img, "b" are in range.
   * let otherRange = view.createRange( // "oo", img, "ba" are in range.
   * 	view.createPositionAt( foo, 1 ),
   * 	view.createPositionAt( bar, 2 )
   * );
   * let transformed = range.getDifference( otherRange );
   * // transformed array has no ranges because `otherRange` contains `range`
   *
   * otherRange = view.createRange( view.createPositionAt( foo, 1 ), view.createPositionAt( p, 2 ); // "oo", img are in range.
   * transformed = range.getDifference( otherRange );
   * // transformed array has one range: from ( p, 2 ) to ( bar, 1 )
   *
   * otherRange = view.createRange( view.createPositionAt( p, 1 ), view.createPositionAt( p, 2 ) ); // img is in range.
   * transformed = range.getDifference( otherRange );
   * // transformed array has two ranges: from ( foo, 1 ) to ( p, 1 ) and from ( p, 2 ) to ( bar, 1 )
   * ```
   *
   * @param otherRange Range to differentiate against.
   * @returns The difference between ranges.
   */
  getDifference(e) {
    const t = [];
    return this.isIntersecting(e) ? (this.containsPosition(e.start) && t.push(new Zr(this.start, e.start)), this.containsPosition(e.end) && t.push(new Zr(e.end, this.end))) : t.push(this.clone()), t;
  }
  /**
   * Returns an intersection of this {@link module:engine/view/range~Range range} and given {@link module:engine/view/range~Range range}.
   * Intersection is a common part of both of those ranges. If ranges has no common part, returns `null`.
   *
   * Examples:
   *
   * ```ts
   * let foo = downcastWriter.createText( 'foo' );
   * let img = downcastWriter.createContainerElement( 'img' );
   * let bar = downcastWriter.createText( 'bar' );
   * let p = downcastWriter.createContainerElement( 'p', null, [ foo, img, bar ] );
   *
   * let range = view.createRange( view.createPositionAt( foo, 2 ), view.createPositionAt( bar, 1 ); // "o", img, "b" are in range.
   * let otherRange = view.createRange( view.createPositionAt( foo, 1 ), view.createPositionAt( p, 2 ); // "oo", img are in range.
   * let transformed = range.getIntersection( otherRange ); // range from ( foo, 1 ) to ( p, 2 ).
   *
   * otherRange = view.createRange( view.createPositionAt( bar, 1 ), view.createPositionAt( bar, 3 ); "ar" is in range.
   * transformed = range.getIntersection( otherRange ); // null - no common part.
   * ```
   *
   * @param otherRange Range to check for intersection.
   * @returns A common part of given ranges or `null` if ranges have no common part.
   */
  getIntersection(e) {
    if (this.isIntersecting(e)) {
      let t = this.start, n = this.end;
      return this.containsPosition(e.start) && (t = e.start), this.containsPosition(e.end) && (n = e.end), new Zr(t, n);
    }
    return null;
  }
  /**
   * Creates a {@link module:engine/view/treewalker~TreeWalker TreeWalker} instance with this range as a boundary.
   *
   * @param options Object with configuration options. See {@link module:engine/view/treewalker~TreeWalker}.
   */
  getWalker(e = {}) {
    return e.boundaries = this, new Is(e);
  }
  /**
   * Returns a {@link module:engine/view/node~Node} or {@link module:engine/view/documentfragment~DocumentFragment}
   * which is a common ancestor of range's both ends (in which the entire range is contained).
   */
  getCommonAncestor() {
    return this.start.getCommonAncestor(this.end);
  }
  /**
   * Returns an {@link module:engine/view/element~Element Element} contained by the range.
   * The element will be returned when it is the **only** node within the range and **fully–contained**
   * at the same time.
   */
  getContainedElement() {
    if (this.isCollapsed)
      return null;
    let e = this.start.nodeAfter, t = this.end.nodeBefore;
    return this.start.parent.is("$text") && this.start.isAtEnd && this.start.parent.nextSibling && (e = this.start.parent.nextSibling), this.end.parent.is("$text") && this.end.isAtStart && this.end.parent.previousSibling && (t = this.end.parent.previousSibling), e && e.is("element") && e === t ? e : null;
  }
  /**
   * Clones this range.
   */
  clone() {
    return new Zr(this.start, this.end);
  }
  /**
   * Returns an iterator that iterates over all {@link module:engine/view/item~Item view items} that are in this range and returns
   * them.
   *
   * This method uses {@link module:engine/view/treewalker~TreeWalker} with `boundaries` set to this range and `ignoreElementEnd` option
   * set to `true`. However it returns only {@link module:engine/view/item~Item items},
   * not {@link module:engine/view/treewalker~TreeWalkerValue}.
   *
   * You may specify additional options for the tree walker. See {@link module:engine/view/treewalker~TreeWalker} for
   * a full list of available options.
   *
   * @param options Object with configuration options. See {@link module:engine/view/treewalker~TreeWalker}.
   */
  *getItems(e = {}) {
    e.boundaries = this, e.ignoreElementEnd = !0;
    const t = new Is(e);
    for (const n of t)
      yield n.item;
  }
  /**
   * Returns an iterator that iterates over all {@link module:engine/view/position~Position positions} that are boundaries or
   * contained in this range.
   *
   * This method uses {@link module:engine/view/treewalker~TreeWalker} with `boundaries` set to this range. However it returns only
   * {@link module:engine/view/position~Position positions}, not {@link module:engine/view/treewalker~TreeWalkerValue}.
   *
   * You may specify additional options for the tree walker. See {@link module:engine/view/treewalker~TreeWalker} for
   * a full list of available options.
   *
   * @param options Object with configuration options. See {@link module:engine/view/treewalker~TreeWalker}.
   */
  *getPositions(e = {}) {
    e.boundaries = this;
    const t = new Is(e);
    yield t.position;
    for (const n of t)
      yield n.nextPosition;
  }
  /**
   * Checks and returns whether this range intersects with the given range.
   *
   * @param otherRange Range to compare with.
   * @returns True if ranges intersect.
   */
  isIntersecting(e) {
    return this.start.isBefore(e.end) && this.end.isAfter(e.start);
  }
  /**
   * Creates a range from the given parents and offsets.
   *
   * @internal
   * @param startElement Start position parent element.
   * @param startOffset Start position offset.
   * @param endElement End position parent element.
   * @param endOffset End position offset.
   * @returns Created range.
   */
  static _createFromParentsAndOffsets(e, t, n, r) {
    return new this(new _e(e, t), new _e(n, r));
  }
  /**
   * Creates a new range, spreading from specified {@link module:engine/view/position~Position position} to a position moved by
   * given `shift`. If `shift` is a negative value, shifted position is treated as the beginning of the range.
   *
   * @internal
   * @param position Beginning of the range.
   * @param shift How long the range should be.
   */
  static _createFromPositionAndShift(e, t) {
    const n = e, r = e.getShiftedBy(t);
    return t > 0 ? new this(n, r) : new this(r, n);
  }
  /**
   * Creates a range inside an {@link module:engine/view/element~Element element} which starts before the first child of
   * that element and ends after the last child of that element.
   *
   * @internal
   * @param element Element which is a parent for the range.
   */
  static _createIn(e) {
    return this._createFromParentsAndOffsets(e, 0, e, e.childCount);
  }
  /**
   * Creates a range that starts before given {@link module:engine/view/item~Item view item} and ends after it.
   *
   * @internal
   */
  static _createOn(e) {
    const t = e.is("$textProxy") ? e.offsetSize : 1;
    return this._createFromPositionAndShift(_e._createBefore(e), t);
  }
};
We.prototype.is = function(i) {
  return i === "range" || i === "view:range";
};
function $u(i) {
  return !!(i.item.is("attributeElement") || i.item.is("uiElement"));
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
let is = class ME extends kt(Us) {
  /**
   * Creates new selection instance.
   *
   * **Note**: The selection constructor is available as a factory method:
   *
   * * {@link module:engine/view/view~View#createSelection `View#createSelection()`},
   * * {@link module:engine/view/upcastwriter~UpcastWriter#createSelection `UpcastWriter#createSelection()`}.
   *
   * ```ts
   * // Creates empty selection without ranges.
   * const selection = writer.createSelection();
   *
   * // Creates selection at the given range.
   * const range = writer.createRange( start, end );
   * const selection = writer.createSelection( range );
   *
   * // Creates selection at the given ranges
   * const ranges = [ writer.createRange( start1, end2 ), writer.createRange( star2, end2 ) ];
   * const selection = writer.createSelection( ranges );
   *
   * // Creates selection from the other selection.
   * const otherSelection = writer.createSelection();
   * const selection = writer.createSelection( otherSelection );
   *
   * // Creates selection from the document selection.
   * const selection = writer.createSelection( editor.editing.view.document.selection );
   *
   * // Creates selection at the given position.
   * const position = writer.createPositionFromPath( root, path );
   * const selection = writer.createSelection( position );
   *
   * // Creates collapsed selection at the position of given item and offset.
   * const paragraph = writer.createContainerElement( 'paragraph' );
   * const selection = writer.createSelection( paragraph, offset );
   *
   * // Creates a range inside an {@link module:engine/view/element~Element element} which starts before the
   * // first child of that element and ends after the last child of that element.
   * const selection = writer.createSelection( paragraph, 'in' );
   *
   * // Creates a range on an {@link module:engine/view/item~Item item} which starts before the item and ends
   * // just after the item.
   * const selection = writer.createSelection( paragraph, 'on' );
   * ```
   *
   * `Selection`'s constructor allow passing additional options (`backward`, `fake` and `label`) as the last argument.
   *
   * ```ts
   * // Creates backward selection.
   * const selection = writer.createSelection( range, { backward: true } );
   * ```
   *
   * Fake selection does not render as browser native selection over selected elements and is hidden to the user.
   * This way, no native selection UI artifacts are displayed to the user and selection over elements can be
   * represented in other way, for example by applying proper CSS class.
   *
   * Additionally fake's selection label can be provided. It will be used to describe fake selection in DOM
   * (and be  properly handled by screen readers).
   *
   * ```ts
   * // Creates fake selection with label.
   * const selection = writer.createSelection( range, { fake: true, label: 'foo' } );
   * ```
   *
   * @internal
   */
  constructor(...e) {
    super(), this._ranges = [], this._lastRangeBackward = !1, this._isFake = !1, this._fakeSelectionLabel = "", e.length && this.setTo(...e);
  }
  /**
   * Returns true if selection instance is marked as `fake`.
   *
   * @see #setTo
   */
  get isFake() {
    return this._isFake;
  }
  /**
   * Returns fake selection label.
   *
   * @see #setTo
   */
  get fakeSelectionLabel() {
    return this._fakeSelectionLabel;
  }
  /**
   * Selection anchor. Anchor may be described as a position where the selection starts. Together with
   * {@link #focus focus} they define the direction of selection, which is important
   * when expanding/shrinking selection. Anchor is always the start or end of the most recent added range.
   * It may be a bit unintuitive when there are multiple ranges in selection.
   *
   * @see #focus
   */
  get anchor() {
    if (!this._ranges.length)
      return null;
    const e = this._ranges[this._ranges.length - 1];
    return (this._lastRangeBackward ? e.end : e.start).clone();
  }
  /**
   * Selection focus. Focus is a position where the selection ends.
   *
   * @see #anchor
   */
  get focus() {
    if (!this._ranges.length)
      return null;
    const e = this._ranges[this._ranges.length - 1];
    return (this._lastRangeBackward ? e.start : e.end).clone();
  }
  /**
   * Returns whether the selection is collapsed. Selection is collapsed when there is exactly one range which is
   * collapsed.
   */
  get isCollapsed() {
    return this.rangeCount === 1 && this._ranges[0].isCollapsed;
  }
  /**
   * Returns number of ranges in selection.
   */
  get rangeCount() {
    return this._ranges.length;
  }
  /**
   * Specifies whether the {@link #focus} precedes {@link #anchor}.
   */
  get isBackward() {
    return !this.isCollapsed && this._lastRangeBackward;
  }
  /**
   * {@link module:engine/view/editableelement~EditableElement EditableElement} instance that contains this selection, or `null`
   * if the selection is not inside an editable element.
   */
  get editableElement() {
    return this.anchor ? this.anchor.editableElement : null;
  }
  /**
   * Returns an iterable that contains copies of all ranges added to the selection.
   */
  *getRanges() {
    for (const e of this._ranges)
      yield e.clone();
  }
  /**
   * Returns copy of the first range in the selection. First range is the one which
   * {@link module:engine/view/range~Range#start start} position {@link module:engine/view/position~Position#isBefore is before} start
   * position of all other ranges (not to confuse with the first range added to the selection).
   * Returns `null` if no ranges are added to selection.
   */
  getFirstRange() {
    let e = null;
    for (const t of this._ranges)
      (!e || t.start.isBefore(e.start)) && (e = t);
    return e ? e.clone() : null;
  }
  /**
   * Returns copy of the last range in the selection. Last range is the one which {@link module:engine/view/range~Range#end end}
   * position {@link module:engine/view/position~Position#isAfter is after} end position of all other ranges (not to confuse
   * with the last range added to the selection). Returns `null` if no ranges are added to selection.
   */
  getLastRange() {
    let e = null;
    for (const t of this._ranges)
      (!e || t.end.isAfter(e.end)) && (e = t);
    return e ? e.clone() : null;
  }
  /**
   * Returns copy of the first position in the selection. First position is the position that
   * {@link module:engine/view/position~Position#isBefore is before} any other position in the selection ranges.
   * Returns `null` if no ranges are added to selection.
   */
  getFirstPosition() {
    const e = this.getFirstRange();
    return e ? e.start.clone() : null;
  }
  /**
   * Returns copy of the last position in the selection. Last position is the position that
   * {@link module:engine/view/position~Position#isAfter is after} any other position in the selection ranges.
   * Returns `null` if no ranges are added to selection.
   */
  getLastPosition() {
    const e = this.getLastRange();
    return e ? e.end.clone() : null;
  }
  /**
   * Checks whether, this selection is equal to given selection. Selections are equal if they have same directions,
   * same number of ranges and all ranges from one selection equal to a range from other selection.
   *
   * @param otherSelection Selection to compare with.
   * @returns `true` if selections are equal, `false` otherwise.
   */
  isEqual(e) {
    if (this.isFake != e.isFake || this.isFake && this.fakeSelectionLabel != e.fakeSelectionLabel || this.rangeCount != e.rangeCount)
      return !1;
    if (this.rangeCount === 0)
      return !0;
    if (!this.anchor.isEqual(e.anchor) || !this.focus.isEqual(e.focus))
      return !1;
    for (const t of this._ranges) {
      let n = !1;
      for (const r of e._ranges)
        if (t.isEqual(r)) {
          n = !0;
          break;
        }
      if (!n)
        return !1;
    }
    return !0;
  }
  /**
   * Checks whether this selection is similar to given selection. Selections are similar if they have same directions, same
   * number of ranges, and all {@link module:engine/view/range~Range#getTrimmed trimmed} ranges from one selection are
   * equal to any trimmed range from other selection.
   *
   * @param otherSelection Selection to compare with.
   * @returns `true` if selections are similar, `false` otherwise.
   */
  isSimilar(e) {
    if (this.isBackward != e.isBackward)
      return !1;
    const t = sg(this.getRanges()), n = sg(e.getRanges());
    if (t != n)
      return !1;
    if (t == 0)
      return !0;
    for (let r of this.getRanges()) {
      r = r.getTrimmed();
      let s = !1;
      for (let o of e.getRanges())
        if (o = o.getTrimmed(), r.start.isEqual(o.start) && r.end.isEqual(o.end)) {
          s = !0;
          break;
        }
      if (!s)
        return !1;
    }
    return !0;
  }
  /**
   * Returns the selected element. {@link module:engine/view/element~Element Element} is considered as selected if there is only
   * one range in the selection, and that range contains exactly one element.
   * Returns `null` if there is no selected element.
   */
  getSelectedElement() {
    return this.rangeCount !== 1 ? null : this.getFirstRange().getContainedElement();
  }
  /**
   * Sets this selection's ranges and direction to the specified location based on the given
   * {@link module:engine/view/selection~Selectable selectable}.
   *
   * ```ts
   * // Sets selection to the given range.
   * const range = writer.createRange( start, end );
   * selection.setTo( range );
   *
   * // Sets selection to given ranges.
   * const ranges = [ writer.createRange( start1, end2 ), writer.createRange( star2, end2 ) ];
   * selection.setTo( range );
   *
   * // Sets selection to the other selection.
   * const otherSelection = writer.createSelection();
   * selection.setTo( otherSelection );
   *
   * // Sets selection to contents of DocumentSelection.
   * selection.setTo( editor.editing.view.document.selection );
   *
   * // Sets collapsed selection at the given position.
   * const position = writer.createPositionAt( root, path );
   * selection.setTo( position );
   *
   * // Sets collapsed selection at the position of given item and offset.
   * selection.setTo( paragraph, offset );
   * ```
   *
   * Creates a range inside an {@link module:engine/view/element~Element element} which starts before the first child of
   * that element and ends after the last child of that element.
   *
   * ```ts
   * selection.setTo( paragraph, 'in' );
   * ```
   *
   * Creates a range on an {@link module:engine/view/item~Item item} which starts before the item and ends just after the item.
   *
   * ```ts
   * selection.setTo( paragraph, 'on' );
   *
   * // Clears selection. Removes all ranges.
   * selection.setTo( null );
   * ```
   *
   * `Selection#setTo()` method allow passing additional options (`backward`, `fake` and `label`) as the last argument.
   *
   * ```ts
   * // Sets selection as backward.
   * selection.setTo( range, { backward: true } );
   * ```
   *
   * Fake selection does not render as browser native selection over selected elements and is hidden to the user.
   * This way, no native selection UI artifacts are displayed to the user and selection over elements can be
   * represented in other way, for example by applying proper CSS class.
   *
   * Additionally fake's selection label can be provided. It will be used to describe fake selection in DOM
   * (and be  properly handled by screen readers).
   *
   * ```ts
   * // Creates fake selection with label.
   * selection.setTo( range, { fake: true, label: 'foo' } );
   * ```
   *
   * @fires change
   */
  setTo(...e) {
    let [t, n, r] = e;
    if (typeof n == "object" && (r = n, n = void 0), t === null)
      this._setRanges([]), this._setFakeOptions(r);
    else if (t instanceof ME || t instanceof ap)
      this._setRanges(t.getRanges(), t.isBackward), this._setFakeOptions({ fake: t.isFake, label: t.fakeSelectionLabel });
    else if (t instanceof We)
      this._setRanges([t], r && r.backward), this._setFakeOptions(r);
    else if (t instanceof _e)
      this._setRanges([new We(t)]), this._setFakeOptions(r);
    else if (t instanceof Hs) {
      const s = !!r && !!r.backward;
      let o;
      if (n === void 0)
        throw new B("view-selection-setto-required-second-parameter", this);
      n == "in" ? o = We._createIn(t) : n == "on" ? o = We._createOn(t) : o = new We(_e._createAt(t, n)), this._setRanges([o], s), this._setFakeOptions(r);
    } else if (di(t))
      this._setRanges(t, r && r.backward), this._setFakeOptions(r);
    else
      throw new B("view-selection-setto-not-selectable", this);
    this.fire("change");
  }
  /**
   * Moves {@link #focus} to the specified location.
   *
   * The location can be specified in the same form as {@link module:engine/view/view~View#createPositionAt view.createPositionAt()}
   * parameters.
   *
   * @fires change
   * @param offset Offset or one of the flags. Used only when first parameter is a {@link module:engine/view/item~Item view item}.
   */
  setFocus(e, t) {
    if (this.anchor === null)
      throw new B("view-selection-setfocus-no-ranges", this);
    const n = _e._createAt(e, t);
    if (n.compareWith(this.focus) == "same")
      return;
    const r = this.anchor;
    this._ranges.pop(), n.compareWith(r) == "before" ? this._addRange(new We(n, r), !0) : this._addRange(new We(r, n)), this.fire("change");
  }
  /**
   * Replaces all ranges that were added to the selection with given array of ranges. Last range of the array
   * is treated like the last added range and is used to set {@link #anchor anchor} and {@link #focus focus}.
   * Accepts a flag describing in which way the selection is made.
   *
   * @param newRanges Iterable object of ranges to set.
   * @param isLastBackward Flag describing if last added range was selected forward - from start to end
   * (`false`) or backward - from end to start (`true`). Defaults to `false`.
   */
  _setRanges(e, t = !1) {
    e = Array.from(e), this._ranges = [];
    for (const n of e)
      this._addRange(n);
    this._lastRangeBackward = !!t;
  }
  /**
   * Sets this selection instance to be marked as `fake`. A fake selection does not render as browser native selection
   * over selected elements and is hidden to the user. This way, no native selection UI artifacts are displayed to
   * the user and selection over elements can be represented in other way, for example by applying proper CSS class.
   *
   * Additionally fake's selection label can be provided. It will be used to describe fake selection in DOM (and be
   * properly handled by screen readers).
   */
  _setFakeOptions(e = {}) {
    this._isFake = !!e.fake, this._fakeSelectionLabel = e.fake && e.label || "";
  }
  /**
   * Adds a range to the selection. Added range is copied. This means that passed range is not saved in the
   * selection instance and you can safely operate on it.
   *
   * Accepts a flag describing in which way the selection is made - passed range might be selected from
   * {@link module:engine/view/range~Range#start start} to {@link module:engine/view/range~Range#end end}
   * or from {@link module:engine/view/range~Range#end end} to {@link module:engine/view/range~Range#start start}.
   * The flag is used to set {@link #anchor anchor} and {@link #focus focus} properties.
   *
   * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-selection-range-intersects` if added range intersects
   * with ranges already stored in Selection instance.
   */
  _addRange(e, t = !1) {
    if (!(e instanceof We))
      throw new B("view-selection-add-range-not-range", this);
    this._pushRange(e), this._lastRangeBackward = !!t;
  }
  /**
   * Adds range to selection - creates copy of given range so it can be safely used and modified.
   *
   * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-selection-range-intersects` if added range intersects
   * with ranges already stored in selection instance.
   */
  _pushRange(e) {
    for (const t of this._ranges)
      if (e.isIntersecting(t))
        throw new B("view-selection-range-intersects", this, { addedRange: e, intersectingRange: t });
    this._ranges.push(new We(e.start, e.end));
  }
};
is.prototype.is = function(i) {
  return i === "selection" || i === "view:selection";
};
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
let ap = class extends kt(Us) {
  constructor(...e) {
    super(), this._selection = new is(), this._selection.delegate("change").to(this), e.length && this._selection.setTo(...e);
  }
  /**
   * Returns true if selection instance is marked as `fake`.
   *
   * @see #_setTo
   */
  get isFake() {
    return this._selection.isFake;
  }
  /**
   * Returns fake selection label.
   *
   * @see #_setTo
   */
  get fakeSelectionLabel() {
    return this._selection.fakeSelectionLabel;
  }
  /**
   * Selection anchor. Anchor may be described as a position where the selection starts. Together with
   * {@link #focus focus} they define the direction of selection, which is important
   * when expanding/shrinking selection. Anchor is always the start or end of the most recent added range.
   * It may be a bit unintuitive when there are multiple ranges in selection.
   *
   * @see #focus
   */
  get anchor() {
    return this._selection.anchor;
  }
  /**
   * Selection focus. Focus is a position where the selection ends.
   *
   * @see #anchor
   */
  get focus() {
    return this._selection.focus;
  }
  /**
   * Returns whether the selection is collapsed. Selection is collapsed when there is exactly one range which is
   * collapsed.
   */
  get isCollapsed() {
    return this._selection.isCollapsed;
  }
  /**
   * Returns number of ranges in selection.
   */
  get rangeCount() {
    return this._selection.rangeCount;
  }
  /**
   * Specifies whether the {@link #focus} precedes {@link #anchor}.
   */
  get isBackward() {
    return this._selection.isBackward;
  }
  /**
   * {@link module:engine/view/editableelement~EditableElement EditableElement} instance that contains this selection, or `null`
   * if the selection is not inside an editable element.
   */
  get editableElement() {
    return this._selection.editableElement;
  }
  /**
   * Used for the compatibility with the {@link module:engine/view/selection~Selection#isEqual} method.
   *
   * @internal
   */
  get _ranges() {
    return this._selection._ranges;
  }
  /**
   * Returns an iterable that contains copies of all ranges added to the selection.
   */
  *getRanges() {
    yield* this._selection.getRanges();
  }
  /**
   * Returns copy of the first range in the selection. First range is the one which
   * {@link module:engine/view/range~Range#start start} position {@link module:engine/view/position~Position#isBefore is before} start
   * position of all other ranges (not to confuse with the first range added to the selection).
   * Returns `null` if no ranges are added to selection.
   */
  getFirstRange() {
    return this._selection.getFirstRange();
  }
  /**
   * Returns copy of the last range in the selection. Last range is the one which {@link module:engine/view/range~Range#end end}
   * position {@link module:engine/view/position~Position#isAfter is after} end position of all other ranges (not to confuse
   * with the last range added to the selection). Returns `null` if no ranges are added to selection.
   */
  getLastRange() {
    return this._selection.getLastRange();
  }
  /**
   * Returns copy of the first position in the selection. First position is the position that
   * {@link module:engine/view/position~Position#isBefore is before} any other position in the selection ranges.
   * Returns `null` if no ranges are added to selection.
   */
  getFirstPosition() {
    return this._selection.getFirstPosition();
  }
  /**
   * Returns copy of the last position in the selection. Last position is the position that
   * {@link module:engine/view/position~Position#isAfter is after} any other position in the selection ranges.
   * Returns `null` if no ranges are added to selection.
   */
  getLastPosition() {
    return this._selection.getLastPosition();
  }
  /**
   * Returns the selected element. {@link module:engine/view/element~Element Element} is considered as selected if there is only
   * one range in the selection, and that range contains exactly one element.
   * Returns `null` if there is no selected element.
   */
  getSelectedElement() {
    return this._selection.getSelectedElement();
  }
  /**
   * Checks whether, this selection is equal to given selection. Selections are equal if they have same directions,
   * same number of ranges and all ranges from one selection equal to a range from other selection.
   *
   * @param otherSelection Selection to compare with.
   * @returns `true` if selections are equal, `false` otherwise.
   */
  isEqual(e) {
    return this._selection.isEqual(e);
  }
  /**
   * Checks whether this selection is similar to given selection. Selections are similar if they have same directions, same
   * number of ranges, and all {@link module:engine/view/range~Range#getTrimmed trimmed} ranges from one selection are
   * equal to any trimmed range from other selection.
   *
   * @param otherSelection Selection to compare with.
   * @returns `true` if selections are similar, `false` otherwise.
   */
  isSimilar(e) {
    return this._selection.isSimilar(e);
  }
  /**
   * Sets this selection's ranges and direction to the specified location based on the given
   * {@link module:engine/view/selection~Selectable selectable}.
   *
   * ```ts
   * // Sets selection to the given range.
   * const range = writer.createRange( start, end );
   * documentSelection._setTo( range );
   *
   * // Sets selection to given ranges.
   * const ranges = [ writer.createRange( start1, end2 ), writer.createRange( start2, end2 ) ];
   * documentSelection._setTo( range );
   *
   * // Sets selection to the other selection.
   * const otherSelection = writer.createSelection();
   * documentSelection._setTo( otherSelection );
   *
   * // Sets collapsed selection at the given position.
   * const position = writer.createPositionAt( root, offset );
   * documentSelection._setTo( position );
   *
   * // Sets collapsed selection at the position of given item and offset.
   * documentSelection._setTo( paragraph, offset );
   * ```
   *
   * Creates a range inside an {@link module:engine/view/element~Element element} which starts before the first child of
   * that element and ends after the last child of that element.
   *
   * ```ts
   * documentSelection._setTo( paragraph, 'in' );
   * ```
   *
   * Creates a range on an {@link module:engine/view/item~Item item} which starts before the item and ends just after the item.
   *
   * ```ts
   * documentSelection._setTo( paragraph, 'on' );
   *
   * // Clears selection. Removes all ranges.
   * documentSelection._setTo( null );
   * ```
   *
   * `Selection#_setTo()` method allow passing additional options (`backward`, `fake` and `label`) as the last argument.
   *
   * ```ts
   * // Sets selection as backward.
   * documentSelection._setTo( range, { backward: true } );
   * ```
   *
   * Fake selection does not render as browser native selection over selected elements and is hidden to the user.
   * This way, no native selection UI artifacts are displayed to the user and selection over elements can be
   * represented in other way, for example by applying proper CSS class.
   *
   * Additionally fake's selection label can be provided. It will be used to des cribe fake selection in DOM
   * (and be  properly handled by screen readers).
   *
   * ```ts
   * // Creates fake selection with label.
   * documentSelection._setTo( range, { fake: true, label: 'foo' } );
   * ```
   *
   * @internal
   * @fires change
   */
  _setTo(...e) {
    this._selection.setTo(...e);
  }
  /**
   * Moves {@link #focus} to the specified location.
   *
   * The location can be specified in the same form as {@link module:engine/view/view~View#createPositionAt view.createPositionAt()}
   * parameters.
   *
   * @internal
   * @fires change
   * @param offset Offset or one of the flags. Used only when first parameter is a {@link module:engine/view/item~Item view item}.
   */
  _setFocus(e, t) {
    this._selection.setFocus(e, t);
  }
};
ap.prototype.is = function(i) {
  return i === "selection" || i == "documentSelection" || i == "view:selection" || i == "view:documentSelection";
};
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class Qo extends Ir {
  /**
   * @param source The emitter.
   * @param name The event name.
   * @param startRange The view range that the bubbling should start from.
   */
  constructor(e, t, n) {
    super(e, t), this.startRange = n, this._eventPhase = "none", this._currentTarget = null;
  }
  /**
   * The current event phase.
   */
  get eventPhase() {
    return this._eventPhase;
  }
  /**
   * The current bubbling target.
   */
  get currentTarget() {
    return this._currentTarget;
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const wm = Symbol("bubbling contexts");
function ug(i) {
  class e extends i {
    fire(n, ...r) {
      try {
        const s = n instanceof Ir ? n : new Ir(this, n), o = bm(this);
        if (!o.size)
          return;
        if (Ga(s, "capturing", this), xo(o, "$capture", s, ...r))
          return s.return;
        const l = s.startRange || this.selection.getFirstRange(), u = l ? l.getContainedElement() : null, h = u ? !!NE(o, u) : !1;
        let f = u || hV(l);
        if (Ga(s, "atTarget", f), !h) {
          if (xo(o, "$text", s, ...r))
            return s.return;
          Ga(s, "bubbling", f);
        }
        for (; f; ) {
          if (f.is("rootElement")) {
            if (xo(o, "$root", s, ...r))
              return s.return;
          } else if (f.is("element") && xo(o, f.name, s, ...r))
            return s.return;
          if (xo(o, f, s, ...r))
            return s.return;
          f = f.parent, Ga(s, "bubbling", f);
        }
        return Ga(s, "bubbling", this), xo(o, "$document", s, ...r), s.return;
      } catch (s) {
        /* istanbul ignore next -- @preserve */
        B.rethrowUnexpectedError(s, this);
      }
    }
    _addEventListener(n, r, s) {
      const o = In(s.context || "$document"), l = bm(this);
      for (const u of o) {
        let h = l.get(u);
        h || (h = new (kt())(), l.set(u, h)), this.listenTo(h, n, r, s);
      }
    }
    _removeEventListener(n, r) {
      const s = bm(this);
      for (const o of s.values())
        this.stopListening(o, n, r);
    }
  }
  return e;
}
{
  const i = ug(Object);
  ["fire", "_addEventListener", "_removeEventListener"].forEach((e) => {
    ug[e] = i.prototype[e];
  });
}
function Ga(i, e, t) {
  i instanceof Qo && (i._eventPhase = e, i._currentTarget = t);
}
function xo(i, e, t, ...n) {
  const r = typeof e == "string" ? i.get(e) : NE(i, e);
  return r ? (r.fire(t, ...n), t.stop.called) : !1;
}
function NE(i, e) {
  for (const [t, n] of i)
    if (typeof t == "function" && t(e))
      return n;
  return null;
}
function bm(i) {
  return i[wm] || (i[wm] = /* @__PURE__ */ new Map()), i[wm];
}
function hV(i) {
  if (!i)
    return null;
  const e = i.start.parent, t = i.end.parent, n = e.getPath(), r = t.getPath();
  return n.length > r.length ? e : t;
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
let DE = class extends ug(Nt()) {
  /**
   * Creates a Document instance.
   *
   * @param stylesProcessor The styles processor instance.
   */
  constructor(e) {
    super(), this._postFixers = /* @__PURE__ */ new Set(), this.selection = new ap(), this.roots = new Br({ idProperty: "rootName" }), this.stylesProcessor = e, this.set("isReadOnly", !1), this.set("isFocused", !1), this.set("isSelecting", !1), this.set("isComposing", !1);
  }
  /**
   * Gets a {@link module:engine/view/document~Document#roots view root element} with the specified name. If the name is not
   * specific "main" root is returned.
   *
   * @param name Name of the root.
   * @returns The view root element with the specified name or null when there is no root of given name.
   */
  getRoot(e = "main") {
    return this.roots.get(e);
  }
  /**
   * Allows registering post-fixer callbacks. A post-fixers mechanism allows to update the view tree just before it is rendered
   * to the DOM.
   *
   * Post-fixers are executed right after all changes from the outermost change block were applied but
   * before the {@link module:engine/view/view~View#event:render render event} is fired. If a post-fixer callback made
   * a change, it should return `true`. When this happens, all post-fixers are fired again to check if something else should
   * not be fixed in the new document tree state.
   *
   * View post-fixers are useful when you want to apply some fixes whenever the view structure changes. Keep in mind that
   * changes executed in a view post-fixer should not break model-view mapping.
   *
   * The types of changes which should be safe:
   *
   * * adding or removing attribute from elements,
   * * changes inside of {@link module:engine/view/uielement~UIElement UI elements},
   * * {@link module:engine/controller/editingcontroller~EditingController#reconvertItem marking some of the model elements to be
   * re-converted}.
   *
   * Try to avoid changes which touch view structure:
   *
   * * you should not add or remove nor wrap or unwrap any view elements,
   * * you should not change the editor data model in a view post-fixer.
   *
   * As a parameter, a post-fixer callback receives a {@link module:engine/view/downcastwriter~DowncastWriter downcast writer}.
   *
   * Typically, a post-fixer will look like this:
   *
   * ```ts
   * editor.editing.view.document.registerPostFixer( writer => {
   * 	if ( checkSomeCondition() ) {
   * 		writer.doSomething();
   *
   * 		// Let other post-fixers know that something changed.
   * 		return true;
   * 	}
   * } );
   * ```
   *
   * Note that nothing happens right after you register a post-fixer (e.g. execute such a code in the console).
   * That is because adding a post-fixer does not execute it.
   * The post-fixer will be executed as soon as any change in the document needs to cause its rendering.
   * If you want to re-render the editor's view after registering the post-fixer then you should do it manually by calling
   * {@link module:engine/view/view~View#forceRender `view.forceRender()`}.
   *
   * If you need to register a callback which is executed when DOM elements are already updated,
   * use {@link module:engine/view/view~View#event:render render event}.
   */
  registerPostFixer(e) {
    this._postFixers.add(e);
  }
  /**
   * Destroys this instance. Makes sure that all observers are destroyed and listeners removed.
   */
  destroy() {
    this.roots.map((e) => e.destroy()), this.stopListening();
  }
  /**
   * Performs post-fixer loops. Executes post-fixer callbacks as long as none of them has done any changes to the model.
   *
   * @internal
   */
  _callPostFixers(e) {
    let t = !1;
    do
      for (const n of this._postFixers)
        if (t = n(e), t)
          break;
    while (t);
  }
};
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const BE = 10;
class Ms extends $i {
  /**
   * Creates an attribute element.
   *
   * @see module:engine/view/downcastwriter~DowncastWriter#createAttributeElement
   * @see module:engine/view/element~Element
   * @protected
   * @param document The document instance to which this element belongs.
   * @param name Node name.
   * @param attrs Collection of attributes.
   * @param children A list of nodes to be inserted into created element.
   */
  constructor(e, t, n, r) {
    super(e, t, n, r), this._priority = BE, this._id = null, this._clonesGroup = null, this.getFillerOffset = fV;
  }
  /**
   * Element priority. Decides in what order elements are wrapped by {@link module:engine/view/downcastwriter~DowncastWriter}.
   */
  get priority() {
    return this._priority;
  }
  /**
   * Element identifier. If set, it is used by {@link module:engine/view/element~Element#isSimilar},
   * and then two elements are considered similar if, and only if they have the same `id`.
   */
  get id() {
    return this._id;
  }
  /**
   * Returns all {@link module:engine/view/attributeelement~AttributeElement attribute elements} that has the
   * same {@link module:engine/view/attributeelement~AttributeElement#id id} and are in the view tree (were not removed).
   *
   * Note: If this element has been removed from the tree, returned set will not include it.
   *
   * Throws {@link module:utils/ckeditorerror~CKEditorError attribute-element-get-elements-with-same-id-no-id}
   * if this element has no `id`.
   *
   * @returns Set containing all the attribute elements
   * with the same `id` that were added and not removed from the view tree.
   */
  getElementsWithSameId() {
    if (this.id === null)
      throw new B("attribute-element-get-elements-with-same-id-no-id", this);
    return new Set(this._clonesGroup);
  }
  /**
   * Checks if this element is similar to other element.
   *
   * If none of elements has set {@link module:engine/view/attributeelement~AttributeElement#id}, then both elements
   * should have the same name, attributes and priority to be considered as similar. Two similar elements can contain
   * different set of children nodes.
   *
   * If at least one element has {@link module:engine/view/attributeelement~AttributeElement#id} set, then both
   * elements have to have the same {@link module:engine/view/attributeelement~AttributeElement#id} value to be
   * considered similar.
   *
   * Similarity is important for {@link module:engine/view/downcastwriter~DowncastWriter}. For example:
   *
   * * two following similar elements can be merged together into one, longer element,
   * * {@link module:engine/view/downcastwriter~DowncastWriter#unwrap} checks similarity of passed element and processed element to
   * decide whether processed element should be unwrapped,
   * * etc.
   */
  isSimilar(e) {
    return this.id !== null || e.id !== null ? this.id === e.id : super.isSimilar(e) && this.priority == e.priority;
  }
  /**
   * Clones provided element with priority.
   *
   * @internal
   * @param deep If set to `true` clones element and all its children recursively. When set to `false`,
   * element will be cloned without any children.
   * @returns Clone of this element.
   */
  _clone(e = !1) {
    const t = super._clone(e);
    return t._priority = this._priority, t._id = this._id, t;
  }
}
Ms.DEFAULT_PRIORITY = BE;
Ms.prototype.is = function(i, e) {
  return e ? e === this.name && (i === "attributeElement" || i === "view:attributeElement" || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
  i === "element" || i === "view:element") : i === "attributeElement" || i === "view:attributeElement" || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
  i === "element" || i === "view:element" || i === "node" || i === "view:node";
};
function fV() {
  if (ym(this))
    return null;
  let i = this.parent;
  for (; i && i.is("attributeElement"); ) {
    if (ym(i) > 1)
      return null;
    i = i.parent;
  }
  return !i || ym(i) > 1 ? null : this.childCount;
}
function ym(i) {
  return Array.from(i.getChildren()).filter((e) => !e.is("uiElement")).length;
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class lp extends $i {
  /**
   * Creates new instance of EmptyElement.
   *
   * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-emptyelement-cannot-add` when third parameter is passed,
   * to inform that usage of EmptyElement is incorrect (adding child nodes to EmptyElement is forbidden).
   *
   * @see module:engine/view/downcastwriter~DowncastWriter#createEmptyElement
   * @internal
   * @param document The document instance to which this element belongs.
   * @param name Node name.
   * @param attrs Collection of attributes.
   * @param children A list of nodes to be inserted into created element.
   */
  constructor(e, t, n, r) {
    super(e, t, n, r), this.getFillerOffset = mV;
  }
  /**
   * Overrides {@link module:engine/view/element~Element#_insertChild} method.
   * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-emptyelement-cannot-add` to prevent
   * adding any child nodes to EmptyElement.
   *
   * @internal
   */
  _insertChild(e, t) {
    if (t && (t instanceof Hs || Array.from(t).length > 0))
      throw new B("view-emptyelement-cannot-add", [this, t]);
    return 0;
  }
}
lp.prototype.is = function(i, e) {
  return e ? e === this.name && (i === "emptyElement" || i === "view:emptyElement" || i === "element" || i === "view:element") : i === "emptyElement" || i === "view:emptyElement" || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
  i === "element" || i === "view:element" || i === "node" || i === "view:node";
};
function mV() {
  return null;
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class ch extends $i {
  /**
   * Creates new instance of UIElement.
   *
   * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-uielement-cannot-add` when third parameter is passed,
   * to inform that usage of UIElement is incorrect (adding child nodes to UIElement is forbidden).
   *
   * @see module:engine/view/downcastwriter~DowncastWriter#createUIElement
   * @internal
   * @param document The document instance to which this element belongs.
   * @param name Node name.
   * @param attrs Collection of attributes.
   * @param children A list of nodes to be inserted into created element.
   */
  constructor(e, t, n, r) {
    super(e, t, n, r), this.getFillerOffset = pV;
  }
  /**
   * Overrides {@link module:engine/view/element~Element#_insertChild} method.
   * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-uielement-cannot-add` to prevent adding any child nodes
   * to UIElement.
   *
   * @internal
   */
  _insertChild(e, t) {
    if (t && (t instanceof Hs || Array.from(t).length > 0))
      throw new B("view-uielement-cannot-add", [this, t]);
    return 0;
  }
  /**
   * Renders this {@link module:engine/view/uielement~UIElement} to DOM. This method is called by
   * {@link module:engine/view/domconverter~DomConverter}.
   * Do not use inheritance to create custom rendering method, replace `render()` method instead:
   *
   * ```ts
   * const myUIElement = downcastWriter.createUIElement( 'span' );
   * myUIElement.render = function( domDocument, domConverter ) {
   * 	const domElement = this.toDomElement( domDocument );
   *
   * 	domConverter.setContentOf( domElement, '<b>this is ui element</b>' );
   *
   * 	return domElement;
   * };
   * ```
   *
   * If changes in your UI element should trigger some editor UI update you should call
   * the {@link module:ui/editorui/editorui~EditorUI#update `editor.ui.update()`} method
   * after rendering your UI element.
   *
   * @param domConverter Instance of the DomConverter used to optimize the output.
   */
  render(e, t) {
    return this.toDomElement(e);
  }
  /**
   * Creates DOM element based on this view UIElement.
   * Note that each time this method is called new DOM element is created.
   */
  toDomElement(e) {
    const t = e.createElement(this.name);
    for (const n of this.getAttributeKeys())
      t.setAttribute(n, this.getAttribute(n));
    return t;
  }
}
ch.prototype.is = function(i, e) {
  return e ? e === this.name && (i === "uiElement" || i === "view:uiElement" || i === "element" || i === "view:element") : i === "uiElement" || i === "view:uiElement" || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
  i === "element" || i === "view:element" || i === "node" || i === "view:node";
};
function gV(i) {
  i.document.on("arrowKey", (e, t) => _V(e, t, i.domConverter), { priority: "low" });
}
function pV() {
  return null;
}
function _V(i, e, t) {
  if (e.keyCode == tt.arrowright) {
    const n = e.domTarget.ownerDocument.defaultView.getSelection(), r = n.rangeCount == 1 && n.getRangeAt(0).collapsed;
    if (r || e.shiftKey) {
      const s = n.focusNode, o = n.focusOffset, l = t.domPositionToView(s, o);
      if (l === null)
        return;
      let u = !1;
      const h = l.getLastMatchingPosition((f) => (f.item.is("uiElement") && (u = !0), !!(f.item.is("uiElement") || f.item.is("attributeElement"))));
      if (u) {
        const f = t.viewPositionToDom(h);
        r ? n.collapse(f.parent, f.offset) : n.extend(f.parent, f.offset);
      }
    }
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class cp extends $i {
  /**
   * Creates a new instance of a raw element.
   *
   * Throws the `view-rawelement-cannot-add` {@link module:utils/ckeditorerror~CKEditorError CKEditorError} when the `children`
   * parameter is passed to inform that the usage of `RawElement` is incorrect (adding child nodes to `RawElement` is forbidden).
   *
   * @see module:engine/view/downcastwriter~DowncastWriter#createRawElement
   * @internal
   * @param document The document instance to which this element belongs.
   * @param name Node name.
   * @param attrs Collection of attributes.
   * @param children A list of nodes to be inserted into created element.
   */
  constructor(e, t, n, r) {
    super(e, t, n, r), this.getFillerOffset = vV;
  }
  /**
   * Overrides the {@link module:engine/view/element~Element#_insertChild} method.
   * Throws the `view-rawelement-cannot-add` {@link module:utils/ckeditorerror~CKEditorError CKEditorError} to prevent
   * adding any child nodes to a raw element.
   *
   * @internal
   */
  _insertChild(e, t) {
    if (t && (t instanceof Hs || Array.from(t).length > 0))
      throw new B("view-rawelement-cannot-add", [this, t]);
    return 0;
  }
  /**
   * This allows rendering the children of a {@link module:engine/view/rawelement~RawElement} on the DOM level.
   * This method is called by the {@link module:engine/view/domconverter~DomConverter} with the raw DOM element
   * passed as an argument, leaving the number and shape of the children up to the integrator.
   *
   * This method **must be defined** for the raw element to work:
   *
   * ```ts
   * const myRawElement = downcastWriter.createRawElement( 'div' );
   *
   * myRawElement.render = function( domElement, domConverter ) {
   * 	domConverter.setContentOf( domElement, '<b>This is the raw content of myRawElement.</b>' );
   * };
   * ```
   *
   * @param domElement The native DOM element representing the raw view element.
   * @param domConverter Instance of the DomConverter used to optimize the output.
   */
  render(e, t) {
  }
}
cp.prototype.is = function(i, e) {
  return e ? e === this.name && (i === "rawElement" || i === "view:rawElement" || i === "element" || i === "view:element") : i === "rawElement" || i === "view:rawElement" || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
  i === this.name || i === "view:" + this.name || i === "element" || i === "view:element" || i === "node" || i === "view:node";
};
function vV() {
  return null;
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
let Ns = class extends kt(Us) {
  /**
   * Creates new DocumentFragment instance.
   *
   * @internal
   * @param document The document to which this document fragment belongs.
   * @param children A list of nodes to be inserted into the created document fragment.
   */
  constructor(e, t) {
    super(), this._children = [], this._customProperties = /* @__PURE__ */ new Map(), this.document = e, t && this._insertChild(0, t);
  }
  /**
   * Iterable interface.
   *
   * Iterates over nodes added to this document fragment.
   */
  [Symbol.iterator]() {
    return this._children[Symbol.iterator]();
  }
  /**
   * Number of child nodes in this document fragment.
   */
  get childCount() {
    return this._children.length;
  }
  /**
   * Is `true` if there are no nodes inside this document fragment, `false` otherwise.
   */
  get isEmpty() {
    return this.childCount === 0;
  }
  /**
   * Artificial root of `DocumentFragment`. Returns itself. Added for compatibility reasons.
   */
  get root() {
    return this;
  }
  /**
   * Artificial parent of `DocumentFragment`. Returns `null`. Added for compatibility reasons.
   */
  get parent() {
    return null;
  }
  /**
   * Artificial element name. Returns `undefined`. Added for compatibility reasons.
   */
  get name() {
  }
  /**
   * Returns the custom property value for the given key.
   */
  getCustomProperty(e) {
    return this._customProperties.get(e);
  }
  /**
   * Returns an iterator which iterates over this document fragment's custom properties.
   * Iterator provides `[ key, value ]` pairs for each stored property.
   */
  *getCustomProperties() {
    yield* this._customProperties.entries();
  }
  /**
   * {@link module:engine/view/documentfragment~DocumentFragment#_insertChild Insert} a child node or a list of child nodes at the end
   * and sets the parent of these nodes to this fragment.
   *
   * @internal
   * @param items Items to be inserted.
   * @returns Number of appended nodes.
   */
  _appendChild(e) {
    return this._insertChild(this.childCount, e);
  }
  /**
   * Gets child at the given index.
   *
   * @param index Index of child.
   * @returns Child node.
   */
  getChild(e) {
    return this._children[e];
  }
  /**
   * Gets index of the given child node. Returns `-1` if child node is not found.
   *
   * @param node Child node.
   * @returns Index of the child node.
   */
  getChildIndex(e) {
    return this._children.indexOf(e);
  }
  /**
   * Gets child nodes iterator.
   *
   * @returns Child nodes iterator.
   */
  getChildren() {
    return this._children[Symbol.iterator]();
  }
  /**
   * Inserts a child node or a list of child nodes on the given index and sets the parent of these nodes to
   * this fragment.
   *
   * @internal
   * @param index Position where nodes should be inserted.
   * @param items Items to be inserted.
   * @returns Number of inserted nodes.
   */
  _insertChild(e, t) {
    this._fireChange("children", this);
    let n = 0;
    const r = wV(this.document, t);
    for (const s of r)
      s.parent !== null && s._remove(), s.parent = this, this._children.splice(e, 0, s), e++, n++;
    return n;
  }
  /**
   * Removes number of child nodes starting at the given index and set the parent of these nodes to `null`.
   *
   * @internal
   * @param index Number of the first node to remove.
   * @param howMany Number of nodes to remove.
   * @returns The array of removed nodes.
   */
  _removeChildren(e, t = 1) {
    this._fireChange("children", this);
    for (let n = e; n < e + t; n++)
      this._children[n].parent = null;
    return this._children.splice(e, t);
  }
  /**
   * Fires `change` event with given type of the change.
   *
   * @internal
   * @param type Type of the change.
   * @param node Changed node.
   */
  _fireChange(e, t) {
    this.fire("change:" + e, t);
  }
  /**
   * Sets a custom property. They can be used to add special data to elements.
   *
   * @see module:engine/view/downcastwriter~DowncastWriter#setCustomProperty
   * @internal
   */
  _setCustomProperty(e, t) {
    this._customProperties.set(e, t);
  }
  /**
   * Removes the custom property stored under the given key.
   *
   * @see module:engine/view/downcastwriter~DowncastWriter#removeCustomProperty
   * @internal
   * @returns Returns true if property was removed.
   */
  _removeCustomProperty(e) {
    return this._customProperties.delete(e);
  }
};
Ns.prototype.is = function(i) {
  return i === "documentFragment" || i === "view:documentFragment";
};
function wV(i, e) {
  return typeof e == "string" ? [new Bt(i, e)] : (di(e) || (e = [e]), Array.from(e).map((t) => typeof t == "string" ? new Bt(i, t) : t instanceof er ? new Bt(i, t.data) : t));
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class VE {
  /**
   * @param document The view document instance.
   */
  constructor(e) {
    this._cloneGroups = /* @__PURE__ */ new Map(), this._slotFactory = null, this.document = e;
  }
  setSelection(...e) {
    this.document.selection._setTo(...e);
  }
  /**
   * Moves {@link module:engine/view/documentselection~DocumentSelection#focus selection's focus} to the specified location.
   *
   * The location can be specified in the same form as {@link module:engine/view/view~View#createPositionAt view.createPositionAt()}
   * parameters.
   *
   * @param Offset or one of the flags. Used only when the first parameter is a {@link module:engine/view/item~Item view item}.
   */
  setSelectionFocus(e, t) {
    this.document.selection._setFocus(e, t);
  }
  /**
   * Creates a new {@link module:engine/view/documentfragment~DocumentFragment} instance.
   *
   * @param children A list of nodes to be inserted into the created document fragment.
   * @returns The created document fragment.
   */
  createDocumentFragment(e) {
    return new Ns(this.document, e);
  }
  /**
   * Creates a new {@link module:engine/view/text~Text text node}.
   *
   * ```ts
   * writer.createText( 'foo' );
   * ```
   *
   * @param data The text's data.
   * @returns The created text node.
   */
  createText(e) {
    return new Bt(this.document, e);
  }
  /**
   * Creates a new {@link module:engine/view/attributeelement~AttributeElement}.
   *
   * ```ts
   * writer.createAttributeElement( 'strong' );
   * writer.createAttributeElement( 'a', { href: 'foo.bar' } );
   *
   * // Make `<a>` element contain other attributes element so the `<a>` element is not broken.
   * writer.createAttributeElement( 'a', { href: 'foo.bar' }, { priority: 5 } );
   *
   * // Set `id` of a marker element so it is not joined or merged with "normal" elements.
   * writer.createAttributeElement( 'span', { class: 'my-marker' }, { id: 'marker:my' } );
   * ```
   *
   * @param name Name of the element.
   * @param attributes Element's attributes.
   * @param options Element's options.
   * @param options.priority Element's {@link module:engine/view/attributeelement~AttributeElement#priority priority}.
   * @param options.id Element's {@link module:engine/view/attributeelement~AttributeElement#id id}.
   * @param options.renderUnsafeAttributes A list of attribute names that should be rendered in the editing
   * pipeline even though they would normally be filtered out by unsafe attribute detection mechanisms.
   * @returns Created element.
   */
  createAttributeElement(e, t, n = {}) {
    const r = new Ms(this.document, e, t);
    return typeof n.priority == "number" && (r._priority = n.priority), n.id && (r._id = n.id), n.renderUnsafeAttributes && r._unsafeAttributesToRender.push(...n.renderUnsafeAttributes), r;
  }
  createContainerElement(e, t, n = {}, r = {}) {
    let s = null;
    ui(n) ? r = n : s = n;
    const o = new yl(this.document, e, t, s);
    return r.renderUnsafeAttributes && o._unsafeAttributesToRender.push(...r.renderUnsafeAttributes), o;
  }
  /**
   * Creates a new {@link module:engine/view/editableelement~EditableElement}.
   *
   * ```ts
   * writer.createEditableElement( 'div' );
   * writer.createEditableElement( 'div', { id: 'foo-1234' } );
   * ```
   *
   * Note: The editable element is to be used in the editing pipeline. Usually, together with
   * {@link module:widget/utils~toWidgetEditable `toWidgetEditable()`}.
   *
   * @param name Name of the element.
   * @param attributes Elements attributes.
   * @param options Element's options.
   * @param options.renderUnsafeAttributes A list of attribute names that should be rendered in the editing
   * pipeline even though they would normally be filtered out by unsafe attribute detection mechanisms.
   * @returns Created element.
   */
  createEditableElement(e, t, n = {}) {
    const r = new lh(this.document, e, t);
    return n.renderUnsafeAttributes && r._unsafeAttributesToRender.push(...n.renderUnsafeAttributes), r;
  }
  /**
   * Creates a new {@link module:engine/view/emptyelement~EmptyElement}.
   *
   * ```ts
   * writer.createEmptyElement( 'img' );
   * writer.createEmptyElement( 'img', { id: 'foo-1234' } );
   * ```
   *
   * @param name Name of the element.
   * @param attributes Elements attributes.
   * @param options Element's options.
   * @param options.renderUnsafeAttributes A list of attribute names that should be rendered in the editing
   * pipeline even though they would normally be filtered out by unsafe attribute detection mechanisms.
   * @returns Created element.
   */
  createEmptyElement(e, t, n = {}) {
    const r = new lp(this.document, e, t);
    return n.renderUnsafeAttributes && r._unsafeAttributesToRender.push(...n.renderUnsafeAttributes), r;
  }
  /**
   * Creates a new {@link module:engine/view/uielement~UIElement}.
   *
   * ```ts
   * writer.createUIElement( 'span' );
   * writer.createUIElement( 'span', { id: 'foo-1234' } );
   * ```
   *
   * A custom render function can be provided as the third parameter:
   *
   * ```ts
   * writer.createUIElement( 'span', null, function( domDocument ) {
   * 	const domElement = this.toDomElement( domDocument );
   * 	domElement.innerHTML = '<b>this is ui element</b>';
   *
   * 	return domElement;
   * } );
   * ```
   *
   * Unlike {@link #createRawElement raw elements}, UI elements are by no means editor content, for instance,
   * they are ignored by the editor selection system.
   *
   * You should not use UI elements as data containers. Check out {@link #createRawElement} instead.
   *
   * @param name The name of the element.
   * @param attributes Element attributes.
   * @param renderFunction A custom render function.
   * @returns The created element.
   */
  createUIElement(e, t, n) {
    const r = new ch(this.document, e, t);
    return n && (r.render = n), r;
  }
  /**
   * Creates a new {@link module:engine/view/rawelement~RawElement}.
   *
   * ```ts
   * writer.createRawElement( 'span', { id: 'foo-1234' }, function( domElement ) {
   * 	domElement.innerHTML = '<b>This is the raw content of the raw element.</b>';
   * } );
   * ```
   *
   * Raw elements work as data containers ("wrappers", "sandboxes") but their children are not managed or
   * even recognized by the editor. This encapsulation allows integrations to maintain custom DOM structures
   * in the editor content without, for instance, worrying about compatibility with other editor features.
   * Raw elements are a perfect tool for integration with external frameworks and data sources.
   *
   * Unlike {@link #createUIElement UI elements}, raw elements act like "real" editor content (similar to
   * {@link module:engine/view/containerelement~ContainerElement} or {@link module:engine/view/emptyelement~EmptyElement}),
   * and they are considered by the editor selection.
   *
   * You should not use raw elements to render the UI in the editor content. Check out {@link #createUIElement `#createUIElement()`}
   * instead.
   *
   * @param name The name of the element.
   * @param attributes Element attributes.
   * @param renderFunction A custom render function.
   * @param options Element's options.
   * @param options.renderUnsafeAttributes A list of attribute names that should be rendered in the editing
   * pipeline even though they would normally be filtered out by unsafe attribute detection mechanisms.
   * @returns The created element.
   */
  createRawElement(e, t, n, r = {}) {
    const s = new cp(this.document, e, t);
    return n && (s.render = n), r.renderUnsafeAttributes && s._unsafeAttributesToRender.push(...r.renderUnsafeAttributes), s;
  }
  /**
   * Adds or overwrites the element's attribute with a specified key and value.
   *
   * ```ts
   * writer.setAttribute( 'href', 'http://ckeditor.com', linkElement );
   * ```
   *
   * @param key The attribute key.
   * @param value The attribute value.
   */
  setAttribute(e, t, n) {
    n._setAttribute(e, t);
  }
  /**
   * Removes attribute from the element.
   *
   * ```ts
   * writer.removeAttribute( 'href', linkElement );
   * ```
   *
   * @param key Attribute key.
   */
  removeAttribute(e, t) {
    t._removeAttribute(e);
  }
  /**
   * Adds specified class to the element.
   *
   * ```ts
   * writer.addClass( 'foo', linkElement );
   * writer.addClass( [ 'foo', 'bar' ], linkElement );
   * ```
   */
  addClass(e, t) {
    t._addClass(e);
  }
  /**
   * Removes specified class from the element.
   *
   * ```ts
   * writer.removeClass( 'foo', linkElement );
   * writer.removeClass( [ 'foo', 'bar' ], linkElement );
   * ```
   */
  removeClass(e, t) {
    t._removeClass(e);
  }
  setStyle(e, t, n) {
    ui(e) && n === void 0 ? t._setStyle(e) : n._setStyle(e, t);
  }
  /**
   * Removes specified style from the element.
   *
   * ```ts
   * writer.removeStyle( 'color', element ); // Removes 'color' style.
   * writer.removeStyle( [ 'color', 'border-top' ], element ); // Removes both 'color' and 'border-top' styles.
   * ```
   *
   * **Note**: This method can work with normalized style names if
   * {@link module:engine/controller/datacontroller~DataController#addStyleProcessorRules a particular style processor rule is enabled}.
   * See {@link module:engine/view/stylesmap~StylesMap#remove `StylesMap#remove()`} for details.
   */
  removeStyle(e, t) {
    t._removeStyle(e);
  }
  /**
   * Sets a custom property on element. Unlike attributes, custom properties are not rendered to the DOM,
   * so they can be used to add special data to elements.
   */
  setCustomProperty(e, t, n) {
    n._setCustomProperty(e, t);
  }
  /**
   * Removes a custom property stored under the given key.
   *
   * @returns Returns true if property was removed.
   */
  removeCustomProperty(e, t) {
    return t._removeCustomProperty(e);
  }
  /**
   * Breaks attribute elements at the provided position or at the boundaries of a provided range. It breaks attribute elements
   * up to their first ancestor that is a container element.
   *
   * In following examples `<p>` is a container, `<b>` and `<u>` are attribute elements:
   *
   * ```html
   * <p>foo<b><u>bar{}</u></b></p> -> <p>foo<b><u>bar</u></b>[]</p>
   * <p>foo<b><u>{}bar</u></b></p> -> <p>foo{}<b><u>bar</u></b></p>
   * <p>foo<b><u>b{}ar</u></b></p> -> <p>foo<b><u>b</u></b>[]<b><u>ar</u></b></p>
   * <p><b>fo{o</b><u>ba}r</u></p> -> <p><b>fo</b><b>o</b><u>ba</u><u>r</u></b></p>
   * ```
   *
   * **Note:** {@link module:engine/view/documentfragment~DocumentFragment DocumentFragment} is treated like a container.
   *
   * **Note:** The difference between {@link module:engine/view/downcastwriter~DowncastWriter#breakAttributes breakAttributes()} and
   * {@link module:engine/view/downcastwriter~DowncastWriter#breakContainer breakContainer()} is that `breakAttributes()` breaks all
   * {@link module:engine/view/attributeelement~AttributeElement attribute elements} that are ancestors of a given `position`,
   * up to the first encountered {@link module:engine/view/containerelement~ContainerElement container element}.
   * `breakContainer()` assumes that a given `position` is directly in the container element and breaks that container element.
   *
   * Throws the `view-writer-invalid-range-container` {@link module:utils/ckeditorerror~CKEditorError CKEditorError}
   * when the {@link module:engine/view/range~Range#start start}
   * and {@link module:engine/view/range~Range#end end} positions of a passed range are not placed inside same parent container.
   *
   * Throws the `view-writer-cannot-break-empty-element` {@link module:utils/ckeditorerror~CKEditorError CKEditorError}
   * when trying to break attributes inside an {@link module:engine/view/emptyelement~EmptyElement EmptyElement}.
   *
   * Throws the `view-writer-cannot-break-ui-element` {@link module:utils/ckeditorerror~CKEditorError CKEditorError}
   * when trying to break attributes inside a {@link module:engine/view/uielement~UIElement UIElement}.
   *
   * @see module:engine/view/attributeelement~AttributeElement
   * @see module:engine/view/containerelement~ContainerElement
   * @see module:engine/view/downcastwriter~DowncastWriter#breakContainer
   * @param positionOrRange The position where to break attribute elements.
   * @returns The new position or range, after breaking the attribute elements.
   */
  breakAttributes(e) {
    return e instanceof _e ? this._breakAttributes(e) : this._breakAttributesRange(e);
  }
  /**
   * Breaks a {@link module:engine/view/containerelement~ContainerElement container view element} into two, at the given position.
   * The position has to be directly inside the container element and cannot be in the root. It does not break the conrainer view element
   * if the position is at the beginning or at the end of its parent element.
   *
   * ```html
   * <p>foo^bar</p> -> <p>foo</p><p>bar</p>
   * <div><p>foo</p>^<p>bar</p></div> -> <div><p>foo</p></div><div><p>bar</p></div>
   * <p>^foobar</p> -> ^<p>foobar</p>
   * <p>foobar^</p> -> <p>foobar</p>^
   * ```
   *
   * **Note:** The difference between {@link module:engine/view/downcastwriter~DowncastWriter#breakAttributes breakAttributes()} and
   * {@link module:engine/view/downcastwriter~DowncastWriter#breakContainer breakContainer()} is that `breakAttributes()` breaks all
   * {@link module:engine/view/attributeelement~AttributeElement attribute elements} that are ancestors of a given `position`,
   * up to the first encountered {@link module:engine/view/containerelement~ContainerElement container element}.
   * `breakContainer()` assumes that the given `position` is directly in the container element and breaks that container element.
   *
   * @see module:engine/view/attributeelement~AttributeElement
   * @see module:engine/view/containerelement~ContainerElement
   * @see module:engine/view/downcastwriter~DowncastWriter#breakAttributes
   * @param position The position where to break the element.
   * @returns The position between broken elements. If an element has not been broken,
   * the returned position is placed either before or after it.
   */
  breakContainer(e) {
    const t = e.parent;
    if (!t.is("containerElement"))
      throw new B("view-writer-break-non-container-element", this.document);
    if (!t.parent)
      throw new B("view-writer-break-root", this.document);
    if (e.isAtStart)
      return _e._createBefore(t);
    if (!e.isAtEnd) {
      const n = t._clone(!1);
      this.insert(_e._createAfter(t), n);
      const r = new We(e, _e._createAt(t, "end")), s = new _e(n, 0);
      this.move(r, s);
    }
    return _e._createAfter(t);
  }
  /**
   * Merges {@link module:engine/view/attributeelement~AttributeElement attribute elements}. It also merges text nodes if needed.
   * Only {@link module:engine/view/attributeelement~AttributeElement#isSimilar similar} attribute elements can be merged.
   *
   * In following examples `<p>` is a container and `<b>` is an attribute element:
   *
   * ```html
   * <p>foo[]bar</p> -> <p>foo{}bar</p>
   * <p><b>foo</b>[]<b>bar</b></p> -> <p><b>foo{}bar</b></p>
   * <p><b foo="bar">a</b>[]<b foo="baz">b</b></p> -> <p><b foo="bar">a</b>[]<b foo="baz">b</b></p>
   * ```
   *
   * It will also take care about empty attributes when merging:
   *
   * ```html
   * <p><b>[]</b></p> -> <p>[]</p>
   * <p><b>foo</b><i>[]</i><b>bar</b></p> -> <p><b>foo{}bar</b></p>
   * ```
   *
   * **Note:** Difference between {@link module:engine/view/downcastwriter~DowncastWriter#mergeAttributes mergeAttributes} and
   * {@link module:engine/view/downcastwriter~DowncastWriter#mergeContainers mergeContainers} is that `mergeAttributes` merges two
   * {@link module:engine/view/attributeelement~AttributeElement attribute elements} or {@link module:engine/view/text~Text text nodes}
   * while `mergeContainer` merges two {@link module:engine/view/containerelement~ContainerElement container elements}.
   *
   * @see module:engine/view/attributeelement~AttributeElement
   * @see module:engine/view/containerelement~ContainerElement
   * @see module:engine/view/downcastwriter~DowncastWriter#mergeContainers
   * @param position Merge position.
   * @returns Position after merge.
   */
  mergeAttributes(e) {
    const t = e.offset, n = e.parent;
    if (n.is("$text"))
      return e;
    if (n.is("attributeElement") && n.childCount === 0) {
      const o = n.parent, l = n.index;
      return n._remove(), this._removeFromClonedElementsGroup(n), this.mergeAttributes(new _e(o, l));
    }
    const r = n.getChild(t - 1), s = n.getChild(t);
    if (!r || !s)
      return e;
    if (r.is("$text") && s.is("$text"))
      return Yw(r, s);
    if (r.is("attributeElement") && s.is("attributeElement") && r.isSimilar(s)) {
      const o = r.childCount;
      return r._appendChild(s.getChildren()), s._remove(), this._removeFromClonedElementsGroup(s), this.mergeAttributes(new _e(r, o));
    }
    return e;
  }
  /**
   * Merges two {@link module:engine/view/containerelement~ContainerElement container elements} that are before and after given position.
   * Precisely, the element after the position is removed and it's contents are moved to element before the position.
   *
   * ```html
   * <p>foo</p>^<p>bar</p> -> <p>foo^bar</p>
   * <div>foo</div>^<p>bar</p> -> <div>foo^bar</div>
   * ```
   *
   * **Note:** Difference between {@link module:engine/view/downcastwriter~DowncastWriter#mergeAttributes mergeAttributes} and
   * {@link module:engine/view/downcastwriter~DowncastWriter#mergeContainers mergeContainers} is that `mergeAttributes` merges two
   * {@link module:engine/view/attributeelement~AttributeElement attribute elements} or {@link module:engine/view/text~Text text nodes}
   * while `mergeContainer` merges two {@link module:engine/view/containerelement~ContainerElement container elements}.
   *
   * @see module:engine/view/attributeelement~AttributeElement
   * @see module:engine/view/containerelement~ContainerElement
   * @see module:engine/view/downcastwriter~DowncastWriter#mergeAttributes
   * @param position Merge position.
   * @returns Position after merge.
   */
  mergeContainers(e) {
    const t = e.nodeBefore, n = e.nodeAfter;
    if (!t || !n || !t.is("containerElement") || !n.is("containerElement"))
      throw new B("view-writer-merge-containers-invalid-position", this.document);
    const r = t.getChild(t.childCount - 1), s = r instanceof Bt ? _e._createAt(r, "end") : _e._createAt(t, "end");
    return this.move(We._createIn(n), _e._createAt(t, "end")), this.remove(We._createOn(n)), s;
  }
  /**
   * Inserts a node or nodes at specified position. Takes care about breaking attributes before insertion
   * and merging them afterwards.
   *
   * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-insert-invalid-node` when nodes to insert
   * contains instances that are not {@link module:engine/view/text~Text Texts},
   * {@link module:engine/view/attributeelement~AttributeElement AttributeElements},
   * {@link module:engine/view/containerelement~ContainerElement ContainerElements},
   * {@link module:engine/view/emptyelement~EmptyElement EmptyElements},
   * {@link module:engine/view/rawelement~RawElement RawElements} or
   * {@link module:engine/view/uielement~UIElement UIElements}.
   *
   * @param position Insertion position.
   * @param nodes Node or nodes to insert.
   * @returns Range around inserted nodes.
   */
  insert(e, t) {
    t = di(t) ? [...t] : [t], LE(t, this.document);
    const n = t.reduce((o, l) => {
      const u = o[o.length - 1], h = !l.is("uiElement");
      return !u || u.breakAttributes != h ? o.push({
        breakAttributes: h,
        nodes: [l]
      }) : u.nodes.push(l), o;
    }, []);
    let r = null, s = e;
    for (const { nodes: o, breakAttributes: l } of n) {
      const u = this._insertNodes(s, o, l);
      r || (r = u.start), s = u.end;
    }
    return r ? new We(r, s) : new We(e);
  }
  /**
   * Removes provided range from the container.
   *
   * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-invalid-range-container` when
   * {@link module:engine/view/range~Range#start start} and {@link module:engine/view/range~Range#end end} positions are not placed inside
   * same parent container.
   *
   * @param rangeOrItem Range to remove from container
   * or an {@link module:engine/view/item~Item item} to remove. If range is provided, after removing, it will be updated
   * to a collapsed range showing the new position.
   * @returns Document fragment containing removed nodes.
   */
  remove(e) {
    const t = e instanceof We ? e : We._createOn(e);
    if (Ya(t, this.document), t.isCollapsed)
      return new Ns(this.document);
    const { start: n, end: r } = this._breakAttributesRange(t, !0), s = n.parent, o = r.offset - n.offset, l = s._removeChildren(n.offset, o);
    for (const h of l)
      this._removeFromClonedElementsGroup(h);
    const u = this.mergeAttributes(n);
    return t.start = u, t.end = u.clone(), new Ns(this.document, l);
  }
  /**
   * Removes matching elements from given range.
   *
   * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-invalid-range-container` when
   * {@link module:engine/view/range~Range#start start} and {@link module:engine/view/range~Range#end end} positions are not placed inside
   * same parent container.
   *
   * @param range Range to clear.
   * @param element Element to remove.
   */
  clear(e, t) {
    Ya(e, this.document);
    const n = e.getWalker({
      direction: "backward",
      ignoreElementEnd: !0
    });
    for (const r of n) {
      const s = r.item;
      let o;
      if (s.is("element") && t.isSimilar(s))
        o = We._createOn(s);
      else if (!r.nextPosition.isAfter(e.start) && s.is("$textProxy")) {
        const l = s.getAncestors().find((u) => u.is("element") && t.isSimilar(u));
        l && (o = We._createIn(l));
      }
      o && (o.end.isAfter(e.end) && (o.end = e.end), o.start.isBefore(e.start) && (o.start = e.start), this.remove(o));
    }
  }
  /**
   * Moves nodes from provided range to target position.
   *
   * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-invalid-range-container` when
   * {@link module:engine/view/range~Range#start start} and {@link module:engine/view/range~Range#end end} positions are not placed inside
   * same parent container.
   *
   * @param sourceRange Range containing nodes to move.
   * @param targetPosition Position to insert.
   * @returns Range in target container. Inserted nodes are placed between
   * {@link module:engine/view/range~Range#start start} and {@link module:engine/view/range~Range#end end} positions.
   */
  move(e, t) {
    let n;
    if (t.isAfter(e.end)) {
      t = this._breakAttributes(t, !0);
      const r = t.parent, s = r.childCount;
      e = this._breakAttributesRange(e, !0), n = this.remove(e), t.offset += r.childCount - s;
    } else
      n = this.remove(e);
    return this.insert(t, n);
  }
  /**
   * Wraps elements within range with provided {@link module:engine/view/attributeelement~AttributeElement AttributeElement}.
   * If a collapsed range is provided, it will be wrapped only if it is equal to view selection.
   *
   * If a collapsed range was passed and is same as selection, the selection
   * will be moved to the inside of the wrapped attribute element.
   *
   * Throws {@link module:utils/ckeditorerror~CKEditorError} `view-writer-invalid-range-container`
   * when {@link module:engine/view/range~Range#start}
   * and {@link module:engine/view/range~Range#end} positions are not placed inside same parent container.
   *
   * Throws {@link module:utils/ckeditorerror~CKEditorError} `view-writer-wrap-invalid-attribute` when passed attribute element is not
   * an instance of {@link module:engine/view/attributeelement~AttributeElement AttributeElement}.
   *
   * Throws {@link module:utils/ckeditorerror~CKEditorError} `view-writer-wrap-nonselection-collapsed-range` when passed range
   * is collapsed and different than view selection.
   *
   * @param range Range to wrap.
   * @param attribute Attribute element to use as wrapper.
   * @returns range Range after wrapping, spanning over wrapping attribute element.
   */
  wrap(e, t) {
    if (!(t instanceof Ms))
      throw new B("view-writer-wrap-invalid-attribute", this.document);
    if (Ya(e, this.document), e.isCollapsed) {
      let n = e.start;
      n.parent.is("element") && !bV(n.parent) && (n = n.getLastMatchingPosition((s) => s.item.is("uiElement"))), n = this._wrapPosition(n, t);
      const r = this.document.selection;
      return r.isCollapsed && r.getFirstPosition().isEqual(e.start) && this.setSelection(n), new We(n);
    } else
      return this._wrapRange(e, t);
  }
  /**
   * Unwraps nodes within provided range from attribute element.
   *
   * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-invalid-range-container` when
   * {@link module:engine/view/range~Range#start start} and {@link module:engine/view/range~Range#end end} positions are not placed inside
   * same parent container.
   */
  unwrap(e, t) {
    if (!(t instanceof Ms))
      throw new B("view-writer-unwrap-invalid-attribute", this.document);
    if (Ya(e, this.document), e.isCollapsed)
      return e;
    const { start: n, end: r } = this._breakAttributesRange(e, !0), s = n.parent, o = this._unwrapChildren(s, n.offset, r.offset, t), l = this.mergeAttributes(o.start);
    l.isEqual(o.start) || o.end.offset--;
    const u = this.mergeAttributes(o.end);
    return new We(l, u);
  }
  /**
   * Renames element by creating a copy of renamed element but with changed name and then moving contents of the
   * old element to the new one. Keep in mind that this will invalidate all {@link module:engine/view/position~Position positions} which
   * has renamed element as {@link module:engine/view/position~Position#parent a parent}.
   *
   * New element has to be created because `Element#tagName` property in DOM is readonly.
   *
   * Since this function creates a new element and removes the given one, the new element is returned to keep reference.
   *
   * @param newName New name for element.
   * @param viewElement Element to be renamed.
   * @returns Element created due to rename.
   */
  rename(e, t) {
    const n = new yl(this.document, e, t.getAttributes());
    return this.insert(_e._createAfter(t), n), this.move(We._createIn(t), _e._createAt(n, 0)), this.remove(We._createOn(t)), n;
  }
  /**
   * Cleans up memory by removing obsolete cloned elements group from the writer.
   *
   * Should be used whenever all {@link module:engine/view/attributeelement~AttributeElement attribute elements}
   * with the same {@link module:engine/view/attributeelement~AttributeElement#id id} are going to be removed from the view and
   * the group will no longer be needed.
   *
   * Cloned elements group are not removed automatically in case if the group is still needed after all its elements
   * were removed from the view.
   *
   * Keep in mind that group names are equal to the `id` property of the attribute element.
   *
   * @param groupName Name of the group to clear.
   */
  clearClonedElementsGroup(e) {
    this._cloneGroups.delete(e);
  }
  /**
   * Creates position at the given location. The location can be specified as:
   *
   * * a {@link module:engine/view/position~Position position},
   * * parent element and offset (offset defaults to `0`),
   * * parent element and `'end'` (sets position at the end of that element),
   * * {@link module:engine/view/item~Item view item} and `'before'` or `'after'` (sets position before or after given view item).
   *
   * This method is a shortcut to other constructors such as:
   *
   * * {@link #createPositionBefore},
   * * {@link #createPositionAfter},
   *
   * @param offset Offset or one of the flags. Used only when the first parameter is a {@link module:engine/view/item~Item view item}.
   */
  createPositionAt(e, t) {
    return _e._createAt(e, t);
  }
  /**
   * Creates a new position after given view item.
   *
   * @param item View item after which the position should be located.
   */
  createPositionAfter(e) {
    return _e._createAfter(e);
  }
  /**
   * Creates a new position before given view item.
   *
   * @param item View item before which the position should be located.
   */
  createPositionBefore(e) {
    return _e._createBefore(e);
  }
  /**
   * Creates a range spanning from `start` position to `end` position.
   *
   * **Note:** This factory method creates its own {@link module:engine/view/position~Position} instances basing on passed values.
   *
   * @param start Start position.
   * @param end End position. If not set, range will be collapsed at `start` position.
   */
  createRange(e, t) {
    return new We(e, t);
  }
  /**
   * Creates a range that starts before given {@link module:engine/view/item~Item view item} and ends after it.
   */
  createRangeOn(e) {
    return We._createOn(e);
  }
  /**
   * Creates a range inside an {@link module:engine/view/element~Element element} which starts before the first child of
   * that element and ends after the last child of that element.
   *
   * @param element Element which is a parent for the range.
   */
  createRangeIn(e) {
    return We._createIn(e);
  }
  createSelection(...e) {
    return new is(...e);
  }
  /**
   * Creates placeholders for child elements of the {@link module:engine/conversion/downcasthelpers~DowncastHelpers#elementToStructure
   * `elementToStructure()`} conversion helper.
   *
   * ```ts
   * const viewSlot = conversionApi.writer.createSlot();
   * const viewPosition = conversionApi.writer.createPositionAt( viewElement, 0 );
   *
   * conversionApi.writer.insert( viewPosition, viewSlot );
   * ```
   *
   * It could be filtered down to a specific subset of children (only `<foo>` model elements in this case):
   *
   * ```ts
   * const viewSlot = conversionApi.writer.createSlot( node => node.is( 'element', 'foo' ) );
   * const viewPosition = conversionApi.writer.createPositionAt( viewElement, 0 );
   *
   * conversionApi.writer.insert( viewPosition, viewSlot );
   * ```
   *
   * While providing a filtered slot, make sure to provide slots for all child nodes. A single node can not be downcasted into
   * multiple slots.
   *
   * **Note**: You should not change the order of nodes. View elements should be in the same order as model nodes.
   *
   * @param modeOrFilter The filter for child nodes.
   * @returns The slot element to be placed in to the view structure while processing
   * {@link module:engine/conversion/downcasthelpers~DowncastHelpers#elementToStructure `elementToStructure()`}.
   */
  createSlot(e = "children") {
    if (!this._slotFactory)
      throw new B("view-writer-invalid-create-slot-context", this.document);
    return this._slotFactory(this, e);
  }
  /**
   * Registers a slot factory.
   *
   * @internal
   * @param slotFactory The slot factory.
   */
  _registerSlotFactory(e) {
    this._slotFactory = e;
  }
  /**
   * Clears the registered slot factory.
   *
   * @internal
   */
  _clearSlotFactory() {
    this._slotFactory = null;
  }
  /**
   * Inserts a node or nodes at the specified position. Takes care of breaking attributes before insertion
   * and merging them afterwards if requested by the breakAttributes param.
   *
   * @param position Insertion position.
   * @param nodes Node or nodes to insert.
   * @param breakAttributes Whether attributes should be broken.
   * @returns Range around inserted nodes.
   */
  _insertNodes(e, t, n) {
    let r;
    if (n ? r = dg(e) : r = e.parent.is("$text") ? e.parent.parent : e.parent, !r)
      throw new B("view-writer-invalid-position-container", this.document);
    let s;
    n ? s = this._breakAttributes(e, !0) : s = e.parent.is("$text") ? Em(e) : e;
    const o = r._insertChild(s.offset, t);
    for (const f of t)
      this._addToClonedElementsGroup(f);
    const l = s.getShiftedBy(o), u = this.mergeAttributes(s);
    u.isEqual(s) || l.offset--;
    const h = this.mergeAttributes(l);
    return new We(u, h);
  }
  /**
   * Wraps children with provided `wrapElement`. Only children contained in `parent` element between
   * `startOffset` and `endOffset` will be wrapped.
   */
  _wrapChildren(e, t, n, r) {
    let s = t;
    const o = [];
    for (; s < n; ) {
      const u = e.getChild(s), h = u.is("$text"), f = u.is("attributeElement");
      if (f && this._wrapAttributeElement(r, u))
        o.push(new _e(e, s));
      else if (h || !f || yV(r, u)) {
        const m = r._clone();
        u._remove(), m._appendChild(u), e._insertChild(s, m), this._addToClonedElementsGroup(m), o.push(new _e(e, s));
      } else
        this._wrapChildren(u, 0, u.childCount, r);
      s++;
    }
    let l = 0;
    for (const u of o) {
      if (u.offset -= l, u.offset == t)
        continue;
      this.mergeAttributes(u).isEqual(u) || (l++, n--);
    }
    return We._createFromParentsAndOffsets(e, t, e, n);
  }
  /**
   * Unwraps children from provided `unwrapElement`. Only children contained in `parent` element between
   * `startOffset` and `endOffset` will be unwrapped.
   */
  _unwrapChildren(e, t, n, r) {
    let s = t;
    const o = [];
    for (; s < n; ) {
      const u = e.getChild(s);
      if (!u.is("attributeElement")) {
        s++;
        continue;
      }
      if (u.isSimilar(r)) {
        const h = u.getChildren(), f = u.childCount;
        u._remove(), e._insertChild(s, h), this._removeFromClonedElementsGroup(u), o.push(new _e(e, s), new _e(e, s + f)), s += f, n += f - 1;
        continue;
      }
      if (this._unwrapAttributeElement(r, u)) {
        o.push(new _e(e, s), new _e(e, s + 1)), s++;
        continue;
      }
      this._unwrapChildren(u, 0, u.childCount, r), s++;
    }
    let l = 0;
    for (const u of o) {
      if (u.offset -= l, u.offset == t || u.offset == n)
        continue;
      this.mergeAttributes(u).isEqual(u) || (l++, n--);
    }
    return We._createFromParentsAndOffsets(e, t, e, n);
  }
  /**
   * Helper function for `view.writer.wrap`. Wraps range with provided attribute element.
   * This method will also merge newly added attribute element with its siblings whenever possible.
   *
   * Throws {@link module:utils/ckeditorerror~CKEditorError} `view-writer-wrap-invalid-attribute` when passed attribute element is not
   * an instance of {@link module:engine/view/attributeelement~AttributeElement AttributeElement}.
   *
   * @returns New range after wrapping, spanning over wrapping attribute element.
   */
  _wrapRange(e, t) {
    const { start: n, end: r } = this._breakAttributesRange(e, !0), s = n.parent, o = this._wrapChildren(s, n.offset, r.offset, t), l = this.mergeAttributes(o.start);
    l.isEqual(o.start) || o.end.offset--;
    const u = this.mergeAttributes(o.end);
    return new We(l, u);
  }
  /**
   * Helper function for {@link #wrap}. Wraps position with provided attribute element.
   * This method will also merge newly added attribute element with its siblings whenever possible.
   *
   * Throws {@link module:utils/ckeditorerror~CKEditorError} `view-writer-wrap-invalid-attribute` when passed attribute element is not
   * an instance of {@link module:engine/view/attributeelement~AttributeElement AttributeElement}.
   *
   * @returns New position after wrapping.
   */
  _wrapPosition(e, t) {
    if (t.isSimilar(e.parent))
      return Gw(e.clone());
    e.parent.is("$text") && (e = Em(e));
    const n = this.createAttributeElement("_wrapPosition-fake-element");
    n._priority = Number.POSITIVE_INFINITY, n.isSimilar = () => !1, e.parent._insertChild(e.offset, n);
    const r = new We(e, e.getShiftedBy(1));
    this.wrap(r, t);
    const s = new _e(n.parent, n.index);
    n._remove();
    const o = s.nodeBefore, l = s.nodeAfter;
    return o instanceof Bt && l instanceof Bt ? Yw(o, l) : Gw(s);
  }
  /**
   * Wraps one {@link module:engine/view/attributeelement~AttributeElement AttributeElement} into another by
   * merging them if possible. When merging is possible - all attributes, styles and classes are moved from wrapper
   * element to element being wrapped.
   *
   * @param wrapper Wrapper AttributeElement.
   * @param toWrap AttributeElement to wrap using wrapper element.
   * @returns Returns `true` if elements are merged.
   */
  _wrapAttributeElement(e, t) {
    if (!Jw(e, t) || e.name !== t.name || e.priority !== t.priority)
      return !1;
    for (const n of e.getAttributeKeys())
      if (!(n === "class" || n === "style") && t.hasAttribute(n) && t.getAttribute(n) !== e.getAttribute(n))
        return !1;
    for (const n of e.getStyleNames())
      if (t.hasStyle(n) && t.getStyle(n) !== e.getStyle(n))
        return !1;
    for (const n of e.getAttributeKeys())
      n === "class" || n === "style" || t.hasAttribute(n) || this.setAttribute(n, e.getAttribute(n), t);
    for (const n of e.getStyleNames())
      t.hasStyle(n) || this.setStyle(n, e.getStyle(n), t);
    for (const n of e.getClassNames())
      t.hasClass(n) || this.addClass(n, t);
    return !0;
  }
  /**
   * Unwraps {@link module:engine/view/attributeelement~AttributeElement AttributeElement} from another by removing
   * corresponding attributes, classes and styles. All attributes, classes and styles from wrapper should be present
   * inside element being unwrapped.
   *
   * @param wrapper Wrapper AttributeElement.
   * @param toUnwrap AttributeElement to unwrap using wrapper element.
   * @returns Returns `true` if elements are unwrapped.
   **/
  _unwrapAttributeElement(e, t) {
    if (!Jw(e, t) || e.name !== t.name || e.priority !== t.priority)
      return !1;
    for (const n of e.getAttributeKeys())
      if (!(n === "class" || n === "style") && (!t.hasAttribute(n) || t.getAttribute(n) !== e.getAttribute(n)))
        return !1;
    if (!t.hasClass(...e.getClassNames()))
      return !1;
    for (const n of e.getStyleNames())
      if (!t.hasStyle(n) || t.getStyle(n) !== e.getStyle(n))
        return !1;
    for (const n of e.getAttributeKeys())
      n === "class" || n === "style" || this.removeAttribute(n, t);
    return this.removeClass(Array.from(e.getClassNames()), t), this.removeStyle(Array.from(e.getStyleNames()), t), !0;
  }
  /**
   * Helper function used by other `DowncastWriter` methods. Breaks attribute elements at the boundaries of given range.
   *
   * @param range Range which `start` and `end` positions will be used to break attributes.
   * @param forceSplitText If set to `true`, will break text nodes even if they are directly in container element.
   * This behavior will result in incorrect view state, but is needed by other view writing methods which then fixes view state.
   * @returns New range with located at break positions.
   */
  _breakAttributesRange(e, t = !1) {
    const n = e.start, r = e.end;
    if (Ya(e, this.document), e.isCollapsed) {
      const u = this._breakAttributes(e.start, t);
      return new We(u, u);
    }
    const s = this._breakAttributes(r, t), o = s.parent.childCount, l = this._breakAttributes(n, t);
    return s.offset += s.parent.childCount - o, new We(l, s);
  }
  /**
   * Helper function used by other `DowncastWriter` methods. Breaks attribute elements at given position.
   *
   * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-cannot-break-empty-element` when break position
   * is placed inside {@link module:engine/view/emptyelement~EmptyElement EmptyElement}.
   *
   * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-cannot-break-ui-element` when break position
   * is placed inside {@link module:engine/view/uielement~UIElement UIElement}.
   *
   * @param position Position where to break attributes.
   * @param forceSplitText If set to `true`, will break text nodes even if they are directly in container element.
   * This behavior will result in incorrect view state, but is needed by other view writing methods which then fixes view state.
   * @returns New position after breaking the attributes.
   */
  _breakAttributes(e, t = !1) {
    const n = e.offset, r = e.parent;
    if (e.parent.is("emptyElement"))
      throw new B("view-writer-cannot-break-empty-element", this.document);
    if (e.parent.is("uiElement"))
      throw new B("view-writer-cannot-break-ui-element", this.document);
    if (e.parent.is("rawElement"))
      throw new B("view-writer-cannot-break-raw-element", this.document);
    if (!t && r.is("$text") && hg(r.parent) || hg(r))
      return e.clone();
    if (r.is("$text"))
      return this._breakAttributes(Em(e), t);
    const s = r.childCount;
    if (n == s) {
      const o = new _e(r.parent, r.index + 1);
      return this._breakAttributes(o, t);
    } else if (n === 0) {
      const o = new _e(r.parent, r.index);
      return this._breakAttributes(o, t);
    } else {
      const o = r.index + 1, l = r._clone();
      r.parent._insertChild(o, l), this._addToClonedElementsGroup(l);
      const u = r.childCount - n, h = r._removeChildren(n, u);
      l._appendChild(h);
      const f = new _e(r.parent, o);
      return this._breakAttributes(f, t);
    }
  }
  /**
   * Stores the information that an {@link module:engine/view/attributeelement~AttributeElement attribute element} was
   * added to the tree. Saves the reference to the group in the given element and updates the group, so other elements
   * from the group now keep a reference to the given attribute element.
   *
   * The clones group can be obtained using {@link module:engine/view/attributeelement~AttributeElement#getElementsWithSameId}.
   *
   * Does nothing if added element has no {@link module:engine/view/attributeelement~AttributeElement#id id}.
   *
   * @param element Attribute element to save.
   */
  _addToClonedElementsGroup(e) {
    if (!e.root.is("rootElement"))
      return;
    if (e.is("element"))
      for (const r of e.getChildren())
        this._addToClonedElementsGroup(r);
    const t = e.id;
    if (!t)
      return;
    let n = this._cloneGroups.get(t);
    n || (n = /* @__PURE__ */ new Set(), this._cloneGroups.set(t, n)), n.add(e), e._clonesGroup = n;
  }
  /**
   * Removes all the information about the given {@link module:engine/view/attributeelement~AttributeElement attribute element}
   * from its clones group.
   *
   * Keep in mind, that the element will still keep a reference to the group (but the group will not keep a reference to it).
   * This allows to reference the whole group even if the element was already removed from the tree.
   *
   * Does nothing if the element has no {@link module:engine/view/attributeelement~AttributeElement#id id}.
   *
   * @param element Attribute element to remove.
   */
  _removeFromClonedElementsGroup(e) {
    if (e.is("element"))
      for (const r of e.getChildren())
        this._removeFromClonedElementsGroup(r);
    const t = e.id;
    if (!t)
      return;
    const n = this._cloneGroups.get(t);
    n && n.delete(e);
  }
}
function bV(i) {
  return Array.from(i.getChildren()).some((e) => !e.is("uiElement"));
}
function dg(i) {
  let e = i.parent;
  for (; !hg(e); ) {
    if (!e)
      return;
    e = e.parent;
  }
  return e;
}
function yV(i, e) {
  return i.priority < e.priority ? !0 : i.priority > e.priority ? !1 : i.getIdentity() < e.getIdentity();
}
function Gw(i) {
  const e = i.nodeBefore;
  if (e && e.is("$text"))
    return new _e(e, e.data.length);
  const t = i.nodeAfter;
  return t && t.is("$text") ? new _e(t, 0) : i;
}
function Em(i) {
  if (i.offset == i.parent.data.length)
    return new _e(i.parent.parent, i.parent.index + 1);
  if (i.offset === 0)
    return new _e(i.parent.parent, i.parent.index);
  const e = i.parent.data.slice(i.offset);
  return i.parent._data = i.parent.data.slice(0, i.offset), i.parent.parent._insertChild(i.parent.index + 1, new Bt(i.root.document, e)), new _e(i.parent.parent, i.parent.index + 1);
}
function Yw(i, e) {
  const t = i.data.length;
  return i._data += e.data, e._remove(), new _e(i, t);
}
const EV = [Bt, Ms, yl, lp, cp, ch];
function LE(i, e) {
  for (const t of i) {
    if (!EV.some((n) => t instanceof n))
      throw new B("view-writer-insert-invalid-node-type", e);
    t.is("$text") || LE(t.getChildren(), e);
  }
}
function hg(i) {
  return i && (i.is("containerElement") || i.is("documentFragment"));
}
function Ya(i, e) {
  const t = dg(i.start), n = dg(i.end);
  if (!t || !n || t !== n)
    throw new B("view-writer-invalid-range-container", e);
}
function Jw(i, e) {
  return i.id === null && e.id === null;
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const FE = (i) => i.createTextNode(" "), $E = (i) => {
  const e = i.createElement("span");
  return e.dataset.ckeFiller = "true", e.innerText = " ", e;
}, zE = (i) => {
  const e = i.createElement("br");
  return e.dataset.ckeFiller = "true", e;
}, nr = 7, Ad = "⁠".repeat(nr);
function li(i) {
  return qt(i) && i.data.substr(0, nr) === Ad;
}
function rl(i) {
  return i.data.length == nr && li(i);
}
function Xw(i) {
  return li(i) ? i.data.slice(nr) : i.data;
}
function CV(i) {
  i.document.on("arrowKey", SV, { priority: "low" });
}
function SV(i, e) {
  if (e.keyCode == tt.arrowleft) {
    const t = e.domTarget.ownerDocument.defaultView.getSelection();
    if (t.rangeCount == 1 && t.getRangeAt(0).collapsed) {
      const n = t.getRangeAt(0).startContainer, r = t.getRangeAt(0).startOffset;
      li(n) && r <= nr && t.collapse(n, 0);
    }
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class TV extends Nt() {
  /**
   * Creates a renderer instance.
   *
   * @param domConverter Converter instance.
   * @param selection View selection.
   */
  constructor(e, t) {
    super(), this.domDocuments = /* @__PURE__ */ new Set(), this.markedAttributes = /* @__PURE__ */ new Set(), this.markedChildren = /* @__PURE__ */ new Set(), this.markedTexts = /* @__PURE__ */ new Set(), this._inlineFiller = null, this._fakeSelectionContainer = null, this.domConverter = e, this.selection = t, this.set("isFocused", !1), this.set("isSelecting", !1), qe.isBlink && !qe.isAndroid && this.on("change:isSelecting", () => {
      this.isSelecting || this.render();
    }), this.set("isComposing", !1), this.on("change:isComposing", () => {
      this.isComposing || this.render();
    });
  }
  /**
   * Marks a view node to be updated in the DOM by {@link #render `render()`}.
   *
   * Note that only view nodes whose parents have corresponding DOM elements need to be marked to be synchronized.
   *
   * @see #markedAttributes
   * @see #markedChildren
   * @see #markedTexts
   *
   * @param type Type of the change.
   * @param node ViewNode to be marked.
   */
  markToSync(e, t) {
    if (e === "text")
      this.domConverter.mapViewToDom(t.parent) && this.markedTexts.add(t);
    else {
      if (!this.domConverter.mapViewToDom(t))
        return;
      if (e === "attributes")
        this.markedAttributes.add(t);
      else if (e === "children")
        this.markedChildren.add(t);
      else
        throw new B("view-renderer-unknown-type", this);
    }
  }
  /**
   * Renders all buffered changes ({@link #markedAttributes}, {@link #markedChildren} and {@link #markedTexts}) and
   * the current view selection (if needed) to the DOM by applying a minimal set of changes to it.
   *
   * Renderer tries not to break the text composition (e.g. IME) and x-index of the selection,
   * so it does as little as it is needed to update the DOM.
   *
   * Renderer also handles {@link module:engine/view/filler fillers}. Especially, it checks if the inline filler is needed
   * at the selection position and adds or removes it. To prevent breaking text composition inline filler will not be
   * removed as long as the selection is in the text node which needed it at first.
   */
  render() {
    if (this.isComposing && !qe.isAndroid)
      return;
    let e = null;
    const t = qe.isBlink && !qe.isAndroid ? !this.isSelecting : !0;
    for (const n of this.markedChildren)
      this._updateChildrenMappings(n);
    t ? (this._inlineFiller && !this._isSelectionInInlineFiller() && this._removeInlineFiller(), this._inlineFiller ? e = this._getInlineFillerPosition() : this._needsInlineFillerAtSelection() && (e = this.selection.getFirstPosition(), this.markedChildren.add(e.parent))) : this._inlineFiller && this._inlineFiller.parentNode && (e = this.domConverter.domPositionToView(this._inlineFiller), e && e.parent.is("$text") && (e = _e._createBefore(e.parent)));
    for (const n of this.markedAttributes)
      this._updateAttrs(n);
    for (const n of this.markedChildren)
      this._updateChildren(n, { inlineFillerPosition: e });
    for (const n of this.markedTexts)
      !this.markedChildren.has(n.parent) && this.domConverter.mapViewToDom(n.parent) && this._updateText(n, { inlineFillerPosition: e });
    if (t)
      if (e) {
        const n = this.domConverter.viewPositionToDom(e), r = n.parent.ownerDocument;
        li(n.parent) ? this._inlineFiller = n.parent : this._inlineFiller = Zw(r, n.parent, n.offset);
      } else
        this._inlineFiller = null;
    this._updateFocus(), this._updateSelection(), this.markedTexts.clear(), this.markedAttributes.clear(), this.markedChildren.clear();
  }
  /**
   * Updates mappings of view element's children.
   *
   * Children that were replaced in the view structure by similar elements (same tag name) are treated as 'replaced'.
   * This means that their mappings can be updated so the new view elements are mapped to the existing DOM elements.
   * Thanks to that these elements do not need to be re-rendered completely.
   *
   * @param viewElement The view element whose children mappings will be updated.
   */
  _updateChildrenMappings(e) {
    if (!this.domConverter.mapViewToDom(e))
      return;
    const n = Array.from(this.domConverter.mapViewToDom(e).childNodes), r = Array.from(this.domConverter.viewChildrenToDom(e, { withChildren: !1 })), s = this._diffNodeLists(n, r), o = this._findUpdateActions(s, n, r, kV);
    if (o.indexOf("update") !== -1) {
      const l = { equal: 0, insert: 0, delete: 0 };
      for (const u of o)
        if (u === "update") {
          const h = l.equal + l.insert, f = l.equal + l.delete, m = e.getChild(h);
          m && !(m.is("uiElement") || m.is("rawElement")) && this._updateElementMappings(m, n[f]), Vw(r[h]), l.equal++;
        } else
          l[u]++;
    }
  }
  /**
   * Updates mappings of a given view element.
   *
   * @param viewElement The view element whose mappings will be updated.
   * @param domElement The DOM element representing the given view element.
   */
  _updateElementMappings(e, t) {
    this.domConverter.unbindDomElement(t), this.domConverter.bindElements(t, e), this.markedChildren.add(e), this.markedAttributes.add(e);
  }
  /**
   * Gets the position of the inline filler based on the current selection.
   * Here, we assume that we know that the filler is needed and
   * {@link #_isSelectionInInlineFiller is at the selection position}, and, since it is needed,
   * it is somewhere at the selection position.
   *
   * Note: The filler position cannot be restored based on the filler's DOM text node, because
   * when this method is called (before rendering), the bindings will often be broken. View-to-DOM
   * bindings are only dependable after rendering.
   */
  _getInlineFillerPosition() {
    const e = this.selection.getFirstPosition();
    return e.parent.is("$text") ? _e._createBefore(e.parent) : e;
  }
  /**
   * Returns `true` if the selection has not left the inline filler's text node.
   * If it is `true`, it means that the filler had been added for a reason and the selection did not
   * leave the filler's text node. For example, the user can be in the middle of a composition so it should not be touched.
   *
   * @returns `true` if the inline filler and selection are in the same place.
   */
  _isSelectionInInlineFiller() {
    if (this.selection.rangeCount != 1 || !this.selection.isCollapsed)
      return !1;
    const e = this.selection.getFirstPosition(), t = this.domConverter.viewPositionToDom(e);
    return !!(t && qt(t.parent) && li(t.parent));
  }
  /**
   * Removes the inline filler.
   */
  _removeInlineFiller() {
    const e = this._inlineFiller;
    if (!li(e))
      throw new B("view-renderer-filler-was-lost", this);
    rl(e) ? e.remove() : e.data = e.data.substr(nr), this._inlineFiller = null;
  }
  /**
   * Checks if the inline {@link module:engine/view/filler filler} should be added.
   *
   * @returns `true` if the inline filler should be added.
   */
  _needsInlineFillerAtSelection() {
    if (this.selection.rangeCount != 1 || !this.selection.isCollapsed)
      return !1;
    const e = this.selection.getFirstPosition(), t = e.parent, n = e.offset;
    if (!this.domConverter.mapViewToDom(t.root) || !t.is("element") || !xV(t) || n === t.getFillerOffset())
      return !1;
    const r = e.nodeBefore, s = e.nodeAfter;
    return !(r instanceof Bt || s instanceof Bt || qe.isAndroid && (r || s));
  }
  /**
   * Checks if text needs to be updated and possibly updates it.
   *
   * @param viewText View text to update.
   * @param options.inlineFillerPosition The position where the inline filler should be rendered.
   */
  _updateText(e, t) {
    const n = this.domConverter.findCorrespondingDomText(e);
    let s = this.domConverter.viewToDom(e).data;
    const o = t.inlineFillerPosition;
    o && o.parent == e.parent && o.offset == e.index && (s = Ad + s), Qw(n, s);
  }
  /**
   * Checks if attribute list needs to be updated and possibly updates it.
   *
   * @param viewElement The view element to update.
   */
  _updateAttrs(e) {
    const t = this.domConverter.mapViewToDom(e);
    if (!t)
      return;
    const n = Array.from(t.attributes).map((s) => s.name), r = e.getAttributeKeys();
    for (const s of r)
      this.domConverter.setDomElementAttribute(t, s, e.getAttribute(s), e);
    for (const s of n)
      e.hasAttribute(s) || this.domConverter.removeDomElementAttribute(t, s);
  }
  /**
   * Checks if elements child list needs to be updated and possibly updates it.
   *
   * Note that on Android, to reduce the risk of composition breaks, it tries to update data of an existing
   * child text nodes instead of replacing them completely.
   *
   * @param viewElement View element to update.
   * @param options.inlineFillerPosition The position where the inline filler should be rendered.
   */
  _updateChildren(e, t) {
    const n = this.domConverter.mapViewToDom(e);
    if (!n)
      return;
    if (qe.isAndroid) {
      let m = null;
      for (const v of Array.from(n.childNodes)) {
        if (m && qt(m) && qt(v)) {
          n.normalize();
          break;
        }
        m = v;
      }
    }
    const r = t.inlineFillerPosition, s = n.childNodes, o = Array.from(this.domConverter.viewChildrenToDom(e, { bind: !0 }));
    r && r.parent === e && Zw(n.ownerDocument, o, r.offset);
    const l = this._diffNodeLists(s, o), u = this._findUpdateActions(l, s, o, AV);
    let h = 0;
    const f = /* @__PURE__ */ new Set();
    for (const m of u)
      m === "delete" ? (f.add(s[h]), Vw(s[h])) : (m === "equal" || m === "update") && h++;
    h = 0;
    for (const m of u)
      m === "insert" ? (bE(n, h, o[h]), h++) : m === "update" ? (Qw(s[h], o[h].data), h++) : m === "equal" && (this._markDescendantTextToSync(this.domConverter.domToView(o[h])), h++);
    for (const m of f)
      m.parentNode || this.domConverter.unbindDomElement(m);
  }
  /**
   * Shorthand for diffing two arrays or node lists of DOM nodes.
   *
   * @param actualDomChildren Actual DOM children
   * @param expectedDomChildren Expected DOM children.
   * @returns The list of actions based on the {@link module:utils/diff~diff} function.
   */
  _diffNodeLists(e, t) {
    return e = RV(e, this._fakeSelectionContainer), cl(e, t, PV.bind(null, this.domConverter));
  }
  /**
   * Finds DOM nodes that were replaced with the similar nodes (same tag name) in the view. All nodes are compared
   * within one `insert`/`delete` action group, for example:
   *
   * ```
   * Actual DOM:		<p><b>Foo</b>Bar<i>Baz</i><b>Bax</b></p>
   * Expected DOM:	<p>Bar<b>123</b><i>Baz</i><b>456</b></p>
   * Input actions:	[ insert, insert, delete, delete, equal, insert, delete ]
   * Output actions:	[ insert, replace, delete, equal, replace ]
   * ```
   *
   * @param actions Actions array which is a result of the {@link module:utils/diff~diff} function.
   * @param actualDom Actual DOM children
   * @param expectedDom Expected DOM children.
   * @param comparator A comparator function that should return `true` if the given node should be reused
   * (either by the update of a text node data or an element children list for similar elements).
   * @returns Actions array modified with the `update` actions.
   */
  _findUpdateActions(e, t, n, r) {
    if (e.indexOf("insert") === -1 || e.indexOf("delete") === -1)
      return e;
    let s = [], o = [], l = [];
    const u = { equal: 0, insert: 0, delete: 0 };
    for (const h of e)
      h === "insert" ? l.push(n[u.equal + u.insert]) : h === "delete" ? o.push(t[u.equal + u.delete]) : (s = s.concat(cl(o, l, r).map((f) => f === "equal" ? "update" : f)), s.push("equal"), o = [], l = []), u[h]++;
    return s.concat(cl(o, l, r).map((h) => h === "equal" ? "update" : h));
  }
  /**
   * Marks text nodes to be synchronized.
   *
   * If a text node is passed, it will be marked. If an element is passed, all descendant text nodes inside it will be marked.
   *
   * @param viewNode View node to sync.
   */
  _markDescendantTextToSync(e) {
    if (e) {
      if (e.is("$text"))
        this.markedTexts.add(e);
      else if (e.is("element"))
        for (const t of e.getChildren())
          this._markDescendantTextToSync(t);
    }
  }
  /**
   * Checks if the selection needs to be updated and possibly updates it.
   */
  _updateSelection() {
    if (qe.isBlink && !qe.isAndroid && this.isSelecting && !this.markedChildren.size)
      return;
    if (this.selection.rangeCount === 0) {
      this._removeDomSelection(), this._removeFakeSelection();
      return;
    }
    const e = this.domConverter.mapViewToDom(this.selection.editableElement);
    !this.isFocused || !e || (this.selection.isFake ? this._updateFakeSelection(e) : this._fakeSelectionContainer && this._fakeSelectionContainer.isConnected ? (this._removeFakeSelection(), this._updateDomSelection(e)) : this.isComposing && qe.isAndroid || this._updateDomSelection(e));
  }
  /**
   * Updates the fake selection.
   *
   * @param domRoot A valid DOM root where the fake selection container should be added.
   */
  _updateFakeSelection(e) {
    const t = e.ownerDocument;
    this._fakeSelectionContainer || (this._fakeSelectionContainer = OV(t));
    const n = this._fakeSelectionContainer;
    if (this.domConverter.bindFakeSelection(n, this.selection), !this._fakeSelectionNeedsUpdate(e))
      return;
    (!n.parentElement || n.parentElement != e) && e.appendChild(n), n.textContent = this.selection.fakeSelectionLabel || " ";
    const r = t.getSelection(), s = t.createRange();
    r.removeAllRanges(), s.selectNodeContents(n), r.addRange(s);
  }
  /**
   * Updates the DOM selection.
   *
   * @param domRoot A valid DOM root where the DOM selection should be rendered.
   */
  _updateDomSelection(e) {
    const t = e.ownerDocument.defaultView.getSelection();
    if (!this._domSelectionNeedsUpdate(t))
      return;
    const n = this.domConverter.viewPositionToDom(this.selection.anchor), r = this.domConverter.viewPositionToDom(this.selection.focus);
    t.collapse(n.parent, n.offset), t.extend(r.parent, r.offset), qe.isGecko && IV(r, t);
  }
  /**
   * Checks whether a given DOM selection needs to be updated.
   *
   * @param domSelection The DOM selection to check.
   */
  _domSelectionNeedsUpdate(e) {
    if (!this.domConverter.isDomSelectionCorrect(e))
      return !0;
    const t = e && this.domConverter.domSelectionToView(e);
    return !(t && this.selection.isEqual(t) || !this.selection.isCollapsed && this.selection.isSimilar(t));
  }
  /**
   * Checks whether the fake selection needs to be updated.
   *
   * @param domRoot A valid DOM root where a new fake selection container should be added.
   */
  _fakeSelectionNeedsUpdate(e) {
    const t = this._fakeSelectionContainer, n = e.ownerDocument.getSelection();
    return !t || t.parentElement !== e || n.anchorNode !== t && !t.contains(n.anchorNode) ? !0 : t.textContent !== this.selection.fakeSelectionLabel;
  }
  /**
   * Removes the DOM selection.
   */
  _removeDomSelection() {
    for (const e of this.domDocuments) {
      const t = e.getSelection();
      if (t.rangeCount) {
        const n = e.activeElement, r = this.domConverter.mapDomToView(n);
        n && r && t.removeAllRanges();
      }
    }
  }
  /**
   * Removes the fake selection.
   */
  _removeFakeSelection() {
    const e = this._fakeSelectionContainer;
    e && e.remove();
  }
  /**
   * Checks if focus needs to be updated and possibly updates it.
   */
  _updateFocus() {
    if (this.isFocused) {
      const e = this.selection.editableElement;
      e && this.domConverter.focus(e);
    }
  }
}
function xV(i) {
  if (i.getAttribute("contenteditable") == "false")
    return !1;
  const e = i.findAncestor((t) => t.hasAttribute("contenteditable"));
  return !e || e.getAttribute("contenteditable") == "true";
}
function Zw(i, e, t) {
  const n = e instanceof Array ? e : e.childNodes, r = n[t];
  if (qt(r))
    return r.data = Ad + r.data, r;
  {
    const s = i.createTextNode(Ad);
    return Array.isArray(e) ? n.splice(t, 0, s) : bE(e, t, s), s;
  }
}
function kV(i, e) {
  return ns(i) && ns(e) && !qt(i) && !qt(e) && !Mo(i) && !Mo(e) && i.tagName.toLowerCase() === e.tagName.toLowerCase();
}
function AV(i, e) {
  return ns(i) && ns(e) && qt(i) && qt(e);
}
function PV(i, e, t) {
  return e === t ? !0 : qt(e) && qt(t) ? e.data === t.data : !!(i.isBlockFiller(e) && i.isBlockFiller(t));
}
function IV(i, e) {
  const t = i.parent;
  if (t.nodeType != Node.ELEMENT_NODE || i.offset != t.childNodes.length - 1)
    return;
  const n = t.childNodes[i.offset];
  n && n.tagName == "BR" && e.addRange(e.getRangeAt(0));
}
function RV(i, e) {
  const t = Array.from(i);
  return t.length == 0 || !e || t[t.length - 1] == e && t.pop(), t;
}
function OV(i) {
  const e = i.createElement("div");
  return e.className = "ck-fake-selection-container", Object.assign(e.style, {
    position: "fixed",
    top: 0,
    left: "-9999px",
    // See https://github.com/ckeditor/ckeditor5/issues/752.
    width: "42px"
  }), e.textContent = " ", e;
}
function Qw(i, e) {
  const t = i.data;
  if (t == e)
    return;
  const n = yy(t, e);
  for (const r of n)
    r.type === "insert" ? i.insertData(r.index, r.values.join("")) : i.deleteData(r.index, r.howMany);
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const MV = zE(Ke.document), NV = FE(Ke.document), DV = $E(Ke.document), zu = "data-ck-unsafe-attribute-", eb = "data-ck-unsafe-element";
class WE {
  /**
   * Creates a DOM converter.
   *
   * @param document The view document instance.
   * @param options An object with configuration options.
   * @param options.blockFillerMode The type of the block filler to use.
   * Default value depends on the options.renderingMode:
   *  'nbsp' when options.renderingMode == 'data',
   *  'br' when options.renderingMode == 'editing'.
   * @param options.renderingMode Whether to leave the View-to-DOM conversion result unchanged
   * or improve editing experience by filtering out interactive data.
   */
  constructor(e, { blockFillerMode: t, renderingMode: n = "editing" } = {}) {
    this._domToViewMapping = /* @__PURE__ */ new WeakMap(), this._viewToDomMapping = /* @__PURE__ */ new WeakMap(), this._fakeSelectionMapping = /* @__PURE__ */ new WeakMap(), this._rawContentElementMatcher = new ah(), this._encounteredRawContentDomNodes = /* @__PURE__ */ new WeakSet(), this.document = e, this.renderingMode = n, this.blockFillerMode = t || (n === "editing" ? "br" : "nbsp"), this.preElements = ["pre"], this.blockElements = [
      "address",
      "article",
      "aside",
      "blockquote",
      "caption",
      "center",
      "dd",
      "details",
      "dir",
      "div",
      "dl",
      "dt",
      "fieldset",
      "figcaption",
      "figure",
      "footer",
      "form",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
      "header",
      "hgroup",
      "legend",
      "li",
      "main",
      "menu",
      "nav",
      "ol",
      "p",
      "pre",
      "section",
      "summary",
      "table",
      "tbody",
      "td",
      "tfoot",
      "th",
      "thead",
      "tr",
      "ul"
    ], this.inlineObjectElements = [
      "object",
      "iframe",
      "input",
      "button",
      "textarea",
      "select",
      "option",
      "video",
      "embed",
      "audio",
      "img",
      "canvas"
    ], this.unsafeElements = ["script", "style"], this._domDocument = this.renderingMode === "editing" ? Ke.document : Ke.document.implementation.createHTMLDocument("");
  }
  /**
   * Binds a given DOM element that represents fake selection to a **position** of a
   * {@link module:engine/view/documentselection~DocumentSelection document selection}.
   * Document selection copy is stored and can be retrieved by the
   * {@link module:engine/view/domconverter~DomConverter#fakeSelectionToView} method.
   */
  bindFakeSelection(e, t) {
    this._fakeSelectionMapping.set(e, new is(t));
  }
  /**
   * Returns a {@link module:engine/view/selection~Selection view selection} instance corresponding to a given
   * DOM element that represents fake selection. Returns `undefined` if binding to the given DOM element does not exist.
   */
  fakeSelectionToView(e) {
    return this._fakeSelectionMapping.get(e);
  }
  /**
   * Binds DOM and view elements, so it will be possible to get corresponding elements using
   * {@link module:engine/view/domconverter~DomConverter#mapDomToView} and
   * {@link module:engine/view/domconverter~DomConverter#mapViewToDom}.
   *
   * @param domElement The DOM element to bind.
   * @param viewElement The view element to bind.
   */
  bindElements(e, t) {
    this._domToViewMapping.set(e, t), this._viewToDomMapping.set(t, e);
  }
  /**
   * Unbinds a given DOM element from the view element it was bound to. Unbinding is deep, meaning that all children of
   * the DOM element will be unbound too.
   *
   * @param domElement The DOM element to unbind.
   */
  unbindDomElement(e) {
    const t = this._domToViewMapping.get(e);
    if (t) {
      this._domToViewMapping.delete(e), this._viewToDomMapping.delete(t);
      for (const n of Array.from(e.children))
        this.unbindDomElement(n);
    }
  }
  /**
   * Binds DOM and view document fragments, so it will be possible to get corresponding document fragments using
   * {@link module:engine/view/domconverter~DomConverter#mapDomToView} and
   * {@link module:engine/view/domconverter~DomConverter#mapViewToDom}.
   *
   * @param domFragment The DOM document fragment to bind.
   * @param viewFragment The view document fragment to bind.
   */
  bindDocumentFragments(e, t) {
    this._domToViewMapping.set(e, t), this._viewToDomMapping.set(t, e);
  }
  /**
   * Decides whether a given pair of attribute key and value should be passed further down the pipeline.
   *
   * @param elementName Element name in lower case.
   */
  shouldRenderAttribute(e, t, n) {
    return this.renderingMode === "data" ? !0 : (e = e.toLowerCase(), e.startsWith("on") || e === "srcdoc" && t.match(/\bon\S+\s*=|javascript:|<\s*\/*script/i) ? !1 : n === "img" && (e === "src" || e === "srcset") || n === "source" && e === "srcset" ? !0 : !t.match(/^\s*(javascript:|data:(image\/svg|text\/x?html))/i));
  }
  /**
   * Set `domElement`'s content using provided `html` argument. Apply necessary filtering for the editing pipeline.
   *
   * @param domElement DOM element that should have `html` set as its content.
   * @param html Textual representation of the HTML that will be set on `domElement`.
   */
  setContentOf(e, t) {
    if (this.renderingMode === "data") {
      e.innerHTML = t;
      return;
    }
    const n = new DOMParser().parseFromString(t, "text/html"), r = n.createDocumentFragment(), s = n.body.childNodes;
    for (; s.length > 0; )
      r.appendChild(s[0]);
    const o = n.createTreeWalker(r, NodeFilter.SHOW_ELEMENT), l = [];
    let u;
    for (; u = o.nextNode(); )
      l.push(u);
    for (const h of l) {
      for (const m of h.getAttributeNames())
        this.setDomElementAttribute(h, m, h.getAttribute(m));
      const f = h.tagName.toLowerCase();
      this._shouldRenameElement(f) && (nb(f), h.replaceWith(this._createReplacementDomElement(f, h)));
    }
    for (; e.firstChild; )
      e.firstChild.remove();
    e.append(r);
  }
  /**
   * Converts the view to the DOM. For all text nodes, not bound elements and document fragments new items will
   * be created. For bound elements and document fragments the method will return corresponding items.
   *
   * @param viewNode View node or document fragment to transform.
   * @param options Conversion options.
   * @param options.bind Determines whether new elements will be bound.
   * @param options.withChildren If `false`, node's and document fragment's children will not be converted.
   * @returns Converted node or DocumentFragment.
   */
  viewToDom(e, t = {}) {
    if (e.is("$text")) {
      const n = this._processDataFromViewText(e);
      return this._domDocument.createTextNode(n);
    } else {
      if (this.mapViewToDom(e))
        return this.mapViewToDom(e);
      let n;
      if (e.is("documentFragment"))
        n = this._domDocument.createDocumentFragment(), t.bind && this.bindDocumentFragments(n, e);
      else {
        if (e.is("uiElement"))
          return e.name === "$comment" ? n = this._domDocument.createComment(e.getCustomProperty("$rawContent")) : n = e.render(this._domDocument, this), t.bind && this.bindElements(n, e), n;
        this._shouldRenameElement(e.name) ? (nb(e.name), n = this._createReplacementDomElement(e.name)) : e.hasAttribute("xmlns") ? n = this._domDocument.createElementNS(e.getAttribute("xmlns"), e.name) : n = this._domDocument.createElement(e.name), e.is("rawElement") && e.render(n, this), t.bind && this.bindElements(n, e);
        for (const r of e.getAttributeKeys())
          this.setDomElementAttribute(n, r, e.getAttribute(r), e);
      }
      if (t.withChildren !== !1)
        for (const r of this.viewChildrenToDom(e, t))
          n.appendChild(r);
      return n;
    }
  }
  /**
   * Sets the attribute on a DOM element.
   *
   * **Note**: To remove the attribute, use {@link #removeDomElementAttribute}.
   *
   * @param domElement The DOM element the attribute should be set on.
   * @param key The name of the attribute.
   * @param value The value of the attribute.
   * @param relatedViewElement The view element related to the `domElement` (if there is any).
   * It helps decide whether the attribute set is unsafe. For instance, view elements created via the
   * {@link module:engine/view/downcastwriter~DowncastWriter} methods can allow certain attributes that would normally be filtered out.
   */
  setDomElementAttribute(e, t, n, r) {
    const s = this.shouldRenderAttribute(t, n, e.tagName.toLowerCase()) || r && r.shouldRenderUnsafeAttribute(t);
    s || Yt("domconverter-unsafe-attribute-detected", { domElement: e, key: t, value: n }), e.hasAttribute(t) && !s ? e.removeAttribute(t) : e.hasAttribute(zu + t) && s && e.removeAttribute(zu + t), e.setAttribute(s ? t : zu + t, n);
  }
  /**
   * Removes an attribute from a DOM element.
   *
   * **Note**: To set the attribute, use {@link #setDomElementAttribute}.
   *
   * @param domElement The DOM element the attribute should be removed from.
   * @param key The name of the attribute.
   */
  removeDomElementAttribute(e, t) {
    t != eb && (e.removeAttribute(t), e.removeAttribute(zu + t));
  }
  /**
   * Converts children of the view element to DOM using the
   * {@link module:engine/view/domconverter~DomConverter#viewToDom} method.
   * Additionally, this method adds block {@link module:engine/view/filler filler} to the list of children, if needed.
   *
   * @param viewElement Parent view element.
   * @param options See {@link module:engine/view/domconverter~DomConverter#viewToDom} options parameter.
   * @returns DOM nodes.
   */
  *viewChildrenToDom(e, t = {}) {
    const n = e.getFillerOffset && e.getFillerOffset();
    let r = 0;
    for (const s of e.getChildren()) {
      n === r && (yield this._getBlockFiller());
      const o = s.is("element") && !!s.getCustomProperty("dataPipeline:transparentRendering") && !Rn(s.getAttributes());
      o && this.renderingMode == "data" ? yield* this.viewChildrenToDom(s, t) : (o && Yt("domconverter-transparent-rendering-unsupported-in-editing-pipeline", { viewElement: s }), yield this.viewToDom(s, t)), r++;
    }
    n === r && (yield this._getBlockFiller());
  }
  /**
   * Converts view {@link module:engine/view/range~Range} to DOM range.
   * Inline and block {@link module:engine/view/filler fillers} are handled during the conversion.
   *
   * @param viewRange View range.
   * @returns DOM range.
   */
  viewRangeToDom(e) {
    const t = this.viewPositionToDom(e.start), n = this.viewPositionToDom(e.end), r = this._domDocument.createRange();
    return r.setStart(t.parent, t.offset), r.setEnd(n.parent, n.offset), r;
  }
  /**
   * Converts view {@link module:engine/view/position~Position} to DOM parent and offset.
   *
   * Inline and block {@link module:engine/view/filler fillers} are handled during the conversion.
   * If the converted position is directly before inline filler it is moved inside the filler.
   *
   * @param viewPosition View position.
   * @returns DOM position or `null` if view position could not be converted to DOM.
   * DOM position has two properties:
   * * `parent` - DOM position parent.
   * * `offset` - DOM position offset.
   */
  viewPositionToDom(e) {
    const t = e.parent;
    if (t.is("$text")) {
      const n = this.findCorrespondingDomText(t);
      if (!n)
        return null;
      let r = e.offset;
      return li(n) && (r += nr), { parent: n, offset: r };
    } else {
      let n, r, s;
      if (e.offset === 0) {
        if (n = this.mapViewToDom(t), !n)
          return null;
        s = n.childNodes[0];
      } else {
        const l = e.nodeBefore;
        if (r = l.is("$text") ? this.findCorrespondingDomText(l) : this.mapViewToDom(l), !r)
          return null;
        n = r.parentNode, s = r.nextSibling;
      }
      if (qt(s) && li(s))
        return { parent: s, offset: nr };
      const o = r ? Fu(r) + 1 : 0;
      return { parent: n, offset: o };
    }
  }
  /**
   * Converts DOM to view. For all text nodes, not bound elements and document fragments new items will
   * be created. For bound elements and document fragments function will return corresponding items. For
   * {@link module:engine/view/filler fillers} `null` will be returned.
   * For all DOM elements rendered by {@link module:engine/view/uielement~UIElement} that UIElement will be returned.
   *
   * @param domNode DOM node or document fragment to transform.
   * @param options Conversion options.
   * @param options.bind Determines whether new elements will be bound. False by default.
   * @param options.withChildren If `true`, node's and document fragment's children will be converted too. True by default.
   * @param options.keepOriginalCase If `false`, node's tag name will be converted to lower case. False by default.
   * @param options.skipComments If `false`, comment nodes will be converted to `$comment`
   * {@link module:engine/view/uielement~UIElement view UI elements}. False by default.
   * @returns Converted node or document fragment or `null` if DOM node is a {@link module:engine/view/filler filler}
   * or the given node is an empty text node.
   */
  domToView(e, t = {}) {
    if (this.isBlockFiller(e))
      return null;
    const n = this.getHostViewElement(e);
    if (n)
      return n;
    if (Mo(e) && t.skipComments)
      return null;
    if (qt(e)) {
      if (rl(e))
        return null;
      {
        const r = this._processDataFromDomText(e);
        return r === "" ? null : new Bt(this.document, r);
      }
    } else {
      if (this.mapDomToView(e))
        return this.mapDomToView(e);
      let r;
      if (this.isDocumentFragment(e))
        r = new Ns(this.document), t.bind && this.bindDocumentFragments(e, r);
      else {
        r = this._createViewElement(e, t), t.bind && this.bindElements(e, r);
        const s = e.attributes;
        if (s)
          for (let o = s.length, l = 0; l < o; l++)
            r._setAttribute(s[l].name, s[l].value);
        if (this._isViewElementWithRawContent(r, t) || Mo(e)) {
          const o = Mo(e) ? e.data : e.innerHTML;
          return r._setCustomProperty("$rawContent", o), this._encounteredRawContentDomNodes.add(e), r;
        }
      }
      if (t.withChildren !== !1)
        for (const s of this.domChildrenToView(e, t))
          r._appendChild(s);
      return r;
    }
  }
  /**
   * Converts children of the DOM element to view nodes using
   * the {@link module:engine/view/domconverter~DomConverter#domToView} method.
   * Additionally this method omits block {@link module:engine/view/filler filler}, if it exists in the DOM parent.
   *
   * @param domElement Parent DOM element.
   * @param options See {@link module:engine/view/domconverter~DomConverter#domToView} options parameter.
   * @returns View nodes.
   */
  *domChildrenToView(e, t) {
    for (let n = 0; n < e.childNodes.length; n++) {
      const r = e.childNodes[n], s = this.domToView(r, t);
      s !== null && (yield s);
    }
  }
  /**
   * Converts DOM selection to view {@link module:engine/view/selection~Selection}.
   * Ranges which cannot be converted will be omitted.
   *
   * @param domSelection DOM selection.
   * @returns View selection.
   */
  domSelectionToView(e) {
    if (e.rangeCount === 1) {
      let r = e.getRangeAt(0).startContainer;
      qt(r) && (r = r.parentNode);
      const s = this.fakeSelectionToView(r);
      if (s)
        return s;
    }
    const t = this.isDomSelectionBackward(e), n = [];
    for (let r = 0; r < e.rangeCount; r++) {
      const s = e.getRangeAt(r), o = this.domRangeToView(s);
      o && n.push(o);
    }
    return new is(n, { backward: t });
  }
  /**
   * Converts DOM Range to view {@link module:engine/view/range~Range}.
   * If the start or end position can not be converted `null` is returned.
   *
   * @param domRange DOM range.
   * @returns View range.
   */
  domRangeToView(e) {
    const t = this.domPositionToView(e.startContainer, e.startOffset), n = this.domPositionToView(e.endContainer, e.endOffset);
    return t && n ? new We(t, n) : null;
  }
  /**
   * Converts DOM parent and offset to view {@link module:engine/view/position~Position}.
   *
   * If the position is inside a {@link module:engine/view/filler filler} which has no corresponding view node,
   * position of the filler will be converted and returned.
   *
   * If the position is inside DOM element rendered by {@link module:engine/view/uielement~UIElement}
   * that position will be converted to view position before that UIElement.
   *
   * If structures are too different and it is not possible to find corresponding position then `null` will be returned.
   *
   * @param domParent DOM position parent.
   * @param domOffset DOM position offset. You can skip it when converting the inline filler node.
   * @returns View position.
   */
  domPositionToView(e, t = 0) {
    if (this.isBlockFiller(e))
      return this.domPositionToView(e.parentNode, Fu(e));
    const n = this.mapDomToView(e);
    if (n && (n.is("uiElement") || n.is("rawElement")))
      return _e._createBefore(n);
    if (qt(e)) {
      if (rl(e))
        return this.domPositionToView(e.parentNode, Fu(e));
      const r = this.findCorrespondingViewText(e);
      let s = t;
      return r ? (li(e) && (s -= nr, s = s < 0 ? 0 : s), new _e(r, s)) : null;
    } else {
      if (t === 0) {
        const r = this.mapDomToView(e);
        if (r)
          return new _e(r, 0);
      } else {
        const r = e.childNodes[t - 1];
        if (qt(r) && rl(r) || r && this.isBlockFiller(r))
          return this.domPositionToView(r.parentNode, Fu(r));
        const s = qt(r) ? this.findCorrespondingViewText(r) : this.mapDomToView(r);
        if (s && s.parent)
          return new _e(s.parent, s.index + 1);
      }
      return null;
    }
  }
  /**
   * Returns corresponding view {@link module:engine/view/element~Element Element} or
   * {@link module:engine/view/documentfragment~DocumentFragment} for provided DOM element or
   * document fragment. If there is no view item {@link module:engine/view/domconverter~DomConverter#bindElements bound}
   * to the given DOM - `undefined` is returned.
   *
   * For all DOM elements rendered by a {@link module:engine/view/uielement~UIElement} or
   * a {@link module:engine/view/rawelement~RawElement}, the parent `UIElement` or `RawElement` will be returned.
   *
   * @param domElementOrDocumentFragment DOM element or document fragment.
   * @returns Corresponding view element, document fragment or `undefined` if no element was bound.
   */
  mapDomToView(e) {
    return this.getHostViewElement(e) || this._domToViewMapping.get(e);
  }
  /**
   * Finds corresponding text node. Text nodes are not {@link module:engine/view/domconverter~DomConverter#bindElements bound},
   * corresponding text node is returned based on the sibling or parent.
   *
   * If the directly previous sibling is a {@link module:engine/view/domconverter~DomConverter#bindElements bound} element, it is used
   * to find the corresponding text node.
   *
   * If this is a first child in the parent and the parent is a {@link module:engine/view/domconverter~DomConverter#bindElements bound}
   * element, it is used to find the corresponding text node.
   *
   * For all text nodes rendered by a {@link module:engine/view/uielement~UIElement} or
   * a {@link module:engine/view/rawelement~RawElement}, the parent `UIElement` or `RawElement` will be returned.
   *
   * Otherwise `null` is returned.
   *
   * Note that for the block or inline {@link module:engine/view/filler filler} this method returns `null`.
   *
   * @param domText DOM text node.
   * @returns Corresponding view text node or `null`, if it was not possible to find a corresponding node.
   */
  findCorrespondingViewText(e) {
    if (rl(e))
      return null;
    const t = this.getHostViewElement(e);
    if (t)
      return t;
    const n = e.previousSibling;
    if (n) {
      if (!this.isElement(n))
        return null;
      const r = this.mapDomToView(n);
      if (r) {
        const s = r.nextSibling;
        return s instanceof Bt ? s : null;
      }
    } else {
      const r = this.mapDomToView(e.parentNode);
      if (r) {
        const s = r.getChild(0);
        return s instanceof Bt ? s : null;
      }
    }
    return null;
  }
  mapViewToDom(e) {
    return this._viewToDomMapping.get(e);
  }
  /**
   * Finds corresponding text node. Text nodes are not {@link module:engine/view/domconverter~DomConverter#bindElements bound},
   * corresponding text node is returned based on the sibling or parent.
   *
   * If the directly previous sibling is a {@link module:engine/view/domconverter~DomConverter#bindElements bound} element, it is used
   * to find the corresponding text node.
   *
   * If this is a first child in the parent and the parent is a {@link module:engine/view/domconverter~DomConverter#bindElements bound}
   * element, it is used to find the corresponding text node.
   *
   * Otherwise `null` is returned.
   *
   * @param viewText View text node.
   * @returns Corresponding DOM text node or `null`, if it was not possible to find a corresponding node.
   */
  findCorrespondingDomText(e) {
    const t = e.previousSibling;
    return t && this.mapViewToDom(t) ? this.mapViewToDom(t).nextSibling : !t && e.parent && this.mapViewToDom(e.parent) ? this.mapViewToDom(e.parent).childNodes[0] : null;
  }
  /**
   * Focuses DOM editable that is corresponding to provided {@link module:engine/view/editableelement~EditableElement}.
   */
  focus(e) {
    const t = this.mapViewToDom(e);
    if (t && t.ownerDocument.activeElement !== t) {
      const { scrollX: n, scrollY: r } = Ke.window, s = [];
      tb(t, (o) => {
        const { scrollLeft: l, scrollTop: u } = o;
        s.push([l, u]);
      }), t.focus(), tb(t, (o) => {
        const [l, u] = s.shift();
        o.scrollLeft = l, o.scrollTop = u;
      }), Ke.window.scrollTo(n, r);
    }
  }
  /**
   * Returns `true` when `node.nodeType` equals `Node.ELEMENT_NODE`.
   *
   * @param node Node to check.
   */
  isElement(e) {
    return e && e.nodeType == Node.ELEMENT_NODE;
  }
  /**
   * Returns `true` when `node.nodeType` equals `Node.DOCUMENT_FRAGMENT_NODE`.
   *
   * @param node Node to check.
   */
  isDocumentFragment(e) {
    return e && e.nodeType == Node.DOCUMENT_FRAGMENT_NODE;
  }
  /**
   * Checks if the node is an instance of the block filler for this DOM converter.
   *
   * ```ts
   * const converter = new DomConverter( viewDocument, { blockFillerMode: 'br' } );
   *
   * converter.isBlockFiller( BR_FILLER( document ) ); // true
   * converter.isBlockFiller( NBSP_FILLER( document ) ); // false
   * ```
   *
   * **Note:**: For the `'nbsp'` mode the method also checks context of a node so it cannot be a detached node.
   *
   * **Note:** A special case in the `'nbsp'` mode exists where the `<br>` in `<p><br></p>` is treated as a block filler.
   *
   * @param domNode DOM node to check.
   * @returns True if a node is considered a block filler for given mode.
   */
  isBlockFiller(e) {
    return this.blockFillerMode == "br" ? e.isEqualNode(MV) : e.tagName === "BR" && jE(e, this.blockElements) && e.parentNode.childNodes.length === 1 ? !0 : e.isEqualNode(DV) || VV(e, this.blockElements);
  }
  /**
   * Returns `true` if given selection is a backward selection, that is, if it's `focus` is before `anchor`.
   *
   * @param DOM Selection instance to check.
   */
  isDomSelectionBackward(e) {
    if (e.isCollapsed)
      return !1;
    const t = this._domDocument.createRange();
    try {
      t.setStart(e.anchorNode, e.anchorOffset), t.setEnd(e.focusNode, e.focusOffset);
    } catch {
      return !1;
    }
    const n = t.collapsed;
    return t.detach(), n;
  }
  /**
   * Returns a parent {@link module:engine/view/uielement~UIElement} or {@link module:engine/view/rawelement~RawElement}
   * that hosts the provided DOM node. Returns `null` if there is no such parent.
   */
  getHostViewElement(e) {
    const t = pE(e);
    for (t.pop(); t.length; ) {
      const n = t.pop(), r = this._domToViewMapping.get(n);
      if (r && (r.is("uiElement") || r.is("rawElement")))
        return r;
    }
    return null;
  }
  /**
   * Checks if the given selection's boundaries are at correct places.
   *
   * The following places are considered as incorrect for selection boundaries:
   *
   * * before or in the middle of an inline filler sequence,
   * * inside a DOM element which represents {@link module:engine/view/uielement~UIElement a view UI element},
   * * inside a DOM element which represents {@link module:engine/view/rawelement~RawElement a view raw element}.
   *
   * @param domSelection The DOM selection object to be checked.
   * @returns `true` if the given selection is at a correct place, `false` otherwise.
   */
  isDomSelectionCorrect(e) {
    return this._isDomSelectionPositionCorrect(e.anchorNode, e.anchorOffset) && this._isDomSelectionPositionCorrect(e.focusNode, e.focusOffset);
  }
  /**
   * Registers a {@link module:engine/view/matcher~MatcherPattern} for view elements whose content should be treated as raw data
   * and not processed during the conversion from DOM nodes to view elements.
   *
   * This is affecting how {@link module:engine/view/domconverter~DomConverter#domToView} and
   * {@link module:engine/view/domconverter~DomConverter#domChildrenToView} process DOM nodes.
   *
   * The raw data can be later accessed by a
   * {@link module:engine/view/element~Element#getCustomProperty custom property of a view element} called `"$rawContent"`.
   *
   * @param pattern Pattern matching a view element whose content should
   * be treated as raw data.
   */
  registerRawContentMatcher(e) {
    this._rawContentElementMatcher.add(e);
  }
  /**
   * Returns the block {@link module:engine/view/filler filler} node based on the current {@link #blockFillerMode} setting.
   */
  _getBlockFiller() {
    switch (this.blockFillerMode) {
      case "nbsp":
        return FE(this._domDocument);
      case "markedNbsp":
        return $E(this._domDocument);
      case "br":
        return zE(this._domDocument);
    }
  }
  /**
   * Checks if the given DOM position is a correct place for selection boundary. See {@link #isDomSelectionCorrect}.
   *
   * @param domParent Position parent.
   * @param offset Position offset.
   * @returns `true` if given position is at a correct place for selection boundary, `false` otherwise.
   */
  _isDomSelectionPositionCorrect(e, t) {
    if (qt(e) && li(e) && t < nr || this.isElement(e) && li(e.childNodes[t]))
      return !1;
    const n = this.mapDomToView(e);
    return !(n && (n.is("uiElement") || n.is("rawElement")));
  }
  /**
   * Takes text data from a given {@link module:engine/view/text~Text#data} and processes it so
   * it is correctly displayed in the DOM.
   *
   * Following changes are done:
   *
   * * a space at the beginning is changed to `&nbsp;` if this is the first text node in its container
   * element or if a previous text node ends with a space character,
   * * space at the end of the text node is changed to `&nbsp;` if there are two spaces at the end of a node or if next node
   * starts with a space or if it is the last text node in its container,
   * * remaining spaces are replaced to a chain of spaces and `&nbsp;` (e.g. `'x   x'` becomes `'x &nbsp; x'`).
   *
   * Content of {@link #preElements} is not processed.
   *
   * @param node View text node to process.
   * @returns Processed text data.
   */
  _processDataFromViewText(e) {
    let t = e.data;
    if (e.getAncestors().some((n) => this.preElements.includes(n.name)))
      return t;
    if (t.charAt(0) == " ") {
      const n = this._getTouchingInlineViewNode(e, !1);
      (n && n.is("$textProxy") && this._nodeEndsWithSpace(n) || !n) && (t = " " + t.substr(1));
    }
    if (t.charAt(t.length - 1) == " ") {
      const n = this._getTouchingInlineViewNode(e, !0), r = n && n.is("$textProxy") && n.data.charAt(0) == " ";
      (t.charAt(t.length - 2) == " " || !n || r) && (t = t.substr(0, t.length - 1) + " ");
    }
    return t.replace(/ {2}/g, "  ");
  }
  /**
   * Checks whether given node ends with a space character after changing appropriate space characters to `&nbsp;`s.
   *
   * @param  node Node to check.
   * @returns `true` if given `node` ends with space, `false` otherwise.
   */
  _nodeEndsWithSpace(e) {
    if (e.getAncestors().some((n) => this.preElements.includes(n.name)))
      return !1;
    const t = this._processDataFromViewText(e);
    return t.charAt(t.length - 1) == " ";
  }
  /**
   * Takes text data from native `Text` node and processes it to a correct {@link module:engine/view/text~Text view text node} data.
   *
   * Following changes are done:
   *
   * * multiple whitespaces are replaced to a single space,
   * * space at the beginning of a text node is removed if it is the first text node in its container
   * element or if the previous text node ends with a space character,
   * * space at the end of the text node is removed if there are two spaces at the end of a node or if next node
   * starts with a space or if it is the last text node in its container
   * * nbsps are converted to spaces.
   *
   * @param node DOM text node to process.
   * @returns Processed data.
   */
  _processDataFromDomText(e) {
    let t = e.data;
    if (BV(e, this.preElements))
      return Xw(e);
    t = t.replace(/[ \n\t\r]{1,}/g, " ");
    const n = this._getTouchingInlineDomNode(e, !1), r = this._getTouchingInlineDomNode(e, !0), s = this._checkShouldLeftTrimDomText(e, n), o = this._checkShouldRightTrimDomText(e, r);
    s && (t = t.replace(/^ /, "")), o && (t = t.replace(/ $/, "")), t = Xw(new Text(t)), t = t.replace(/ \u00A0/g, "  ");
    const l = r && this.isElement(r) && r.tagName != "BR", u = r && qt(r) && r.data.charAt(0) == " ";
    return (/( |\u00A0)\u00A0$/.test(t) || !r || l || u) && (t = t.replace(/\u00A0$/, " ")), (s || n && this.isElement(n) && n.tagName != "BR") && (t = t.replace(/^\u00A0/, " ")), t;
  }
  /**
   * Helper function which checks if a DOM text node, preceded by the given `prevNode` should
   * be trimmed from the left side.
   *
   * @param prevNode Either DOM text or `<br>` or one of `#inlineObjectElements`.
   */
  _checkShouldLeftTrimDomText(e, t) {
    return t ? this.isElement(t) ? t.tagName === "BR" : this._encounteredRawContentDomNodes.has(e.previousSibling) ? !1 : /[^\S\u00A0]/.test(t.data.charAt(t.data.length - 1)) : !0;
  }
  /**
   * Helper function which checks if a DOM text node, succeeded by the given `nextNode` should
   * be trimmed from the right side.
   *
   * @param nextNode Either DOM text or `<br>` or one of `#inlineObjectElements`.
   */
  _checkShouldRightTrimDomText(e, t) {
    return t ? !1 : !li(e);
  }
  /**
   * Helper function. For given {@link module:engine/view/text~Text view text node}, it finds previous or next sibling
   * that is contained in the same container element. If there is no such sibling, `null` is returned.
   *
   * @param node Reference node.
   * @returns Touching text node, an inline object
   * or `null` if there is no next or previous touching text node.
   */
  _getTouchingInlineViewNode(e, t) {
    const n = new Is({
      startPosition: t ? _e._createAfter(e) : _e._createBefore(e),
      direction: t ? "forward" : "backward"
    });
    for (const r of n) {
      if (r.item.is("element") && this.inlineObjectElements.includes(r.item.name))
        return r.item;
      if (r.item.is("containerElement"))
        return null;
      if (r.item.is("element", "br"))
        return null;
      if (r.item.is("$textProxy"))
        return r.item;
    }
    return null;
  }
  /**
   * Helper function. For the given text node, it finds the closest touching node which is either
   * a text, `<br>` or an {@link #inlineObjectElements inline object}.
   *
   * If no such node is found, `null` is returned.
   *
   * For instance, in the following DOM structure:
   *
   * ```html
   * <p>foo<b>bar</b><br>bom</p>
   * ```
   *
   * * `foo` doesn't have its previous touching inline node (`null` is returned),
   * * `foo`'s next touching inline node is `bar`
   * * `bar`'s next touching inline node is `<br>`
   *
   * This method returns text nodes and `<br>` elements because these types of nodes affect how
   * spaces in the given text node need to be converted.
   */
  _getTouchingInlineDomNode(e, t) {
    if (!e.parentNode)
      return null;
    const n = t ? "firstChild" : "lastChild", r = t ? "nextSibling" : "previousSibling";
    let s = !0, o = e;
    do
      if (!s && o[n] ? o = o[n] : o[r] ? (o = o[r], s = !1) : (o = o.parentNode, s = !0), !o || this._isBlockElement(o))
        return null;
    while (!(qt(o) || o.tagName == "BR" || this._isInlineObjectElement(o)));
    return o;
  }
  /**
   * Returns `true` if a DOM node belongs to {@link #blockElements}. `false` otherwise.
   */
  _isBlockElement(e) {
    return this.isElement(e) && this.blockElements.includes(e.tagName.toLowerCase());
  }
  /**
   * Returns `true` if a DOM node belongs to {@link #inlineObjectElements}. `false` otherwise.
   */
  _isInlineObjectElement(e) {
    return this.isElement(e) && this.inlineObjectElements.includes(e.tagName.toLowerCase());
  }
  /**
   * Creates view element basing on the node type.
   *
   * @param node DOM node to check.
   * @param options Conversion options. See {@link module:engine/view/domconverter~DomConverter#domToView} options parameter.
   */
  _createViewElement(e, t) {
    if (Mo(e))
      return new ch(this.document, "$comment");
    const n = t.keepOriginalCase ? e.tagName : e.tagName.toLowerCase();
    return new $i(this.document, n);
  }
  /**
   * Checks if view element's content should be treated as a raw data.
   *
   * @param viewElement View element to check.
   * @param options Conversion options. See {@link module:engine/view/domconverter~DomConverter#domToView} options parameter.
   */
  _isViewElementWithRawContent(e, t) {
    return t.withChildren !== !1 && !!this._rawContentElementMatcher.match(e);
  }
  /**
   * Checks whether a given element name should be renamed in a current rendering mode.
   *
   * @param elementName The name of view element.
   */
  _shouldRenameElement(e) {
    const t = e.toLowerCase();
    return this.renderingMode === "editing" && this.unsafeElements.includes(t);
  }
  /**
   * Return a <span> element with a special attribute holding the name of the original element.
   * Optionally, copy all the attributes of the original element if that element is provided.
   *
   * @param elementName The name of view element.
   * @param originalDomElement The original DOM element to copy attributes and content from.
   */
  _createReplacementDomElement(e, t) {
    const n = this._domDocument.createElement("span");
    if (n.setAttribute(eb, e), t) {
      for (; t.firstChild; )
        n.appendChild(t.firstChild);
      for (const r of t.getAttributeNames())
        n.setAttribute(r, t.getAttribute(r));
    }
    return n;
  }
}
function BV(i, e) {
  return pE(i).some((n) => n.tagName && e.includes(n.tagName.toLowerCase()));
}
function tb(i, e) {
  let t = i;
  for (; t; )
    e(t), t = t.parentElement;
}
function VV(i, e) {
  return i.isEqualNode(NV) && jE(i, e) && i.parentNode.childNodes.length === 1;
}
function jE(i, e) {
  const t = i.parentNode;
  return !!t && !!t.tagName && e.includes(t.tagName.toLowerCase());
}
function nb(i) {
  i === "script" && Yt("domconverter-unsafe-script-element-detected"), i === "style" && Yt("domconverter-unsafe-style-element-detected");
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class dr extends as() {
  /**
   * Creates an instance of the observer.
   */
  constructor(e) {
    super(), this._isEnabled = !1, this.view = e, this.document = e.document;
  }
  /**
   * The state of the observer. If it is disabled, no events will be fired.
   */
  get isEnabled() {
    return this._isEnabled;
  }
  /**
   * Enables the observer. This method is called when the observer is registered to the
   * {@link module:engine/view/view~View} and after {@link module:engine/view/view~View#forceRender rendering}
   * (all observers are {@link #disable disabled} before rendering).
   *
   * A typical use case for disabling observers is that mutation observers need to be disabled for the rendering.
   * However, a child class may not need to be disabled, so it can implement an empty method.
   *
   * @see module:engine/view/observer/observer~Observer#disable
   */
  enable() {
    this._isEnabled = !0;
  }
  /**
   * Disables the observer. This method is called before
   * {@link module:engine/view/view~View#forceRender rendering} to prevent firing events during rendering.
   *
   * @see module:engine/view/observer/observer~Observer#enable
   */
  disable() {
    this._isEnabled = !1;
  }
  /**
   * Disables and destroys the observer, among others removes event listeners created by the observer.
   */
  destroy() {
    this.disable(), this.stopListening();
  }
  /**
   * Checks whether a given DOM event should be ignored (should not be turned into a synthetic view document event).
   *
   * Currently, an event will be ignored only if its target or any of its ancestors has the `data-cke-ignore-events` attribute.
   * This attribute can be used inside the structures generated by
   * {@link module:engine/view/downcastwriter~DowncastWriter#createUIElement `DowncastWriter#createUIElement()`} to ignore events
   * fired within a UI that should be excluded from CKEditor 5's realms.
   *
   * @param domTarget The DOM event target to check (usually an element, sometimes a text node and
   * potentially sometimes a document, too).
   * @returns Whether this event should be ignored by the observer.
   */
  checkShouldIgnoreEventFromTarget(e) {
    return e && e.nodeType === 3 && (e = e.parentNode), !e || e.nodeType !== 1 ? !1 : e.matches("[data-cke-ignore-events], [data-cke-ignore-events] *");
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class Wo {
  /**
   * @param view The instance of the view controller.
   * @param domEvent The DOM event.
   * @param additionalData Additional properties that the instance should contain.
   */
  constructor(e, t, n) {
    this.view = e, this.document = e.document, this.domEvent = t, this.domTarget = t.target, Ly(this, n);
  }
  /**
   * The tree view element representing the target.
   */
  get target() {
    return this.view.domConverter.mapDomToView(this.domTarget);
  }
  /**
   * Prevents the native's event default action.
   */
  preventDefault() {
    this.domEvent.preventDefault();
  }
  /**
   * Stops native event propagation.
   */
  stopPropagation() {
    this.domEvent.stopPropagation();
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class qs extends dr {
  constructor() {
    super(...arguments), this.useCapture = !1;
  }
  /**
   * @inheritDoc
   */
  observe(e) {
    (typeof this.domEventType == "string" ? [this.domEventType] : this.domEventType).forEach((n) => {
      this.listenTo(e, n, (r, s) => {
        this.isEnabled && !this.checkShouldIgnoreEventFromTarget(s.target) && this.onDomEvent(s);
      }, { useCapture: this.useCapture });
    });
  }
  /**
   * @inheritDoc
   */
  stopObserving(e) {
    this.stopListening(e);
  }
  /**
   * Calls `Document#fire()` if observer {@link #isEnabled is enabled}.
   *
   * @see module:utils/emittermixin~Emitter#fire
   * @param eventType The event type (name).
   * @param domEvent The DOM event.
   * @param additionalData The additional data which should extend the
   * {@link module:engine/view/observer/domeventdata~DomEventData event data} object.
   */
  fire(e, t, n) {
    this.isEnabled && this.document.fire(e, new Wo(this.view, t, n));
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class LV extends qs {
  constructor() {
    super(...arguments), this.domEventType = ["keydown", "keyup"];
  }
  /**
   * @inheritDoc
   */
  onDomEvent(e) {
    const t = {
      keyCode: e.keyCode,
      altKey: e.altKey,
      ctrlKey: e.ctrlKey,
      shiftKey: e.shiftKey,
      metaKey: e.metaKey,
      get keystroke() {
        return zo(this);
      }
    };
    this.fire(e.type, e, t);
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class FV extends dr {
  /**
   * Creates new FakeSelectionObserver instance.
   */
  constructor(e) {
    super(e), this._fireSelectionChangeDoneDebounced = $o((t) => {
      this.document.fire("selectionChangeDone", t);
    }, 200);
  }
  /**
   * @inheritDoc
   */
  observe() {
    const e = this.document;
    e.on("arrowKey", (t, n) => {
      e.selection.isFake && this.isEnabled && n.preventDefault();
    }, { context: "$capture" }), e.on("arrowKey", (t, n) => {
      e.selection.isFake && this.isEnabled && this._handleSelectionMove(n.keyCode);
    }, { priority: "lowest" });
  }
  /**
   * @inheritDoc
   */
  stopObserving() {
  }
  /**
   * @inheritDoc
   */
  destroy() {
    super.destroy(), this._fireSelectionChangeDoneDebounced.cancel();
  }
  /**
   * Handles collapsing view selection according to given key code. If left or up key is provided - new selection will be
   * collapsed to left. If right or down key is pressed - new selection will be collapsed to right.
   *
   * This method fires {@link module:engine/view/document~Document#event:selectionChange} and
   * {@link module:engine/view/document~Document#event:selectionChangeDone} events imitating behaviour of
   * {@link module:engine/view/observer/selectionobserver~SelectionObserver}.
   */
  _handleSelectionMove(e) {
    const t = this.document.selection, n = new is(t.getRanges(), { backward: t.isBackward, fake: !1 });
    (e == tt.arrowleft || e == tt.arrowup) && n.setTo(n.getFirstPosition()), (e == tt.arrowright || e == tt.arrowdown) && n.setTo(n.getLastPosition());
    const r = {
      oldSelection: t,
      newSelection: n,
      domSelection: null
    };
    this.document.fire("selectionChange", r), this._fireSelectionChangeDoneDebounced(r);
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class UE extends dr {
  /**
   * @inheritDoc
   */
  constructor(e) {
    super(e), this._config = {
      childList: !0,
      characterData: !0,
      subtree: !0
    }, this.domConverter = e.domConverter, this.renderer = e._renderer, this._domElements = /* @__PURE__ */ new Set(), this._mutationObserver = new window.MutationObserver(this._onMutations.bind(this));
  }
  /**
   * Synchronously handles mutations and empties the queue.
   */
  flush() {
    this._onMutations(this._mutationObserver.takeRecords());
  }
  /**
   * @inheritDoc
   */
  observe(e) {
    this._domElements.add(e), this.isEnabled && this._mutationObserver.observe(e, this._config);
  }
  /**
   * @inheritDoc
   */
  stopObserving(e) {
    if (this._domElements.delete(e), this.isEnabled) {
      this._mutationObserver.disconnect();
      for (const t of this._domElements)
        this._mutationObserver.observe(t, this._config);
    }
  }
  /**
   * @inheritDoc
   */
  enable() {
    super.enable();
    for (const e of this._domElements)
      this._mutationObserver.observe(e, this._config);
  }
  /**
   * @inheritDoc
   */
  disable() {
    super.disable(), this._mutationObserver.disconnect();
  }
  /**
   * @inheritDoc
   */
  destroy() {
    super.destroy(), this._mutationObserver.disconnect();
  }
  /**
   * Handles mutations. Mark view elements to sync and call render.
   *
   * @param domMutations Array of native mutations.
   */
  _onMutations(e) {
    if (e.length === 0)
      return;
    const t = this.domConverter, n = /* @__PURE__ */ new Set(), r = /* @__PURE__ */ new Set();
    for (const o of e) {
      const l = t.mapDomToView(o.target);
      l && (l.is("uiElement") || l.is("rawElement") || o.type === "childList" && !this._isBogusBrMutation(o) && r.add(l));
    }
    for (const o of e) {
      const l = t.mapDomToView(o.target);
      if (!(l && (l.is("uiElement") || l.is("rawElement"))) && o.type === "characterData") {
        const u = t.findCorrespondingViewText(o.target);
        u && !r.has(u.parent) ? n.add(u) : !u && li(o.target) && r.add(t.mapDomToView(o.target.parentNode));
      }
    }
    let s = !1;
    for (const o of n)
      s = !0, this.renderer.markToSync("text", o);
    for (const o of r) {
      const l = t.mapViewToDom(o), u = Array.from(o.getChildren()), h = Array.from(t.domChildrenToView(l, { withChildren: !1 }));
      nB(u, h, $V) || (s = !0, this.renderer.markToSync("children", o));
    }
    s && this.view.forceRender();
  }
  /**
   * Checks if mutation was generated by the browser inserting bogus br on the end of the block element.
   * Such mutations are generated while pressing space or performing native spellchecker correction
   * on the end of the block element in Firefox browser.
   *
   * @param mutation Native mutation object.
   */
  _isBogusBrMutation(e) {
    let t = null;
    return e.nextSibling === null && e.removedNodes.length === 0 && e.addedNodes.length == 1 && (t = this.domConverter.domToView(e.addedNodes[0], {
      withChildren: !1
    })), t && t.is("element", "br");
  }
}
function $V(i, e) {
  if (!Array.isArray(i))
    return i === e ? !0 : i.is("$text") && e.is("$text") ? i.data === e.data : !1;
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class fg extends qs {
  /**
   * @inheritDoc
   */
  constructor(e) {
    super(e), this._isFocusChanging = !1, this.domEventType = ["focus", "blur"], this.useCapture = !0;
    const t = this.document;
    t.on("focus", () => {
      this._isFocusChanging = !0, this._renderTimeoutId = setTimeout(() => {
        this.flush(), e.change(() => {
        });
      }, 50);
    }), t.on("blur", (n, r) => {
      const s = t.selection.editableElement;
      (s === null || s === r.target) && (t.isFocused = !1, this._isFocusChanging = !1, e.change(() => {
      }));
    });
  }
  /**
   * Finishes setting the document focus state.
   */
  flush() {
    this._isFocusChanging && (this._isFocusChanging = !1, this.document.isFocused = !0);
  }
  /**
   * @inheritDoc
   */
  onDomEvent(e) {
    this.fire(e.type, e);
  }
  /**
   * @inheritDoc
   */
  destroy() {
    this._renderTimeoutId && clearTimeout(this._renderTimeoutId), super.destroy();
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class zV extends dr {
  constructor(e) {
    super(e), this.mutationObserver = e.getObserver(UE), this.focusObserver = e.getObserver(fg), this.selection = this.document.selection, this.domConverter = e.domConverter, this._documents = /* @__PURE__ */ new WeakSet(), this._fireSelectionChangeDoneDebounced = $o((t) => {
      this.document.fire("selectionChangeDone", t);
    }, 200), this._clearInfiniteLoopInterval = setInterval(() => this._clearInfiniteLoop(), 1e3), this._documentIsSelectingInactivityTimeoutDebounced = $o(() => this.document.isSelecting = !1, 5e3), this._loopbackCounter = 0;
  }
  /**
   * @inheritDoc
   */
  observe(e) {
    const t = e.ownerDocument, n = () => {
      this.document.isSelecting = !0, this._documentIsSelectingInactivityTimeoutDebounced();
    }, r = () => {
      this.document.isSelecting && (this._handleSelectionChange(null, t), this.document.isSelecting = !1, this._documentIsSelectingInactivityTimeoutDebounced.cancel());
    };
    this.listenTo(e, "selectstart", n, { priority: "highest" }), this.listenTo(e, "keydown", r, { priority: "highest", useCapture: !0 }), this.listenTo(e, "keyup", r, { priority: "highest", useCapture: !0 }), !this._documents.has(t) && (this.listenTo(t, "mouseup", r, { priority: "highest", useCapture: !0 }), this.listenTo(t, "selectionchange", (s, o) => {
      this.document.isComposing && !qe.isAndroid || (this._handleSelectionChange(o, t), this._documentIsSelectingInactivityTimeoutDebounced());
    }), this._documents.add(t));
  }
  /**
   * @inheritDoc
   */
  stopObserving(e) {
    this.stopListening(e);
  }
  /**
   * @inheritDoc
   */
  destroy() {
    super.destroy(), clearInterval(this._clearInfiniteLoopInterval), this._fireSelectionChangeDoneDebounced.cancel(), this._documentIsSelectingInactivityTimeoutDebounced.cancel();
  }
  /* istanbul ignore next -- @preserve */
  _reportInfiniteLoop() {
  }
  /**
   * Selection change listener. {@link module:engine/view/observer/mutationobserver~MutationObserver#flush Flush} mutations, check if
   * a selection changes and fires {@link module:engine/view/document~Document#event:selectionChange} event on every change
   * and {@link module:engine/view/document~Document#event:selectionChangeDone} when a selection stop changing.
   *
   * @param domEvent DOM event.
   * @param domDocument DOM document.
   */
  _handleSelectionChange(e, t) {
    if (!this.isEnabled)
      return;
    const n = t.defaultView.getSelection();
    if (this.checkShouldIgnoreEventFromTarget(n.anchorNode))
      return;
    this.mutationObserver.flush();
    const r = this.domConverter.domSelectionToView(n);
    if (r.rangeCount == 0) {
      this.view.hasDomSelection = !1;
      return;
    }
    if (this.view.hasDomSelection = !0, !(this.selection.isEqual(r) && this.domConverter.isDomSelectionCorrect(n))) {
      if (++this._loopbackCounter > 60) {
        this._reportInfiniteLoop();
        return;
      }
      if (this.focusObserver.flush(), this.selection.isSimilar(r))
        this.view.forceRender();
      else {
        const s = {
          oldSelection: this.selection,
          newSelection: r,
          domSelection: n
        };
        this.document.fire("selectionChange", s), this._fireSelectionChangeDoneDebounced(s);
      }
    }
  }
  /**
   * Clears `SelectionObserver` internal properties connected with preventing infinite loop.
   */
  _clearInfiniteLoop() {
    this._loopbackCounter = 0;
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class WV extends qs {
  /**
   * @inheritDoc
   */
  constructor(e) {
    super(e), this.domEventType = ["compositionstart", "compositionupdate", "compositionend"];
    const t = this.document;
    t.on("compositionstart", () => {
      t.isComposing = !0;
    }, { priority: "low" }), t.on("compositionend", () => {
      t.isComposing = !1;
    }, { priority: "low" });
  }
  /**
   * @inheritDoc
   */
  onDomEvent(e) {
    this.fire(e.type, e, {
      data: e.data
    });
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class HE {
  /**
   * @param nativeDataTransfer The native [`DataTransfer`](https://developer.mozilla.org/en-US/docs/Web/API/DataTransfer) object.
   * @param options.cacheFiles Whether `files` list should be initialized in the constructor.
   */
  constructor(e, t = {}) {
    this._files = t.cacheFiles ? ib(e) : null, this._native = e;
  }
  /**
   * The array of files created from the native `DataTransfer#files` or `DataTransfer#items`.
   */
  get files() {
    return this._files || (this._files = ib(this._native)), this._files;
  }
  /**
   * Returns an array of available native content types.
   */
  get types() {
    return this._native.types;
  }
  /**
   * Gets the data from the data transfer by its MIME type.
   *
   * ```ts
   * dataTransfer.getData( 'text/plain' );
   * ```
   *
   * @param type The MIME type. E.g. `text/html` or `text/plain`.
   */
  getData(e) {
    return this._native.getData(e);
  }
  /**
   * Sets the data in the data transfer.
   *
   * @param type The MIME type. E.g. `text/html` or `text/plain`.
   */
  setData(e, t) {
    this._native.setData(e, t);
  }
  /**
   * The effect that is allowed for a drag operation.
   */
  set effectAllowed(e) {
    this._native.effectAllowed = e;
  }
  get effectAllowed() {
    return this._native.effectAllowed;
  }
  /**
   * The actual drop effect.
   */
  set dropEffect(e) {
    this._native.dropEffect = e;
  }
  get dropEffect() {
    return this._native.dropEffect;
  }
  /**
   * Whether the dragging operation was canceled.
   */
  get isCanceled() {
    return this._native.dropEffect == "none" || !!this._native.mozUserCancelled;
  }
}
function ib(i) {
  const e = Array.from(i.files || []), t = Array.from(i.items || []);
  return e.length ? e : t.filter((n) => n.kind === "file").map((n) => n.getAsFile());
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class jV extends qs {
  constructor() {
    super(...arguments), this.domEventType = "beforeinput";
  }
  /**
   * @inheritDoc
   */
  onDomEvent(e) {
    const t = e.getTargetRanges(), n = this.view, r = n.document;
    let s = null, o = null, l = [];
    if (e.dataTransfer && (s = new HE(e.dataTransfer)), e.data !== null ? o = e.data : s && (o = s.getData("text/plain")), r.selection.isFake)
      l = Array.from(r.selection.getRanges());
    else if (t.length)
      l = t.map((u) => n.domConverter.domRangeToView(u));
    else if (qe.isAndroid) {
      const u = e.target.ownerDocument.defaultView.getSelection();
      l = Array.from(n.domConverter.domSelectionToView(u).getRanges());
    }
    if (qe.isAndroid && e.inputType == "insertCompositionText" && o && o.endsWith(`
`)) {
      this.fire(e.type, e, {
        inputType: "insertParagraph",
        targetRanges: [n.createRange(l[0].end)]
      });
      return;
    }
    if (e.inputType == "insertText" && o && o.includes(`
`)) {
      const u = o.split(/\n{1,2}/g);
      let h = l;
      for (let f = 0; f < u.length; f++) {
        const m = u[f];
        m != "" && (this.fire(e.type, e, {
          data: m,
          dataTransfer: s,
          targetRanges: h,
          inputType: e.inputType,
          isComposing: e.isComposing
        }), h = [r.selection.getFirstRange()]), f + 1 < u.length && (this.fire(e.type, e, {
          inputType: "insertParagraph",
          targetRanges: h
        }), h = [r.selection.getFirstRange()]);
      }
      return;
    }
    this.fire(e.type, e, {
      data: o,
      dataTransfer: s,
      targetRanges: l,
      inputType: e.inputType,
      isComposing: e.isComposing
    });
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class UV extends dr {
  /**
   * @inheritDoc
   */
  constructor(e) {
    super(e), this.document.on("keydown", (t, n) => {
      if (this.isEnabled && RB(n.keyCode)) {
        const r = new Qo(this.document, "arrowKey", this.document.selection.getFirstRange());
        this.document.fire(r, n), r.stop.called && t.stop();
      }
    });
  }
  /**
   * @inheritDoc
   */
  observe() {
  }
  /**
   * @inheritDoc
   */
  stopObserving() {
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class HV extends dr {
  /**
   * @inheritDoc
   */
  constructor(e) {
    super(e);
    const t = this.document;
    t.on("keydown", (n, r) => {
      if (!this.isEnabled || r.keyCode != tt.tab || r.ctrlKey)
        return;
      const s = new Qo(t, "tab", t.selection.getFirstRange());
      t.fire(s, r), s.stop.called && n.stop();
    });
  }
  /**
   * @inheritDoc
   */
  observe() {
  }
  /**
   * @inheritDoc
   */
  stopObserving() {
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
let qV = class extends Nt() {
  /**
   * @param stylesProcessor The styles processor instance.
   */
  constructor(e) {
    super(), this.domRoots = /* @__PURE__ */ new Map(), this._initialDomRootAttributes = /* @__PURE__ */ new WeakMap(), this._observers = /* @__PURE__ */ new Map(), this._ongoingChange = !1, this._postFixersInProgress = !1, this._renderingDisabled = !1, this._hasChangedSinceTheLastRendering = !1, this.document = new DE(e), this.domConverter = new WE(this.document), this.set("isRenderingInProgress", !1), this.set("hasDomSelection", !1), this._renderer = new TV(this.domConverter, this.document.selection), this._renderer.bind("isFocused", "isSelecting", "isComposing").to(this.document, "isFocused", "isSelecting", "isComposing"), this._writer = new VE(this.document), this.addObserver(UE), this.addObserver(fg), this.addObserver(zV), this.addObserver(LV), this.addObserver(FV), this.addObserver(WV), this.addObserver(UV), this.addObserver(jV), this.addObserver(HV), CV(this), gV(this), this.on("render", () => {
      this._render(), this.document.fire("layoutChanged"), this._hasChangedSinceTheLastRendering = !1;
    }), this.listenTo(this.document.selection, "change", () => {
      this._hasChangedSinceTheLastRendering = !0;
    }), this.listenTo(this.document, "change:isFocused", () => {
      this._hasChangedSinceTheLastRendering = !0;
    });
  }
  /**
   * Attaches a DOM root element to the view element and enable all observers on that element.
   * Also {@link module:engine/view/renderer~Renderer#markToSync mark element} to be synchronized
   * with the view what means that all child nodes will be removed and replaced with content of the view root.
   *
   * This method also will change view element name as the same as tag name of given dom root.
   * Name is always transformed to lower case.
   *
   * **Note:** Use {@link #detachDomRoot `detachDomRoot()`} to revert this action.
   *
   * @param domRoot DOM root element.
   * @param name Name of the root.
   */
  attachDomRoot(e, t = "main") {
    const n = this.document.getRoot(t);
    n._name = e.tagName.toLowerCase();
    const r = {};
    for (const { name: o, value: l } of Array.from(e.attributes))
      r[o] = l, o === "class" ? this._writer.addClass(l.split(" "), n) : this._writer.setAttribute(o, l, n);
    this._initialDomRootAttributes.set(e, r);
    const s = () => {
      this._writer.setAttribute("contenteditable", (!n.isReadOnly).toString(), n), n.isReadOnly ? this._writer.addClass("ck-read-only", n) : this._writer.removeClass("ck-read-only", n);
    };
    s(), this.domRoots.set(t, e), this.domConverter.bindElements(e, n), this._renderer.markToSync("children", n), this._renderer.markToSync("attributes", n), this._renderer.domDocuments.add(e.ownerDocument), n.on("change:children", (o, l) => this._renderer.markToSync("children", l)), n.on("change:attributes", (o, l) => this._renderer.markToSync("attributes", l)), n.on("change:text", (o, l) => this._renderer.markToSync("text", l)), n.on("change:isReadOnly", () => this.change(s)), n.on("change", () => {
      this._hasChangedSinceTheLastRendering = !0;
    });
    for (const o of this._observers.values())
      o.observe(e, t);
  }
  /**
   * Detaches a DOM root element from the view element and restores its attributes to the state before
   * {@link #attachDomRoot `attachDomRoot()`}.
   *
   * @param name Name of the root to detach.
   */
  detachDomRoot(e) {
    const t = this.domRoots.get(e);
    Array.from(t.attributes).forEach(({ name: r }) => t.removeAttribute(r));
    const n = this._initialDomRootAttributes.get(t);
    for (const r in n)
      t.setAttribute(r, n[r]);
    this.domRoots.delete(e), this.domConverter.unbindDomElement(t);
    for (const r of this._observers.values())
      r.stopObserving(t);
  }
  /**
   * Gets DOM root element.
   *
   * @param name  Name of the root.
   * @returns DOM root element instance.
   */
  getDomRoot(e = "main") {
    return this.domRoots.get(e);
  }
  /**
   * Creates observer of the given type if not yet created, {@link module:engine/view/observer/observer~Observer#enable enables} it
   * and {@link module:engine/view/observer/observer~Observer#observe attaches} to all existing and future
   * {@link #domRoots DOM roots}.
   *
   * Note: Observers are recognized by their constructor (classes). A single observer will be instantiated and used only
   * when registered for the first time. This means that features and other components can register a single observer
   * multiple times without caring whether it has been already added or not.
   *
   * @param ObserverConstructor The constructor of an observer to add.
   * Should create an instance inheriting from {@link module:engine/view/observer/observer~Observer}.
   * @returns Added observer instance.
   */
  addObserver(e) {
    let t = this._observers.get(e);
    if (t)
      return t;
    t = new e(this), this._observers.set(e, t);
    for (const [n, r] of this.domRoots)
      t.observe(r, n);
    return t.enable(), t;
  }
  /**
   * Returns observer of the given type or `undefined` if such observer has not been added yet.
   *
   * @param ObserverConstructor The constructor of an observer to get.
   * @returns Observer instance or undefined.
   */
  getObserver(e) {
    return this._observers.get(e);
  }
  /**
   * Disables all added observers.
   */
  disableObservers() {
    for (const e of this._observers.values())
      e.disable();
  }
  /**
   * Enables all added observers.
   */
  enableObservers() {
    for (const e of this._observers.values())
      e.enable();
  }
  /**
   * Scrolls the page viewport and {@link #domRoots} with their ancestors to reveal the
   * caret, **if not already visible to the user**.
   *
   * @param options Additional configuration of the scrolling behavior.
   * @param options.viewportOffset A distance between the DOM selection and the viewport boundary to be maintained
   * while scrolling to the selection (default is 20px). Setting this value to `0` will reveal the selection precisely at
   * the viewport boundary.
   * @param options.ancestorOffset A distance between the DOM selection and scrollable DOM root ancestor(s) to be maintained
   * while scrolling to the selection (default is 20px). Setting this value to `0` will reveal the selection precisely at
   * the scrollable ancestor(s) boundary.
   * @param options.alignToTop When set `true`, the DOM selection will be aligned to the top of the viewport if not already visible
   * (see `forceScroll` to learn more).
   * @param options.forceScroll When set `true`, the DOM selection will be aligned to the top of the viewport and scrollable ancestors
   * whether it is already visible or not. This option will only work when `alignToTop` is `true`.
   */
  scrollToTheSelection({ alignToTop: e, forceScroll: t, viewportOffset: n = 20, ancestorOffset: r = 20 } = {}) {
    const s = this.document.selection.getFirstRange();
    s && TB({
      target: this.domConverter.viewRangeToDom(s),
      viewportOffset: n,
      ancestorOffset: r,
      alignToTop: e,
      forceScroll: t
    });
  }
  /**
   * It will focus DOM element representing {@link module:engine/view/editableelement~EditableElement EditableElement}
   * that is currently having selection inside.
   */
  focus() {
    if (!this.document.isFocused) {
      const e = this.document.selection.editableElement;
      e && (this.domConverter.focus(e), this.forceRender());
    }
  }
  /**
   * The `change()` method is the primary way of changing the view. You should use it to modify any node in the view tree.
   * It makes sure that after all changes are made the view is rendered to the DOM (assuming that the view will be changed
   * inside the callback). It prevents situations when the DOM is updated when the view state is not yet correct. It allows
   * to nest calls one inside another and still performs a single rendering after all those changes are made.
   * It also returns the return value of its callback.
   *
   * ```ts
   * const text = view.change( writer => {
   * 	const newText = writer.createText( 'foo' );
   * 	writer.insert( position1, newText );
   *
   * 	view.change( writer => {
   * 		writer.insert( position2, writer.createText( 'bar' ) );
   * 	} );
   *
   * 	writer.remove( range );
   *
   * 	return newText;
   * } );
   * ```
   *
   * When the outermost change block is done and rendering to the DOM is over the
   * {@link module:engine/view/view~View#event:render `View#render`} event is fired.
   *
   * This method throws a `applying-view-changes-on-rendering` error when
   * the change block is used after rendering to the DOM has started.
   *
   * @param callback Callback function which may modify the view.
   * @returns Value returned by the callback.
   */
  change(e) {
    if (this.isRenderingInProgress || this._postFixersInProgress)
      throw new B("cannot-change-view-tree", this);
    try {
      if (this._ongoingChange)
        return e(this._writer);
      this._ongoingChange = !0;
      const t = e(this._writer);
      return this._ongoingChange = !1, !this._renderingDisabled && this._hasChangedSinceTheLastRendering && (this._postFixersInProgress = !0, this.document._callPostFixers(this._writer), this._postFixersInProgress = !1, this.fire("render")), t;
    } catch (t) {
      /* istanbul ignore next -- @preserve */
      B.rethrowUnexpectedError(t, this);
    }
  }
  /**
   * Forces rendering {@link module:engine/view/document~Document view document} to DOM. If any view changes are
   * currently in progress, rendering will start after all {@link #change change blocks} are processed.
   *
   * Note that this method is dedicated for special cases. All view changes should be wrapped in the {@link #change}
   * block and the view will automatically check whether it needs to render DOM or not.
   *
   * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `applying-view-changes-on-rendering` when
   * trying to re-render when rendering to DOM has already started.
   */
  forceRender() {
    this._hasChangedSinceTheLastRendering = !0, this.getObserver(fg).flush(), this.change(() => {
    });
  }
  /**
   * Destroys this instance. Makes sure that all observers are destroyed and listeners removed.
   */
  destroy() {
    for (const e of this._observers.values())
      e.destroy();
    this.document.destroy(), this.stopListening();
  }
  /**
   * Creates position at the given location. The location can be specified as:
   *
   * * a {@link module:engine/view/position~Position position},
   * * parent element and offset (offset defaults to `0`),
   * * parent element and `'end'` (sets position at the end of that element),
   * * {@link module:engine/view/item~Item view item} and `'before'` or `'after'` (sets position before or after given view item).
   *
   * This method is a shortcut to other constructors such as:
   *
   * * {@link #createPositionBefore},
   * * {@link #createPositionAfter},
   *
   * @param offset Offset or one of the flags. Used only when first parameter is a {@link module:engine/view/item~Item view item}.
   */
  createPositionAt(e, t) {
    return _e._createAt(e, t);
  }
  /**
   * Creates a new position after given view item.
   *
   * @param item View item after which the position should be located.
   */
  createPositionAfter(e) {
    return _e._createAfter(e);
  }
  /**
   * Creates a new position before given view item.
   *
   * @param item View item before which the position should be located.
   */
  createPositionBefore(e) {
    return _e._createBefore(e);
  }
  /**
   * Creates a range spanning from `start` position to `end` position.
   *
   * **Note:** This factory method creates it's own {@link module:engine/view/position~Position} instances basing on passed values.
   *
   * @param start Start position.
   * @param end End position. If not set, range will be collapsed at `start` position.
   */
  createRange(e, t) {
    return new We(e, t);
  }
  /**
   * Creates a range that starts before given {@link module:engine/view/item~Item view item} and ends after it.
   */
  createRangeOn(e) {
    return We._createOn(e);
  }
  /**
   * Creates a range inside an {@link module:engine/view/element~Element element} which starts before the first child of
   * that element and ends after the last child of that element.
   *
   * @param element Element which is a parent for the range.
   */
  createRangeIn(e) {
    return We._createIn(e);
  }
  createSelection(...e) {
    return new is(...e);
  }
  /**
   * Disables or enables rendering. If the flag is set to `true` then the rendering will be disabled.
   * If the flag is set to `false` and if there was some change in the meantime, then the rendering action will be performed.
   *
   * @internal
   * @param flag A flag indicates whether the rendering should be disabled.
   */
  _disableRendering(e) {
    this._renderingDisabled = e, e == !1 && this.change(() => {
    });
  }
  /**
   * Renders all changes. In order to avoid triggering the observers (e.g. selection) all observers are disabled
   * before rendering and re-enabled after that.
   */
  _render() {
    this.isRenderingInProgress = !0, this.disableObservers(), this._renderer.render(), this.enableObservers(), this.isRenderingInProgress = !1;
  }
};
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class ls {
  /* istanbul ignore next -- @preserve */
  is() {
    throw new Error("is() method is abstract");
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
let Ks = class extends ls {
  /**
   * Creates a model node.
   *
   * This is an abstract class, so this constructor should not be used directly.
   *
   * @param attrs Node's attributes. See {@link module:utils/tomap~toMap} for a list of accepted values.
   */
  constructor(e) {
    super(), this.parent = null, this._attrs = Or(e);
  }
  /**
   * {@link module:engine/model/document~Document Document} that owns this root element.
   */
  get document() {
    return null;
  }
  /**
   * Index of this node in its parent or `null` if the node has no parent.
   *
   * Accessing this property throws an error if this node's parent element does not contain it.
   * This means that model tree got broken.
   */
  get index() {
    let e;
    if (!this.parent)
      return null;
    if ((e = this.parent.getChildIndex(this)) === null)
      throw new B("model-node-not-found-in-parent", this);
    return e;
  }
  /**
   * Offset at which this node starts in its parent. It is equal to the sum of {@link #offsetSize offsetSize}
   * of all its previous siblings. Equals to `null` if node has no parent.
   *
   * Accessing this property throws an error if this node's parent element does not contain it.
   * This means that model tree got broken.
   */
  get startOffset() {
    let e;
    if (!this.parent)
      return null;
    if ((e = this.parent.getChildStartOffset(this)) === null)
      throw new B("model-node-not-found-in-parent", this);
    return e;
  }
  /**
   * Offset size of this node. Represents how much "offset space" is occupied by the node in it's parent.
   * It is important for {@link module:engine/model/position~Position position}. When node has `offsetSize` greater than `1`, position
   * can be placed between that node start and end. `offsetSize` greater than `1` is for nodes that represents more
   * than one entity, i.e. {@link module:engine/model/text~Text text node}.
   */
  get offsetSize() {
    return 1;
  }
  /**
   * Offset at which this node ends in it's parent. It is equal to the sum of this node's
   * {@link module:engine/model/node~Node#startOffset start offset} and {@link #offsetSize offset size}.
   * Equals to `null` if the node has no parent.
   */
  get endOffset() {
    return this.parent ? this.startOffset + this.offsetSize : null;
  }
  /**
   * Node's next sibling or `null` if the node is a last child of it's parent or if the node has no parent.
   */
  get nextSibling() {
    const e = this.index;
    return e !== null && this.parent.getChild(e + 1) || null;
  }
  /**
   * Node's previous sibling or `null` if the node is a first child of it's parent or if the node has no parent.
   */
  get previousSibling() {
    const e = this.index;
    return e !== null && this.parent.getChild(e - 1) || null;
  }
  /**
   * The top-most ancestor of the node. If node has no parent it is the root itself. If the node is a part
   * of {@link module:engine/model/documentfragment~DocumentFragment}, it's `root` is equal to that `DocumentFragment`.
   */
  get root() {
    let e = this;
    for (; e.parent; )
      e = e.parent;
    return e;
  }
  /**
   * Returns `true` if the node is inside a document root that is attached to the document.
   */
  isAttached() {
    return this.parent === null ? !1 : this.root.isAttached();
  }
  /**
   * Gets path to the node. The path is an array containing starting offsets of consecutive ancestors of this node,
   * beginning from {@link module:engine/model/node~Node#root root}, down to this node's starting offset. The path can be used to
   * create {@link module:engine/model/position~Position Position} instance.
   *
   * ```ts
   * const abc = new Text( 'abc' );
   * const foo = new Text( 'foo' );
   * const h1 = new Element( 'h1', null, new Text( 'header' ) );
   * const p = new Element( 'p', null, [ abc, foo ] );
   * const div = new Element( 'div', null, [ h1, p ] );
   * foo.getPath(); // Returns [ 1, 3 ]. `foo` is in `p` which is in `div`. `p` starts at offset 1, while `foo` at 3.
   * h1.getPath(); // Returns [ 0 ].
   * div.getPath(); // Returns [].
   * ```
   */
  getPath() {
    const e = [];
    let t = this;
    for (; t.parent; )
      e.unshift(t.startOffset), t = t.parent;
    return e;
  }
  /**
   * Returns ancestors array of this node.
   *
   * @param options Options object.
   * @param options.includeSelf When set to `true` this node will be also included in parent's array.
   * @param options.parentFirst When set to `true`, array will be sorted from node's parent to root element,
   * otherwise root element will be the first item in the array.
   * @returns Array with ancestors.
   */
  getAncestors(e = {}) {
    const t = [];
    let n = e.includeSelf ? this : this.parent;
    for (; n; )
      t[e.parentFirst ? "push" : "unshift"](n), n = n.parent;
    return t;
  }
  /**
   * Returns a {@link module:engine/model/element~Element} or {@link module:engine/model/documentfragment~DocumentFragment}
   * which is a common ancestor of both nodes.
   *
   * @param node The second node.
   * @param options Options object.
   * @param options.includeSelf When set to `true` both nodes will be considered "ancestors" too.
   * Which means that if e.g. node A is inside B, then their common ancestor will be B.
   */
  getCommonAncestor(e, t = {}) {
    const n = this.getAncestors(t), r = e.getAncestors(t);
    let s = 0;
    for (; n[s] == r[s] && n[s]; )
      s++;
    return s === 0 ? null : n[s - 1];
  }
  /**
   * Returns whether this node is before given node. `false` is returned if nodes are in different trees (for example,
   * in different {@link module:engine/model/documentfragment~DocumentFragment}s).
   *
   * @param node Node to compare with.
   */
  isBefore(e) {
    if (this == e || this.root !== e.root)
      return !1;
    const t = this.getPath(), n = e.getPath(), r = Pn(t, n);
    switch (r) {
      case "prefix":
        return !0;
      case "extension":
        return !1;
      default:
        return t[r] < n[r];
    }
  }
  /**
   * Returns whether this node is after given node. `false` is returned if nodes are in different trees (for example,
   * in different {@link module:engine/model/documentfragment~DocumentFragment}s).
   *
   * @param node Node to compare with.
   */
  isAfter(e) {
    return this == e || this.root !== e.root ? !1 : !this.isBefore(e);
  }
  /**
   * Checks if the node has an attribute with given key.
   *
   * @param key Key of attribute to check.
   * @returns `true` if attribute with given key is set on node, `false` otherwise.
   */
  hasAttribute(e) {
    return this._attrs.has(e);
  }
  /**
   * Gets an attribute value for given key or `undefined` if that attribute is not set on node.
   *
   * @param key Key of attribute to look for.
   * @returns Attribute value or `undefined`.
   */
  getAttribute(e) {
    return this._attrs.get(e);
  }
  /**
   * Returns iterator that iterates over this node's attributes.
   *
   * Attributes are returned as arrays containing two items. First one is attribute key and second is attribute value.
   * This format is accepted by native `Map` object and also can be passed in `Node` constructor.
   */
  getAttributes() {
    return this._attrs.entries();
  }
  /**
   * Returns iterator that iterates over this node's attribute keys.
   */
  getAttributeKeys() {
    return this._attrs.keys();
  }
  /**
   * Converts `Node` to plain object and returns it.
   *
   * @returns `Node` converted to plain object.
   */
  toJSON() {
    const e = {};
    return this._attrs.size && (e.attributes = Array.from(this._attrs).reduce((t, n) => (t[n[0]] = n[1], t), {})), e;
  }
  /**
   * Creates a copy of this node, that is a node with exactly same attributes, and returns it.
   *
   * @internal
   * @returns Node with same attributes as this node.
   */
  _clone(e) {
    return new this.constructor(this._attrs);
  }
  /**
   * Removes this node from it's parent.
   *
   * @internal
   * @see module:engine/model/writer~Writer#remove
   */
  _remove() {
    this.parent._removeChildren(this.index);
  }
  /**
   * Sets attribute on the node. If attribute with the same key already is set, it's value is overwritten.
   *
   * @see module:engine/model/writer~Writer#setAttribute
   * @internal
   * @param key Key of attribute to set.
   * @param value Attribute value.
   */
  _setAttribute(e, t) {
    this._attrs.set(e, t);
  }
  /**
   * Removes all attributes from the node and sets given attributes.
   *
   * @see module:engine/model/writer~Writer#setAttributes
   * @internal
   * @param attrs Attributes to set. See {@link module:utils/tomap~toMap} for a list of accepted values.
   */
  _setAttributesTo(e) {
    this._attrs = Or(e);
  }
  /**
   * Removes an attribute with given key from the node.
   *
   * @see module:engine/model/writer~Writer#removeAttribute
   * @internal
   * @param key Key of attribute to remove.
   * @returns `true` if the attribute was set on the element, `false` otherwise.
   */
  _removeAttribute(e) {
    return this._attrs.delete(e);
  }
  /**
   * Removes all attributes from the node.
   *
   * @see module:engine/model/writer~Writer#clearAttributes
   * @internal
   */
  _clearAttributes() {
    this._attrs.clear();
  }
};
Ks.prototype.is = function(i) {
  return i === "node" || i === "model:node";
};
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class dl {
  /**
   * Creates an empty node list.
   *
   * @internal
   * @param nodes Nodes contained in this node list.
   */
  constructor(e) {
    this._nodes = [], e && this._insertNodes(0, e);
  }
  /**
   * Iterable interface.
   *
   * Iterates over all nodes contained inside this node list.
   */
  [Symbol.iterator]() {
    return this._nodes[Symbol.iterator]();
  }
  /**
   * Number of nodes contained inside this node list.
   */
  get length() {
    return this._nodes.length;
  }
  /**
   * Sum of {@link module:engine/model/node~Node#offsetSize offset sizes} of all nodes contained inside this node list.
   */
  get maxOffset() {
    return this._nodes.reduce((e, t) => e + t.offsetSize, 0);
  }
  /**
   * Gets the node at the given index. Returns `null` if incorrect index was passed.
   */
  getNode(e) {
    return this._nodes[e] || null;
  }
  /**
   * Returns an index of the given node. Returns `null` if given node is not inside this node list.
   */
  getNodeIndex(e) {
    const t = this._nodes.indexOf(e);
    return t == -1 ? null : t;
  }
  /**
   * Returns the starting offset of given node. Starting offset is equal to the sum of
   * {@link module:engine/model/node~Node#offsetSize offset sizes} of all nodes that are before this node in this node list.
   */
  getNodeStartOffset(e) {
    const t = this.getNodeIndex(e);
    return t === null ? null : this._nodes.slice(0, t).reduce((n, r) => n + r.offsetSize, 0);
  }
  /**
   * Converts index to offset in node list.
   *
   * Returns starting offset of a node that is at given index. Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError}
   * `model-nodelist-index-out-of-bounds` if given index is less than `0` or more than {@link #length}.
   */
  indexToOffset(e) {
    if (e == this._nodes.length)
      return this.maxOffset;
    const t = this._nodes[e];
    if (!t)
      throw new B("model-nodelist-index-out-of-bounds", this);
    return this.getNodeStartOffset(t);
  }
  /**
   * Converts offset in node list to index.
   *
   * Returns index of a node that occupies given offset. Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError}
   * `model-nodelist-offset-out-of-bounds` if given offset is less than `0` or more than {@link #maxOffset}.
   */
  offsetToIndex(e) {
    let t = 0;
    for (const n of this._nodes) {
      if (e >= t && e < t + n.offsetSize)
        return this.getNodeIndex(n);
      t += n.offsetSize;
    }
    if (t != e)
      throw new B("model-nodelist-offset-out-of-bounds", this, {
        offset: e,
        nodeList: this
      });
    return this.length;
  }
  /**
   * Inserts given nodes at given index.
   *
   * @internal
   * @param index Index at which nodes should be inserted.
   * @param nodes Nodes to be inserted.
   */
  _insertNodes(e, t) {
    for (const n of t)
      if (!(n instanceof Ks))
        throw new B("model-nodelist-insertnodes-not-node", this);
    this._nodes = UB(this._nodes, Array.from(t), e, 0);
  }
  /**
   * Removes one or more nodes starting at the given index.
   *
   * @internal
   * @param indexStart Index of the first node to remove.
   * @param howMany Number of nodes to remove.
   * @returns Array containing removed nodes.
   */
  _removeNodes(e, t = 1) {
    return this._nodes.splice(e, t);
  }
  /**
   * Converts `NodeList` instance to an array containing nodes that were inserted in the node list. Nodes
   * are also converted to their plain object representation.
   *
   * @returns `NodeList` instance converted to `Array`.
   */
  toJSON() {
    return this._nodes.map((e) => e.toJSON());
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
let Dt = class mg extends Ks {
  /**
   * Creates a text node.
   *
   * **Note:** Constructor of this class shouldn't be used directly in the code.
   * Use the {@link module:engine/model/writer~Writer#createText} method instead.
   *
   * @internal
   * @param data Node's text.
   * @param attrs Node's attributes. See {@link module:utils/tomap~toMap} for a list of accepted values.
   */
  constructor(e, t) {
    super(t), this._data = e || "";
  }
  /**
   * @inheritDoc
   */
  get offsetSize() {
    return this.data.length;
  }
  /**
   * Returns a text data contained in the node.
   */
  get data() {
    return this._data;
  }
  /**
   * Converts `Text` instance to plain object and returns it.
   *
   * @returns`Text` instance converted to plain object.
   */
  toJSON() {
    const e = super.toJSON();
    return e.data = this.data, e;
  }
  /**
   * Creates a copy of this text node and returns it. Created text node has same text data and attributes as original text node.
   *
   * @internal
   * @returns `Text` instance created using given plain object.
   */
  _clone() {
    return new mg(this.data, this.getAttributes());
  }
  /**
   * Creates a `Text` instance from given plain object (i.e. parsed JSON string).
   *
   * @param json Plain object to be converted to `Text`.
   * @returns `Text` instance created using given plain object.
   */
  static fromJSON(e) {
    return new mg(e.data, e.attributes);
  }
};
Dt.prototype.is = function(i) {
  return i === "$text" || i === "model:$text" || // This are legacy values kept for backward compatibility.
  i === "text" || i === "model:text" || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
  i === "node" || i === "model:node";
};
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class Bi extends ls {
  /**
   * Creates a text proxy.
   *
   * @internal
   * @param textNode Text node which part is represented by this text proxy.
   * @param offsetInText Offset in {@link module:engine/model/textproxy~TextProxy#textNode text node} from which the text proxy
   * starts.
   * @param length Text proxy length, that is how many text node's characters, starting from `offsetInText` it represents.
   */
  constructor(e, t, n) {
    if (super(), this.textNode = e, t < 0 || t > e.offsetSize)
      throw new B("model-textproxy-wrong-offsetintext", this);
    if (n < 0 || t + n > e.offsetSize)
      throw new B("model-textproxy-wrong-length", this);
    this.data = e.data.substring(t, t + n), this.offsetInText = t;
  }
  /**
   * Offset at which this text proxy starts in it's parent.
   *
   * @see module:engine/model/node~Node#startOffset
   */
  get startOffset() {
    return this.textNode.startOffset !== null ? this.textNode.startOffset + this.offsetInText : null;
  }
  /**
   * Offset size of this text proxy. Equal to the number of characters represented by the text proxy.
   *
   * @see module:engine/model/node~Node#offsetSize
   */
  get offsetSize() {
    return this.data.length;
  }
  /**
   * Offset at which this text proxy ends in it's parent.
   *
   * @see module:engine/model/node~Node#endOffset
   */
  get endOffset() {
    return this.startOffset !== null ? this.startOffset + this.offsetSize : null;
  }
  /**
   * Flag indicating whether `TextProxy` instance covers only part of the original {@link module:engine/model/text~Text text node}
   * (`true`) or the whole text node (`false`).
   *
   * This is `false` when text proxy starts at the very beginning of {@link module:engine/model/textproxy~TextProxy#textNode textNode}
   * ({@link module:engine/model/textproxy~TextProxy#offsetInText offsetInText} equals `0`) and text proxy sizes is equal to
   * text node size.
   */
  get isPartial() {
    return this.offsetSize !== this.textNode.offsetSize;
  }
  /**
   * Parent of this text proxy, which is same as parent of text node represented by this text proxy.
   */
  get parent() {
    return this.textNode.parent;
  }
  /**
   * Root of this text proxy, which is same as root of text node represented by this text proxy.
   */
  get root() {
    return this.textNode.root;
  }
  /**
   * Gets path to this text proxy.
   *
   * @see module:engine/model/node~Node#getPath
   */
  getPath() {
    const e = this.textNode.getPath();
    return e.length > 0 && (e[e.length - 1] += this.offsetInText), e;
  }
  /**
   * Returns ancestors array of this text proxy.
   *
   * @param options Options object.
   * @param options.includeSelf When set to `true` this text proxy will be also included in parent's array.
   * @param options.parentFirst When set to `true`, array will be sorted from text proxy parent to root element,
   * otherwise root element will be the first item in the array.
   * @returns Array with ancestors.
   */
  getAncestors(e = {}) {
    const t = [];
    let n = e.includeSelf ? this : this.parent;
    for (; n; )
      t[e.parentFirst ? "push" : "unshift"](n), n = n.parent;
    return t;
  }
  /**
   * Checks if this text proxy has an attribute for given key.
   *
   * @param key Key of attribute to check.
   * @returns `true` if attribute with given key is set on text proxy, `false` otherwise.
   */
  hasAttribute(e) {
    return this.textNode.hasAttribute(e);
  }
  /**
   * Gets an attribute value for given key or `undefined` if that attribute is not set on text proxy.
   *
   * @param key Key of attribute to look for.
   * @returns Attribute value or `undefined`.
   */
  getAttribute(e) {
    return this.textNode.getAttribute(e);
  }
  /**
   * Returns iterator that iterates over this node's attributes. Attributes are returned as arrays containing two
   * items. First one is attribute key and second is attribute value.
   *
   * This format is accepted by native `Map` object and also can be passed in `Node` constructor.
   */
  getAttributes() {
    return this.textNode.getAttributes();
  }
  /**
   * Returns iterator that iterates over this node's attribute keys.
   */
  getAttributeKeys() {
    return this.textNode.getAttributeKeys();
  }
}
Bi.prototype.is = function(i) {
  return i === "$textProxy" || i === "model:$textProxy" || // This are legacy values kept for backward compatibility.
  i === "textProxy" || i === "model:textProxy";
};
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class gt extends Ks {
  /**
   * Creates a model element.
   *
   * **Note:** Constructor of this class shouldn't be used directly in the code.
   * Use the {@link module:engine/model/writer~Writer#createElement} method instead.
   *
   * @internal
   * @param name Element's name.
   * @param attrs Element's attributes. See {@link module:utils/tomap~toMap} for a list of accepted values.
   * @param children One or more nodes to be inserted as children of created element.
   */
  constructor(e, t, n) {
    super(t), this._children = new dl(), this.name = e, n && this._insertChild(0, n);
  }
  /**
   * Number of this element's children.
   */
  get childCount() {
    return this._children.length;
  }
  /**
   * Sum of {@link module:engine/model/node~Node#offsetSize offset sizes} of all of this element's children.
   */
  get maxOffset() {
    return this._children.maxOffset;
  }
  /**
   * Is `true` if there are no nodes inside this element, `false` otherwise.
   */
  get isEmpty() {
    return this.childCount === 0;
  }
  /**
   * Gets the child at the given index.
   */
  getChild(e) {
    return this._children.getNode(e);
  }
  /**
   * Returns an iterator that iterates over all of this element's children.
   */
  getChildren() {
    return this._children[Symbol.iterator]();
  }
  /**
   * Returns an index of the given child node. Returns `null` if given node is not a child of this element.
   *
   * @param node Child node to look for.
   * @returns Child node's index in this element.
   */
  getChildIndex(e) {
    return this._children.getNodeIndex(e);
  }
  /**
   * Returns the starting offset of given child. Starting offset is equal to the sum of
   * {@link module:engine/model/node~Node#offsetSize offset sizes} of all node's siblings that are before it. Returns `null` if
   * given node is not a child of this element.
   *
   * @param node Child node to look for.
   * @returns Child node's starting offset.
   */
  getChildStartOffset(e) {
    return this._children.getNodeStartOffset(e);
  }
  /**
   * Returns index of a node that occupies given offset. If given offset is too low, returns `0`. If given offset is
   * too high, returns {@link module:engine/model/element~Element#getChildIndex index after last child}.
   *
   * ```ts
   * const textNode = new Text( 'foo' );
   * const pElement = new Element( 'p' );
   * const divElement = new Element( [ textNode, pElement ] );
   * divElement.offsetToIndex( -1 ); // Returns 0, because offset is too low.
   * divElement.offsetToIndex( 0 ); // Returns 0, because offset 0 is taken by `textNode` which is at index 0.
   * divElement.offsetToIndex( 1 ); // Returns 0, because `textNode` has `offsetSize` equal to 3, so it occupies offset 1 too.
   * divElement.offsetToIndex( 2 ); // Returns 0.
   * divElement.offsetToIndex( 3 ); // Returns 1.
   * divElement.offsetToIndex( 4 ); // Returns 2. There are no nodes at offset 4, so last available index is returned.
   * ```
   */
  offsetToIndex(e) {
    return this._children.offsetToIndex(e);
  }
  /**
   * Returns a descendant node by its path relative to this element.
   *
   * ```ts
   * // <this>a<b>c</b></this>
   * this.getNodeByPath( [ 0 ] );     // -> "a"
   * this.getNodeByPath( [ 1 ] );     // -> <b>
   * this.getNodeByPath( [ 1, 0 ] );  // -> "c"
   * ```
   *
   * @param relativePath Path of the node to find, relative to this element.
   */
  getNodeByPath(e) {
    let t = this;
    for (const n of e)
      t = t.getChild(t.offsetToIndex(n));
    return t;
  }
  /**
   * Returns the parent element of the given name. Returns null if the element is not inside the desired parent.
   *
   * @param parentName The name of the parent element to find.
   * @param options Options object.
   * @param options.includeSelf When set to `true` this node will be also included while searching.
   */
  findAncestor(e, t = {}) {
    let n = t.includeSelf ? this : this.parent;
    for (; n; ) {
      if (n.name === e)
        return n;
      n = n.parent;
    }
    return null;
  }
  /**
   * Converts `Element` instance to plain object and returns it. Takes care of converting all of this element's children.
   *
   * @returns `Element` instance converted to plain object.
   */
  toJSON() {
    const e = super.toJSON();
    if (e.name = this.name, this._children.length > 0) {
      e.children = [];
      for (const t of this._children)
        e.children.push(t.toJSON());
    }
    return e;
  }
  /**
   * Creates a copy of this element and returns it. Created element has the same name and attributes as the original element.
   * If clone is deep, the original element's children are also cloned. If not, then empty element is returned.
   *
   * @internal
   * @param deep If set to `true` clones element and all its children recursively. When set to `false`,
   * element will be cloned without any child.
   */
  _clone(e = !1) {
    const t = e ? Array.from(this._children).map((n) => n._clone(!0)) : void 0;
    return new gt(this.name, this.getAttributes(), t);
  }
  /**
   * {@link module:engine/model/element~Element#_insertChild Inserts} one or more nodes at the end of this element.
   *
   * @see module:engine/model/writer~Writer#append
   * @internal
   * @param nodes Nodes to be inserted.
   */
  _appendChild(e) {
    this._insertChild(this.childCount, e);
  }
  /**
   * Inserts one or more nodes at the given index and sets {@link module:engine/model/node~Node#parent parent} of these nodes
   * to this element.
   *
   * @see module:engine/model/writer~Writer#insert
   * @internal
   * @param index Index at which nodes should be inserted.
   * @param items Items to be inserted.
   */
  _insertChild(e, t) {
    const n = KV(t);
    for (const r of n)
      r.parent !== null && r._remove(), r.parent = this;
    this._children._insertNodes(e, n);
  }
  /**
   * Removes one or more nodes starting at the given index and sets
   * {@link module:engine/model/node~Node#parent parent} of these nodes to `null`.
   *
   * @see module:engine/model/writer~Writer#remove
   * @internal
   * @param index Index of the first node to remove.
   * @param howMany Number of nodes to remove.
   * @returns Array containing removed nodes.
   */
  _removeChildren(e, t = 1) {
    const n = this._children._removeNodes(e, t);
    for (const r of n)
      r.parent = null;
    return n;
  }
  /**
   * Creates an `Element` instance from given plain object (i.e. parsed JSON string).
   * Converts `Element` children to proper nodes.
   *
   * @param json Plain object to be converted to `Element`.
   * @returns `Element` instance created using given plain object.
   */
  static fromJSON(e) {
    let t;
    if (e.children) {
      t = [];
      for (const n of e.children)
        n.name ? t.push(gt.fromJSON(n)) : t.push(Dt.fromJSON(n));
    }
    return new gt(e.name, e.attributes, t);
  }
}
gt.prototype.is = function(i, e) {
  return e ? e === this.name && (i === "element" || i === "model:element") : i === "element" || i === "model:element" || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
  i === "node" || i === "model:node";
};
function KV(i) {
  return typeof i == "string" ? [new Dt(i)] : (di(i) || (i = [i]), Array.from(i).map((e) => typeof e == "string" ? new Dt(e) : e instanceof Bi ? new Dt(e.data, e.getAttributes()) : e));
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class ir {
  /**
   * Creates a range iterator. All parameters are optional, but you have to specify either `boundaries` or `startPosition`.
   *
   * @param options Object with configuration.
   */
  constructor(e) {
    if (!e || !e.boundaries && !e.startPosition)
      throw new B("model-tree-walker-no-start-position", null);
    const t = e.direction || "forward";
    if (t != "forward" && t != "backward")
      throw new B("model-tree-walker-unknown-direction", e, { direction: t });
    this.direction = t, this.boundaries = e.boundaries || null, e.startPosition ? this._position = e.startPosition.clone() : this._position = oe._createAt(this.boundaries[this.direction == "backward" ? "end" : "start"]), this.position.stickiness = "toNone", this.singleCharacters = !!e.singleCharacters, this.shallow = !!e.shallow, this.ignoreElementEnd = !!e.ignoreElementEnd, this._boundaryStartParent = this.boundaries ? this.boundaries.start.parent : null, this._boundaryEndParent = this.boundaries ? this.boundaries.end.parent : null, this._visitedParent = this.position.parent;
  }
  /**
   * Iterable interface.
   *
   * @returns {Iterable.<module:engine/model/treewalker~TreeWalkerValue>}
   */
  [Symbol.iterator]() {
    return this;
  }
  /**
   * Iterator position. This is always static position, even if the initial position was a
   * {@link module:engine/model/liveposition~LivePosition live position}. If start position is not defined then position depends
   * on {@link #direction}. If direction is `'forward'` position starts form the beginning, when direction
   * is `'backward'` position starts from the end.
   */
  get position() {
    return this._position;
  }
  /**
   * Moves {@link #position} in the {@link #direction} skipping values as long as the callback function returns `true`.
   *
   * For example:
   *
   * ```ts
   * walker.skip( value => value.type == 'text' ); // <paragraph>[]foo</paragraph> -> <paragraph>foo[]</paragraph>
   * walker.skip( () => true ); // Move the position to the end: <paragraph>[]foo</paragraph> -> <paragraph>foo</paragraph>[]
   * walker.skip( () => false ); // Do not move the position.
   * ```
   *
   * @param skip Callback function. Gets {@link module:engine/model/treewalker~TreeWalkerValue} and should
   * return `true` if the value should be skipped or `false` if not.
   */
  skip(e) {
    let t, n, r, s;
    do
      r = this.position, s = this._visitedParent, { done: t, value: n } = this.next();
    while (!t && e(n));
    t || (this._position = r, this._visitedParent = s);
  }
  /**
   * Gets the next tree walker's value.
   */
  next() {
    return this.direction == "forward" ? this._next() : this._previous();
  }
  /**
   * Makes a step forward in model. Moves the {@link #position} to the next position and returns the encountered value.
   */
  _next() {
    const e = this.position, t = this.position.clone(), n = this._visitedParent;
    if (n.parent === null && t.offset === n.maxOffset)
      return { done: !0, value: void 0 };
    if (n === this._boundaryEndParent && t.offset == this.boundaries.end.offset)
      return { done: !0, value: void 0 };
    const r = hl(t, n), s = r || qE(t, n, r);
    if (s instanceof gt)
      return this.shallow ? t.offset++ : (t.path.push(0), this._visitedParent = s), this._position = t, Ss("elementStart", s, e, t, 1);
    if (s instanceof Dt) {
      let o;
      if (this.singleCharacters)
        o = 1;
      else {
        let h = s.endOffset;
        this._boundaryEndParent == n && this.boundaries.end.offset < h && (h = this.boundaries.end.offset), o = h - t.offset;
      }
      const l = t.offset - s.startOffset, u = new Bi(s, l, o);
      return t.offset += o, this._position = t, Ss("text", u, e, t, o);
    } else
      return t.path.pop(), t.offset++, this._position = t, this._visitedParent = n.parent, this.ignoreElementEnd ? this._next() : Ss("elementEnd", n, e, t);
  }
  /**
   * Makes a step backward in model. Moves the {@link #position} to the previous position and returns the encountered value.
   */
  _previous() {
    const e = this.position, t = this.position.clone(), n = this._visitedParent;
    if (n.parent === null && t.offset === 0)
      return { done: !0, value: void 0 };
    if (n == this._boundaryStartParent && t.offset == this.boundaries.start.offset)
      return { done: !0, value: void 0 };
    const r = t.parent, s = hl(t, r), o = s || KE(t, r, s);
    if (o instanceof gt)
      return t.offset--, this.shallow ? (this._position = t, Ss("elementStart", o, e, t, 1)) : (t.path.push(o.maxOffset), this._position = t, this._visitedParent = o, this.ignoreElementEnd ? this._previous() : Ss("elementEnd", o, e, t));
    if (o instanceof Dt) {
      let l;
      if (this.singleCharacters)
        l = 1;
      else {
        let f = o.startOffset;
        this._boundaryStartParent == n && this.boundaries.start.offset > f && (f = this.boundaries.start.offset), l = t.offset - f;
      }
      const u = t.offset - o.startOffset, h = new Bi(o, u - l, l);
      return t.offset -= l, this._position = t, Ss("text", h, e, t, l);
    } else
      return t.path.pop(), this._position = t, this._visitedParent = n.parent, Ss("elementStart", n, e, t, 1);
  }
}
function Ss(i, e, t, n, r) {
  return {
    done: !1,
    value: {
      type: i,
      item: e,
      previousPosition: t,
      nextPosition: n,
      length: r
    }
  };
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class oe extends ls {
  /**
   * Creates a position.
   *
   * @param root Root of the position.
   * @param path Position path. See {@link module:engine/model/position~Position#path}.
   * @param stickiness Position stickiness. See {@link module:engine/model/position~PositionStickiness}.
   */
  constructor(e, t, n = "toNone") {
    if (super(), !e.is("element") && !e.is("documentFragment"))
      throw new B("model-position-root-invalid", e);
    if (!(t instanceof Array) || t.length === 0)
      throw new B("model-position-path-incorrect-format", e, { path: t });
    e.is("rootElement") ? t = t.slice() : (t = [...e.getPath(), ...t], e = e.root), this.root = e, this.path = t, this.stickiness = n;
  }
  /**
   * Offset at which this position is located in its {@link module:engine/model/position~Position#parent parent}. It is equal
   * to the last item in position {@link module:engine/model/position~Position#path path}.
   *
   * @type {Number}
   */
  get offset() {
    return this.path[this.path.length - 1];
  }
  set offset(e) {
    this.path[this.path.length - 1] = e;
  }
  /**
   * Parent element of this position.
   *
   * Keep in mind that `parent` value is calculated when the property is accessed.
   * If {@link module:engine/model/position~Position#path position path}
   * leads to a non-existing element, `parent` property will throw error.
   *
   * Also it is a good idea to cache `parent` property if it is used frequently in an algorithm (i.e. in a long loop).
   */
  get parent() {
    let e = this.root;
    for (let t = 0; t < this.path.length - 1; t++)
      if (e = e.getChild(e.offsetToIndex(this.path[t])), !e)
        throw new B("model-position-path-incorrect", this, { position: this });
    if (e.is("$text"))
      throw new B("model-position-path-incorrect", this, { position: this });
    return e;
  }
  /**
   * Position {@link module:engine/model/position~Position#offset offset} converted to an index in position's parent node. It is
   * equal to the {@link module:engine/model/node~Node#index index} of a node after this position. If position is placed
   * in text node, position index is equal to the index of that text node.
   */
  get index() {
    return this.parent.offsetToIndex(this.offset);
  }
  /**
   * Returns {@link module:engine/model/text~Text text node} instance in which this position is placed or `null` if this
   * position is not in a text node.
   */
  get textNode() {
    return hl(this, this.parent);
  }
  /**
   * Node directly after this position or `null` if this position is in text node.
   */
  get nodeAfter() {
    const e = this.parent;
    return qE(this, e, hl(this, e));
  }
  /**
   * Node directly before this position or `null` if this position is in text node.
   */
  get nodeBefore() {
    const e = this.parent;
    return KE(this, e, hl(this, e));
  }
  /**
   * Is `true` if position is at the beginning of its {@link module:engine/model/position~Position#parent parent}, `false` otherwise.
   */
  get isAtStart() {
    return this.offset === 0;
  }
  /**
   * Is `true` if position is at the end of its {@link module:engine/model/position~Position#parent parent}, `false` otherwise.
   */
  get isAtEnd() {
    return this.offset == this.parent.maxOffset;
  }
  /**
   * Checks whether this position is before or after given position.
   *
   * This method is safe to use it on non-existing positions (for example during operational transformation).
   */
  compareWith(e) {
    if (this.root != e.root)
      return "different";
    const t = Pn(this.path, e.path);
    switch (t) {
      case "same":
        return "same";
      case "prefix":
        return "before";
      case "extension":
        return "after";
      default:
        return this.path[t] < e.path[t] ? "before" : "after";
    }
  }
  /**
   * Gets the farthest position which matches the callback using
   * {@link module:engine/model/treewalker~TreeWalker TreeWalker}.
   *
   * For example:
   *
   * ```ts
   * getLastMatchingPosition( value => value.type == 'text' );
   * // <paragraph>[]foo</paragraph> -> <paragraph>foo[]</paragraph>
   *
   * getLastMatchingPosition( value => value.type == 'text', { direction: 'backward' } );
   * // <paragraph>foo[]</paragraph> -> <paragraph>[]foo</paragraph>
   *
   * getLastMatchingPosition( value => false );
   * // Do not move the position.
   * ```
   *
   * @param skip Callback function. Gets {@link module:engine/model/treewalker~TreeWalkerValue} and should
   * return `true` if the value should be skipped or `false` if not.
   * @param options Object with configuration options. See {@link module:engine/model/treewalker~TreeWalker}.
   *
   * @returns The position after the last item which matches the `skip` callback test.
   */
  getLastMatchingPosition(e, t = {}) {
    t.startPosition = this;
    const n = new ir(t);
    return n.skip(e), n.position;
  }
  /**
   * Returns a path to this position's parent. Parent path is equal to position {@link module:engine/model/position~Position#path path}
   * but without the last item.
   *
   * This method is safe to use it on non-existing positions (for example during operational transformation).
   *
   * @returns Path to the parent.
   */
  getParentPath() {
    return this.path.slice(0, -1);
  }
  /**
   * Returns ancestors array of this position, that is this position's parent and its ancestors.
   *
   * @returns Array with ancestors.
   */
  getAncestors() {
    const e = this.parent;
    return e.is("documentFragment") ? [e] : e.getAncestors({ includeSelf: !0 });
  }
  /**
   * Returns the parent element of the given name. Returns null if the position is not inside the desired parent.
   *
   * @param parentName The name of the parent element to find.
   */
  findAncestor(e) {
    const t = this.parent;
    return t.is("element") ? t.findAncestor(e, { includeSelf: !0 }) : null;
  }
  /**
   * Returns the slice of two position {@link #path paths} which is identical. The {@link #root roots}
   * of these two paths must be identical.
   *
   * This method is safe to use it on non-existing positions (for example during operational transformation).
   *
   * @param position The second position.
   * @returns The common path.
   */
  getCommonPath(e) {
    if (this.root != e.root)
      return [];
    const t = Pn(this.path, e.path), n = typeof t == "string" ? Math.min(this.path.length, e.path.length) : t;
    return this.path.slice(0, n);
  }
  /**
   * Returns an {@link module:engine/model/element~Element} or {@link module:engine/model/documentfragment~DocumentFragment}
   * which is a common ancestor of both positions. The {@link #root roots} of these two positions must be identical.
   *
   * @param position The second position.
   */
  getCommonAncestor(e) {
    const t = this.getAncestors(), n = e.getAncestors();
    let r = 0;
    for (; t[r] == n[r] && t[r]; )
      r++;
    return r === 0 ? null : t[r - 1];
  }
  /**
   * Returns a new instance of `Position`, that has same {@link #parent parent} but it's offset
   * is shifted by `shift` value (can be a negative value).
   *
   * This method is safe to use it on non-existing positions (for example during operational transformation).
   *
   * @param shift Offset shift. Can be a negative value.
   * @returns Shifted position.
   */
  getShiftedBy(e) {
    const t = this.clone(), n = t.offset + e;
    return t.offset = n < 0 ? 0 : n, t;
  }
  /**
   * Checks whether this position is after given position.
   *
   * This method is safe to use it on non-existing positions (for example during operational transformation).
   *
   * @see module:engine/model/position~Position#isBefore
   * @param  otherPosition Position to compare with.
   * @returns True if this position is after given position.
   */
  isAfter(e) {
    return this.compareWith(e) == "after";
  }
  /**
   * Checks whether this position is before given position.
   *
   * **Note:** watch out when using negation of the value returned by this method, because the negation will also
   * be `true` if positions are in different roots and you might not expect this. You should probably use
   * `a.isAfter( b ) || a.isEqual( b )` or `!a.isBefore( p ) && a.root == b.root` in most scenarios. If your
   * condition uses multiple `isAfter` and `isBefore` checks, build them so they do not use negated values, i.e.:
   *
   * ```ts
   * if ( a.isBefore( b ) && c.isAfter( d ) ) {
   * 	// do A.
   * } else {
   * 	// do B.
   * }
   * ```
   *
   * or, if you have only one if-branch:
   *
   * ```ts
   * if ( !( a.isBefore( b ) && c.isAfter( d ) ) {
   * 	// do B.
   * }
   * ```
   *
   * rather than:
   *
   * ```ts
   * if ( !a.isBefore( b ) || && !c.isAfter( d ) ) {
   * 	// do B.
   * } else {
   * 	// do A.
   * }
   * ```
   *
   * This method is safe to use it on non-existing positions (for example during operational transformation).
   *
   * @param otherPosition Position to compare with.
   * @returns True if this position is before given position.
   */
  isBefore(e) {
    return this.compareWith(e) == "before";
  }
  /**
   * Checks whether this position is equal to given position.
   *
   * This method is safe to use it on non-existing positions (for example during operational transformation).
   *
   * @param otherPosition Position to compare with.
   * @returns True if positions are same.
   */
  isEqual(e) {
    return this.compareWith(e) == "same";
  }
  /**
   * Checks whether this position is touching given position. Positions touch when there are no text nodes
   * or empty nodes in a range between them. Technically, those positions are not equal but in many cases
   * they are very similar or even indistinguishable.
   *
   * @param otherPosition Position to compare with.
   * @returns True if positions touch.
   */
  isTouching(e) {
    if (this.root !== e.root)
      return !1;
    const t = Math.min(this.path.length, e.path.length);
    for (let n = 0; n < t; n++) {
      const r = this.path[n] - e.path[n];
      if (r < -1 || r > 1)
        return !1;
      if (r === 1)
        return rb(e, this, n);
      if (r === -1)
        return rb(this, e, n);
    }
    return this.path.length === e.path.length ? !0 : this.path.length > e.path.length ? gg(this.path, t) : gg(e.path, t);
  }
  /**
   * Checks if two positions are in the same parent.
   *
   * This method is safe to use it on non-existing positions (for example during operational transformation).
   *
   * @param position Position to compare with.
   * @returns `true` if positions have the same parent, `false` otherwise.
   */
  hasSameParentAs(e) {
    if (this.root !== e.root)
      return !1;
    const t = this.getParentPath(), n = e.getParentPath();
    return Pn(t, n) == "same";
  }
  /**
   * Returns a copy of this position that is transformed by given `operation`.
   *
   * The new position's parameters are updated accordingly to the effect of the `operation`.
   *
   * For example, if `n` nodes are inserted before the position, the returned position {@link ~Position#offset} will be
   * increased by `n`. If the position was in a merged element, it will be accordingly moved to the new element, etc.
   *
   * This method is safe to use it on non-existing positions (for example during operational transformation).
   *
   * @param operation Operation to transform by.
   * @returns Transformed position.
   */
  getTransformedByOperation(e) {
    let t;
    switch (e.type) {
      case "insert":
        t = this._getTransformedByInsertOperation(e);
        break;
      case "move":
      case "remove":
      case "reinsert":
        t = this._getTransformedByMoveOperation(e);
        break;
      case "split":
        t = this._getTransformedBySplitOperation(e);
        break;
      case "merge":
        t = this._getTransformedByMergeOperation(e);
        break;
      default:
        t = oe._createAt(this);
        break;
    }
    return t;
  }
  /**
   * Returns a copy of this position transformed by an insert operation.
   *
   * @internal
   */
  _getTransformedByInsertOperation(e) {
    return this._getTransformedByInsertion(e.position, e.howMany);
  }
  /**
   * Returns a copy of this position transformed by a move operation.
   *
   * @internal
   */
  _getTransformedByMoveOperation(e) {
    return this._getTransformedByMove(e.sourcePosition, e.targetPosition, e.howMany);
  }
  /**
   * Returns a copy of this position transformed by a split operation.
   *
   * @internal
   */
  _getTransformedBySplitOperation(e) {
    const t = e.movedRange;
    return t.containsPosition(this) || t.start.isEqual(this) && this.stickiness == "toNext" ? this._getCombined(e.splitPosition, e.moveTargetPosition) : e.graveyardPosition ? this._getTransformedByMove(e.graveyardPosition, e.insertionPosition, 1) : this._getTransformedByInsertion(e.insertionPosition, 1);
  }
  /**
   * Returns a copy of this position transformed by merge operation.
   *
   * @internal
   */
  _getTransformedByMergeOperation(e) {
    const t = e.movedRange, n = t.containsPosition(this) || t.start.isEqual(this);
    let r;
    return n ? (r = this._getCombined(e.sourcePosition, e.targetPosition), e.sourcePosition.isBefore(e.targetPosition) && (r = r._getTransformedByDeletion(e.deletionPosition, 1))) : this.isEqual(e.deletionPosition) ? r = oe._createAt(e.deletionPosition) : r = this._getTransformedByMove(e.deletionPosition, e.graveyardPosition, 1), r;
  }
  /**
   * Returns a copy of this position that is updated by removing `howMany` nodes starting from `deletePosition`.
   * It may happen that this position is in a removed node. If that is the case, `null` is returned instead.
   *
   * @internal
   * @param deletePosition Position before the first removed node.
   * @param howMany How many nodes are removed.
   * @returns Transformed position or `null`.
   */
  _getTransformedByDeletion(e, t) {
    const n = oe._createAt(this);
    if (this.root != e.root)
      return n;
    if (Pn(e.getParentPath(), this.getParentPath()) == "same") {
      if (e.offset < this.offset) {
        if (e.offset + t > this.offset)
          return null;
        n.offset -= t;
      }
    } else if (Pn(e.getParentPath(), this.getParentPath()) == "prefix") {
      const r = e.path.length - 1;
      if (e.offset <= this.path[r]) {
        if (e.offset + t > this.path[r])
          return null;
        n.path[r] -= t;
      }
    }
    return n;
  }
  /**
   * Returns a copy of this position that is updated by inserting `howMany` nodes at `insertPosition`.
   *
   * @internal
   * @param insertPosition Position where nodes are inserted.
   * @param howMany How many nodes are inserted.
   * @returns Transformed position.
   */
  _getTransformedByInsertion(e, t) {
    const n = oe._createAt(this);
    if (this.root != e.root)
      return n;
    if (Pn(e.getParentPath(), this.getParentPath()) == "same")
      (e.offset < this.offset || e.offset == this.offset && this.stickiness != "toPrevious") && (n.offset += t);
    else if (Pn(e.getParentPath(), this.getParentPath()) == "prefix") {
      const r = e.path.length - 1;
      e.offset <= this.path[r] && (n.path[r] += t);
    }
    return n;
  }
  /**
   * Returns a copy of this position that is updated by moving `howMany` nodes from `sourcePosition` to `targetPosition`.
   *
   * @internal
   * @param sourcePosition Position before the first element to move.
   * @param targetPosition Position where moved elements will be inserted.
   * @param howMany How many consecutive nodes to move, starting from `sourcePosition`.
   * @returns Transformed position.
   */
  _getTransformedByMove(e, t, n) {
    if (t = t._getTransformedByDeletion(e, n), e.isEqual(t))
      return oe._createAt(this);
    const r = this._getTransformedByDeletion(e, n);
    return r === null || e.isEqual(this) && this.stickiness == "toNext" || e.getShiftedBy(n).isEqual(this) && this.stickiness == "toPrevious" ? this._getCombined(e, t) : r._getTransformedByInsertion(t, n);
  }
  /**
   * Returns a new position that is a combination of this position and given positions.
   *
   * The combined position is a copy of this position transformed by moving a range starting at `source` position
   * to the `target` position. It is expected that this position is inside the moved range.
   *
   * Example:
   *
   * ```ts
   * let original = model.createPositionFromPath( root, [ 2, 3, 1 ] );
   * let source = model.createPositionFromPath( root, [ 2, 2 ] );
   * let target = model.createPositionFromPath( otherRoot, [ 1, 1, 3 ] );
   * original._getCombined( source, target ); // path is [ 1, 1, 4, 1 ], root is `otherRoot`
   * ```
   *
   * Explanation:
   *
   * We have a position `[ 2, 3, 1 ]` and move some nodes from `[ 2, 2 ]` to `[ 1, 1, 3 ]`. The original position
   * was inside moved nodes and now should point to the new place. The moved nodes will be after
   * positions `[ 1, 1, 3 ]`, `[ 1, 1, 4 ]`, `[ 1, 1, 5 ]`. Since our position was in the second moved node,
   * the transformed position will be in a sub-tree of a node at `[ 1, 1, 4 ]`. Looking at original path, we
   * took care of `[ 2, 3 ]` part of it. Now we have to add the rest of the original path to the transformed path.
   * Finally, the transformed position will point to `[ 1, 1, 4, 1 ]`.
   *
   * @internal
   * @param source Beginning of the moved range.
   * @param target Position where the range is moved.
   * @returns Combined position.
   */
  _getCombined(e, t) {
    const n = e.path.length - 1, r = oe._createAt(t);
    return r.stickiness = this.stickiness, r.offset = r.offset + this.path[n] - e.offset, r.path = [...r.path, ...this.path.slice(n + 1)], r;
  }
  /**
   * @inheritDoc
   */
  toJSON() {
    return {
      root: this.root.toJSON(),
      path: Array.from(this.path),
      stickiness: this.stickiness
    };
  }
  /**
   * Returns a new position that is equal to current position.
   */
  clone() {
    return new this.constructor(this.root, this.path, this.stickiness);
  }
  /**
   * Creates position at the given location. The location can be specified as:
   *
   * * a {@link module:engine/model/position~Position position},
   * * parent element and offset (offset defaults to `0`),
   * * parent element and `'end'` (sets position at the end of that element),
   * * {@link module:engine/model/item~Item model item} and `'before'` or `'after'` (sets position before or after given model item).
   *
   * This method is a shortcut to other factory methods such as:
   *
   * * {@link module:engine/model/position~Position._createBefore},
   * * {@link module:engine/model/position~Position._createAfter}.
   *
   * @internal
   * @param offset Offset or one of the flags. Used only when the first parameter is a {@link module:engine/model/item~Item model item}.
   * @param stickiness Position stickiness. Used only when the first parameter is a {@link module:engine/model/item~Item model item}.
   */
  static _createAt(e, t, n = "toNone") {
    if (e instanceof oe)
      return new oe(e.root, e.path, e.stickiness);
    {
      const r = e;
      if (t == "end")
        t = r.maxOffset;
      else {
        if (t == "before")
          return this._createBefore(r, n);
        if (t == "after")
          return this._createAfter(r, n);
        if (t !== 0 && !t)
          throw new B("model-createpositionat-offset-required", [this, e]);
      }
      if (!r.is("element") && !r.is("documentFragment"))
        throw new B("model-position-parent-incorrect", [this, e]);
      const s = r.getPath();
      return s.push(t), new this(r.root, s, n);
    }
  }
  /**
   * Creates a new position, after given {@link module:engine/model/item~Item model item}.
   *
   * @internal
   * @param item Item after which the position should be placed.
   * @param stickiness Position stickiness.
   */
  static _createAfter(e, t) {
    if (!e.parent)
      throw new B("model-position-after-root", [this, e], { root: e });
    return this._createAt(e.parent, e.endOffset, t);
  }
  /**
   * Creates a new position, before the given {@link module:engine/model/item~Item model item}.
   *
   * @internal
   * @param item Item before which the position should be placed.
   * @param stickiness Position stickiness.
   */
  static _createBefore(e, t) {
    if (!e.parent)
      throw new B("model-position-before-root", e, { root: e });
    return this._createAt(e.parent, e.startOffset, t);
  }
  /**
   * Creates a `Position` instance from given plain object (i.e. parsed JSON string).
   *
   * @param json Plain object to be converted to `Position`.
   * @param doc Document object that will be position owner.
   * @returns `Position` instance created using given plain object.
   */
  static fromJSON(e, t) {
    if (e.root === "$graveyard") {
      const n = new oe(t.graveyard, e.path);
      return n.stickiness = e.stickiness, n;
    }
    if (!t.getRoot(e.root))
      throw new B("model-position-fromjson-no-root", t, { rootName: e.root });
    return new oe(t.getRoot(e.root), e.path, e.stickiness);
  }
}
oe.prototype.is = function(i) {
  return i === "position" || i === "model:position";
};
function hl(i, e) {
  const t = e.getChild(e.offsetToIndex(i.offset));
  return t && t.is("$text") && t.startOffset < i.offset ? t : null;
}
function qE(i, e, t) {
  return t !== null ? null : e.getChild(e.offsetToIndex(i.offset));
}
function KE(i, e, t) {
  return t !== null ? null : e.getChild(e.offsetToIndex(i.offset) - 1);
}
function rb(i, e, t) {
  return !(t + 1 === i.path.length || !gg(e.path, t + 1) || !GV(i, t + 1));
}
function gg(i, e) {
  for (; e < i.length; ) {
    if (i[e] !== 0)
      return !1;
    e++;
  }
  return !0;
}
function GV(i, e) {
  let t = i.parent, n = i.path.length - 1, r = 0;
  for (; n >= e; ) {
    if (i.path[n] + r !== t.maxOffset)
      return !1;
    r = 1, n--, t = t.parent;
  }
  return !0;
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class X extends ls {
  /**
   * Creates a range spanning from `start` position to `end` position.
   *
   * @param start The start position.
   * @param end The end position. If not set, the range will be collapsed at the `start` position.
   */
  constructor(e, t) {
    super(), this.start = oe._createAt(e), this.end = t ? oe._createAt(t) : oe._createAt(e), this.start.stickiness = this.isCollapsed ? "toNone" : "toNext", this.end.stickiness = this.isCollapsed ? "toNone" : "toPrevious";
  }
  /**
   * Iterable interface.
   *
   * Iterates over all {@link module:engine/model/item~Item items} that are in this range and returns
   * them together with additional information like length or {@link module:engine/model/position~Position positions},
   * grouped as {@link module:engine/model/treewalker~TreeWalkerValue}.
   * It iterates over all {@link module:engine/model/textproxy~TextProxy text contents} that are inside the range
   * and all the {@link module:engine/model/element~Element}s that are entered into when iterating over this range.
   *
   * This iterator uses {@link module:engine/model/treewalker~TreeWalker} with `boundaries` set to this range
   * and `ignoreElementEnd` option set to `true`.
   */
  *[Symbol.iterator]() {
    yield* new ir({ boundaries: this, ignoreElementEnd: !0 });
  }
  /**
   * Describes whether the range is collapsed, that is if {@link #start} and
   * {@link #end} positions are equal.
   */
  get isCollapsed() {
    return this.start.isEqual(this.end);
  }
  /**
   * Describes whether this range is flat, that is if {@link #start} position and
   * {@link #end} position are in the same {@link module:engine/model/position~Position#parent}.
   */
  get isFlat() {
    const e = this.start.getParentPath(), t = this.end.getParentPath();
    return Pn(e, t) == "same";
  }
  /**
   * Range root element.
   */
  get root() {
    return this.start.root;
  }
  /**
   * Checks whether this range contains given {@link module:engine/model/position~Position position}.
   *
   * @param position Position to check.
   * @returns `true` if given {@link module:engine/model/position~Position position} is contained
   * in this range,`false` otherwise.
   */
  containsPosition(e) {
    return e.isAfter(this.start) && e.isBefore(this.end);
  }
  /**
   * Checks whether this range contains given {@link ~Range range}.
   *
   * @param otherRange Range to check.
   * @param loose Whether the check is loose or strict. If the check is strict (`false`), compared range cannot
   * start or end at the same position as this range boundaries. If the check is loose (`true`), compared range can start, end or
   * even be equal to this range. Note that collapsed ranges are always compared in strict mode.
   * @returns {Boolean} `true` if given {@link ~Range range} boundaries are contained by this range, `false` otherwise.
   */
  containsRange(e, t = !1) {
    e.isCollapsed && (t = !1);
    const n = this.containsPosition(e.start) || t && this.start.isEqual(e.start), r = this.containsPosition(e.end) || t && this.end.isEqual(e.end);
    return n && r;
  }
  /**
   * Checks whether given {@link module:engine/model/item~Item} is inside this range.
   */
  containsItem(e) {
    const t = oe._createBefore(e);
    return this.containsPosition(t) || this.start.isEqual(t);
  }
  /**
   * Two ranges are equal if their {@link #start} and {@link #end} positions are equal.
   *
   * @param otherRange Range to compare with.
   * @returns `true` if ranges are equal, `false` otherwise.
   */
  isEqual(e) {
    return this.start.isEqual(e.start) && this.end.isEqual(e.end);
  }
  /**
   * Checks and returns whether this range intersects with given range.
   *
   * @param otherRange Range to compare with.
   * @returns `true` if ranges intersect, `false` otherwise.
   */
  isIntersecting(e) {
    return this.start.isBefore(e.end) && this.end.isAfter(e.start);
  }
  /**
   * Computes which part(s) of this {@link ~Range range} is not a part of given {@link ~Range range}.
   * Returned array contains zero, one or two {@link ~Range ranges}.
   *
   * Examples:
   *
   * ```ts
   * let range = model.createRange(
   * 	model.createPositionFromPath( root, [ 2, 7 ] ),
   * 	model.createPositionFromPath( root, [ 4, 0, 1 ] )
   * );
   * let otherRange = model.createRange( model.createPositionFromPath( root, [ 1 ] ), model.createPositionFromPath( root, [ 5 ] ) );
   * let transformed = range.getDifference( otherRange );
   * // transformed array has no ranges because `otherRange` contains `range`
   *
   * otherRange = model.createRange( model.createPositionFromPath( root, [ 1 ] ), model.createPositionFromPath( root, [ 3 ] ) );
   * transformed = range.getDifference( otherRange );
   * // transformed array has one range: from [ 3 ] to [ 4, 0, 1 ]
   *
   * otherRange = model.createRange( model.createPositionFromPath( root, [ 3 ] ), model.createPositionFromPath( root, [ 4 ] ) );
   * transformed = range.getDifference( otherRange );
   * // transformed array has two ranges: from [ 2, 7 ] to [ 3 ] and from [ 4 ] to [ 4, 0, 1 ]
   * ```
   *
   * @param otherRange Range to differentiate against.
   * @returns The difference between ranges.
   */
  getDifference(e) {
    const t = [];
    return this.isIntersecting(e) ? (this.containsPosition(e.start) && t.push(new X(this.start, e.start)), this.containsPosition(e.end) && t.push(new X(e.end, this.end))) : t.push(new X(this.start, this.end)), t;
  }
  /**
   * Returns an intersection of this {@link ~Range range} and given {@link ~Range range}.
   * Intersection is a common part of both of those ranges. If ranges has no common part, returns `null`.
   *
   * Examples:
   *
   * ```ts
   * let range = model.createRange(
   * 	model.createPositionFromPath( root, [ 2, 7 ] ),
   * 	model.createPositionFromPath( root, [ 4, 0, 1 ] )
   * );
   * let otherRange = model.createRange( model.createPositionFromPath( root, [ 1 ] ), model.createPositionFromPath( root, [ 2 ] ) );
   * let transformed = range.getIntersection( otherRange ); // null - ranges have no common part
   *
   * otherRange = model.createRange( model.createPositionFromPath( root, [ 3 ] ), model.createPositionFromPath( root, [ 5 ] ) );
   * transformed = range.getIntersection( otherRange ); // range from [ 3 ] to [ 4, 0, 1 ]
   * ```
   *
   * @param otherRange Range to check for intersection.
   * @returns A common part of given ranges or `null` if ranges have no common part.
   */
  getIntersection(e) {
    if (this.isIntersecting(e)) {
      let t = this.start, n = this.end;
      return this.containsPosition(e.start) && (t = e.start), this.containsPosition(e.end) && (n = e.end), new X(t, n);
    }
    return null;
  }
  /**
   * Returns a range created by joining this {@link ~Range range} with the given {@link ~Range range}.
   * If ranges have no common part, returns `null`.
   *
   * Examples:
   *
   * ```ts
   * let range = model.createRange(
   * 	model.createPositionFromPath( root, [ 2, 7 ] ),
   * 	model.createPositionFromPath( root, [ 4, 0, 1 ] )
   * );
   * let otherRange = model.createRange(
   * 	model.createPositionFromPath( root, [ 1 ] ),
   * 	model.createPositionFromPath( root, [ 2 ] )
   * );
   * let transformed = range.getJoined( otherRange ); // null - ranges have no common part
   *
   * otherRange = model.createRange(
   * 	model.createPositionFromPath( root, [ 3 ] ),
   * 	model.createPositionFromPath( root, [ 5 ] )
   * );
   * transformed = range.getJoined( otherRange ); // range from [ 2, 7 ] to [ 5 ]
   * ```
   *
   * @param otherRange Range to be joined.
   * @param loose Whether the intersection check is loose or strict. If the check is strict (`false`),
   * ranges are tested for intersection or whether start/end positions are equal. If the check is loose (`true`),
   * compared range is also checked if it's {@link module:engine/model/position~Position#isTouching touching} current range.
   * @returns A sum of given ranges or `null` if ranges have no common part.
   */
  getJoined(e, t = !1) {
    let n = this.isIntersecting(e);
    if (n || (this.start.isBefore(e.start) ? n = t ? this.end.isTouching(e.start) : this.end.isEqual(e.start) : n = t ? e.end.isTouching(this.start) : e.end.isEqual(this.start)), !n)
      return null;
    let r = this.start, s = this.end;
    return e.start.isBefore(r) && (r = e.start), e.end.isAfter(s) && (s = e.end), new X(r, s);
  }
  /**
   * Computes and returns the smallest set of {@link #isFlat flat} ranges, that covers this range in whole.
   *
   * See an example of a model structure (`[` and `]` are range boundaries):
   *
   * ```
   * root                                                            root
   *  |- element DIV                         DIV             P2              P3             DIV
   *  |   |- element H                   H        P1        f o o           b a r       H         P4
   *  |   |   |- "fir[st"             fir[st     lorem                               se]cond     ipsum
   *  |   |- element P1
   *  |   |   |- "lorem"                                              ||
   *  |- element P2                                                   ||
   *  |   |- "foo"                                                    VV
   *  |- element P3
   *  |   |- "bar"                                                   root
   *  |- element DIV                         DIV             [P2             P3]             DIV
   *  |   |- element H                   H       [P1]       f o o           b a r        H         P4
   *  |   |   |- "se]cond"            fir[st]    lorem                               [se]cond     ipsum
   *  |   |- element P4
   *  |   |   |- "ipsum"
   * ```
   *
   * As it can be seen, letters contained in the range are: `stloremfoobarse`, spread across different parents.
   * We are looking for minimal set of flat ranges that contains the same nodes.
   *
   * Minimal flat ranges for above range `( [ 0, 0, 3 ], [ 3, 0, 2 ] )` will be:
   *
   * ```
   * ( [ 0, 0, 3 ], [ 0, 0, 5 ] ) = "st"
   * ( [ 0, 1 ], [ 0, 2 ] ) = element P1 ("lorem")
   * ( [ 1 ], [ 3 ] ) = element P2, element P3 ("foobar")
   * ( [ 3, 0, 0 ], [ 3, 0, 2 ] ) = "se"
   * ```
   *
   * **Note:** if an {@link module:engine/model/element~Element element} is not wholly contained in this range, it won't be returned
   * in any of the returned flat ranges. See in the example how `H` elements at the beginning and at the end of the range
   * were omitted. Only their parts that were wholly in the range were returned.
   *
   * **Note:** this method is not returning flat ranges that contain no nodes.
   *
   * @returns Array of flat ranges covering this range.
   */
  getMinimalFlatRanges() {
    const e = [], t = this.start.getCommonPath(this.end).length, n = oe._createAt(this.start);
    let r = n.parent;
    for (; n.path.length > t + 1; ) {
      const s = r.maxOffset - n.offset;
      s !== 0 && e.push(new X(n, n.getShiftedBy(s))), n.path = n.path.slice(0, -1), n.offset++, r = r.parent;
    }
    for (; n.path.length <= this.end.path.length; ) {
      const s = this.end.path[n.path.length - 1], o = s - n.offset;
      o !== 0 && e.push(new X(n, n.getShiftedBy(o))), n.offset = s, n.path.push(0);
    }
    return e;
  }
  /**
   * Creates a {@link module:engine/model/treewalker~TreeWalker TreeWalker} instance with this range as a boundary.
   *
   * For example, to iterate over all items in the entire document root:
   *
   * ```ts
   * // Create a range spanning over the entire root content:
   * const range = editor.model.createRangeIn( editor.model.document.getRoot() );
   *
   * // Iterate over all items in this range:
   * for ( const value of range.getWalker() ) {
   * 	console.log( value.item );
   * }
   * ```
   *
   * @param options Object with configuration options. See {@link module:engine/model/treewalker~TreeWalker}.
   */
  getWalker(e = {}) {
    return e.boundaries = this, new ir(e);
  }
  /**
   * Returns an iterator that iterates over all {@link module:engine/model/item~Item items} that are in this range and returns
   * them.
   *
   * This method uses {@link module:engine/model/treewalker~TreeWalker} with `boundaries` set to this range and `ignoreElementEnd` option
   * set to `true`. However it returns only {@link module:engine/model/item~Item model items},
   * not {@link module:engine/model/treewalker~TreeWalkerValue}.
   *
   * You may specify additional options for the tree walker. See {@link module:engine/model/treewalker~TreeWalker} for
   * a full list of available options.
   *
   * @param options Object with configuration options. See {@link module:engine/model/treewalker~TreeWalker}.
   */
  *getItems(e = {}) {
    e.boundaries = this, e.ignoreElementEnd = !0;
    const t = new ir(e);
    for (const n of t)
      yield n.item;
  }
  /**
   * Returns an iterator that iterates over all {@link module:engine/model/position~Position positions} that are boundaries or
   * contained in this range.
   *
   * This method uses {@link module:engine/model/treewalker~TreeWalker} with `boundaries` set to this range. However it returns only
   * {@link module:engine/model/position~Position positions}, not {@link module:engine/model/treewalker~TreeWalkerValue}.
   *
   * You may specify additional options for the tree walker. See {@link module:engine/model/treewalker~TreeWalker} for
   * a full list of available options.
   *
   * @param options Object with configuration options. See {@link module:engine/model/treewalker~TreeWalker}.
   */
  *getPositions(e = {}) {
    e.boundaries = this;
    const t = new ir(e);
    yield t.position;
    for (const n of t)
      yield n.nextPosition;
  }
  /**
   * Returns a range that is a result of transforming this range by given `operation`.
   *
   * **Note:** transformation may break one range into multiple ranges (for example, when a part of the range is
   * moved to a different part of document tree). For this reason, an array is returned by this method and it
   * may contain one or more `Range` instances.
   *
   * @param operation Operation to transform range by.
   * @returns Range which is the result of transformation.
   */
  getTransformedByOperation(e) {
    switch (e.type) {
      case "insert":
        return this._getTransformedByInsertOperation(e);
      case "move":
      case "remove":
      case "reinsert":
        return this._getTransformedByMoveOperation(e);
      case "split":
        return [this._getTransformedBySplitOperation(e)];
      case "merge":
        return [this._getTransformedByMergeOperation(e)];
    }
    return [new X(this.start, this.end)];
  }
  /**
   * Returns a range that is a result of transforming this range by multiple `operations`.
   *
   * @see ~Range#getTransformedByOperation
   * @param operations Operations to transform the range by.
   * @returns Range which is the result of transformation.
   */
  getTransformedByOperations(e) {
    const t = [new X(this.start, this.end)];
    for (const n of e)
      for (let r = 0; r < t.length; r++) {
        const s = t[r].getTransformedByOperation(n);
        t.splice(r, 1, ...s), r += s.length - 1;
      }
    for (let n = 0; n < t.length; n++) {
      const r = t[n];
      for (let s = n + 1; s < t.length; s++) {
        const o = t[s];
        (r.containsRange(o) || o.containsRange(r) || r.isEqual(o)) && t.splice(s, 1);
      }
    }
    return t;
  }
  /**
   * Returns an {@link module:engine/model/element~Element} or {@link module:engine/model/documentfragment~DocumentFragment}
   * which is a common ancestor of the range's both ends (in which the entire range is contained).
   */
  getCommonAncestor() {
    return this.start.getCommonAncestor(this.end);
  }
  /**
   * Returns an {@link module:engine/model/element~Element Element} contained by the range.
   * The element will be returned when it is the **only** node within the range and **fully–contained**
   * at the same time.
   */
  getContainedElement() {
    if (this.isCollapsed)
      return null;
    const e = this.start.nodeAfter, t = this.end.nodeBefore;
    return e && e.is("element") && e === t ? e : null;
  }
  /**
   * Converts `Range` to plain object and returns it.
   *
   * @returns `Node` converted to plain object.
   */
  toJSON() {
    return {
      start: this.start.toJSON(),
      end: this.end.toJSON()
    };
  }
  /**
   * Returns a new range that is equal to current range.
   */
  clone() {
    return new this.constructor(this.start, this.end);
  }
  /**
   * Returns a result of transforming a copy of this range by insert operation.
   *
   * One or more ranges may be returned as a result of this transformation.
   *
   * @internal
   */
  _getTransformedByInsertOperation(e, t = !1) {
    return this._getTransformedByInsertion(e.position, e.howMany, t);
  }
  /**
   * Returns a result of transforming a copy of this range by move operation.
   *
   * One or more ranges may be returned as a result of this transformation.
   *
   * @internal
   */
  _getTransformedByMoveOperation(e, t = !1) {
    const n = e.sourcePosition, r = e.howMany, s = e.targetPosition;
    return this._getTransformedByMove(n, s, r, t);
  }
  /**
   * Returns a result of transforming a copy of this range by split operation.
   *
   * Always one range is returned. The transformation is done in a way to not break the range.
   *
   * @internal
   */
  _getTransformedBySplitOperation(e) {
    const t = this.start._getTransformedBySplitOperation(e);
    let n = this.end._getTransformedBySplitOperation(e);
    return this.end.isEqual(e.insertionPosition) && (n = this.end.getShiftedBy(1)), t.root != n.root && (n = this.end.getShiftedBy(-1)), new X(t, n);
  }
  /**
   * Returns a result of transforming a copy of this range by merge operation.
   *
   * Always one range is returned. The transformation is done in a way to not break the range.
   *
   * @internal
   */
  _getTransformedByMergeOperation(e) {
    if (this.start.isEqual(e.targetPosition) && this.end.isEqual(e.deletionPosition))
      return new X(this.start);
    let t = this.start._getTransformedByMergeOperation(e), n = this.end._getTransformedByMergeOperation(e);
    return t.root != n.root && (n = this.end.getShiftedBy(-1)), t.isAfter(n) ? (e.sourcePosition.isBefore(e.targetPosition) ? (t = oe._createAt(n), t.offset = 0) : (e.deletionPosition.isEqual(t) || (n = e.deletionPosition), t = e.targetPosition), new X(t, n)) : new X(t, n);
  }
  /**
   * Returns an array containing one or two {@link ~Range ranges} that are a result of transforming this
   * {@link ~Range range} by inserting `howMany` nodes at `insertPosition`. Two {@link ~Range ranges} are
   * returned if the insertion was inside this {@link ~Range range} and `spread` is set to `true`.
   *
   * Examples:
   *
   * ```ts
   * let range = model.createRange(
   * 	model.createPositionFromPath( root, [ 2, 7 ] ),
   * 	model.createPositionFromPath( root, [ 4, 0, 1 ] )
   * );
   * let transformed = range._getTransformedByInsertion( model.createPositionFromPath( root, [ 1 ] ), 2 );
   * // transformed array has one range from [ 4, 7 ] to [ 6, 0, 1 ]
   *
   * transformed = range._getTransformedByInsertion( model.createPositionFromPath( root, [ 4, 0, 0 ] ), 4 );
   * // transformed array has one range from [ 2, 7 ] to [ 4, 0, 5 ]
   *
   * transformed = range._getTransformedByInsertion( model.createPositionFromPath( root, [ 3, 2 ] ), 4 );
   * // transformed array has one range, which is equal to original range
   *
   * transformed = range._getTransformedByInsertion( model.createPositionFromPath( root, [ 3, 2 ] ), 4, true );
   * // transformed array has two ranges: from [ 2, 7 ] to [ 3, 2 ] and from [ 3, 6 ] to [ 4, 0, 1 ]
   * ```
   *
   * @internal
   * @param insertPosition Position where nodes are inserted.
   * @param howMany How many nodes are inserted.
   * @param spread Flag indicating whether this range should be spread if insertion
   * was inside the range. Defaults to `false`.
   * @returns Result of the transformation.
   */
  _getTransformedByInsertion(e, t, n = !1) {
    if (n && this.containsPosition(e))
      return [
        new X(this.start, e),
        new X(e.getShiftedBy(t), this.end._getTransformedByInsertion(e, t))
      ];
    {
      const r = new X(this.start, this.end);
      return r.start = r.start._getTransformedByInsertion(e, t), r.end = r.end._getTransformedByInsertion(e, t), [r];
    }
  }
  /**
   * Returns an array containing {@link ~Range ranges} that are a result of transforming this
   * {@link ~Range range} by moving `howMany` nodes from `sourcePosition` to `targetPosition`.
   *
   * @internal
   * @param sourcePosition Position from which nodes are moved.
   * @param targetPosition Position to where nodes are moved.
   * @param howMany How many nodes are moved.
   * @param spread Whether the range should be spread if the move points inside the range.
   * @returns  Result of the transformation.
   */
  _getTransformedByMove(e, t, n, r = !1) {
    if (this.isCollapsed) {
      const m = this.start._getTransformedByMove(e, t, n);
      return [new X(m)];
    }
    const s = X._createFromPositionAndShift(e, n), o = t._getTransformedByDeletion(e, n);
    if (this.containsPosition(t) && !r && (s.containsPosition(this.start) || s.containsPosition(this.end))) {
      const m = this.start._getTransformedByMove(e, t, n), v = this.end._getTransformedByMove(e, t, n);
      return [new X(m, v)];
    }
    let l;
    const u = this.getDifference(s);
    let h = null;
    const f = this.getIntersection(s);
    if (u.length == 1 ? h = new X(u[0].start._getTransformedByDeletion(e, n), u[0].end._getTransformedByDeletion(e, n)) : u.length == 2 && (h = new X(this.start, this.end._getTransformedByDeletion(e, n))), h ? l = h._getTransformedByInsertion(o, n, f !== null || r) : l = [], f) {
      const m = new X(f.start._getCombined(s.start, o), f.end._getCombined(s.start, o));
      l.length == 2 ? l.splice(1, 0, m) : l.push(m);
    }
    return l;
  }
  /**
   * Returns a copy of this range that is transformed by deletion of `howMany` nodes from `deletePosition`.
   *
   * If the deleted range is intersecting with the transformed range, the transformed range will be shrank.
   *
   * If the deleted range contains transformed range, `null` will be returned.
   *
   * @internal
   * @param deletionPosition Position from which nodes are removed.
   * @param howMany How many nodes are removed.
   * @returns Result of the transformation.
   */
  _getTransformedByDeletion(e, t) {
    let n = this.start._getTransformedByDeletion(e, t), r = this.end._getTransformedByDeletion(e, t);
    return n == null && r == null ? null : (n == null && (n = e), r == null && (r = e), new X(n, r));
  }
  /**
   * Creates a new range, spreading from specified {@link module:engine/model/position~Position position} to a position moved by
   * given `shift`. If `shift` is a negative value, shifted position is treated as the beginning of the range.
   *
   * @internal
   * @param position Beginning of the range.
   * @param shift How long the range should be.
   */
  static _createFromPositionAndShift(e, t) {
    const n = e, r = e.getShiftedBy(t);
    return t > 0 ? new this(n, r) : new this(r, n);
  }
  /**
   * Creates a range inside an {@link module:engine/model/element~Element element} which starts before the first child of
   * that element and ends after the last child of that element.
   *
   * @internal
   * @param element Element which is a parent for the range.
   */
  static _createIn(e) {
    return new this(oe._createAt(e, 0), oe._createAt(e, e.maxOffset));
  }
  /**
   * Creates a range that starts before given {@link module:engine/model/item~Item model item} and ends after it.
   *
   * @internal
   */
  static _createOn(e) {
    return this._createFromPositionAndShift(oe._createBefore(e), e.offsetSize);
  }
  /**
   * Combines all ranges from the passed array into a one range. At least one range has to be passed.
   * Passed ranges must not have common parts.
   *
   * The first range from the array is a reference range. If other ranges start or end on the exactly same position where
   * the reference range, they get combined into one range.
   *
   * ```
   * [  ][]  [    ][ ][             ][ ][]  [  ]  // Passed ranges, shown sorted
   * [    ]                                       // The result of the function if the first range was a reference range.
   *         [                           ]        // The result of the function if the third-to-seventh range was a reference range.
   *                                        [  ]  // The result of the function if the last range was a reference range.
   * ```
   *
   * @internal
   * @param ranges Ranges to combine.
   * @returns Combined range.
   */
  static _createFromRanges(e) {
    if (e.length === 0)
      throw new B("range-create-from-ranges-empty-array", null);
    if (e.length == 1)
      return e[0].clone();
    const t = e[0];
    e.sort((s, o) => s.start.isAfter(o.start) ? 1 : -1);
    const n = e.indexOf(t), r = new this(t.start, t.end);
    if (n > 0)
      for (let s = n - 1; e[s].end.isEqual(r.start); s++)
        r.start = oe._createAt(e[s].start);
    for (let s = n + 1; s < e.length && e[s].start.isEqual(r.end); s++)
      r.end = oe._createAt(e[s].end);
    return r;
  }
  /**
   * Creates a `Range` instance from given plain object (i.e. parsed JSON string).
   *
   * @param json Plain object to be converted to `Range`.
   * @param doc Document object that will be range owner.
   * @returns `Range` instance created using given plain object.
   */
  static fromJSON(e, t) {
    return new this(oe.fromJSON(e.start, t), oe.fromJSON(e.end, t));
  }
}
X.prototype.is = function(i) {
  return i === "range" || i === "model:range";
};
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class GE extends kt() {
  /**
   * Creates an instance of the mapper.
   */
  constructor() {
    super(), this._modelToViewMapping = /* @__PURE__ */ new WeakMap(), this._viewToModelMapping = /* @__PURE__ */ new WeakMap(), this._viewToModelLengthCallbacks = /* @__PURE__ */ new Map(), this._markerNameToElements = /* @__PURE__ */ new Map(), this._elementToMarkerNames = /* @__PURE__ */ new Map(), this._deferredBindingRemovals = /* @__PURE__ */ new Map(), this._unboundMarkerNames = /* @__PURE__ */ new Set(), this.on("modelToViewPosition", (e, t) => {
      if (t.viewPosition)
        return;
      const n = this._modelToViewMapping.get(t.modelPosition.parent);
      if (!n)
        throw new B("mapping-model-position-view-parent-not-found", this, { modelPosition: t.modelPosition });
      t.viewPosition = this.findPositionIn(n, t.modelPosition.offset);
    }, { priority: "low" }), this.on("viewToModelPosition", (e, t) => {
      if (t.modelPosition)
        return;
      const n = this.findMappedViewAncestor(t.viewPosition), r = this._viewToModelMapping.get(n), s = this._toModelOffset(t.viewPosition.parent, t.viewPosition.offset, n);
      t.modelPosition = oe._createAt(r, s);
    }, { priority: "low" });
  }
  /**
   * Marks model and view elements as corresponding. Corresponding elements can be retrieved by using
   * the {@link module:engine/conversion/mapper~Mapper#toModelElement toModelElement} and
   * {@link module:engine/conversion/mapper~Mapper#toViewElement toViewElement} methods.
   * The information that elements are bound is also used to translate positions.
   *
   * @param modelElement Model element.
   * @param viewElement View element.
   */
  bindElements(e, t) {
    this._modelToViewMapping.set(e, t), this._viewToModelMapping.set(t, e);
  }
  /**
   * Unbinds the given {@link module:engine/view/element~Element view element} from the map.
   *
   * **Note:** view-to-model binding will be removed, if it existed. However, corresponding model-to-view binding
   * will be removed only if model element is still bound to the passed `viewElement`.
   *
   * This behavior allows for re-binding model element to another view element without fear of losing the new binding
   * when the previously bound view element is unbound.
   *
   * @param viewElement View element to unbind.
   * @param options The options object.
   * @param options.defer Controls whether the binding should be removed immediately or deferred until a
   * {@link #flushDeferredBindings `flushDeferredBindings()`} call.
   */
  unbindViewElement(e, t = {}) {
    const n = this.toModelElement(e);
    if (this._elementToMarkerNames.has(e))
      for (const r of this._elementToMarkerNames.get(e))
        this._unboundMarkerNames.add(r);
    t.defer ? this._deferredBindingRemovals.set(e, e.root) : (this._viewToModelMapping.delete(e), this._modelToViewMapping.get(n) == e && this._modelToViewMapping.delete(n));
  }
  /**
   * Unbinds the given {@link module:engine/model/element~Element model element} from the map.
   *
   * **Note:** the model-to-view binding will be removed, if it existed. However, the corresponding view-to-model binding
   * will be removed only if the view element is still bound to the passed `modelElement`.
   *
   * This behavior lets for re-binding view element to another model element without fear of losing the new binding
   * when the previously bound model element is unbound.
   *
   * @param modelElement Model element to unbind.
   */
  unbindModelElement(e) {
    const t = this.toViewElement(e);
    this._modelToViewMapping.delete(e), this._viewToModelMapping.get(t) == e && this._viewToModelMapping.delete(t);
  }
  /**
   * Binds the given marker name with the given {@link module:engine/view/element~Element view element}. The element
   * will be added to the current set of elements bound with the given marker name.
   *
   * @param element Element to bind.
   * @param name Marker name.
   */
  bindElementToMarker(e, t) {
    const n = this._markerNameToElements.get(t) || /* @__PURE__ */ new Set();
    n.add(e);
    const r = this._elementToMarkerNames.get(e) || /* @__PURE__ */ new Set();
    r.add(t), this._markerNameToElements.set(t, n), this._elementToMarkerNames.set(e, r);
  }
  /**
   * Unbinds an element from given marker name.
   *
   * @param element Element to unbind.
   * @param name Marker name.
   */
  unbindElementFromMarkerName(e, t) {
    const n = this._markerNameToElements.get(t);
    n && (n.delete(e), n.size == 0 && this._markerNameToElements.delete(t));
    const r = this._elementToMarkerNames.get(e);
    r && (r.delete(t), r.size == 0 && this._elementToMarkerNames.delete(e));
  }
  /**
   * Returns all marker names of markers which have changed due to unbinding a view element (so it is assumed that the view element
   * has been removed, moved or renamed) since the last flush. After returning, the marker names list is cleared.
   */
  flushUnboundMarkerNames() {
    const e = Array.from(this._unboundMarkerNames);
    return this._unboundMarkerNames.clear(), e;
  }
  /**
   * Unbinds all deferred binding removals of view elements that in the meantime were not re-attached to some root or document fragment.
   *
   * See: {@link #unbindViewElement `unbindViewElement()`}.
   */
  flushDeferredBindings() {
    for (const [e, t] of this._deferredBindingRemovals)
      e.root == t && this.unbindViewElement(e);
    this._deferredBindingRemovals = /* @__PURE__ */ new Map();
  }
  /**
   * Removes all model to view and view to model bindings.
   */
  clearBindings() {
    this._modelToViewMapping = /* @__PURE__ */ new WeakMap(), this._viewToModelMapping = /* @__PURE__ */ new WeakMap(), this._markerNameToElements = /* @__PURE__ */ new Map(), this._elementToMarkerNames = /* @__PURE__ */ new Map(), this._unboundMarkerNames = /* @__PURE__ */ new Set(), this._deferredBindingRemovals = /* @__PURE__ */ new Map();
  }
  toModelElement(e) {
    return this._viewToModelMapping.get(e);
  }
  toViewElement(e) {
    return this._modelToViewMapping.get(e);
  }
  /**
   * Gets the corresponding model range.
   *
   * @param viewRange View range.
   * @returns Corresponding model range.
   */
  toModelRange(e) {
    return new X(this.toModelPosition(e.start), this.toModelPosition(e.end));
  }
  /**
   * Gets the corresponding view range.
   *
   * @param modelRange Model range.
   * @returns Corresponding view range.
   */
  toViewRange(e) {
    return new We(this.toViewPosition(e.start), this.toViewPosition(e.end));
  }
  /**
   * Gets the corresponding model position.
   *
   * @fires viewToModelPosition
   * @param viewPosition View position.
   * @returns Corresponding model position.
   */
  toModelPosition(e) {
    const t = {
      viewPosition: e,
      mapper: this
    };
    return this.fire("viewToModelPosition", t), t.modelPosition;
  }
  /**
   * Gets the corresponding view position.
   *
   * @fires modelToViewPosition
   * @param modelPosition Model position.
   * @param options Additional options for position mapping process.
   * @param options.isPhantom Should be set to `true` if the model position to map is pointing to a place
   * in model tree which no longer exists. For example, it could be an end of a removed model range.
   * @returns Corresponding view position.
   */
  toViewPosition(e, t = {}) {
    const n = {
      modelPosition: e,
      mapper: this,
      isPhantom: t.isPhantom
    };
    return this.fire("modelToViewPosition", n), n.viewPosition;
  }
  /**
   * Gets all view elements bound to the given marker name.
   *
   * @param name Marker name.
   * @returns View elements bound with the given marker name or `null`
   * if no elements are bound to the given marker name.
   */
  markerNameToElements(e) {
    const t = this._markerNameToElements.get(e);
    if (!t)
      return null;
    const n = /* @__PURE__ */ new Set();
    for (const r of t)
      if (r.is("attributeElement"))
        for (const s of r.getElementsWithSameId())
          n.add(s);
      else
        n.add(r);
    return n;
  }
  /**
   * Registers a callback that evaluates the length in the model of a view element with the given name.
   *
   * The callback is fired with one argument, which is a view element instance. The callback is expected to return
   * a number representing the length of the view element in the model.
   *
   * ```ts
   * // List item in view may contain nested list, which have other list items. In model though,
   * // the lists are represented by flat structure. Because of those differences, length of list view element
   * // may be greater than one. In the callback it's checked how many nested list items are in evaluated list item.
   *
   * function getViewListItemLength( element ) {
   * 	let length = 1;
   *
   * 	for ( let child of element.getChildren() ) {
   * 		if ( child.name == 'ul' || child.name == 'ol' ) {
   * 			for ( let item of child.getChildren() ) {
   * 				length += getViewListItemLength( item );
   * 			}
   * 		}
   * 	}
   *
   * 	return length;
   * }
   *
   * mapper.registerViewToModelLength( 'li', getViewListItemLength );
   * ```
   *
   * @param viewElementName Name of view element for which callback is registered.
   * @param lengthCallback Function return a length of view element instance in model.
   */
  registerViewToModelLength(e, t) {
    this._viewToModelLengthCallbacks.set(e, t);
  }
  /**
   * For the given `viewPosition`, finds and returns the closest ancestor of this position that has a mapping to
   * the model.
   *
   * @param viewPosition Position for which a mapped ancestor should be found.
   */
  findMappedViewAncestor(e) {
    let t = e.parent;
    for (; !this._viewToModelMapping.has(t); )
      t = t.parent;
    return t;
  }
  /**
   * Calculates model offset based on the view position and the block element.
   *
   * Example:
   *
   * ```html
   * <p>foo<b>ba|r</b></p> // _toModelOffset( b, 2, p ) -> 5
   * ```
   *
   * Is a sum of:
   *
   * ```html
   * <p>foo|<b>bar</b></p> // _toModelOffset( p, 3, p ) -> 3
   * <p>foo<b>ba|r</b></p> // _toModelOffset( b, 2, b ) -> 2
   * ```
   *
   * @param viewParent Position parent.
   * @param viewOffset Position offset.
   * @param viewBlock Block used as a base to calculate offset.
   * @returns Offset in the model.
   */
  _toModelOffset(e, t, n) {
    if (n != e) {
      const s = this._toModelOffset(e.parent, e.index, n), o = this._toModelOffset(e, t, e);
      return s + o;
    }
    if (e.is("$text"))
      return t;
    let r = 0;
    for (let s = 0; s < t; s++)
      r += this.getModelLength(e.getChild(s));
    return r;
  }
  /**
   * Gets the length of the view element in the model.
   *
   * The length is calculated as follows:
   * * if a {@link #registerViewToModelLength length mapping callback} is provided for the given `viewNode`, it is used to
   * evaluate the model length (`viewNode` is used as first and only parameter passed to the callback),
   * * length of a {@link module:engine/view/text~Text text node} is equal to the length of its
   * {@link module:engine/view/text~Text#data data},
   * * length of a {@link module:engine/view/uielement~UIElement ui element} is equal to 0,
   * * length of a mapped {@link module:engine/view/element~Element element} is equal to 1,
   * * length of a non-mapped {@link module:engine/view/element~Element element} is equal to the length of its children.
   *
   * Examples:
   *
   * ```
   * foo                          -> 3 // Text length is equal to its data length.
   * <p>foo</p>                   -> 1 // Length of an element which is mapped is by default equal to 1.
   * <b>foo</b>                   -> 3 // Length of an element which is not mapped is a length of its children.
   * <div><p>x</p><p>y</p></div>  -> 2 // Assuming that <div> is not mapped and <p> are mapped.
   * ```
   *
   * @param viewNode View node.
   * @returns Length of the node in the tree model.
   */
  getModelLength(e) {
    if (this._viewToModelLengthCallbacks.get(e.name))
      return this._viewToModelLengthCallbacks.get(e.name)(e);
    if (this._viewToModelMapping.has(e))
      return 1;
    if (e.is("$text"))
      return e.data.length;
    if (e.is("uiElement"))
      return 0;
    {
      let t = 0;
      for (const n of e.getChildren())
        t += this.getModelLength(n);
      return t;
    }
  }
  /**
   * Finds the position in the view node (or in its children) with the expected model offset.
   *
   * Example:
   *
   * ```
   * <p>fo<b>bar</b>bom</p> -> expected offset: 4
   *
   * findPositionIn( p, 4 ):
   * <p>|fo<b>bar</b>bom</p> -> expected offset: 4, actual offset: 0
   * <p>fo|<b>bar</b>bom</p> -> expected offset: 4, actual offset: 2
   * <p>fo<b>bar</b>|bom</p> -> expected offset: 4, actual offset: 5 -> we are too far
   *
   * findPositionIn( b, 4 - ( 5 - 3 ) ):
   * <p>fo<b>|bar</b>bom</p> -> expected offset: 2, actual offset: 0
   * <p>fo<b>bar|</b>bom</p> -> expected offset: 2, actual offset: 3 -> we are too far
   *
   * findPositionIn( bar, 2 - ( 3 - 3 ) ):
   * We are in the text node so we can simple find the offset.
   * <p>fo<b>ba|r</b>bom</p> -> expected offset: 2, actual offset: 2 -> position found
   * ```
   *
   * @param viewParent Tree view element in which we are looking for the position.
   * @param expectedOffset Expected offset.
   * @returns Found position.
   */
  findPositionIn(e, t) {
    let n, r = 0, s = 0, o = 0;
    if (e.is("$text"))
      return new _e(e, t);
    for (; s < t; )
      n = e.getChild(o), r = this.getModelLength(n), s += r, o++;
    return s == t ? this._moveViewPositionToTextNode(new _e(e, o)) : this.findPositionIn(n, t - (s - r));
  }
  /**
   * Because we prefer positions in the text nodes over positions next to text nodes, if the view position was next to a text node,
   * it moves it into the text node instead.
   *
   * ```
   * <p>[]<b>foo</b></p> -> <p>[]<b>foo</b></p> // do not touch if position is not directly next to text
   * <p>foo[]<b>foo</b></p> -> <p>foo{}<b>foo</b></p> // move to text node
   * <p><b>[]foo</b></p> -> <p><b>{}foo</b></p> // move to text node
   * ```
   *
   * @param viewPosition Position potentially next to the text node.
   * @returns Position in the text node if possible.
   */
  _moveViewPositionToTextNode(e) {
    const t = e.nodeBefore, n = e.nodeAfter;
    return t instanceof Bt ? new _e(t, t.data.length) : n instanceof Bt ? new _e(n, 0) : e;
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class YV {
  constructor() {
    this._consumable = /* @__PURE__ */ new Map(), this._textProxyRegistry = /* @__PURE__ */ new Map();
  }
  /**
   * Adds a consumable value to the consumables list and links it with a given model item.
   *
   * ```ts
   * modelConsumable.add( modelElement, 'insert' ); // Add `modelElement` insertion change to consumable values.
   * modelConsumable.add( modelElement, 'addAttribute:bold' ); // Add `bold` attribute insertion on `modelElement` change.
   * modelConsumable.add( modelElement, 'removeAttribute:bold' ); // Add `bold` attribute removal on `modelElement` change.
   * modelConsumable.add( modelSelection, 'selection' ); // Add `modelSelection` to consumable values.
   * modelConsumable.add( modelRange, 'range' ); // Add `modelRange` to consumable values.
   * ```
   *
   * @param item Model item, range or selection that has the consumable.
   * @param type Consumable type. Will be normalized to a proper form, that is either `<word>` or `<part>:<part>`.
   * Second colon and everything after will be cut. Passing event name is a safe and good practice.
   */
  add(e, t) {
    t = Wu(t), e instanceof Bi && (e = this._getSymbolForTextProxy(e)), this._consumable.has(e) || this._consumable.set(e, /* @__PURE__ */ new Map()), this._consumable.get(e).set(t, !0);
  }
  /**
   * Removes a given consumable value from a given model item.
   *
   * ```ts
   * modelConsumable.consume( modelElement, 'insert' ); // Remove `modelElement` insertion change from consumable values.
   * modelConsumable.consume( modelElement, 'addAttribute:bold' ); // Remove `bold` attribute insertion on `modelElement` change.
   * modelConsumable.consume( modelElement, 'removeAttribute:bold' ); // Remove `bold` attribute removal on `modelElement` change.
   * modelConsumable.consume( modelSelection, 'selection' ); // Remove `modelSelection` from consumable values.
   * modelConsumable.consume( modelRange, 'range' ); // Remove 'modelRange' from consumable values.
   * ```
   *
   * @param item Model item, range or selection from which consumable will be consumed.
   * @param type Consumable type. Will be normalized to a proper form, that is either `<word>` or `<part>:<part>`.
   * Second colon and everything after will be cut. Passing event name is a safe and good practice.
   * @returns `true` if consumable value was available and was consumed, `false` otherwise.
   */
  consume(e, t) {
    return t = Wu(t), e instanceof Bi && (e = this._getSymbolForTextProxy(e)), this.test(e, t) ? (this._consumable.get(e).set(t, !1), !0) : !1;
  }
  /**
   * Tests whether there is a consumable value of a given type connected with a given model item.
   *
   * ```ts
   * modelConsumable.test( modelElement, 'insert' ); // Check for `modelElement` insertion change.
   * modelConsumable.test( modelElement, 'addAttribute:bold' ); // Check for `bold` attribute insertion on `modelElement` change.
   * modelConsumable.test( modelElement, 'removeAttribute:bold' ); // Check for `bold` attribute removal on `modelElement` change.
   * modelConsumable.test( modelSelection, 'selection' ); // Check if `modelSelection` is consumable.
   * modelConsumable.test( modelRange, 'range' ); // Check if `modelRange` is consumable.
   * ```
   *
   * @param item Model item, range or selection to be tested.
   * @param type Consumable type. Will be normalized to a proper form, that is either `<word>` or `<part>:<part>`.
   * Second colon and everything after will be cut. Passing event name is a safe and good practice.
   * @returns `null` if such consumable was never added, `false` if the consumable values was
   * already consumed or `true` if it was added and not consumed yet.
   */
  test(e, t) {
    t = Wu(t), e instanceof Bi && (e = this._getSymbolForTextProxy(e));
    const n = this._consumable.get(e);
    if (n === void 0)
      return null;
    const r = n.get(t);
    return r === void 0 ? null : r;
  }
  /**
   * Reverts consuming of a consumable value.
   *
   * ```ts
   * modelConsumable.revert( modelElement, 'insert' ); // Revert consuming `modelElement` insertion change.
   * modelConsumable.revert( modelElement, 'addAttribute:bold' ); // Revert consuming `bold` attribute insert from `modelElement`.
   * modelConsumable.revert( modelElement, 'removeAttribute:bold' ); // Revert consuming `bold` attribute remove from `modelElement`.
   * modelConsumable.revert( modelSelection, 'selection' ); // Revert consuming `modelSelection`.
   * modelConsumable.revert( modelRange, 'range' ); // Revert consuming `modelRange`.
   * ```
   *
   * @param item Model item, range or selection to be reverted.
   * @param type Consumable type.
   * @returns `true` if consumable has been reversed, `false` otherwise. `null` if the consumable has
   * never been added.
   */
  revert(e, t) {
    t = Wu(t), e instanceof Bi && (e = this._getSymbolForTextProxy(e));
    const n = this.test(e, t);
    return n === !1 ? (this._consumable.get(e).set(t, !0), !0) : n === !0 ? !1 : null;
  }
  /**
   * Verifies if all events from the specified group were consumed.
   *
   * @param eventGroup The events group to verify.
   */
  verifyAllConsumed(e) {
    const t = [];
    for (const [n, r] of this._consumable)
      for (const [s, o] of r) {
        const l = s.split(":")[0];
        o && e == l && t.push({
          event: s,
          item: n.name || n.description
        });
      }
    if (t.length)
      throw new B("conversion-model-consumable-not-consumed", null, { items: t });
  }
  /**
   * Gets a unique symbol for the passed {@link module:engine/model/textproxy~TextProxy} instance. All `TextProxy` instances that
   * have same parent, same start index and same end index will get the same symbol.
   *
   * Used internally to correctly consume `TextProxy` instances.
   *
   * @internal
   * @param textProxy `TextProxy` instance to get a symbol for.
   * @returns Symbol representing all equal instances of `TextProxy`.
   */
  _getSymbolForTextProxy(e) {
    let t = null;
    const n = this._textProxyRegistry.get(e.startOffset);
    if (n) {
      const r = n.get(e.endOffset);
      r && (t = r.get(e.parent));
    }
    return t || (t = this._addSymbolForTextProxy(e)), t;
  }
  /**
   * Adds a symbol for the given {@link module:engine/model/textproxy~TextProxy} instance.
   *
   * Used internally to correctly consume `TextProxy` instances.
   *
   * @param textProxy Text proxy instance.
   * @returns Symbol generated for given `TextProxy`.
   */
  _addSymbolForTextProxy(e) {
    const t = e.startOffset, n = e.endOffset, r = e.parent, s = Symbol("$textProxy:" + e.data);
    let o, l;
    return o = this._textProxyRegistry.get(t), o || (o = /* @__PURE__ */ new Map(), this._textProxyRegistry.set(t, o)), l = o.get(n), l || (l = /* @__PURE__ */ new Map(), o.set(n, l)), l.set(r, s), s;
  }
}
function Wu(i) {
  const e = i.split(":");
  return e[0] == "insert" ? e[0] : e[0] == "addMarker" || e[0] == "removeMarker" ? i : e.length > 1 ? e[0] + ":" + e[1] : e[0];
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class YE extends kt() {
  /**
   * Creates a downcast dispatcher instance.
   *
   * @see module:engine/conversion/downcastdispatcher~DowncastConversionApi
   *
   * @param conversionApi Additional properties for an interface that will be passed to events fired
   * by the downcast dispatcher.
   */
  constructor(e) {
    super(), this._conversionApi = { dispatcher: this, ...e }, this._firedEventsMap = /* @__PURE__ */ new WeakMap();
  }
  /**
   * Converts changes buffered in the given {@link module:engine/model/differ~Differ model differ}
   * and fires conversion events based on it.
   *
   * @fires insert
   * @fires remove
   * @fires attribute
   * @fires addMarker
   * @fires removeMarker
   * @fires reduceChanges
   * @param differ The differ object with buffered changes.
   * @param markers Markers related to the model fragment to convert.
   * @param writer The view writer that should be used to modify the view document.
   */
  convertChanges(e, t, n) {
    const r = this._createConversionApi(n, e.getRefreshedItems());
    for (const o of e.getMarkersToRemove())
      this._convertMarkerRemove(o.name, o.range, r);
    const s = this._reduceChanges(e.getChanges());
    for (const o of s)
      o.type === "insert" ? this._convertInsert(X._createFromPositionAndShift(o.position, o.length), r) : o.type === "reinsert" ? this._convertReinsert(X._createFromPositionAndShift(o.position, o.length), r) : o.type === "remove" ? this._convertRemove(o.position, o.length, o.name, r) : this._convertAttribute(o.range, o.attributeKey, o.attributeOldValue, o.attributeNewValue, r);
    for (const o of r.mapper.flushUnboundMarkerNames()) {
      const l = t.get(o).getRange();
      this._convertMarkerRemove(o, l, r), this._convertMarkerAdd(o, l, r);
    }
    for (const o of e.getMarkersToAdd())
      this._convertMarkerAdd(o.name, o.range, r);
    r.mapper.flushDeferredBindings(), r.consumable.verifyAllConsumed("insert");
  }
  /**
   * Starts a conversion of a model range and the provided markers.
   *
   * @fires insert
   * @fires attribute
   * @fires addMarker
   * @param range The inserted range.
   * @param markers The map of markers that should be down-casted.
   * @param writer The view writer that should be used to modify the view document.
   * @param options Optional options object passed to `convertionApi.options`.
   */
  convert(e, t, n, r = {}) {
    const s = this._createConversionApi(n, void 0, r);
    this._convertInsert(e, s);
    for (const [o, l] of t)
      this._convertMarkerAdd(o, l, s);
    s.consumable.verifyAllConsumed("insert");
  }
  /**
   * Starts the model selection conversion.
   *
   * Fires events for a given {@link module:engine/model/selection~Selection selection} to start the selection conversion.
   *
   * @fires selection
   * @fires addMarker
   * @fires attribute
   * @param selection The selection to convert.
   * @param markers Markers connected with the converted model.
   * @param writer View writer that should be used to modify the view document.
   */
  convertSelection(e, t, n) {
    const r = Array.from(t.getMarkersAtPosition(e.getFirstPosition())), s = this._createConversionApi(n);
    if (this._addConsumablesForSelection(s.consumable, e, r), this.fire("selection", { selection: e }, s), !!e.isCollapsed) {
      for (const o of r) {
        const l = o.getRange();
        if (!JV(e.getFirstPosition(), o, s.mapper))
          continue;
        const u = {
          item: e,
          markerName: o.name,
          markerRange: l
        };
        s.consumable.test(e, "addMarker:" + o.name) && this.fire(`addMarker:${o.name}`, u, s);
      }
      for (const o of e.getAttributeKeys()) {
        const l = {
          item: e,
          range: e.getFirstRange(),
          attributeKey: o,
          attributeOldValue: null,
          attributeNewValue: e.getAttribute(o)
        };
        s.consumable.test(e, "attribute:" + l.attributeKey) && this.fire(`attribute:${l.attributeKey}:$text`, l, s);
      }
    }
  }
  /**
   * Fires insertion conversion of a range of nodes.
   *
   * For each node in the range, {@link #event:insert `insert` event is fired}. For each attribute on each node,
   * {@link #event:attribute `attribute` event is fired}.
   *
   * @fires insert
   * @fires attribute
   * @param range The inserted range.
   * @param conversionApi The conversion API object.
   * @param options.doNotAddConsumables Whether the ModelConsumable should not get populated
   * for items in the provided range.
   */
  _convertInsert(e, t, n = {}) {
    n.doNotAddConsumables || this._addConsumablesForInsert(t.consumable, Array.from(e));
    for (const r of Array.from(e.getWalker({ shallow: !0 })).map(sb))
      this._testAndFire("insert", r, t);
  }
  /**
   * Fires conversion of a single node removal. Fires {@link #event:remove remove event} with provided data.
   *
   * @param position Position from which node was removed.
   * @param length Offset size of removed node.
   * @param name Name of removed node.
   * @param conversionApi The conversion API object.
   */
  _convertRemove(e, t, n, r) {
    this.fire(`remove:${n}`, { position: e, length: t }, r);
  }
  /**
   * Starts a conversion of an attribute change on a given `range`.
   *
   * For each node in the given `range`, {@link #event:attribute attribute event} is fired with the passed data.
   *
   * @fires attribute
   * @param range Changed range.
   * @param key Key of the attribute that has changed.
   * @param oldValue Attribute value before the change or `null` if the attribute has not been set before.
   * @param newValue New attribute value or `null` if the attribute has been removed.
   * @param conversionApi The conversion API object.
   */
  _convertAttribute(e, t, n, r, s) {
    this._addConsumablesForRange(s.consumable, e, `attribute:${t}`);
    for (const o of e) {
      const l = {
        item: o.item,
        range: X._createFromPositionAndShift(o.previousPosition, o.length),
        attributeKey: t,
        attributeOldValue: n,
        attributeNewValue: r
      };
      this._testAndFire(`attribute:${t}`, l, s);
    }
  }
  /**
   * Fires re-insertion conversion (with a `reconversion` flag passed to `insert` events)
   * of a range of elements (only elements on the range depth, without children).
   *
   * For each node in the range on its depth (without children), {@link #event:insert `insert` event} is fired.
   * For each attribute on each node, {@link #event:attribute `attribute` event} is fired.
   *
   * @fires insert
   * @fires attribute
   * @param range The range to reinsert.
   * @param conversionApi The conversion API object.
   */
  _convertReinsert(e, t) {
    const n = Array.from(e.getWalker({ shallow: !0 }));
    this._addConsumablesForInsert(t.consumable, n);
    for (const r of n.map(sb))
      this._testAndFire("insert", { ...r, reconversion: !0 }, t);
  }
  /**
   * Converts the added marker. Fires the {@link #event:addMarker `addMarker`} event for each item
   * in the marker's range. If the range is collapsed, a single event is dispatched. See the event description for more details.
   *
   * @fires addMarker
   * @param markerName Marker name.
   * @param markerRange The marker range.
   * @param conversionApi The conversion API object.
   */
  _convertMarkerAdd(e, t, n) {
    if (t.root.rootName == "$graveyard")
      return;
    const r = `addMarker:${e}`;
    if (n.consumable.add(t, r), this.fire(r, { markerName: e, markerRange: t }, n), !!n.consumable.consume(t, r)) {
      this._addConsumablesForRange(n.consumable, t, r);
      for (const s of t.getItems()) {
        if (!n.consumable.test(s, r))
          continue;
        const o = { item: s, range: X._createOn(s), markerName: e, markerRange: t };
        this.fire(r, o, n);
      }
    }
  }
  /**
   * Fires the conversion of the marker removal. Fires the {@link #event:removeMarker `removeMarker`} event with the provided data.
   *
   * @fires removeMarker
   * @param markerName Marker name.
   * @param markerRange The marker range.
   * @param conversionApi The conversion API object.
   */
  _convertMarkerRemove(e, t, n) {
    t.root.rootName != "$graveyard" && this.fire(`removeMarker:${e}`, { markerName: e, markerRange: t }, n);
  }
  /**
   * Fires the reduction of changes buffered in the {@link module:engine/model/differ~Differ `Differ`}.
   *
   * Features can replace selected {@link module:engine/model/differ~DiffItem `DiffItem`}s with `reinsert` entries to trigger
   * reconversion. The {@link module:engine/conversion/downcasthelpers~DowncastHelpers#elementToStructure
   * `DowncastHelpers.elementToStructure()`} is using this event to trigger reconversion.
   *
   * @fires reduceChanges
   */
  _reduceChanges(e) {
    const t = { changes: e };
    return this.fire("reduceChanges", t), t.changes;
  }
  /**
   * Populates provided {@link module:engine/conversion/modelconsumable~ModelConsumable} with values to consume from a given range,
   * assuming that the range has just been inserted to the model.
   *
   * @param consumable The consumable.
   * @param walkerValues The walker values for the inserted range.
   * @returns The values to consume.
   */
  _addConsumablesForInsert(e, t) {
    for (const n of t) {
      const r = n.item;
      if (e.test(r, "insert") === null) {
        e.add(r, "insert");
        for (const s of r.getAttributeKeys())
          e.add(r, "attribute:" + s);
      }
    }
    return e;
  }
  /**
   * Populates provided {@link module:engine/conversion/modelconsumable~ModelConsumable} with values to consume for a given range.
   *
   * @param consumable The consumable.
   * @param range The affected range.
   * @param type Consumable type.
   * @returns The values to consume.
   */
  _addConsumablesForRange(e, t, n) {
    for (const r of t.getItems())
      e.add(r, n);
    return e;
  }
  /**
   * Populates provided {@link module:engine/conversion/modelconsumable~ModelConsumable} with selection consumable values.
   *
   * @param consumable The consumable.
   * @param selection The selection to create the consumable from.
   * @param markers Markers that contain the selection.
   * @returns The values to consume.
   */
  _addConsumablesForSelection(e, t, n) {
    e.add(t, "selection");
    for (const r of n)
      e.add(t, "addMarker:" + r.name);
    for (const r of t.getAttributeKeys())
      e.add(t, "attribute:" + r);
    return e;
  }
  /**
   * Tests whether given event wasn't already fired and if so, fires it.
   *
   * @fires insert
   * @fires attribute
   * @param type Event type.
   * @param data Event data.
   * @param conversionApi The conversion API object.
   */
  _testAndFire(e, t, n) {
    const r = XV(e, t), s = t.item.is("$textProxy") ? n.consumable._getSymbolForTextProxy(t.item) : t.item, o = this._firedEventsMap.get(n), l = o.get(s);
    if (!l)
      o.set(s, /* @__PURE__ */ new Set([r]));
    else if (!l.has(r))
      l.add(r);
    else
      return;
    this.fire(r, t, n);
  }
  /**
   * Fires not already fired events for setting attributes on just inserted item.
   *
   * @param item The model item to convert attributes for.
   * @param conversionApi The conversion API object.
   */
  _testAndFireAddAttributes(e, t) {
    const n = {
      item: e,
      range: X._createOn(e)
    };
    for (const r of n.item.getAttributeKeys())
      n.attributeKey = r, n.attributeOldValue = null, n.attributeNewValue = n.item.getAttribute(r), this._testAndFire(`attribute:${r}`, n, t);
  }
  /**
   * Builds an instance of the {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi} from a template and a given
   * {@link module:engine/view/downcastwriter~DowncastWriter `DowncastWriter`} and options object.
   *
   * @param writer View writer that should be used to modify the view document.
   * @param refreshedItems A set of model elements that should not reuse their
   * previous view representations.
   * @param options Optional options passed to `convertionApi.options`.
   * @return The conversion API object.
   */
  _createConversionApi(e, t = /* @__PURE__ */ new Set(), n = {}) {
    const r = {
      ...this._conversionApi,
      consumable: new YV(),
      writer: e,
      options: n,
      convertItem: (s) => this._convertInsert(X._createOn(s), r),
      convertChildren: (s) => this._convertInsert(X._createIn(s), r, { doNotAddConsumables: !0 }),
      convertAttributes: (s) => this._testAndFireAddAttributes(s, r),
      canReuseView: (s) => !t.has(r.mapper.toModelElement(s))
    };
    return this._firedEventsMap.set(r, /* @__PURE__ */ new Map()), r;
  }
}
function JV(i, e, t) {
  const n = e.getRange(), r = Array.from(i.getAncestors());
  return r.shift(), r.reverse(), !r.some((o) => {
    if (n.containsItem(o))
      return !!t.toViewElement(o).getCustomProperty("addHighlight");
  });
}
function XV(i, e) {
  const t = e.item.is("element") ? e.item.name : "$text";
  return `${i}:${t}`;
}
function sb(i) {
  const e = i.item, t = X._createFromPositionAndShift(i.previousPosition, i.length);
  return {
    item: e,
    range: t
  };
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class Vi extends kt(ls) {
  /**
   * Creates a new selection instance based on the given {@link module:engine/model/selection~Selectable selectable}
   * or creates an empty selection if no arguments were passed.
   *
   * ```ts
   * // Creates empty selection without ranges.
   * const selection = writer.createSelection();
   *
   * // Creates selection at the given range.
   * const range = writer.createRange( start, end );
   * const selection = writer.createSelection( range );
   *
   * // Creates selection at the given ranges
   * const ranges = [ writer.createRange( start1, end2 ), writer.createRange( star2, end2 ) ];
   * const selection = writer.createSelection( ranges );
   *
   * // Creates selection from the other selection.
   * // Note: It doesn't copy selection attributes.
   * const otherSelection = writer.createSelection();
   * const selection = writer.createSelection( otherSelection );
   *
   * // Creates selection from the given document selection.
   * // Note: It doesn't copy selection attributes.
   * const documentSelection = model.document.selection;
   * const selection = writer.createSelection( documentSelection );
   *
   * // Creates selection at the given position.
   * const position = writer.createPositionFromPath( root, path );
   * const selection = writer.createSelection( position );
   *
   * // Creates selection at the given offset in the given element.
   * const paragraph = writer.createElement( 'paragraph' );
   * const selection = writer.createSelection( paragraph, offset );
   *
   * // Creates a range inside an {@link module:engine/model/element~Element element} which starts before the
   * // first child of that element and ends after the last child of that element.
   * const selection = writer.createSelection( paragraph, 'in' );
   *
   * // Creates a range on an {@link module:engine/model/item~Item item} which starts before the item and ends
   * // just after the item.
   * const selection = writer.createSelection( paragraph, 'on' );
   * ```
   *
   * Selection's constructor allow passing additional options (`'backward'`) as the last argument.
   *
   * ```ts
   * // Creates backward selection.
   * const selection = writer.createSelection( range, { backward: true } );
   * ```
   *
   * @internal
   */
  constructor(...e) {
    super(), this._lastRangeBackward = !1, this._attrs = /* @__PURE__ */ new Map(), this._ranges = [], e.length && this.setTo(...e);
  }
  /**
   * Selection anchor. Anchor is the position from which the selection was started. If a user is making a selection
   * by dragging the mouse, the anchor is where the user pressed the mouse button (the beginning of the selection).
   *
   * Anchor and {@link #focus} define the direction of the selection, which is important
   * when expanding/shrinking selection. The focus moves, while the anchor should remain in the same place.
   *
   * Anchor is always set to the {@link module:engine/model/range~Range#start start} or
   * {@link module:engine/model/range~Range#end end} position of the last of selection's ranges. Whether it is
   * the `start` or `end` depends on the specified `options.backward`. See the {@link #setTo `setTo()`} method.
   *
   * May be set to `null` if there are no ranges in the selection.
   *
   * @see #focus
   */
  get anchor() {
    if (this._ranges.length > 0) {
      const e = this._ranges[this._ranges.length - 1];
      return this._lastRangeBackward ? e.end : e.start;
    }
    return null;
  }
  /**
   * Selection focus. Focus is the position where the selection ends. If a user is making a selection
   * by dragging the mouse, the focus is where the mouse cursor is.
   *
   * May be set to `null` if there are no ranges in the selection.
   *
   * @see #anchor
   */
  get focus() {
    if (this._ranges.length > 0) {
      const e = this._ranges[this._ranges.length - 1];
      return this._lastRangeBackward ? e.start : e.end;
    }
    return null;
  }
  /**
   * Whether the selection is collapsed. Selection is collapsed when there is exactly one range in it
   * and it is collapsed.
   */
  get isCollapsed() {
    return this._ranges.length === 1 ? this._ranges[0].isCollapsed : !1;
  }
  /**
   * Returns the number of ranges in the selection.
   */
  get rangeCount() {
    return this._ranges.length;
  }
  /**
   * Specifies whether the selection's {@link #focus} precedes the selection's {@link #anchor}.
   */
  get isBackward() {
    return !this.isCollapsed && this._lastRangeBackward;
  }
  /**
   * Checks whether this selection is equal to the given selection. Selections are equal if they have the same directions,
   * the same number of ranges and all ranges from one selection equal to ranges from the another selection.
   *
   * @param otherSelection Selection to compare with.
   * @returns `true` if selections are equal, `false` otherwise.
   */
  isEqual(e) {
    if (this.rangeCount != e.rangeCount)
      return !1;
    if (this.rangeCount === 0)
      return !0;
    if (!this.anchor.isEqual(e.anchor) || !this.focus.isEqual(e.focus))
      return !1;
    for (const t of this._ranges) {
      let n = !1;
      for (const r of e._ranges)
        if (t.isEqual(r)) {
          n = !0;
          break;
        }
      if (!n)
        return !1;
    }
    return !0;
  }
  /**
   * Returns an iterable object that iterates over copies of selection ranges.
   */
  *getRanges() {
    for (const e of this._ranges)
      yield new X(e.start, e.end);
  }
  /**
   * Returns a copy of the first range in the selection.
   * First range is the one which {@link module:engine/model/range~Range#start start} position
   * {@link module:engine/model/position~Position#isBefore is before} start position of all other ranges
   * (not to confuse with the first range added to the selection).
   *
   * Returns `null` if there are no ranges in selection.
   */
  getFirstRange() {
    let e = null;
    for (const t of this._ranges)
      (!e || t.start.isBefore(e.start)) && (e = t);
    return e ? new X(e.start, e.end) : null;
  }
  /**
   * Returns a copy of the last range in the selection.
   * Last range is the one which {@link module:engine/model/range~Range#end end} position
   * {@link module:engine/model/position~Position#isAfter is after} end position of all other ranges (not to confuse with the range most
   * recently added to the selection).
   *
   * Returns `null` if there are no ranges in selection.
   */
  getLastRange() {
    let e = null;
    for (const t of this._ranges)
      (!e || t.end.isAfter(e.end)) && (e = t);
    return e ? new X(e.start, e.end) : null;
  }
  /**
   * Returns the first position in the selection.
   * First position is the position that {@link module:engine/model/position~Position#isBefore is before}
   * any other position in the selection.
   *
   * Returns `null` if there are no ranges in selection.
   */
  getFirstPosition() {
    const e = this.getFirstRange();
    return e ? e.start.clone() : null;
  }
  /**
   * Returns the last position in the selection.
   * Last position is the position that {@link module:engine/model/position~Position#isAfter is after}
   * any other position in the selection.
   *
   * Returns `null` if there are no ranges in selection.
   */
  getLastPosition() {
    const e = this.getLastRange();
    return e ? e.end.clone() : null;
  }
  /**
   * Sets this selection's ranges and direction to the specified location based on the given
   * {@link module:engine/model/selection~Selectable selectable}.
   *
   * ```ts
   * // Removes all selection's ranges.
   * selection.setTo( null );
   *
   * // Sets selection to the given range.
   * const range = writer.createRange( start, end );
   * selection.setTo( range );
   *
   * // Sets selection to given ranges.
   * const ranges = [ writer.createRange( start1, end2 ), writer.createRange( star2, end2 ) ];
   * selection.setTo( ranges );
   *
   * // Sets selection to other selection.
   * // Note: It doesn't copy selection attributes.
   * const otherSelection = writer.createSelection();
   * selection.setTo( otherSelection );
   *
   * // Sets selection to the given document selection.
   * // Note: It doesn't copy selection attributes.
   * const documentSelection = new DocumentSelection( doc );
   * selection.setTo( documentSelection );
   *
   * // Sets collapsed selection at the given position.
   * const position = writer.createPositionFromPath( root, path );
   * selection.setTo( position );
   *
   * // Sets collapsed selection at the position of the given node and an offset.
   * selection.setTo( paragraph, offset );
   * ```
   *
   * Creates a range inside an {@link module:engine/model/element~Element element} which starts before the first child of
   * that element and ends after the last child of that element.
   *
   * ```ts
   * selection.setTo( paragraph, 'in' );
   * ```
   *
   * Creates a range on an {@link module:engine/model/item~Item item} which starts before the item and ends just after the item.
   *
   * ```ts
   * selection.setTo( paragraph, 'on' );
   * ```
   *
   * `Selection#setTo()`' method allow passing additional options (`backward`) as the last argument.
   *
   * ```ts
   * // Sets backward selection.
   * const selection = writer.createSelection( range, { backward: true } );
   * ```
   */
  setTo(...e) {
    let [t, n, r] = e;
    if (typeof n == "object" && (r = n, n = void 0), t === null)
      this._setRanges([]);
    else if (t instanceof Vi)
      this._setRanges(t.getRanges(), t.isBackward);
    else if (t && typeof t.getRanges == "function")
      this._setRanges(t.getRanges(), t.isBackward);
    else if (t instanceof X)
      this._setRanges([t], !!r && !!r.backward);
    else if (t instanceof oe)
      this._setRanges([new X(t)]);
    else if (t instanceof Ks) {
      const s = !!r && !!r.backward;
      let o;
      if (n == "in")
        o = X._createIn(t);
      else if (n == "on")
        o = X._createOn(t);
      else if (n !== void 0)
        o = new X(oe._createAt(t, n));
      else
        throw new B("model-selection-setto-required-second-parameter", [this, t]);
      this._setRanges([o], s);
    } else if (di(t))
      this._setRanges(t, r && !!r.backward);
    else
      throw new B("model-selection-setto-not-selectable", [this, t]);
  }
  /**
   * Replaces all ranges that were added to the selection with given array of ranges. Last range of the array
   * is treated like the last added range and is used to set {@link module:engine/model/selection~Selection#anchor} and
   * {@link module:engine/model/selection~Selection#focus}. Accepts a flag describing in which direction the selection is made.
   *
   * @fires change:range
   * @param newRanges Ranges to set.
   * @param isLastBackward Flag describing if last added range was selected forward - from start to end (`false`)
   * or backward - from end to start (`true`).
   */
  _setRanges(e, t = !1) {
    const n = Array.from(e), r = n.some((s) => {
      if (!(s instanceof X))
        throw new B("model-selection-set-ranges-not-range", [this, e]);
      return this._ranges.every((o) => !o.isEqual(s));
    });
    n.length === this._ranges.length && !r || (this._replaceAllRanges(n), this._lastRangeBackward = !!t, this.fire("change:range", { directChange: !0 }));
  }
  /**
   * Moves {@link module:engine/model/selection~Selection#focus} to the specified location.
   *
   * The location can be specified in the same form as
   * {@link module:engine/model/writer~Writer#createPositionAt writer.createPositionAt()} parameters.
   *
   * @fires change:range
   * @param offset Offset or one of the flags. Used only when first parameter is a {@link module:engine/model/item~Item model item}.
   */
  setFocus(e, t) {
    if (this.anchor === null)
      throw new B("model-selection-setfocus-no-ranges", [this, e]);
    const n = oe._createAt(e, t);
    if (n.compareWith(this.focus) == "same")
      return;
    const r = this.anchor;
    this._ranges.length && this._popRange(), n.compareWith(r) == "before" ? (this._pushRange(new X(n, r)), this._lastRangeBackward = !0) : (this._pushRange(new X(r, n)), this._lastRangeBackward = !1), this.fire("change:range", { directChange: !0 });
  }
  /**
   * Gets an attribute value for given key or `undefined` if that attribute is not set on the selection.
   *
   * @param key Key of attribute to look for.
   * @returns Attribute value or `undefined`.
   */
  getAttribute(e) {
    return this._attrs.get(e);
  }
  /**
   * Returns iterable that iterates over this selection's attributes.
   *
   * Attributes are returned as arrays containing two items. First one is attribute key and second is attribute value.
   * This format is accepted by native `Map` object and also can be passed in `Node` constructor.
   */
  getAttributes() {
    return this._attrs.entries();
  }
  /**
   * Returns iterable that iterates over this selection's attribute keys.
   */
  getAttributeKeys() {
    return this._attrs.keys();
  }
  /**
   * Checks if the selection has an attribute for given key.
   *
   * @param key Key of attribute to check.
   * @returns `true` if attribute with given key is set on selection, `false` otherwise.
   */
  hasAttribute(e) {
    return this._attrs.has(e);
  }
  /**
   * Removes an attribute with given key from the selection.
   *
   * If given attribute was set on the selection, fires the {@link #event:change:range} event with
   * removed attribute key.
   *
   * @fires change:attribute
   * @param key Key of attribute to remove.
   */
  removeAttribute(e) {
    this.hasAttribute(e) && (this._attrs.delete(e), this.fire("change:attribute", { attributeKeys: [e], directChange: !0 }));
  }
  /**
   * Sets attribute on the selection. If attribute with the same key already is set, it's value is overwritten.
   *
   * If the attribute value has changed, fires the {@link #event:change:range} event with
   * the attribute key.
   *
   * @fires change:attribute
   * @param key Key of attribute to set.
   * @param value Attribute value.
   */
  setAttribute(e, t) {
    this.getAttribute(e) !== t && (this._attrs.set(e, t), this.fire("change:attribute", { attributeKeys: [e], directChange: !0 }));
  }
  /**
   * Returns the selected element. {@link module:engine/model/element~Element Element} is considered as selected if there is only
   * one range in the selection, and that range contains exactly one element.
   * Returns `null` if there is no selected element.
   */
  getSelectedElement() {
    return this.rangeCount !== 1 ? null : this.getFirstRange().getContainedElement();
  }
  /**
   * Gets elements of type {@link module:engine/model/schema~Schema#isBlock "block"} touched by the selection.
   *
   * This method's result can be used for example to apply block styling to all blocks covered by this selection.
   *
   * **Note:** `getSelectedBlocks()` returns blocks that are nested in other non-block elements
   * but will not return blocks nested in other blocks.
   *
   * In this case the function will return exactly all 3 paragraphs (note: `<blockQuote>` is not a block itself):
   *
   * ```xml
   * <paragraph>[a</paragraph>
   * <blockQuote>
   * 	<paragraph>b</paragraph>
   * </blockQuote>
   * <paragraph>c]d</paragraph>
   * ```
   *
   * In this case the paragraph will also be returned, despite the collapsed selection:
   *
   * ```xml
   * <paragraph>[]a</paragraph>
   * ```
   *
   * In such a scenario, however, only blocks A, B & E will be returned as blocks C & D are nested in block B:
   *
   * ```xml
   * [<blockA></blockA>
   * <blockB>
   * 	<blockC></blockC>
   * 	<blockD></blockD>
   * </blockB>
   * <blockE></blockE>]
   * ```
   *
   * If the selection is inside a block all the inner blocks (A & B) are returned:
   *
   * ```xml
   * <block>
   * 	<blockA>[a</blockA>
   * 	<blockB>b]</blockB>
   * </block>
   * ```
   *
   * **Special case**: Selection ignores first and/or last blocks if nothing (from user perspective) is selected in them.
   *
   * ```xml
   * // Selection ends and the beginning of the last block.
   * <paragraph>[a</paragraph>
   * <paragraph>b</paragraph>
   * <paragraph>]c</paragraph> // This block will not be returned
   *
   * // Selection begins at the end of the first block.
   * <paragraph>a[</paragraph> // This block will not be returned
   * <paragraph>b</paragraph>
   * <paragraph>c]</paragraph>
   *
   * // Selection begings at the end of the first block and ends at the beginning of the last block.
   * <paragraph>a[</paragraph> // This block will not be returned
   * <paragraph>b</paragraph>
   * <paragraph>]c</paragraph> // This block will not be returned
   * ```
   */
  *getSelectedBlocks() {
    const e = /* @__PURE__ */ new WeakSet();
    for (const t of this.getRanges()) {
      const n = ob(t.start, e);
      QV(n, t) && (yield n);
      for (const s of t.getWalker()) {
        const o = s.item;
        s.type == "elementEnd" && ZV(o, e, t) && (yield o);
      }
      const r = ob(t.end, e);
      eL(r, t) && (yield r);
    }
  }
  /**
   * Checks whether the selection contains the entire content of the given element. This means that selection must start
   * at a position {@link module:engine/model/position~Position#isTouching touching} the element's start and ends at position
   * touching the element's end.
   *
   * By default, this method will check whether the entire content of the selection's current root is selected.
   * Useful to check if e.g. the user has just pressed <kbd>Ctrl</kbd> + <kbd>A</kbd>.
   */
  containsEntireContent(e = this.anchor.root) {
    const t = oe._createAt(e, 0), n = oe._createAt(e, "end");
    return t.isTouching(this.getFirstPosition()) && n.isTouching(this.getLastPosition());
  }
  /**
   * Adds given range to internal {@link #_ranges ranges array}. Throws an error
   * if given range is intersecting with any range that is already stored in this selection.
   */
  _pushRange(e) {
    this._checkRange(e), this._ranges.push(new X(e.start, e.end));
  }
  /**
   * Checks if given range intersects with ranges that are already in the selection. Throws an error if it does.
   */
  _checkRange(e) {
    for (let t = 0; t < this._ranges.length; t++)
      if (e.isIntersecting(this._ranges[t]))
        throw new B("model-selection-range-intersects", [this, e], { addedRange: e, intersectingRange: this._ranges[t] });
  }
  /**
   * Replaces all the ranges by the given ones.
   * Uses {@link #_popRange _popRange} and {@link #_pushRange _pushRange} to ensure proper ranges removal and addition.
   */
  _replaceAllRanges(e) {
    this._removeAllRanges();
    for (const t of e)
      this._pushRange(t);
  }
  /**
   * Deletes ranges from internal range array. Uses {@link #_popRange _popRange} to
   * ensure proper ranges removal.
   */
  _removeAllRanges() {
    for (; this._ranges.length > 0; )
      this._popRange();
  }
  /**
   * Removes most recently added range from the selection.
   */
  _popRange() {
    this._ranges.pop();
  }
}
Vi.prototype.is = function(i) {
  return i === "selection" || i === "model:selection";
};
function JE(i, e) {
  return e.has(i) ? !1 : (e.add(i), i.root.document.model.schema.isBlock(i) && !!i.parent);
}
function ZV(i, e, t) {
  return JE(i, e) && up(i, t);
}
function ob(i, e) {
  const n = i.parent.root.document.model.schema, r = i.parent.getAncestors({ parentFirst: !0, includeSelf: !0 });
  let s = !1;
  const o = r.find((l) => s ? !1 : (s = n.isLimit(l), !s && JE(l, e)));
  return r.forEach((l) => e.add(l)), o;
}
function up(i, e) {
  const t = tL(i);
  return t ? !e.containsRange(X._createOn(t), !0) : !0;
}
function QV(i, e) {
  return i ? e.isCollapsed || i.isEmpty ? !0 : e.start.isTouching(oe._createAt(i, i.maxOffset)) ? !1 : up(i, e) : !1;
}
function eL(i, e) {
  return i ? e.isCollapsed || i.isEmpty ? !0 : e.end.isTouching(oe._createAt(i, 0)) ? !1 : up(i, e) : !1;
}
function tL(i) {
  const e = i.root.document.model.schema;
  let t = i.parent;
  for (; t; ) {
    if (e.isBlock(t))
      return t;
    t = t.parent;
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class ur extends kt(X) {
  /**
   * Creates a live range.
   *
   * @see module:engine/model/range~Range
   */
  constructor(e, t) {
    super(e, t), nL.call(this);
  }
  /**
   * Unbinds all events previously bound by `LiveRange`. Use it whenever you don't need `LiveRange` instance
   * anymore (i.e. when leaving scope in which it was declared or before re-assigning variable that was
   * referring to it).
   */
  detach() {
    this.stopListening();
  }
  /**
   * Creates a {@link module:engine/model/range~Range range instance} that is equal to this live range.
   */
  toRange() {
    return new X(this.start, this.end);
  }
  /**
   * Creates a `LiveRange` instance that is equal to the given range.
   */
  static fromRange(e) {
    return new ur(e.start, e.end);
  }
}
ur.prototype.is = function(i) {
  return i === "liveRange" || i === "model:liveRange" || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
  i == "range" || i === "model:range";
};
function nL() {
  this.listenTo(this.root.document.model, "applyOperation", (i, e) => {
    const t = e[0];
    t.isDocumentOperation && iL.call(this, t);
  }, { priority: "low" });
}
function iL(i) {
  const e = this.getTransformedByOperation(i), t = X._createFromRanges(e), n = !t.isEqual(this), r = rL(this, i);
  let s = null;
  if (n) {
    t.root.rootName == "$graveyard" && (i.type == "remove" ? s = i.sourcePosition : s = i.deletionPosition);
    const o = this.toRange();
    this.start = t.start, this.end = t.end, this.fire("change:range", o, { deletionPosition: s });
  } else
    r && this.fire("change:content", this.toRange(), { deletionPosition: s });
}
function rL(i, e) {
  switch (e.type) {
    case "insert":
      return i.containsPosition(e.position);
    case "move":
    case "remove":
    case "reinsert":
    case "merge":
      return i.containsPosition(e.sourcePosition) || i.start.isEqual(e.sourcePosition) || i.containsPosition(e.targetPosition);
    case "split":
      return i.containsPosition(e.splitPosition) || i.containsPosition(e.insertionPosition);
  }
  return !1;
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const El = "selection:";
class zi extends kt(ls) {
  /**
   * Creates an empty live selection for given {@link module:engine/model/document~Document}.
   *
   * @param doc Document which owns this selection.
   */
  constructor(e) {
    super(), this._selection = new sL(e), this._selection.delegate("change:range").to(this), this._selection.delegate("change:attribute").to(this), this._selection.delegate("change:marker").to(this);
  }
  /**
   * Describes whether the selection is collapsed. Selection is collapsed when there is exactly one range which is
   * collapsed.
   */
  get isCollapsed() {
    return this._selection.isCollapsed;
  }
  /**
   * Selection anchor. Anchor may be described as a position where the most recent part of the selection starts.
   * Together with {@link #focus} they define the direction of selection, which is important
   * when expanding/shrinking selection. Anchor is always {@link module:engine/model/range~Range#start start} or
   * {@link module:engine/model/range~Range#end end} position of the most recently added range.
   *
   * Is set to `null` if there are no ranges in selection.
   *
   * @see #focus
   */
  get anchor() {
    return this._selection.anchor;
  }
  /**
   * Selection focus. Focus is a position where the selection ends.
   *
   * Is set to `null` if there are no ranges in selection.
   *
   * @see #anchor
   */
  get focus() {
    return this._selection.focus;
  }
  /**
   * Number of ranges in selection.
   */
  get rangeCount() {
    return this._selection.rangeCount;
  }
  /**
   * Describes whether `Documentselection` has own range(s) set, or if it is defaulted to
   * {@link module:engine/model/document~Document#_getDefaultRange document's default range}.
   */
  get hasOwnRange() {
    return this._selection.hasOwnRange;
  }
  /**
   * Specifies whether the {@link #focus}
   * precedes {@link #anchor}.
   *
   * @readonly
   * @type {Boolean}
   */
  get isBackward() {
    return this._selection.isBackward;
  }
  /**
   * Describes whether the gravity is overridden (using {@link module:engine/model/writer~Writer#overrideSelectionGravity}) or not.
   *
   * Note that the gravity remains overridden as long as will not be restored the same number of times as it was overridden.
   */
  get isGravityOverridden() {
    return this._selection.isGravityOverridden;
  }
  /**
   * A collection of selection {@link module:engine/model/markercollection~Marker markers}.
   * Marker is a selection marker when selection range is inside the marker range.
   *
   * **Note**: Only markers from {@link ~DocumentSelection#observeMarkers observed markers groups} are collected.
   */
  get markers() {
    return this._selection.markers;
  }
  /**
   * Used for the compatibility with the {@link module:engine/model/selection~Selection#isEqual} method.
   *
   * @internal
   */
  get _ranges() {
    return this._selection._ranges;
  }
  /**
   * Returns an iterable that iterates over copies of selection ranges.
   */
  getRanges() {
    return this._selection.getRanges();
  }
  /**
   * Returns the first position in the selection.
   * First position is the position that {@link module:engine/model/position~Position#isBefore is before}
   * any other position in the selection.
   *
   * Returns `null` if there are no ranges in selection.
   */
  getFirstPosition() {
    return this._selection.getFirstPosition();
  }
  /**
   * Returns the last position in the selection.
   * Last position is the position that {@link module:engine/model/position~Position#isAfter is after}
   * any other position in the selection.
   *
   * Returns `null` if there are no ranges in selection.
   */
  getLastPosition() {
    return this._selection.getLastPosition();
  }
  /**
   * Returns a copy of the first range in the selection.
   * First range is the one which {@link module:engine/model/range~Range#start start} position
   * {@link module:engine/model/position~Position#isBefore is before} start position of all other ranges
   * (not to confuse with the first range added to the selection).
   *
   * Returns `null` if there are no ranges in selection.
   */
  getFirstRange() {
    return this._selection.getFirstRange();
  }
  /**
   * Returns a copy of the last range in the selection.
   * Last range is the one which {@link module:engine/model/range~Range#end end} position
   * {@link module:engine/model/position~Position#isAfter is after} end position of all other ranges (not to confuse with the range most
   * recently added to the selection).
   *
   * Returns `null` if there are no ranges in selection.
   */
  getLastRange() {
    return this._selection.getLastRange();
  }
  /**
   * Gets elements of type {@link module:engine/model/schema~Schema#isBlock "block"} touched by the selection.
   *
   * This method's result can be used for example to apply block styling to all blocks covered by this selection.
   *
   * **Note:** `getSelectedBlocks()` returns blocks that are nested in other non-block elements
   * but will not return blocks nested in other blocks.
   *
   * In this case the function will return exactly all 3 paragraphs (note: `<blockQuote>` is not a block itself):
   *
   * ```
   * <paragraph>[a</paragraph>
   * <blockQuote>
   * 	<paragraph>b</paragraph>
   * </blockQuote>
   * <paragraph>c]d</paragraph>
   * ```
   *
   * In this case the paragraph will also be returned, despite the collapsed selection:
   *
   * ```
   * <paragraph>[]a</paragraph>
   * ```
   *
   * In such a scenario, however, only blocks A, B & E will be returned as blocks C & D are nested in block B:
   *
   * ```
   * [<blockA></blockA>
   * <blockB>
   * 	<blockC></blockC>
   * 	<blockD></blockD>
   * </blockB>
   * <blockE></blockE>]
   * ```
   *
   * If the selection is inside a block all the inner blocks (A & B) are returned:
   *
   * ```
   * <block>
   * 	<blockA>[a</blockA>
   * 	<blockB>b]</blockB>
   * </block>
   * ```
   *
   * **Special case**: If a selection ends at the beginning of a block, that block is not returned as from user perspective
   * this block wasn't selected. See [#984](https://github.com/ckeditor/ckeditor5-engine/issues/984) for more details.
   *
   * ```
   * <paragraph>[a</paragraph>
   * <paragraph>b</paragraph>
   * <paragraph>]c</paragraph> // this block will not be returned
   * ```
   */
  getSelectedBlocks() {
    return this._selection.getSelectedBlocks();
  }
  /**
   * Returns the selected element. {@link module:engine/model/element~Element Element} is considered as selected if there is only
   * one range in the selection, and that range contains exactly one element.
   * Returns `null` if there is no selected element.
   */
  getSelectedElement() {
    return this._selection.getSelectedElement();
  }
  /**
   * Checks whether the selection contains the entire content of the given element. This means that selection must start
   * at a position {@link module:engine/model/position~Position#isTouching touching} the element's start and ends at position
   * touching the element's end.
   *
   * By default, this method will check whether the entire content of the selection's current root is selected.
   * Useful to check if e.g. the user has just pressed <kbd>Ctrl</kbd> + <kbd>A</kbd>.
   */
  containsEntireContent(e) {
    return this._selection.containsEntireContent(e);
  }
  /**
   * Unbinds all events previously bound by document selection.
   */
  destroy() {
    this._selection.destroy();
  }
  /**
   * Returns iterable that iterates over this selection's attribute keys.
   */
  getAttributeKeys() {
    return this._selection.getAttributeKeys();
  }
  /**
   * Returns iterable that iterates over this selection's attributes.
   *
   * Attributes are returned as arrays containing two items. First one is attribute key and second is attribute value.
   * This format is accepted by native `Map` object and also can be passed in `Node` constructor.
   */
  getAttributes() {
    return this._selection.getAttributes();
  }
  /**
   * Gets an attribute value for given key or `undefined` if that attribute is not set on the selection.
   *
   * @param key Key of attribute to look for.
   * @returns Attribute value or `undefined`.
   */
  getAttribute(e) {
    return this._selection.getAttribute(e);
  }
  /**
   * Checks if the selection has an attribute for given key.
   *
   * @param key Key of attribute to check.
   * @returns `true` if attribute with given key is set on selection, `false` otherwise.
   */
  hasAttribute(e) {
    return this._selection.hasAttribute(e);
  }
  /**
   * Refreshes selection attributes and markers according to the current position in the model.
   */
  refresh() {
    this._selection.updateMarkers(), this._selection._updateAttributes(!1);
  }
  /**
   * Registers a marker group prefix or a marker name to be collected in the
   * {@link ~DocumentSelection#markers selection markers collection}.
   *
   * See also {@link module:engine/model/markercollection~MarkerCollection#getMarkersGroup `MarkerCollection#getMarkersGroup()`}.
   *
   * @param prefixOrName The marker group prefix or marker name.
   */
  observeMarkers(e) {
    this._selection.observeMarkers(e);
  }
  /**
   * Moves {@link module:engine/model/documentselection~DocumentSelection#focus} to the specified location.
   * Should be used only within the {@link module:engine/model/writer~Writer#setSelectionFocus} method.
   *
   * The location can be specified in the same form as
   * {@link module:engine/model/writer~Writer#createPositionAt writer.createPositionAt()} parameters.
   *
   * @see module:engine/model/writer~Writer#setSelectionFocus
   * @internal
   * @param offset Offset or one of the flags. Used only when
   * first parameter is a {@link module:engine/model/item~Item model item}.
   */
  _setFocus(e, t) {
    this._selection.setFocus(e, t);
  }
  /**
   * Sets this selection's ranges and direction to the specified location based on the given
   * {@link module:engine/model/selection~Selectable selectable}.
   * Should be used only within the {@link module:engine/model/writer~Writer#setSelection} method.
   *
   * @see module:engine/model/writer~Writer#setSelection
   * @internal
   */
  _setTo(...e) {
    this._selection.setTo(...e);
  }
  /**
   * Sets attribute on the selection. If attribute with the same key already is set, it's value is overwritten.
   * Should be used only within the {@link module:engine/model/writer~Writer#setSelectionAttribute} method.
   *
   * @see module:engine/model/writer~Writer#setSelectionAttribute
   * @internal
   * @param key Key of the attribute to set.
   * @param value Attribute value.
   */
  _setAttribute(e, t) {
    this._selection.setAttribute(e, t);
  }
  /**
   * Removes an attribute with given key from the selection.
   * If the given attribute was set on the selection, fires the {@link module:engine/model/selection~Selection#event:change:range}
   * event with removed attribute key.
   * Should be used only within the {@link module:engine/model/writer~Writer#removeSelectionAttribute} method.
   *
   * @see module:engine/model/writer~Writer#removeSelectionAttribute
   * @internal
   * @param key Key of the attribute to remove.
   */
  _removeAttribute(e) {
    this._selection.removeAttribute(e);
  }
  /**
   * Returns an iterable that iterates through all selection attributes stored in current selection's parent.
   *
   * @internal
   */
  _getStoredAttributes() {
    return this._selection.getStoredAttributes();
  }
  /**
   * Temporarily changes the gravity of the selection from the left to the right.
   *
   * The gravity defines from which direction the selection inherits its attributes. If it's the default left
   * gravity, the selection (after being moved by the the user) inherits attributes from its left hand side.
   * This method allows to temporarily override this behavior by forcing the gravity to the right.
   *
   * It returns an unique identifier which is required to restore the gravity. It guarantees the symmetry
   * of the process.
   *
   * @see module:engine/model/writer~Writer#overrideSelectionGravity
   * @internal
   * @returns The unique id which allows restoring the gravity.
   */
  _overrideGravity() {
    return this._selection.overrideGravity();
  }
  /**
   * Restores the {@link ~DocumentSelection#_overrideGravity overridden gravity}.
   *
   * Restoring the gravity is only possible using the unique identifier returned by
   * {@link ~DocumentSelection#_overrideGravity}. Note that the gravity remains overridden as long as won't be restored
   * the same number of times it was overridden.
   *
   * @see module:engine/model/writer~Writer#restoreSelectionGravity
   * @internal
   * @param uid The unique id returned by {@link #_overrideGravity}.
   */
  _restoreGravity(e) {
    this._selection.restoreGravity(e);
  }
  /**
   * Generates and returns an attribute key for selection attributes store, basing on original attribute key.
   *
   * @internal
   * @param key Attribute key to convert.
   * @returns Converted attribute key, applicable for selection store.
   */
  static _getStoreAttributeKey(e) {
    return El + e;
  }
  /**
   * Checks whether the given attribute key is an attribute stored on an element.
   *
   * @internal
   */
  static _isStoreAttributeKey(e) {
    return e.startsWith(El);
  }
}
zi.prototype.is = function(i) {
  return i === "selection" || i == "model:selection" || i == "documentSelection" || i == "model:documentSelection";
};
class sL extends Vi {
  /**
   * Creates an empty live selection for given {@link module:engine/model/document~Document}.
   *
   * @param doc Document which owns this selection.
   */
  constructor(e) {
    super(), this.markers = new Br({ idProperty: "name" }), this._attributePriority = /* @__PURE__ */ new Map(), this._selectionRestorePosition = null, this._hasChangedRange = !1, this._overriddenGravityRegister = /* @__PURE__ */ new Set(), this._observedMarkers = /* @__PURE__ */ new Set(), this._model = e.model, this._document = e, this.listenTo(this._model, "applyOperation", (t, n) => {
      const r = n[0];
      !r.isDocumentOperation || r.type == "marker" || r.type == "rename" || r.type == "noop" || (this._ranges.length == 0 && this._selectionRestorePosition && this._fixGraveyardSelection(this._selectionRestorePosition), this._selectionRestorePosition = null, this._hasChangedRange && (this._hasChangedRange = !1, this.fire("change:range", { directChange: !1 })));
    }, { priority: "lowest" }), this.on("change:range", () => {
      this._validateSelectionRanges(this.getRanges());
    }), this.listenTo(this._model.markers, "update", (t, n, r, s) => {
      this._updateMarker(n, s);
    }), this.listenTo(this._document, "change", (t, n) => {
      oL(this._model, n);
    });
  }
  get isCollapsed() {
    return this._ranges.length === 0 ? this._document._getDefaultRange().isCollapsed : super.isCollapsed;
  }
  get anchor() {
    return super.anchor || this._document._getDefaultRange().start;
  }
  get focus() {
    return super.focus || this._document._getDefaultRange().end;
  }
  get rangeCount() {
    return this._ranges.length ? this._ranges.length : 1;
  }
  /**
   * Describes whether `LiveSelection` has own range(s) set, or if it is defaulted to
   * {@link module:engine/model/document~Document#_getDefaultRange document's default range}.
   */
  get hasOwnRange() {
    return this._ranges.length > 0;
  }
  /**
   * When set to `true` then selection attributes on node before the caret won't be taken
   * into consideration while updating selection attributes.
   */
  get isGravityOverridden() {
    return !!this._overriddenGravityRegister.size;
  }
  /**
   * Unbinds all events previously bound by live selection.
   */
  destroy() {
    for (let e = 0; e < this._ranges.length; e++)
      this._ranges[e].detach();
    this.stopListening();
  }
  *getRanges() {
    this._ranges.length ? yield* super.getRanges() : yield this._document._getDefaultRange();
  }
  getFirstRange() {
    return super.getFirstRange() || this._document._getDefaultRange();
  }
  getLastRange() {
    return super.getLastRange() || this._document._getDefaultRange();
  }
  setTo(...e) {
    super.setTo(...e), this._updateAttributes(!0), this.updateMarkers();
  }
  setFocus(e, t) {
    super.setFocus(e, t), this._updateAttributes(!0), this.updateMarkers();
  }
  setAttribute(e, t) {
    if (this._setAttribute(e, t)) {
      const n = [e];
      this.fire("change:attribute", { attributeKeys: n, directChange: !0 });
    }
  }
  removeAttribute(e) {
    if (this._removeAttribute(e)) {
      const t = [e];
      this.fire("change:attribute", { attributeKeys: t, directChange: !0 });
    }
  }
  overrideGravity() {
    const e = Rr();
    return this._overriddenGravityRegister.add(e), this._overriddenGravityRegister.size === 1 && this._updateAttributes(!0), e;
  }
  restoreGravity(e) {
    if (!this._overriddenGravityRegister.has(e))
      throw new B("document-selection-gravity-wrong-restore", this, { uid: e });
    this._overriddenGravityRegister.delete(e), this.isGravityOverridden || this._updateAttributes(!0);
  }
  observeMarkers(e) {
    this._observedMarkers.add(e), this.updateMarkers();
  }
  _replaceAllRanges(e) {
    this._validateSelectionRanges(e), super._replaceAllRanges(e);
  }
  _popRange() {
    this._ranges.pop().detach();
  }
  _pushRange(e) {
    const t = this._prepareRange(e);
    t && this._ranges.push(t);
  }
  _validateSelectionRanges(e) {
    for (const t of e)
      if (!this._document._validateSelectionRange(t))
        throw new B("document-selection-wrong-position", this, { range: t });
  }
  /**
   * Prepares given range to be added to selection. Checks if it is correct,
   * converts it to {@link module:engine/model/liverange~LiveRange LiveRange}
   * and sets listeners listening to the range's change event.
   */
  _prepareRange(e) {
    if (this._checkRange(e), e.root == this._document.graveyard)
      return;
    const t = ur.fromRange(e);
    return t.on("change:range", (n, r, s) => {
      if (this._hasChangedRange = !0, t.root == this._document.graveyard) {
        this._selectionRestorePosition = s.deletionPosition;
        const o = this._ranges.indexOf(t);
        this._ranges.splice(o, 1), t.detach();
      }
    }), t;
  }
  updateMarkers() {
    if (!this._observedMarkers.size)
      return;
    const e = [];
    let t = !1;
    for (const r of this._model.markers) {
      const s = r.name.split(":", 1)[0];
      if (!this._observedMarkers.has(s))
        continue;
      const o = r.getRange();
      for (const l of this.getRanges())
        o.containsRange(l, !l.isCollapsed) && e.push(r);
    }
    const n = Array.from(this.markers);
    for (const r of e)
      this.markers.has(r) || (this.markers.add(r), t = !0);
    for (const r of Array.from(this.markers))
      e.includes(r) || (this.markers.remove(r), t = !0);
    t && this.fire("change:marker", { oldMarkers: n, directChange: !1 });
  }
  _updateMarker(e, t) {
    const n = e.name.split(":", 1)[0];
    if (!this._observedMarkers.has(n))
      return;
    let r = !1;
    const s = Array.from(this.markers), o = this.markers.has(e);
    if (!t)
      o && (this.markers.remove(e), r = !0);
    else {
      let l = !1;
      for (const u of this.getRanges())
        if (t.containsRange(u, !u.isCollapsed)) {
          l = !0;
          break;
        }
      l && !o ? (this.markers.add(e), r = !0) : !l && o && (this.markers.remove(e), r = !0);
    }
    r && this.fire("change:marker", { oldMarkers: s, directChange: !1 });
  }
  /**
   * Updates this selection attributes according to its ranges and the {@link module:engine/model/document~Document model document}.
   */
  _updateAttributes(e) {
    const t = Or(this._getSurroundingAttributes()), n = Or(this.getAttributes());
    if (e)
      this._attributePriority = /* @__PURE__ */ new Map(), this._attrs = /* @__PURE__ */ new Map();
    else
      for (const [s, o] of this._attributePriority)
        o == "low" && (this._attrs.delete(s), this._attributePriority.delete(s));
    this._setAttributesTo(t);
    const r = [];
    for (const [s, o] of this.getAttributes())
      (!n.has(s) || n.get(s) !== o) && r.push(s);
    for (const [s] of n)
      this.hasAttribute(s) || r.push(s);
    r.length > 0 && this.fire("change:attribute", { attributeKeys: r, directChange: !1 });
  }
  /**
   * Internal method for setting `LiveSelection` attribute. Supports attribute priorities (through `directChange`
   * parameter).
   */
  _setAttribute(e, t, n = !0) {
    const r = n ? "normal" : "low";
    return r == "low" && this._attributePriority.get(e) == "normal" || super.getAttribute(e) === t ? !1 : (this._attrs.set(e, t), this._attributePriority.set(e, r), !0);
  }
  /**
   * Internal method for removing `LiveSelection` attribute. Supports attribute priorities (through `directChange`
   * parameter).
   *
   * NOTE: Even if attribute is not present in the selection but is provided to this method, it's priority will
   * be changed according to `directChange` parameter.
   */
  _removeAttribute(e, t = !0) {
    const n = t ? "normal" : "low";
    return n == "low" && this._attributePriority.get(e) == "normal" || (this._attributePriority.set(e, n), !super.hasAttribute(e)) ? !1 : (this._attrs.delete(e), !0);
  }
  /**
   * Internal method for setting multiple `LiveSelection` attributes. Supports attribute priorities (through
   * `directChange` parameter).
   */
  _setAttributesTo(e) {
    const t = /* @__PURE__ */ new Set();
    for (const [n, r] of this.getAttributes())
      e.get(n) !== r && this._removeAttribute(n, !1);
    for (const [n, r] of e)
      this._setAttribute(n, r, !1) && t.add(n);
    return t;
  }
  /**
   * Returns an iterable that iterates through all selection attributes stored in current selection's parent.
   */
  *getStoredAttributes() {
    const e = this.getFirstPosition().parent;
    if (this.isCollapsed && e.isEmpty)
      for (const t of e.getAttributeKeys())
        t.startsWith(El) && (yield [t.substr(El.length), e.getAttribute(t)]);
  }
  /**
   * Checks model text nodes that are closest to the selection's first position and returns attributes of first
   * found element. If there are no text nodes in selection's first position parent, it returns selection
   * attributes stored in that parent.
   */
  _getSurroundingAttributes() {
    const e = this.getFirstPosition(), t = this._model.schema;
    let n = null;
    if (this.isCollapsed) {
      const r = e.textNode ? e.textNode : e.nodeBefore, s = e.textNode ? e.textNode : e.nodeAfter;
      if (this.isGravityOverridden || (n = ju(r)), n || (n = ju(s)), !this.isGravityOverridden && !n) {
        let o = r;
        for (; o && !t.isInline(o) && !n; )
          o = o.previousSibling, n = ju(o);
      }
      if (!n) {
        let o = s;
        for (; o && !t.isInline(o) && !n; )
          o = o.nextSibling, n = ju(o);
      }
      n || (n = this.getStoredAttributes());
    } else {
      const r = this.getFirstRange();
      for (const s of r) {
        if (s.item.is("element") && t.isObject(s.item))
          break;
        if (s.type == "text") {
          n = s.item.getAttributes();
          break;
        }
      }
    }
    return n;
  }
  /**
   * Fixes the selection after all its ranges got removed.
   * @param deletionPosition Position where the deletion happened.
   */
  _fixGraveyardSelection(e) {
    const t = this._model.schema.getNearestSelectionRange(e);
    t && this._pushRange(t);
  }
}
function ju(i) {
  return i instanceof Bi || i instanceof Dt ? i.getAttributes() : null;
}
function oL(i, e) {
  const t = i.document.differ;
  for (const n of t.getChanges()) {
    if (n.type != "insert")
      continue;
    const r = n.position.parent;
    n.length === r.maxOffset && i.enqueueChange(e, (o) => {
      const l = Array.from(r.getAttributeKeys()).filter((u) => u.startsWith(El));
      for (const u of l)
        o.removeAttribute(u, r);
    });
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class XE {
  /**
   * Creates a conversion helpers instance.
   */
  constructor(e) {
    this._dispatchers = e;
  }
  /**
   * Registers a conversion helper.
   *
   * **Note**: See full usage example in the `{@link module:engine/conversion/conversion~Conversion#for conversion.for()}`
   * method description.
   *
   * @param conversionHelper The function to be called on event.
   */
  add(e) {
    for (const t of this._dispatchers)
      e(t);
    return this;
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class aL extends XE {
  /**
   * Model element to view element conversion helper.
   *
   * This conversion results in creating a view element. For example, model `<paragraph>Foo</paragraph>` becomes `<p>Foo</p>` in the view.
   *
   * ```ts
   * editor.conversion.for( 'downcast' ).elementToElement( {
   * 	model: 'paragraph',
   * 	view: 'p'
   * } );
   *
   * editor.conversion.for( 'downcast' ).elementToElement( {
   * 	model: 'paragraph',
   * 	view: 'div',
   * 	converterPriority: 'high'
   * } );
   *
   * editor.conversion.for( 'downcast' ).elementToElement( {
   * 	model: 'fancyParagraph',
   * 	view: {
   * 		name: 'p',
   * 		classes: 'fancy'
   * 	}
   * } );
   *
   * editor.conversion.for( 'downcast' ).elementToElement( {
   * 	model: 'heading',
   * 	view: ( modelElement, conversionApi ) => {
   * 		const { writer } = conversionApi;
   *
   * 		return writer.createContainerElement( 'h' + modelElement.getAttribute( 'level' ) );
   * 	}
   * } );
   * ```
   *
   * The element-to-element conversion supports the reconversion mechanism. It can be enabled by using either the `attributes` or
   * the `children` props on a model description. You will find a couple examples below.
   *
   * In order to reconvert an element if any of its direct children have been added or removed, use the `children` property on a `model`
   * description. For example, this model:
   *
   * ```xml
   * <box>
   * 	<paragraph>Some text.</paragraph>
   * </box>
   * ```
   *
   * will be converted into this structure in the view:
   *
   * ```html
   * <div class="box" data-type="single">
   * 	<p>Some text.</p>
   * </div>
   * ```
   *
   * But if more items were inserted in the model:
   *
   * ```xml
   * <box>
   * 	<paragraph>Some text.</paragraph>
   * 	<paragraph>Other item.</paragraph>
   * </box>
   * ```
   *
   * it will be converted into this structure in the view (note the element `data-type` change):
   *
   * ```html
   * <div class="box" data-type="multiple">
   * 	<p>Some text.</p>
   * 	<p>Other item.</p>
   * </div>
   * ```
   *
   * Such a converter would look like this (note that the `paragraph` elements are converted separately):
   *
   * ```ts
   * editor.conversion.for( 'downcast' ).elementToElement( {
   * 	model: {
   * 		name: 'box',
   * 		children: true
   * 	},
   * 	view: ( modelElement, conversionApi ) => {
   * 		const { writer } = conversionApi;
   *
   * 		return writer.createContainerElement( 'div', {
   * 			class: 'box',
   * 			'data-type': modelElement.childCount == 1 ? 'single' : 'multiple'
   * 		} );
   * 	}
   * } );
   * ```
   *
   * In order to reconvert element if any of its attributes have been updated, use the `attributes` property on a `model`
   * description. For example, this model:
   *
   * ```xml
   * <heading level="2">Some text.</heading>
   * ```
   *
   * will be converted into this structure in the view:
   *
   * ```html
   * <h2>Some text.</h2>
   * ```
   *
   * But if the `heading` element's `level` attribute has been updated to `3` for example, then
   * it will be converted into this structure in the view:
   *
   * ```html
   * <h3>Some text.</h3>
   * ```
   *
   * Such a converter would look as follows:
   *
   * ```ts
   * editor.conversion.for( 'downcast' ).elementToElement( {
   * 	model: {
   * 		name: 'heading',
   * 		attributes: 'level'
   * 	},
   * 	view: ( modelElement, conversionApi ) => {
   * 		const { writer } = conversionApi;
   *
   * 		return writer.createContainerElement( 'h' + modelElement.getAttribute( 'level' ) );
   * 	}
   * } );
   * ```
   *
   * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter
   * to the conversion process.
   *
   * You can read more about the element-to-element conversion in the
   * {@glink framework/deep-dive/conversion/downcast downcast conversion} guide.
   *
   * @param config Conversion configuration.
   * @param config.model The description or a name of the model element to convert.
   * @param config.model.attributes The list of attribute names that should be consumed while creating
   * the view element. Note that the view will be reconverted if any of the listed attributes changes.
   * @param config.model.children Specifies whether the view element requires reconversion if the list
   * of the model child nodes changed.
   * @param config.view A view element definition or a function that takes the model element and
   * {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi downcast conversion API}
   * as parameters and returns a view container element.
   */
  elementToElement(e) {
    return this.add(TL(e));
  }
  /**
   * The model element to view structure (several elements) conversion helper.
   *
   * This conversion results in creating a view structure with one or more slots defined for the child nodes.
   * For example, a model `<table>` may become this structure in the view:
   *
   * ```html
   * <figure class="table">
   * 	<table>
   * 		<tbody>${ slot for table rows }</tbody>
   * 	</table>
   * </figure>
   * ```
   *
   * The children of the model's `<table>` element will be inserted into the `<tbody>` element.
   * If the `elementToElement()` helper was used, the children would be inserted into the `<figure>`.
   *
   * An example converter that converts the following model structure:
   *
   * ```xml
   * <wrappedParagraph>Some text.</wrappedParagraph>
   * ```
   *
   * into this structure in the view:
   *
   * ```html
   * <div class="wrapper">
   * 	<p>Some text.</p>
   * </div>
   * ```
   *
   * would look like this:
   *
   * ```ts
   * editor.conversion.for( 'downcast' ).elementToStructure( {
   * 	model: 'wrappedParagraph',
   * 	view: ( modelElement, conversionApi ) => {
   * 		const { writer } = conversionApi;
   *
   * 		const wrapperViewElement = writer.createContainerElement( 'div', { class: 'wrapper' } );
   * 		const paragraphViewElement = writer.createContainerElement( 'p' );
   *
   * 		writer.insert( writer.createPositionAt( wrapperViewElement, 0 ), paragraphViewElement );
   * 		writer.insert( writer.createPositionAt( paragraphViewElement, 0 ), writer.createSlot() );
   *
   * 		return wrapperViewElement;
   * 	}
   * } );
   * ```
   *
   * The `slorFor()` function can also take a callback that allows filtering which children of the model element
   * should be converted into this slot.
   *
   * Imagine a table feature where for this model structure:
   *
   * ```xml
   * <table headingRows="1">
   * 	<tableRow> ... table cells 1 ... </tableRow>
   * 	<tableRow> ... table cells 2 ... </tableRow>
   * 	<tableRow> ... table cells 3 ... </tableRow>
   * 	<caption>Caption text</caption>
   * </table>
   * ```
   *
   * we want to generate this view structure:
   *
   * ```html
   * <figure class="table">
   * 	<table>
   * 		<thead>
   * 			<tr> ... table cells 1 ... </tr>
   * 		</thead>
   * 		<tbody>
   * 			<tr> ... table cells 2 ... </tr>
   * 			<tr> ... table cells 3 ... </tr>
   * 		</tbody>
   * 	</table>
   * 	<figcaption>Caption text</figcaption>
   * </figure>
   * ```
   *
   * The converter has to take the `headingRows` attribute into consideration when allocating the `<tableRow>` elements
   * into the `<tbody>` and `<thead>` elements. Hence, we need two slots and need to define proper filter callbacks for them.
   *
   * Additionally, all elements other than `<tableRow>` should be placed outside the `<table>` tag.
   * In the example above, this will handle the table caption.
   *
   * Such a converter would look like this:
   *
   * ```ts
   * editor.conversion.for( 'downcast' ).elementToStructure( {
   * 	model: {
   * 		name: 'table',
   * 		attributes: [ 'headingRows' ]
   * 	},
   * 	view: ( modelElement, conversionApi ) => {
   * 		const { writer } = conversionApi;
   *
   * 		const figureElement = writer.createContainerElement( 'figure', { class: 'table' } );
   * 		const tableElement = writer.createContainerElement( 'table' );
   *
   * 		writer.insert( writer.createPositionAt( figureElement, 0 ), tableElement );
   *
   * 		const headingRows = modelElement.getAttribute( 'headingRows' ) || 0;
   *
   * 		if ( headingRows > 0 ) {
   * 			const tableHead = writer.createContainerElement( 'thead' );
   *
   * 			const headSlot = writer.createSlot( node => node.is( 'element', 'tableRow' ) && node.index < headingRows );
   *
   * 			writer.insert( writer.createPositionAt( tableElement, 'end' ), tableHead );
   * 			writer.insert( writer.createPositionAt( tableHead, 0 ), headSlot );
   * 		}
   *
   * 		if ( headingRows < tableUtils.getRows( table ) ) {
   * 			const tableBody = writer.createContainerElement( 'tbody' );
   *
   * 			const bodySlot = writer.createSlot( node => node.is( 'element', 'tableRow' ) && node.index >= headingRows );
   *
   * 			writer.insert( writer.createPositionAt( tableElement, 'end' ), tableBody );
   * 			writer.insert( writer.createPositionAt( tableBody, 0 ), bodySlot );
   * 		}
   *
   * 		const restSlot = writer.createSlot( node => !node.is( 'element', 'tableRow' ) );
   *
   * 		writer.insert( writer.createPositionAt( figureElement, 'end' ), restSlot );
   *
   * 		return figureElement;
   * 	}
   * } );
   * ```
   *
   * Note: The children of a model element that's being converted must be allocated in the same order in the view
   * in which they are placed in the model.
   *
   * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter
   * to the conversion process.
   *
   * @param config Conversion configuration.
   * @param config.model The description or a name of the model element to convert.
   * @param config.model.name The name of the model element to convert.
   * @param config.model.attributes The list of attribute names that should be consumed while creating
   * the view structure. Note that the view will be reconverted if any of the listed attributes will change.
   * @param config.view A function that takes the model element and
   * {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi downcast conversion API} as parameters
   * and returns a view container element with slots for model child nodes to be converted into.
   */
  elementToStructure(e) {
    return this.add(xL(e));
  }
  /**
   * Model attribute to view element conversion helper.
   *
   * This conversion results in wrapping view nodes with a view attribute element. For example, a model text node with
   * `"Foo"` as data and the `bold` attribute becomes `<strong>Foo</strong>` in the view.
   *
   * ```ts
   * editor.conversion.for( 'downcast' ).attributeToElement( {
   * 	model: 'bold',
   * 	view: 'strong'
   * } );
   *
   * editor.conversion.for( 'downcast' ).attributeToElement( {
   * 	model: 'bold',
   * 	view: 'b',
   * 	converterPriority: 'high'
   * } );
   *
   * editor.conversion.for( 'downcast' ).attributeToElement( {
   * 	model: 'invert',
   * 	view: {
   * 		name: 'span',
   * 		classes: [ 'font-light', 'bg-dark' ]
   * 	}
   * } );
   *
   * editor.conversion.for( 'downcast' ).attributeToElement( {
   * 	model: {
   * 		key: 'fontSize',
   * 		values: [ 'big', 'small' ]
   * 	},
   * 	view: {
   * 		big: {
   * 			name: 'span',
   * 			styles: {
   * 				'font-size': '1.2em'
   * 			}
   * 		},
   * 		small: {
   * 			name: 'span',
   * 			styles: {
   * 				'font-size': '0.8em'
   * 			}
   * 		}
   * 	}
   * } );
   *
   * editor.conversion.for( 'downcast' ).attributeToElement( {
   * 	model: 'bold',
   * 	view: ( modelAttributeValue, conversionApi ) => {
   * 		const { writer } = conversionApi;
   *
   * 		return writer.createAttributeElement( 'span', {
   * 			style: 'font-weight:' + modelAttributeValue
   * 		} );
   * 	}
   * } );
   *
   * editor.conversion.for( 'downcast' ).attributeToElement( {
   * 	model: {
   * 		key: 'color',
   * 		name: '$text'
   * 	},
   * 	view: ( modelAttributeValue, conversionApi ) => {
   * 		const { writer } = conversionApi;
   *
   * 		return writer.createAttributeElement( 'span', {
   * 			style: 'color:' + modelAttributeValue
   * 		} );
   * 	}
   * } );
   * ```
   *
   * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter
   * to the conversion process.
   *
   * @param config Conversion configuration.
   * @param config.model The key of the attribute to convert from or a `{ key, values }` object. `values` is an array
   * of `String`s with possible values if the model attribute is an enumerable.
   * @param config.view A view element definition or a function
   * that takes the model attribute value and
   * {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi downcast conversion API} as parameters and returns a view
   * attribute element. If `config.model.values` is given, `config.view` should be an object assigning values from `config.model.values`
   * to view element definitions or functions.
   * @param config.converterPriority Converter priority.
   */
  attributeToElement(e) {
    return this.add(kL(e));
  }
  /**
   * Model attribute to view attribute conversion helper.
   *
   * This conversion results in adding an attribute to a view node, basing on an attribute from a model node. For example,
   * `<imageInline src='foo.jpg'></imageInline>` is converted to `<img src='foo.jpg'></img>`.
   *
   * ```ts
   * editor.conversion.for( 'downcast' ).attributeToAttribute( {
   * 	model: 'source',
   * 	view: 'src'
   * } );
   *
   * editor.conversion.for( 'downcast' ).attributeToAttribute( {
   * 	model: 'source',
   * 	view: 'href',
   * 	converterPriority: 'high'
   * } );
   *
   * editor.conversion.for( 'downcast' ).attributeToAttribute( {
   * 	model: {
   * 		name: 'imageInline',
   * 		key: 'source'
   * 	},
   * 	view: 'src'
   * } );
   *
   * editor.conversion.for( 'downcast' ).attributeToAttribute( {
   * 	model: {
   * 		name: 'styled',
   * 		values: [ 'dark', 'light' ]
   * 	},
   * 	view: {
   * 		dark: {
   * 			key: 'class',
   * 			value: [ 'styled', 'styled-dark' ]
   * 		},
   * 		light: {
   * 			key: 'class',
   * 			value: [ 'styled', 'styled-light' ]
   * 		}
   * 	}
   * } );
   *
   * editor.conversion.for( 'downcast' ).attributeToAttribute( {
   * 	model: 'styled',
   * 	view: modelAttributeValue => ( {
   * 		key: 'class',
   * 		value: 'styled-' + modelAttributeValue
   * 	} )
   * } );
   * ```
   *
   * **Note**: Downcasting to a style property requires providing `value` as an object:
   *
   * ```ts
   * editor.conversion.for( 'downcast' ).attributeToAttribute( {
   * 	model: 'lineHeight',
   * 	view: modelAttributeValue => ( {
   * 		key: 'style',
   * 		value: {
   * 			'line-height': modelAttributeValue,
   * 			'border-bottom': '1px dotted #ba2'
   * 		}
   * 	} )
   * } );
   * ```
   *
   * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter
   * to the conversion process.
   *
   * @param config Conversion configuration.
   * @param config.model The key of the attribute to convert from or a `{ key, values, [ name ] }` object describing
   * the attribute key, possible values and, optionally, an element name to convert from.
   * @param config.view A view attribute key, or a `{ key, value }` object or a function that takes the model attribute value and
   * {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi downcast conversion API}
   * as parameters and returns a `{ key, value }` object. If the `key` is `'class'`, the `value` can be a `String` or an
   * array of `String`s. If the `key` is `'style'`, the `value` is an object with key-value pairs. In other cases, `value` is a `String`.
   * If `config.model.values` is set, `config.view` should be an object assigning values from `config.model.values` to
   * `{ key, value }` objects or a functions.
   * @param config.converterPriority Converter priority.
   */
  attributeToAttribute(e) {
    return this.add(AL(e));
  }
  /**
   * Model marker to view element conversion helper.
   *
   * **Note**: This method should be used mainly for editing the downcast and it is recommended
   * to use the {@link #markerToData `#markerToData()`} helper instead.
   *
   * This helper may produce invalid HTML code (e.g. a span between table cells).
   * It should only be used when you are sure that the produced HTML will be semantically correct.
   *
   * This conversion results in creating a view element on the boundaries of the converted marker. If the converted marker
   * is collapsed, only one element is created. For example, a model marker set like this: `<paragraph>F[oo b]ar</paragraph>`
   * becomes `<p>F<span data-marker="search"></span>oo b<span data-marker="search"></span>ar</p>` in the view.
   *
   * ```ts
   * editor.conversion.for( 'editingDowncast' ).markerToElement( {
   * 	model: 'search',
   * 	view: 'marker-search'
   * } );
   *
   * editor.conversion.for( 'editingDowncast' ).markerToElement( {
   * 	model: 'search',
   * 	view: 'search-result',
   * 	converterPriority: 'high'
   * } );
   *
   * editor.conversion.for( 'editingDowncast' ).markerToElement( {
   * 	model: 'search',
   * 	view: {
   * 		name: 'span',
   * 		attributes: {
   * 			'data-marker': 'search'
   * 		}
   * 	}
   * } );
   *
   * editor.conversion.for( 'editingDowncast' ).markerToElement( {
   * 	model: 'search',
   * 	view: ( markerData, conversionApi ) => {
   * 		const { writer } = conversionApi;
   *
   * 		return writer.createUIElement( 'span', {
   * 			'data-marker': 'search',
   * 			'data-start': markerData.isOpening
   * 		} );
   * 	}
   * } );
   * ```
   *
   * If a function is passed as the `config.view` parameter, it will be used to generate both boundary elements. The function
   * receives the `data` object and {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi downcast conversion API}
   * as a parameters and should return an instance of the
   * {@link module:engine/view/uielement~UIElement view UI element}. The `data` object and
   * {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi `conversionApi`} are passed from
   * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:addMarker}. Additionally,
   * the `data.isOpening` parameter is passed, which is set to `true` for the marker start boundary element, and `false` for
   * the marker end boundary element.
   *
   * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter
   * to the conversion process.
   *
   * @param config Conversion configuration.
   * @param config.model The name of the model marker (or model marker group) to convert.
   * @param config.view A view element definition or a function that takes the model marker data and
   * {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi downcast conversion API} as a parameters
   * and returns a view UI element.
   * @param config.converterPriority Converter priority.
   */
  markerToElement(e) {
    return this.add(PL(e));
  }
  /**
   * Model marker to highlight conversion helper.
   *
   * This conversion results in creating a highlight on view nodes. For this kind of conversion,
   * the {@link module:engine/conversion/downcasthelpers~HighlightDescriptor} should be provided.
   *
   * For text nodes, a `<span>` {@link module:engine/view/attributeelement~AttributeElement} is created and it wraps all text nodes
   * in the converted marker range. For example, a model marker set like this: `<paragraph>F[oo b]ar</paragraph>` becomes
   * `<p>F<span class="comment">oo b</span>ar</p>` in the view.
   *
   * {@link module:engine/view/containerelement~ContainerElement} may provide a custom way of handling highlight. Most often,
   * the element itself is given classes and attributes described in the highlight descriptor (instead of being wrapped in `<span>`).
   * For example, a model marker set like this:
   * `[<imageInline src="foo.jpg"></imageInline>]` becomes `<img src="foo.jpg" class="comment"></img>` in the view.
   *
   * For container elements, the conversion is two-step. While the converter processes the highlight descriptor and passes it
   * to a container element, it is the container element instance itself that applies values from the highlight descriptor.
   * So, in a sense, the converter takes care of stating what should be applied on what, while the element decides how to apply that.
   *
   * ```ts
   * editor.conversion.for( 'downcast' ).markerToHighlight( { model: 'comment', view: { classes: 'comment' } } );
   *
   * editor.conversion.for( 'downcast' ).markerToHighlight( {
   * 	model: 'comment',
   * 	view: { classes: 'comment' },
   * 	converterPriority: 'high'
   * } );
   *
   * editor.conversion.for( 'downcast' ).markerToHighlight( {
   * 	model: 'comment',
   * 	view: ( data, conversionApi ) => {
   * 		// Assuming that the marker name is in a form of comment:commentType:commentId.
   * 		const [ , commentType, commentId ] = data.markerName.split( ':' );
   *
   * 		return {
   * 			classes: [ 'comment', 'comment-' + commentType ],
   * 			attributes: { 'data-comment-id': commentId }
   * 		};
   * 	}
   * } );
   * ```
   *
   * If a function is passed as the `config.view` parameter, it will be used to generate the highlight descriptor. The function
   * receives the `data` object and {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi downcast conversion API}
   * as the parameters and should return a
   * {@link module:engine/conversion/downcasthelpers~HighlightDescriptor highlight descriptor}.
   * The `data` object properties are passed from {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:addMarker}.
   *
   * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter
   * to the conversion process.
   *
   * @param config Conversion configuration.
   * @param config.model The name of the model marker (or model marker group) to convert.
   * @param config.view A highlight descriptor that will be used for highlighting or a function that takes the model marker data and
   * {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi downcast conversion API} as a parameters
   * and returns a highlight descriptor.
   * @param config.converterPriority Converter priority.
   */
  markerToHighlight(e) {
    return this.add(RL(e));
  }
  /**
   * Model marker converter for data downcast.
   *
   * This conversion creates a representation for model marker boundaries in the view:
   *
   * * If the marker boundary is before or after a model element, a view attribute is set on a corresponding view element.
   * * In other cases, a view element with the specified tag name is inserted at the corresponding view position.
   *
   * Typically, the marker names use the `group:uniqueId:otherData` convention. For example: `comment:e34zfk9k2n459df53sjl34:zx32c`.
   * The default configuration for this conversion is that the first part is the `group` part and the rest of
   * the marker name becomes the `name` part.
   *
   * Tag and attribute names and values are generated from the marker name:
   *
   * * The templates for attributes are `data-[group]-start-before="[name]"`, `data-[group]-start-after="[name]"`,
   * `data-[group]-end-before="[name]"` and `data-[group]-end-after="[name]"`.
   * * The templates for view elements are `<[group]-start name="[name]">` and `<[group]-end name="[name]">`.
   *
   * Attributes mark whether the given marker's start or end boundary is before or after the given element.
   * The `data-[group]-start-before` and `data-[group]-end-after` attributes are favored.
   * The other two are used when the former two cannot be used.
   *
   * The conversion configuration can take a function that will generate different group and name parts.
   * If such a function is set as the `config.view` parameter, it is passed a marker name and it is expected to return an object with two
   * properties: `group` and `name`. If the function returns a falsy value, the conversion will not take place.
   *
   * Basic usage:
   *
   * ```ts
   * // Using the default conversion.
   * // In this case, all markers with names starting with 'comment:' will be converted.
   * // The `group` parameter will be set to `comment`.
   * // The `name` parameter will be the rest of the marker name (without the `:`).
   * editor.conversion.for( 'dataDowncast' ).markerToData( {
   * 	model: 'comment'
   * } );
   * ```
   *
   * An example of a view that may be generated by this conversion (assuming a marker with the name `comment:commentId:uid` marked
   * by `[]`):
   *
   * ```
   * // Model:
   * <paragraph>Foo[bar</paragraph>
   * <imageBlock src="abc.jpg"></imageBlock>]
   *
   * // View:
   * <p>Foo<comment-start name="commentId:uid"></comment-start>bar</p>
   * <figure data-comment-end-after="commentId:uid" class="image"><img src="abc.jpg" /></figure>
   * ```
   *
   * In the example above, the comment starts before "bar" and ends after the image.
   *
   * If the `name` part is empty, the following view may be generated:
   *
   * ```html
   * <p>Foo <myMarker-start></myMarker-start>bar</p>
   * <figure data-myMarker-end-after="" class="image"><img src="abc.jpg" /></figure>
   * ```
   *
   * **Note:** A situation where some markers have the `name` part and some do not, is incorrect and should be avoided.
   *
   * Examples where `data-group-start-after` and `data-group-end-before` are used:
   *
   * ```
   * // Model:
   * <blockQuote>[]<paragraph>Foo</paragraph></blockQuote>
   *
   * // View:
   * <blockquote><p data-group-end-before="name" data-group-start-before="name">Foo</p></blockquote>
   * ```
   *
   * Similarly, when a marker is collapsed after the last element:
   *
   * ```
   * // Model:
   * <blockQuote><paragraph>Foo</paragraph>[]</blockQuote>
   *
   * // View:
   * <blockquote><p data-group-end-after="name" data-group-start-after="name">Foo</p></blockquote>
   * ```
   *
   * When there are multiple markers from the same group stored in the same attribute of the same element, their
   * name parts are put together in the attribute value, for example: `data-group-start-before="name1,name2,name3"`.
   *
   * Other examples of usage:
   *
   * ```ts
   * // Using a custom function which is the same as the default conversion:
   * editor.conversion.for( 'dataDowncast' ).markerToData( {
   * 	model: 'comment'
   * 	view: markerName => ( {
   * 		group: 'comment',
   * 		name: markerName.substr( 8 ) // Removes 'comment:' part.
   * 	} )
   * } );
   *
   * // Using the converter priority:
   * editor.conversion.for( 'dataDowncast' ).markerToData( {
   * 	model: 'comment'
   * 	view: markerName => ( {
   * 		group: 'comment',
   * 		name: markerName.substr( 8 ) // Removes 'comment:' part.
   * 	} ),
   * 	converterPriority: 'high'
   * } );
   * ```
   *
   * This kind of conversion is useful for saving data into the database, so it should be used in the data conversion pipeline.
   *
   * See the {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} API guide to learn how to
   * add a converter to the conversion process.
   *
   * @param config Conversion configuration.
   * @param config.model The name of the model marker (or the model marker group) to convert.
   * @param config.view A function that takes the model marker name and
   * {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi downcast conversion API} as the parameters
   * and returns an object with the `group` and `name` properties.
   * @param config.converterPriority Converter priority.
   */
  markerToData(e) {
    return this.add(IL(e));
  }
}
function ZE() {
  return (i, e, t) => {
    if (!t.consumable.consume(e.item, i.name))
      return;
    const n = t.writer, r = t.mapper.toViewPosition(e.range.start), s = n.createText(e.item.data);
    n.insert(r, s);
  };
}
function QE() {
  return (i, e, t) => {
    t.convertAttributes(e.item), !e.reconversion && e.item.is("element") && !e.item.isEmpty && t.convertChildren(e.item);
  };
}
function lL() {
  return (i, e, t) => {
    const n = t.mapper.toViewPosition(e.position), r = e.position.getShiftedBy(e.length), s = t.mapper.toViewPosition(r, { isPhantom: !0 }), o = t.writer.createRange(n, s), l = t.writer.remove(o.getTrimmed());
    for (const u of t.writer.createRangeIn(l).getItems())
      t.mapper.unbindViewElement(u, { defer: !0 });
  };
}
function eC(i, e) {
  const t = i.createAttributeElement("span", e.attributes);
  return e.classes && t._addClass(e.classes), typeof e.priority == "number" && (t._priority = e.priority), t._id = e.id, t;
}
function cL() {
  return (i, e, t) => {
    const n = e.selection;
    if (n.isCollapsed || !t.consumable.consume(n, "selection"))
      return;
    const r = [];
    for (const s of n.getRanges())
      r.push(t.mapper.toViewRange(s));
    t.writer.setSelection(r, { backward: n.isBackward });
  };
}
function uL() {
  return (i, e, t) => {
    const n = e.selection;
    if (!n.isCollapsed || !t.consumable.consume(n, "selection"))
      return;
    const r = t.writer, s = n.getFirstPosition(), o = t.mapper.toViewPosition(s), l = r.breakAttributes(o);
    r.setSelection(l);
  };
}
function dL() {
  return (i, e, t) => {
    const n = t.writer, r = n.document.selection;
    for (const s of r.getRanges())
      s.isCollapsed && s.end.parent.isAttached() && t.writer.mergeAttributes(s.start);
    n.setSelection(null);
  };
}
function hL(i) {
  return (e, t, n) => {
    if (!n.consumable.test(t.item, e.name))
      return;
    const r = i(t.attributeOldValue, n, t), s = i(t.attributeNewValue, n, t);
    if (!r && !s)
      return;
    n.consumable.consume(t.item, e.name);
    const o = n.writer, l = o.document.selection;
    if (t.item instanceof Vi || t.item instanceof zi)
      o.wrap(l.getFirstRange(), s);
    else {
      let u = n.mapper.toViewRange(t.range);
      t.attributeOldValue !== null && r && (u = o.unwrap(u, r)), t.attributeNewValue !== null && s && o.wrap(u, s);
    }
  };
}
function fL(i, e = LL) {
  return (t, n, r) => {
    if (!e(n.item, r.consumable, { preflight: !0 }))
      return;
    const s = i(n.item, r, n);
    if (!s)
      return;
    e(n.item, r.consumable);
    const o = r.mapper.toViewPosition(n.range.start);
    r.mapper.bindElements(n.item, s), r.writer.insert(o, s), r.convertAttributes(n.item), sC(s, n.item.getChildren(), r, { reconversion: n.reconversion });
  };
}
function mL(i, e) {
  return (t, n, r) => {
    if (!e(n.item, r.consumable, { preflight: !0 }))
      return;
    const s = /* @__PURE__ */ new Map();
    r.writer._registerSlotFactory(NL(n.item, s, r));
    const o = i(n.item, r, n);
    if (r.writer._clearSlotFactory(), !o)
      return;
    DL(n.item, s, r), e(n.item, r.consumable);
    const l = r.mapper.toViewPosition(n.range.start);
    r.mapper.bindElements(n.item, o), r.writer.insert(l, o), r.convertAttributes(n.item), BL(o, s, r, { reconversion: n.reconversion });
  };
}
function gL(i) {
  return (e, t, n) => {
    t.isOpening = !0;
    const r = i(t, n);
    t.isOpening = !1;
    const s = i(t, n);
    if (!r || !s)
      return;
    const o = t.markerRange;
    if (o.isCollapsed && !n.consumable.consume(o, e.name))
      return;
    for (const h of o)
      if (!n.consumable.consume(h.item, e.name))
        return;
    const l = n.mapper, u = n.writer;
    u.insert(l.toViewPosition(o.start), r), n.mapper.bindElementToMarker(r, t.markerName), o.isCollapsed || (u.insert(l.toViewPosition(o.end), s), n.mapper.bindElementToMarker(s, t.markerName)), e.stop();
  };
}
function pL() {
  return (i, e, t) => {
    const n = t.mapper.markerNameToElements(e.markerName);
    if (n) {
      for (const r of n)
        t.mapper.unbindElementFromMarkerName(r, e.markerName), t.writer.clear(t.writer.createRangeOn(r), r);
      t.writer.clearClonedElementsGroup(e.markerName), i.stop();
    }
  };
}
function _L(i) {
  return (e, t, n) => {
    const r = i(t.markerName, n);
    if (!r)
      return;
    const s = t.markerRange;
    n.consumable.consume(s, e.name) && (ab(s, !1, n, t, r), ab(s, !0, n, t, r), e.stop());
  };
}
function ab(i, e, t, n, r) {
  const s = e ? i.start : i.end, o = s.nodeAfter && s.nodeAfter.is("element") ? s.nodeAfter : null, l = s.nodeBefore && s.nodeBefore.is("element") ? s.nodeBefore : null;
  if (o || l) {
    let h, f;
    e && o || !e && !l ? (h = o, f = !0) : (h = l, f = !1);
    const m = t.mapper.toViewElement(h);
    if (m) {
      vL(m, e, f, t, n, r);
      return;
    }
  }
  const u = t.mapper.toViewPosition(s);
  wL(u, e, t, n, r);
}
function vL(i, e, t, n, r, s) {
  const o = `data-${s.group}-${e ? "start" : "end"}-${t ? "before" : "after"}`, l = i.hasAttribute(o) ? i.getAttribute(o).split(",") : [];
  l.unshift(s.name), n.writer.setAttribute(o, l.join(","), i), n.mapper.bindElementToMarker(i, r.markerName);
}
function wL(i, e, t, n, r) {
  const s = `${r.group}-${e ? "start" : "end"}`, o = r.name ? { name: r.name } : null, l = t.writer.createUIElement(s, o);
  t.writer.insert(i, l), t.mapper.bindElementToMarker(l, n.markerName);
}
function bL(i) {
  return (e, t, n) => {
    const r = i(t.markerName, n);
    if (!r)
      return;
    const s = n.mapper.markerNameToElements(t.markerName);
    if (!s)
      return;
    for (const l of s)
      n.mapper.unbindElementFromMarkerName(l, t.markerName), l.is("containerElement") ? (o(`data-${r.group}-start-before`, l), o(`data-${r.group}-start-after`, l), o(`data-${r.group}-end-before`, l), o(`data-${r.group}-end-after`, l)) : n.writer.clear(n.writer.createRangeOn(l), l);
    n.writer.clearClonedElementsGroup(t.markerName), e.stop();
    function o(l, u) {
      if (u.hasAttribute(l)) {
        const h = new Set(u.getAttribute(l).split(","));
        h.delete(r.name), h.size == 0 ? n.writer.removeAttribute(l, u) : n.writer.setAttribute(l, Array.from(h).join(","), u);
      }
    }
  };
}
function yL(i) {
  return (e, t, n) => {
    if (!n.consumable.test(t.item, e.name))
      return;
    const r = i(t.attributeOldValue, n, t), s = i(t.attributeNewValue, n, t);
    if (!r && !s)
      return;
    n.consumable.consume(t.item, e.name);
    const o = n.mapper.toViewElement(t.item), l = n.writer;
    if (!o)
      throw new B("conversion-attribute-to-attribute-on-text", n.dispatcher, t);
    if (t.attributeOldValue !== null && r)
      if (r.key == "class") {
        const u = In(r.value);
        for (const h of u)
          l.removeClass(h, o);
      } else if (r.key == "style") {
        const u = Object.keys(r.value);
        for (const h of u)
          l.removeStyle(h, o);
      } else
        l.removeAttribute(r.key, o);
    if (t.attributeNewValue !== null && s)
      if (s.key == "class") {
        const u = In(s.value);
        for (const h of u)
          l.addClass(h, o);
      } else if (s.key == "style") {
        const u = Object.keys(s.value);
        for (const h of u)
          l.setStyle(h, s.value[h], o);
      } else
        l.setAttribute(s.key, s.value, o);
  };
}
function EL(i) {
  return (e, t, n) => {
    if (!t.item || !(t.item instanceof Vi || t.item instanceof zi) && !t.item.is("$textProxy"))
      return;
    const r = dp(i, t, n);
    if (!r || !n.consumable.consume(t.item, e.name))
      return;
    const s = n.writer, o = eC(s, r), l = s.document.selection;
    if (t.item instanceof Vi || t.item instanceof zi)
      s.wrap(l.getFirstRange(), o);
    else {
      const u = n.mapper.toViewRange(t.range), h = s.wrap(u, o);
      for (const f of h.getItems())
        if (f.is("attributeElement") && f.isSimilar(o)) {
          n.mapper.bindElementToMarker(f, t.markerName);
          break;
        }
    }
  };
}
function CL(i) {
  return (e, t, n) => {
    if (!t.item || !(t.item instanceof gt))
      return;
    const r = dp(i, t, n);
    if (!r || !n.consumable.test(t.item, e.name))
      return;
    const s = n.mapper.toViewElement(t.item);
    if (s && s.getCustomProperty("addHighlight")) {
      n.consumable.consume(t.item, e.name);
      for (const l of X._createIn(t.item))
        n.consumable.consume(l.item, e.name);
      s.getCustomProperty("addHighlight")(s, r, n.writer), n.mapper.bindElementToMarker(s, t.markerName);
    }
  };
}
function SL(i) {
  return (e, t, n) => {
    if (t.markerRange.isCollapsed)
      return;
    const r = dp(i, t, n);
    if (!r)
      return;
    const s = eC(n.writer, r), o = n.mapper.markerNameToElements(t.markerName);
    if (o) {
      for (const l of o)
        n.mapper.unbindElementFromMarkerName(l, t.markerName), l.is("attributeElement") ? n.writer.unwrap(n.writer.createRangeOn(l), s) : l.getCustomProperty("removeHighlight")(l, r.id, n.writer);
      n.writer.clearClonedElementsGroup(t.markerName), e.stop();
    }
  };
}
function TL(i) {
  const e = tC(i.model), t = Cl(i.view, "container");
  return e.attributes.length && (e.children = !0), (n) => {
    n.on(`insert:${e.name}`, fL(t, rC(e)), { priority: i.converterPriority || "normal" }), (e.children || e.attributes.length) && n.on("reduceChanges", iC(e), { priority: "low" });
  };
}
function xL(i) {
  const e = tC(i.model), t = Cl(i.view, "container");
  return e.children = !0, (n) => {
    if (n._conversionApi.schema.checkChild(e.name, "$text"))
      throw new B("conversion-element-to-structure-disallowed-text", n, { elementName: e.name });
    n.on(`insert:${e.name}`, mL(t, rC(e)), { priority: i.converterPriority || "normal" }), n.on("reduceChanges", iC(e), { priority: "low" });
  };
}
function kL(i) {
  i = js(i);
  let e = i.model;
  typeof e == "string" && (e = { key: e });
  let t = `attribute:${e.key}`;
  if (e.name && (t += ":" + e.name), e.values)
    for (const r of e.values)
      i.view[r] = Cl(i.view[r], "attribute");
  else
    i.view = Cl(i.view, "attribute");
  const n = nC(i);
  return (r) => {
    r.on(t, hL(n), { priority: i.converterPriority || "normal" });
  };
}
function AL(i) {
  i = js(i);
  let e = i.model;
  typeof e == "string" && (e = { key: e });
  let t = `attribute:${e.key}`;
  if (e.name && (t += ":" + e.name), e.values)
    for (const r of e.values)
      i.view[r] = lb(i.view[r]);
  else
    i.view = lb(i.view);
  const n = nC(i);
  return (r) => {
    r.on(t, yL(n), { priority: i.converterPriority || "normal" });
  };
}
function PL(i) {
  const e = Cl(i.view, "ui");
  return (t) => {
    t.on(`addMarker:${i.model}`, gL(e), { priority: i.converterPriority || "normal" }), t.on(`removeMarker:${i.model}`, pL(), { priority: i.converterPriority || "normal" });
  };
}
function IL(i) {
  i = js(i);
  const e = i.model;
  let t = i.view;
  return t || (t = (n) => ({
    group: e,
    name: n.substr(i.model.length + 1)
  })), (n) => {
    n.on(`addMarker:${e}`, _L(t), { priority: i.converterPriority || "normal" }), n.on(`removeMarker:${e}`, bL(t), { priority: i.converterPriority || "normal" });
  };
}
function RL(i) {
  return (e) => {
    e.on(`addMarker:${i.model}`, EL(i.view), { priority: i.converterPriority || "normal" }), e.on(`addMarker:${i.model}`, CL(i.view), { priority: i.converterPriority || "normal" }), e.on(`removeMarker:${i.model}`, SL(i.view), { priority: i.converterPriority || "normal" });
  };
}
function tC(i) {
  return typeof i == "string" && (i = { name: i }), i.attributes ? Array.isArray(i.attributes) || (i.attributes = [i.attributes]) : i.attributes = [], i.children = !!i.children, i;
}
function Cl(i, e) {
  return typeof i == "function" ? i : (t, n) => OL(i, n, e);
}
function OL(i, e, t) {
  typeof i == "string" && (i = { name: i });
  let n;
  const r = e.writer, s = Object.assign({}, i.attributes);
  if (t == "container")
    n = r.createContainerElement(i.name, s);
  else if (t == "attribute") {
    const o = {
      priority: i.priority || Ms.DEFAULT_PRIORITY
    };
    n = r.createAttributeElement(i.name, s, o);
  } else
    n = r.createUIElement(i.name, s);
  if (i.styles) {
    const o = Object.keys(i.styles);
    for (const l of o)
      r.setStyle(l, i.styles[l], n);
  }
  if (i.classes) {
    const o = i.classes;
    if (typeof o == "string")
      r.addClass(o, n);
    else
      for (const l of o)
        r.addClass(l, n);
  }
  return n;
}
function nC(i) {
  return i.model.values ? (e, t, n) => {
    const r = i.view[e];
    return r ? r(e, t, n) : null;
  } : i.view;
}
function lb(i) {
  return typeof i == "string" ? (e) => ({ key: i, value: e }) : typeof i == "object" ? i.value ? () => i : (e) => ({ key: i.key, value: e }) : i;
}
function dp(i, e, t) {
  const n = typeof i == "function" ? i(e, t) : i;
  return n ? (n.priority || (n.priority = 10), n.id || (n.id = e.markerName), n) : null;
}
function ML(i) {
  return (e, t) => {
    if (!e.is("element", i.name))
      return !1;
    if (t.type == "attribute") {
      if (i.attributes.includes(t.attributeKey))
        return !0;
    } else {
      /* istanbul ignore else: This is always true because otherwise it would not register a reducer callback. -- @preserve */
      if (i.children)
        return !0;
    }
    return !1;
  };
}
function iC(i) {
  const e = ML(i);
  return (t, n) => {
    const r = [];
    n.reconvertedElements || (n.reconvertedElements = /* @__PURE__ */ new Set());
    for (const s of n.changes) {
      const o = s.type == "attribute" ? s.range.start.nodeAfter : s.position.parent;
      if (!o || !e(o, s)) {
        r.push(s);
        continue;
      }
      if (!n.reconvertedElements.has(o)) {
        n.reconvertedElements.add(o);
        const l = oe._createBefore(o);
        let u = r.length;
        for (let h = r.length - 1; h >= 0; h--) {
          const f = r[h], v = (f.type == "attribute" ? f.range.start : f.position).compareWith(l);
          if (v == "before" || f.type == "remove" && v == "same")
            break;
          u = h;
        }
        r.splice(u, 0, {
          type: "remove",
          name: o.name,
          position: l,
          length: 1
        }, {
          type: "reinsert",
          name: o.name,
          position: l,
          length: 1
        });
      }
    }
    n.changes = r;
  };
}
function rC(i) {
  return (e, t, n = {}) => {
    const r = ["insert"];
    for (const s of i.attributes)
      e.hasAttribute(s) && r.push(`attribute:${s}`);
    return r.every((s) => t.test(e, s)) ? (n.preflight || r.forEach((s) => t.consume(e, s)), !0) : !1;
  };
}
function NL(i, e, t) {
  return (n, r) => {
    const s = n.createContainerElement("$slot");
    let o = null;
    if (r === "children")
      o = Array.from(i.getChildren());
    else if (typeof r == "function")
      o = Array.from(i.getChildren()).filter((l) => r(l));
    else
      throw new B("conversion-slot-mode-unknown", t.dispatcher, { modeOrFilter: r });
    return e.set(s, o), s;
  };
}
function DL(i, e, t) {
  const n = Array.from(e.values()).flat(), r = new Set(n);
  if (r.size != n.length)
    throw new B("conversion-slot-filter-overlap", t.dispatcher, { element: i });
  if (r.size != i.childCount)
    throw new B("conversion-slot-filter-incomplete", t.dispatcher, { element: i });
}
function BL(i, e, t, n) {
  t.mapper.on("modelToViewPosition", o, { priority: "highest" });
  let r = null, s = null;
  for ([r, s] of e)
    sC(i, s, t, n), t.writer.move(t.writer.createRangeIn(r), t.writer.createPositionBefore(r)), t.writer.remove(r);
  t.mapper.off("modelToViewPosition", o);
  function o(l, u) {
    const h = u.modelPosition.nodeAfter, f = s.indexOf(h);
    f < 0 || (u.viewPosition = u.mapper.findPositionIn(r, f));
  }
}
function sC(i, e, t, n) {
  for (const r of e)
    VL(i.root, r, t, n) || t.convertItem(r);
}
function VL(i, e, t, n) {
  const { writer: r, mapper: s } = t;
  if (!n.reconversion)
    return !1;
  const o = s.toViewElement(e);
  return !o || o.root == i || !t.canReuseView(o) ? !1 : (r.move(r.createRangeOn(o), s.toViewPosition(oe._createBefore(e))), !0);
}
function LL(i, e, { preflight: t } = {}) {
  return t ? e.test(i, "insert") : e.consume(i, "insert");
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function oC(i) {
  const { schema: e, document: t } = i.model;
  for (const n of t.getRootNames()) {
    const r = t.getRoot(n);
    if (r.isEmpty && !e.checkChild(r, "$text") && e.checkChild(r, "paragraph"))
      return i.insertElement("paragraph", r), !0;
  }
  return !1;
}
function aC(i, e, t) {
  const n = t.createContext(i);
  return !(!t.checkChild(n, "paragraph") || !t.checkChild(n.push("paragraph"), e));
}
function lC(i, e) {
  const t = e.createElement("paragraph");
  return e.insert(t, i), e.createPositionAt(t, 0);
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class FL extends XE {
  /**
   * View element to model element conversion helper.
   *
   * This conversion results in creating a model element. For example,
   * view `<p>Foo</p>` becomes `<paragraph>Foo</paragraph>` in the model.
   *
   * Keep in mind that the element will be inserted only if it is allowed
   * by {@link module:engine/model/schema~Schema schema} configuration.
   *
   * ```ts
   * editor.conversion.for( 'upcast' ).elementToElement( {
   * 	view: 'p',
   * 	model: 'paragraph'
   * } );
   *
   * editor.conversion.for( 'upcast' ).elementToElement( {
   * 	view: 'p',
   * 	model: 'paragraph',
   * 	converterPriority: 'high'
   * } );
   *
   * editor.conversion.for( 'upcast' ).elementToElement( {
   * 	view: {
   * 		name: 'p',
   * 		classes: 'fancy'
   * 	},
   * 	model: 'fancyParagraph'
   * } );
   *
   * editor.conversion.for( 'upcast' ).elementToElement( {
   * 	view: {
   * 		name: 'p',
   * 		classes: 'heading'
   * 	},
   * 	model: ( viewElement, conversionApi ) => {
   * 		const modelWriter = conversionApi.writer;
   *
   * 		return modelWriter.createElement( 'heading', { level: viewElement.getAttribute( 'data-level' ) } );
   * 	}
   * } );
   * ```
   *
   * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter
   * to the conversion process.
   *
   * @param config Conversion configuration.
   * @param config.view Pattern matching all view elements which should be converted. If not set, the converter
   * will fire for every view element.
   * @param config.model Name of the model element, a model element instance or a function that takes a view element
   * and {@link module:engine/conversion/upcastdispatcher~UpcastConversionApi upcast conversion API}
   * and returns a model element. The model element will be inserted in the model.
   * @param config.converterPriority Converter priority.
   */
  elementToElement(e) {
    return this.add(cC(e));
  }
  /**
   * View element to model attribute conversion helper.
   *
   * This conversion results in setting an attribute on a model node. For example, view `<strong>Foo</strong>` becomes
   * `Foo` {@link module:engine/model/text~Text model text node} with `bold` attribute set to `true`.
   *
   * This helper is meant to set a model attribute on all the elements that are inside the converted element:
   *
   * ```
   * <strong>Foo</strong>   -->   <strong><p>Foo</p></strong>   -->   <paragraph><$text bold="true">Foo</$text></paragraph>
   * ```
   *
   * Above is a sample of HTML code, that goes through autoparagraphing (first step) and then is converted (second step).
   * Even though `<strong>` is over `<p>` element, `bold="true"` was added to the text. See
   * {@link module:engine/conversion/upcasthelpers~UpcastHelpers#attributeToAttribute} for comparison.
   *
   * Keep in mind that the attribute will be set only if it is allowed by {@link module:engine/model/schema~Schema schema} configuration.
   *
   * ```ts
   * editor.conversion.for( 'upcast' ).elementToAttribute( {
   * 	view: 'strong',
   * 	model: 'bold'
   * } );
   *
   * editor.conversion.for( 'upcast' ).elementToAttribute( {
   * 	view: 'strong',
   * 	model: 'bold',
   * 	converterPriority: 'high'
   * } );
   *
   * editor.conversion.for( 'upcast' ).elementToAttribute( {
   * 	view: {
   * 		name: 'span',
   * 		classes: 'bold'
   * 	},
   * 	model: 'bold'
   * } );
   *
   * editor.conversion.for( 'upcast' ).elementToAttribute( {
   * 	view: {
   * 		name: 'span',
   * 		classes: [ 'styled', 'styled-dark' ]
   * 	},
   * 	model: {
   * 		key: 'styled',
   * 		value: 'dark'
   * 	}
   * } );
   *
   * editor.conversion.for( 'upcast' ).elementToAttribute( {
   * 	view: {
   * 		name: 'span',
   * 		styles: {
   * 			'font-size': /[\s\S]+/
   * 		}
   * 	},
   * 	model: {
   * 		key: 'fontSize',
   * 		value: ( viewElement, conversionApi ) => {
   * 			const fontSize = viewElement.getStyle( 'font-size' );
   * 			const value = fontSize.substr( 0, fontSize.length - 2 );
   *
   * 			if ( value <= 10 ) {
   * 				return 'small';
   * 			} else if ( value > 12 ) {
   * 				return 'big';
   * 			}
   *
   * 			return null;
   * 		}
   * 	}
   * } );
   * ```
   *
   * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter
   * to the conversion process.
   *
   * @param config Conversion configuration.
   * @param config.view Pattern matching all view elements which should be converted.
   * @param config.model Model attribute key or an object with `key` and `value` properties, describing
   * the model attribute. `value` property may be set as a function that takes a view element and
   * {@link module:engine/conversion/upcastdispatcher~UpcastConversionApi upcast conversion API} and returns the value.
   * If `String` is given, the model attribute value will be set to `true`.
   * @param config.converterPriority Converter priority. Defaults to `low`.
   */
  elementToAttribute(e) {
    return this.add(WL(e));
  }
  /**
   * View attribute to model attribute conversion helper.
   *
   * This conversion results in setting an attribute on a model node. For example, view `<img src="foo.jpg"></img>` becomes
   * `<imageBlock source="foo.jpg"></imageBlock>` in the model.
   *
   * This helper is meant to convert view attributes from view elements which got converted to the model, so the view attribute
   * is set only on the corresponding model node:
   *
   * ```
   * <div class="dark"><div>foo</div></div>    -->    <div dark="true"><div>foo</div></div>
   * ```
   *
   * Above, `class="dark"` attribute is added only to the `<div>` elements that has it. This is in contrary to
   * {@link module:engine/conversion/upcasthelpers~UpcastHelpers#elementToAttribute} which sets attributes for
   * all the children in the model:
   *
   * ```
   * <strong>Foo</strong>   -->   <strong><p>Foo</p></strong>   -->   <paragraph><$text bold="true">Foo</$text></paragraph>
   * ```
   *
   * Above is a sample of HTML code, that goes through autoparagraphing (first step) and then is converted (second step).
   * Even though `<strong>` is over `<p>` element, `bold="true"` was added to the text.
   *
   * Keep in mind that the attribute will be set only if it is allowed by {@link module:engine/model/schema~Schema schema} configuration.
   *
   * ```ts
   * editor.conversion.for( 'upcast' ).attributeToAttribute( {
   * 	view: 'src',
   * 	model: 'source'
   * } );
   *
   * editor.conversion.for( 'upcast' ).attributeToAttribute( {
   * 	view: { key: 'src' },
   * 	model: 'source'
   * } );
   *
   * editor.conversion.for( 'upcast' ).attributeToAttribute( {
   * 	view: { key: 'src' },
   * 	model: 'source',
   * 	converterPriority: 'normal'
   * } );
   *
   * editor.conversion.for( 'upcast' ).attributeToAttribute( {
   * 	view: {
   * 		key: 'data-style',
   * 		value: /[\s\S]+/
   * 	},
   * 	model: 'styled'
   * } );
   *
   * editor.conversion.for( 'upcast' ).attributeToAttribute( {
   * 	view: {
   * 		name: 'img',
   * 		key: 'class',
   * 		value: 'styled-dark'
   * 	},
   * 	model: {
   * 		key: 'styled',
   * 		value: 'dark'
   * 	}
   * } );
   *
   * editor.conversion.for( 'upcast' ).attributeToAttribute( {
   * 	view: {
   * 		key: 'class',
   * 		value: /styled-[\S]+/
   * 	},
   * 	model: {
   * 		key: 'styled'
   * 		value: ( viewElement, conversionApi ) => {
   * 			const regexp = /styled-([\S]+)/;
   * 			const match = viewElement.getAttribute( 'class' ).match( regexp );
   *
   * 			return match[ 1 ];
   * 		}
   * 	}
   * } );
   * ```
   *
   * Converting styles works a bit differently as it requires `view.styles` to be an object and by default
   * a model attribute will be set to `true` by such a converter. You can set the model attribute to any value by providing the `value`
   * callback that returns the desired value.
   *
   * ```ts
   * // Default conversion of font-weight style will result in setting bold attribute to true.
   * editor.conversion.for( 'upcast' ).attributeToAttribute( {
   * 	view: {
   * 		styles: {
   * 			'font-weight': 'bold'
   * 		}
   * 	},
   * 	model: 'bold'
   * } );
   *
   * // This converter will pass any style value to the `lineHeight` model attribute.
   * editor.conversion.for( 'upcast' ).attributeToAttribute( {
   * 	view: {
   * 		styles: {
   * 			'line-height': /[\s\S]+/
   * 		}
   * 	},
   * 	model: {
   * 		key: 'lineHeight',
   * 		value: ( viewElement, conversionApi ) => viewElement.getStyle( 'line-height' )
   * 	}
   * } );
   * ```
   *
   * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter
   * to the conversion process.
   *
   * @param config Conversion configuration.
   * @param config.view Specifies which view attribute will be converted. If a `String` is passed,
   * attributes with given key will be converted. If an `Object` is passed, it must have a required `key` property,
   * specifying view attribute key, and may have an optional `value` property, specifying view attribute value and optional `name`
   * property specifying a view element name from/on which the attribute should be converted. `value` can be given as a `String`,
   * a `RegExp` or a function callback, that takes view attribute value as the only parameter and returns `Boolean`.
   * @param config.model Model attribute key or an object with `key` and `value` properties, describing
   * the model attribute. `value` property may be set as a function that takes a view element and
   * {@link module:engine/conversion/upcastdispatcher~UpcastConversionApi upcast conversion API} and returns the value.
   * If `String` is given, the model attribute value will be same as view attribute value.
   * @param config.converterPriority Converter priority. Defaults to `low`.
   */
  attributeToAttribute(e) {
    return this.add(jL(e));
  }
  /**
   * View element to model marker conversion helper.
   *
   * This conversion results in creating a model marker. For example, if the marker was stored in a view as an element:
   * `<p>Fo<span data-marker="comment" data-comment-id="7"></span>o</p><p>B<span data-marker="comment" data-comment-id="7"></span>ar</p>`,
   * after the conversion is done, the marker will be available in
   * {@link module:engine/model/model~Model#markers model document markers}.
   *
   * **Note**: When this helper is used in the data upcast in combination with
   * {@link module:engine/conversion/downcasthelpers~DowncastHelpers#markerToData `#markerToData()`} in the data downcast,
   * then invalid HTML code (e.g. a span between table cells) may be produced by the latter converter.
   *
   * In most of the cases, the {@link #dataToMarker} should be used instead.
   *
   * ```ts
   * editor.conversion.for( 'upcast' ).elementToMarker( {
   * 	view: 'marker-search',
   * 	model: 'search'
   * } );
   *
   * editor.conversion.for( 'upcast' ).elementToMarker( {
   * 	view: 'marker-search',
   * 	model: 'search',
   * 	converterPriority: 'high'
   * } );
   *
   * editor.conversion.for( 'upcast' ).elementToMarker( {
   * 	view: 'marker-search',
   * 	model: ( viewElement, conversionApi ) => 'comment:' + viewElement.getAttribute( 'data-comment-id' )
   * } );
   *
   * editor.conversion.for( 'upcast' ).elementToMarker( {
   * 	view: {
   * 		name: 'span',
   * 		attributes: {
   * 			'data-marker': 'search'
   * 		}
   * 	},
   * 	model: 'search'
   * } );
   * ```
   *
   * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter
   * to the conversion process.
   *
   * @param config Conversion configuration.
   * @param config.view Pattern matching all view elements which should be converted.
   * @param config.model Name of the model marker, or a function that takes a view element and returns
   * a model marker name.
   * @param config.converterPriority Converter priority.
   */
  elementToMarker(e) {
    return this.add(UL(e));
  }
  /**
   * View-to-model marker conversion helper.
   *
   * Converts view data created by {@link module:engine/conversion/downcasthelpers~DowncastHelpers#markerToData `#markerToData()`}
   * back to a model marker.
   *
   * This converter looks for specific view elements and view attributes that mark marker boundaries. See
   * {@link module:engine/conversion/downcasthelpers~DowncastHelpers#markerToData `#markerToData()`} to learn what view data
   * is expected by this converter.
   *
   * The `config.view` property is equal to the marker group name to convert.
   *
   * By default, this converter creates markers with the `group:name` name convention (to match the default `markerToData` conversion).
   *
   * The conversion configuration can take a function that will generate a marker name.
   * If such function is set as the `config.model` parameter, it is passed the `name` part from the view element or attribute and it is
   * expected to return a string with the marker name.
   *
   * Basic usage:
   *
   * ```ts
   * // Using the default conversion.
   * // In this case, all markers from the `comment` group will be converted.
   * // The conversion will look for `<comment-start>` and `<comment-end>` tags and
   * // `data-comment-start-before`, `data-comment-start-after`,
   * // `data-comment-end-before` and `data-comment-end-after` attributes.
   * editor.conversion.for( 'upcast' ).dataToMarker( {
   * 	view: 'comment'
   * } );
   * ```
   *
   * An example of a model that may be generated by this conversion:
   *
   * ```
   * // View:
   * <p>Foo<comment-start name="commentId:uid"></comment-start>bar</p>
   * <figure data-comment-end-after="commentId:uid" class="image"><img src="abc.jpg" /></figure>
   *
   * // Model:
   * <paragraph>Foo[bar</paragraph>
   * <imageBlock src="abc.jpg"></imageBlock>]
   * ```
   *
   * Where `[]` are boundaries of a marker that will receive the `comment:commentId:uid` name.
   *
   * Other examples of usage:
   *
   * ```ts
   * // Using a custom function which is the same as the default conversion:
   * editor.conversion.for( 'upcast' ).dataToMarker( {
   * 	view: 'comment',
   * 	model: ( name, conversionApi ) => 'comment:' + name,
   * } );
   *
   * // Using the converter priority:
   * editor.conversion.for( 'upcast' ).dataToMarker( {
   * 	view: 'comment',
   * 	model: ( name, conversionApi ) => 'comment:' + name,
   * 	converterPriority: 'high'
   * } );
   * ```
   *
   * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter
   * to the conversion process.
   *
   * @param config Conversion configuration.
   * @param config.view The marker group name to convert.
   * @param config.model A function that takes the `name` part from the view element or attribute and
   * {@link module:engine/conversion/upcastdispatcher~UpcastConversionApi upcast conversion API} and returns the marker name.
   * @param config.converterPriority Converter priority.
   */
  dataToMarker(e) {
    return this.add(HL(e));
  }
}
function cb() {
  return (i, e, t) => {
    if (!e.modelRange && t.consumable.consume(e.viewItem, { name: !0 })) {
      const { modelRange: n, modelCursor: r } = t.convertChildren(e.viewItem, e.modelCursor);
      e.modelRange = n, e.modelCursor = r;
    }
  };
}
function $L() {
  return (i, e, { schema: t, consumable: n, writer: r }) => {
    let s = e.modelCursor;
    if (!n.test(e.viewItem))
      return;
    if (!t.checkChild(s, "$text")) {
      if (!aC(s, "$text", t) || e.viewItem.data.trim().length == 0)
        return;
      const l = s.nodeBefore;
      s = lC(s, r), l && l.is("element", "$marker") && (r.move(r.createRangeOn(l), s), s = r.createPositionAfter(l));
    }
    n.consume(e.viewItem);
    const o = r.createText(e.viewItem.data);
    r.insert(o, s), e.modelRange = r.createRange(s, s.getShiftedBy(o.offsetSize)), e.modelCursor = e.modelRange.end;
  };
}
function zL(i, e) {
  return (t, n) => {
    const r = n.newSelection, s = [];
    for (const l of r.getRanges())
      s.push(e.toModelRange(l));
    const o = i.createSelection(s, { backward: r.isBackward });
    o.isEqual(i.document.selection) || i.change((l) => {
      l.setSelection(o);
    });
  };
}
function cC(i) {
  i = js(i);
  const e = pg(i), t = hp(i.view), n = t ? `element:${t}` : "element";
  return (r) => {
    r.on(n, e, { priority: i.converterPriority || "normal" });
  };
}
function WL(i) {
  i = js(i), uC(i);
  const e = dC(i, !1), t = hp(i.view), n = t ? `element:${t}` : "element";
  return (r) => {
    r.on(n, e, { priority: i.converterPriority || "low" });
  };
}
function jL(i) {
  i = js(i);
  let e = null;
  (typeof i.view == "string" || i.view.key) && (e = GL(i)), uC(i, e);
  const t = dC(i, !0);
  return (n) => {
    n.on("element", t, { priority: i.converterPriority || "low" });
  };
}
function UL(i) {
  const e = XL(i.model);
  return cC({ ...i, model: e });
}
function HL(i) {
  i = js(i), i.model || (i.model = (r) => r ? i.view + ":" + r : i.view);
  const e = {
    view: i.view,
    model: i.model
  }, t = pg(ub(e, "start")), n = pg(ub(e, "end"));
  return (r) => {
    r.on(`element:${i.view}-start`, t, { priority: i.converterPriority || "normal" }), r.on(`element:${i.view}-end`, n, { priority: i.converterPriority || "normal" });
    const s = Os.get("low"), o = Os.get("highest"), l = Os.get(i.converterPriority) / o;
    r.on("element", qL(e), { priority: s + l });
  };
}
function qL(i) {
  return (e, t, n) => {
    const r = `data-${i.view}`;
    if (!n.consumable.test(t.viewItem, { attributes: r + "-end-after" }) && !n.consumable.test(t.viewItem, { attributes: r + "-start-after" }) && !n.consumable.test(t.viewItem, { attributes: r + "-end-before" }) && !n.consumable.test(t.viewItem, { attributes: r + "-start-before" }))
      return;
    t.modelRange || Object.assign(t, n.convertChildren(t.viewItem, t.modelCursor)), n.consumable.consume(t.viewItem, { attributes: r + "-end-after" }) && s(t.modelRange.end, t.viewItem.getAttribute(r + "-end-after").split(",")), n.consumable.consume(t.viewItem, { attributes: r + "-start-after" }) && s(t.modelRange.end, t.viewItem.getAttribute(r + "-start-after").split(",")), n.consumable.consume(t.viewItem, { attributes: r + "-end-before" }) && s(t.modelRange.start, t.viewItem.getAttribute(r + "-end-before").split(",")), n.consumable.consume(t.viewItem, { attributes: r + "-start-before" }) && s(t.modelRange.start, t.viewItem.getAttribute(r + "-start-before").split(","));
    function s(o, l) {
      for (const u of l) {
        const h = i.model(u, n), f = n.writer.createElement("$marker", { "data-name": h });
        n.writer.insert(f, o), t.modelCursor.isEqual(o) ? t.modelCursor = t.modelCursor.getShiftedBy(1) : t.modelCursor = t.modelCursor._getTransformedByInsertion(o, 1), t.modelRange = t.modelRange._getTransformedByInsertion(o, 1)[0];
      }
    }
  };
}
function hp(i) {
  return typeof i == "string" ? i : typeof i == "object" && typeof i.name == "string" ? i.name : null;
}
function pg(i) {
  const e = new ah(i.view);
  return (t, n, r) => {
    const s = e.match(n.viewItem);
    if (!s)
      return;
    const o = s.match;
    if (o.name = !0, !r.consumable.test(n.viewItem, o))
      return;
    const l = KL(i.model, n.viewItem, r);
    l && r.safeInsert(l, n.modelCursor) && (r.consumable.consume(n.viewItem, o), r.convertChildren(n.viewItem, l), r.updateConversionResult(l, n));
  };
}
function KL(i, e, t) {
  return i instanceof Function ? i(e, t) : t.writer.createElement(i);
}
function GL(i) {
  typeof i.view == "string" && (i.view = { key: i.view });
  const e = i.view.key;
  let t;
  if (e == "class" || e == "style")
    t = {
      [e == "class" ? "classes" : "styles"]: i.view.value
    };
  else {
    const n = typeof i.view.value > "u" ? /[\s\S]*/ : i.view.value;
    t = {
      attributes: {
        [e]: n
      }
    };
  }
  return i.view.name && (t.name = i.view.name), i.view = t, e;
}
function uC(i, e = null) {
  const t = e === null ? !0 : (s) => s.getAttribute(e), n = typeof i.model != "object" ? i.model : i.model.key, r = typeof i.model != "object" || typeof i.model.value > "u" ? t : i.model.value;
  i.model = { key: n, value: r };
}
function dC(i, e) {
  const t = new ah(i.view);
  return (n, r, s) => {
    if (!r.modelRange && e)
      return;
    const o = t.match(r.viewItem);
    if (!o || (YL(i.view, r.viewItem) ? o.match.name = !0 : delete o.match.name, !s.consumable.test(r.viewItem, o.match)))
      return;
    const l = i.model.key, u = typeof i.model.value == "function" ? i.model.value(r.viewItem, s) : i.model.value;
    if (u === null)
      return;
    r.modelRange || Object.assign(r, s.convertChildren(r.viewItem, r.modelCursor)), JL(r.modelRange, { key: l, value: u }, e, s) && (s.consumable.test(r.viewItem, { name: !0 }) && (o.match.name = !0), s.consumable.consume(r.viewItem, o.match));
  };
}
function YL(i, e) {
  const t = typeof i == "function" ? i(e) : i;
  return typeof t == "object" && !hp(t) ? !1 : !t.classes && !t.attributes && !t.styles;
}
function JL(i, e, t, n) {
  let r = !1;
  for (const s of Array.from(i.getItems({ shallow: t })))
    n.schema.checkAttribute(s, e.key) && (r = !0, !s.hasAttribute(e.key) && n.writer.setAttribute(e.key, e.value, s));
  return r;
}
function XL(i) {
  return (e, t) => {
    const n = typeof i == "string" ? i : i(e, t);
    return t.writer.createElement("$marker", { "data-name": n });
  };
}
function ub(i, e) {
  const t = (n, r) => {
    const s = n.getAttribute("name"), o = i.model(s, r);
    return r.writer.createElement("$marker", { "data-name": o });
  };
  return {
    // Upcast <markerGroup-start> and <markerGroup-end> elements.
    view: `${i.view}-${e}`,
    model: t
  };
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function ZL(i) {
  i.document.registerPostFixer((e) => QL(e, i));
}
function QL(i, e) {
  const t = e.document.selection, n = e.schema, r = [];
  let s = !1;
  for (const o of t.getRanges()) {
    const l = hC(o, n);
    l && !l.isEqual(o) ? (r.push(l), s = !0) : r.push(o);
  }
  return s && i.setSelection(i8(r), { backward: t.isBackward }), !1;
}
function hC(i, e) {
  return i.isCollapsed ? e8(i, e) : t8(i, e);
}
function e8(i, e) {
  const t = i.start, n = e.getNearestSelectionRange(t);
  if (!n) {
    const s = t.getAncestors().reverse().find((o) => e.isObject(o));
    return s ? X._createOn(s) : null;
  }
  if (!n.isCollapsed)
    return n;
  const r = n.start;
  return t.isEqual(r) ? null : new X(r);
}
function t8(i, e) {
  const { start: t, end: n } = i, r = e.checkChild(t, "$text"), s = e.checkChild(n, "$text"), o = e.getLimitElement(t), l = e.getLimitElement(n);
  if (o === l) {
    if (r && s)
      return null;
    if (n8(t, n, e)) {
      const m = t.nodeAfter && e.isSelectable(t.nodeAfter) ? null : e.getNearestSelectionRange(t, "forward"), C = n.nodeBefore && e.isSelectable(n.nodeBefore) ? null : e.getNearestSelectionRange(n, "backward"), k = m ? m.start : t, S = C ? C.end : n;
      return new X(k, S);
    }
  }
  const u = o && !o.is("rootElement"), h = l && !l.is("rootElement");
  if (u || h) {
    const f = t.nodeAfter && n.nodeBefore && t.nodeAfter.parent === n.nodeBefore.parent, m = u && (!f || !hb(t.nodeAfter, e)), v = h && (!f || !hb(n.nodeBefore, e));
    let C = t, k = n;
    return m && (C = oe._createBefore(db(o, e))), v && (k = oe._createAfter(db(l, e))), new X(C, k);
  }
  return null;
}
function db(i, e) {
  let t = i, n = t;
  for (; e.isLimit(n) && n.parent; )
    t = n, n = n.parent;
  return t;
}
function n8(i, e, t) {
  const n = i.nodeAfter && !t.isLimit(i.nodeAfter) || t.checkChild(i, "$text"), r = e.nodeBefore && !t.isLimit(e.nodeBefore) || t.checkChild(e, "$text");
  return n || r;
}
function i8(i) {
  const e = [...i], t = /* @__PURE__ */ new Set();
  let n = 1;
  for (; n < e.length; ) {
    const s = e[n], o = e.slice(0, n);
    for (const [l, u] of o.entries())
      if (!t.has(l)) {
        if (s.isEqual(u))
          t.add(l);
        else if (s.isIntersecting(u)) {
          t.add(l), t.add(n);
          const h = s.getJoined(u);
          e.push(h);
        }
      }
    n++;
  }
  return e.filter((s, o) => !t.has(o));
}
function hb(i, e) {
  return i && e.isSelectable(i);
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class r8 extends Nt() {
  /**
   * Creates an editing controller instance.
   *
   * @param model Editing model.
   * @param stylesProcessor The styles processor instance.
   */
  constructor(e, t) {
    super(), this.model = e, this.view = new qV(t), this.mapper = new GE(), this.downcastDispatcher = new YE({
      mapper: this.mapper,
      schema: e.schema
    });
    const n = this.model.document, r = n.selection, s = this.model.markers;
    this.listenTo(this.model, "_beforeChanges", () => {
      this.view._disableRendering(!0);
    }, { priority: "highest" }), this.listenTo(this.model, "_afterChanges", () => {
      this.view._disableRendering(!1);
    }, { priority: "lowest" }), this.listenTo(n, "change", () => {
      this.view.change((o) => {
        this.downcastDispatcher.convertChanges(n.differ, s, o), this.downcastDispatcher.convertSelection(r, s, o);
      });
    }, { priority: "low" }), this.listenTo(this.view.document, "selectionChange", zL(this.model, this.mapper)), this.listenTo(this.view.document, "beforeinput", s8(this.mapper, this.model.schema, this.view), { priority: "high" }), this.downcastDispatcher.on("insert:$text", ZE(), { priority: "lowest" }), this.downcastDispatcher.on("insert", QE(), { priority: "lowest" }), this.downcastDispatcher.on("remove", lL(), { priority: "low" }), this.downcastDispatcher.on("selection", dL(), { priority: "high" }), this.downcastDispatcher.on("selection", cL(), { priority: "low" }), this.downcastDispatcher.on("selection", uL(), { priority: "low" }), this.view.document.roots.bindTo(this.model.document.roots).using((o) => {
      if (o.rootName == "$graveyard")
        return null;
      const l = new OE(this.view.document, o.name);
      return l.rootName = o.rootName, this.mapper.bindElements(o, l), l;
    });
  }
  /**
   * Removes all event listeners attached to the `EditingController`. Destroys all objects created
   * by `EditingController` that need to be destroyed.
   */
  destroy() {
    this.view.destroy(), this.stopListening();
  }
  /**
   * Calling this method will refresh the marker by triggering the downcast conversion for it.
   *
   * Reconverting the marker is useful when you want to change its {@link module:engine/view/element~Element view element}
   * without changing any marker data. For instance:
   *
   * ```ts
   * let isCommentActive = false;
   *
   * model.conversion.markerToHighlight( {
   * 	model: 'comment',
   * 	view: data => {
   * 		const classes = [ 'comment-marker' ];
   *
   * 		if ( isCommentActive ) {
   * 			classes.push( 'comment-marker--active' );
   * 		}
   *
   * 		return { classes };
   * 	}
   * } );
   *
   * // ...
   *
   * // Change the property that indicates if marker is displayed as active or not.
   * isCommentActive = true;
   *
   * // Reconverting will downcast and synchronize the marker with the new isCommentActive state value.
   * editor.editing.reconvertMarker( 'comment' );
   * ```
   *
   * **Note**: If you want to reconvert a model item, use {@link #reconvertItem} instead.
   *
   * @param markerOrName Name of a marker to update, or a marker instance.
   */
  reconvertMarker(e) {
    const t = typeof e == "string" ? e : e.name, n = this.model.markers.get(t);
    if (!n)
      throw new B("editingcontroller-reconvertmarker-marker-not-exist", this, { markerName: t });
    this.model.change(() => {
      this.model.markers._refresh(n);
    });
  }
  /**
   * Calling this method will downcast a model item on demand (by requesting a refresh in the {@link module:engine/model/differ~Differ}).
   *
   * You can use it if you want the view representation of a specific item updated as a response to external modifications. For instance,
   * when the view structure depends not only on the associated model data but also on some external state.
   *
   * **Note**: If you want to reconvert a model marker, use {@link #reconvertMarker} instead.
   *
   * @param item Item to refresh.
   */
  reconvertItem(e) {
    this.model.change(() => {
      this.model.document.differ._refreshItem(e);
    });
  }
}
function s8(i, e, t) {
  return (n, r) => {
    if (!(t.document.isComposing && !qe.isAndroid))
      for (let s = 0; s < r.targetRanges.length; s++) {
        const o = r.targetRanges[s], l = i.toModelRange(o), u = hC(l, e);
        !u || u.isEqual(l) || (r.targetRanges[s] = i.toViewRange(u));
      }
  };
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class fl {
  constructor() {
    this._consumables = /* @__PURE__ */ new Map();
  }
  add(e, t) {
    let n;
    if (e.is("$text") || e.is("documentFragment")) {
      this._consumables.set(e, !0);
      return;
    }
    this._consumables.has(e) ? n = this._consumables.get(e) : (n = new o8(e), this._consumables.set(e, n)), n.add(t);
  }
  /**
   * Tests if {@link module:engine/view/element~Element view element}, {@link module:engine/view/text~Text text node} or
   * {@link module:engine/view/documentfragment~DocumentFragment document fragment} can be consumed.
   * It returns `true` when all items included in method's call can be consumed. Returns `false` when
   * first already consumed item is found and `null` when first non-consumable item is found.
   *
   * ```ts
   * viewConsumable.test( p, { name: true } ); // Tests element's name.
   * viewConsumable.test( p, { attributes: 'name' } ); // Tests attribute.
   * viewConsumable.test( p, { classes: 'foobar' } ); // Tests class.
   * viewConsumable.test( p, { styles: 'color' } ); // Tests style.
   * viewConsumable.test( p, { attributes: 'name', styles: 'color' } ); // Tests attribute and style.
   * viewConsumable.test( p, { classes: [ 'baz', 'bar' ] } ); // Multiple consumables can be tested.
   * viewConsumable.test( textNode ); // Tests text node.
   * viewConsumable.test( docFragment ); // Tests document fragment.
   * ```
   *
   * Testing classes and styles as attribute will test if all added classes/styles can be consumed.
   *
   * ```ts
   * viewConsumable.test( p, { attributes: 'class' } ); // Tests if all added classes can be consumed.
   * viewConsumable.test( p, { attributes: 'style' } ); // Tests if all added styles can be consumed.
   * ```
   *
   * @param consumables Used only if first parameter is {@link module:engine/view/element~Element view element} instance.
   * @param consumables.name If set to true element's name will be included.
   * @param consumables.attributes Attribute name or array of attribute names.
   * @param consumables.classes Class name or array of class names.
   * @param consumables.styles Style name or array of style names.
   * @returns Returns `true` when all items included in method's call can be consumed. Returns `false`
   * when first already consumed item is found and `null` when first non-consumable item is found.
   */
  test(e, t) {
    const n = this._consumables.get(e);
    return n === void 0 ? null : e.is("$text") || e.is("documentFragment") ? n : n.test(t);
  }
  /**
   * Consumes {@link module:engine/view/element~Element view element}, {@link module:engine/view/text~Text text node} or
   * {@link module:engine/view/documentfragment~DocumentFragment document fragment}.
   * It returns `true` when all items included in method's call can be consumed, otherwise returns `false`.
   *
   * ```ts
   * viewConsumable.consume( p, { name: true } ); // Consumes element's name.
   * viewConsumable.consume( p, { attributes: 'name' } ); // Consumes element's attribute.
   * viewConsumable.consume( p, { classes: 'foobar' } ); // Consumes element's class.
   * viewConsumable.consume( p, { styles: 'color' } ); // Consumes element's style.
   * viewConsumable.consume( p, { attributes: 'name', styles: 'color' } ); // Consumes attribute and style.
   * viewConsumable.consume( p, { classes: [ 'baz', 'bar' ] } ); // Multiple consumables can be consumed.
   * viewConsumable.consume( textNode ); // Consumes text node.
   * viewConsumable.consume( docFragment ); // Consumes document fragment.
   * ```
   *
   * Consuming classes and styles as attribute will test if all added classes/styles can be consumed.
   *
   * ```ts
   * viewConsumable.consume( p, { attributes: 'class' } ); // Consume only if all added classes can be consumed.
   * viewConsumable.consume( p, { attributes: 'style' } ); // Consume only if all added styles can be consumed.
   * ```
   *
   * @param consumables Used only if first parameter is {@link module:engine/view/element~Element view element} instance.
   * @param consumables.name If set to true element's name will be included.
   * @param consumables.attributes Attribute name or array of attribute names.
   * @param consumables.classes Class name or array of class names.
   * @param consumables.styles Style name or array of style names.
   * @returns Returns `true` when all items included in method's call can be consumed,
   * otherwise returns `false`.
   */
  consume(e, t) {
    return this.test(e, t) ? (e.is("$text") || e.is("documentFragment") ? this._consumables.set(e, !1) : this._consumables.get(e).consume(t), !0) : !1;
  }
  /**
   * Reverts {@link module:engine/view/element~Element view element}, {@link module:engine/view/text~Text text node} or
   * {@link module:engine/view/documentfragment~DocumentFragment document fragment} so they can be consumed once again.
   * Method does not revert items that were never previously added for consumption, even if they are included in
   * method's call.
   *
   * ```ts
   * viewConsumable.revert( p, { name: true } ); // Reverts element's name.
   * viewConsumable.revert( p, { attributes: 'name' } ); // Reverts element's attribute.
   * viewConsumable.revert( p, { classes: 'foobar' } ); // Reverts element's class.
   * viewConsumable.revert( p, { styles: 'color' } ); // Reverts element's style.
   * viewConsumable.revert( p, { attributes: 'name', styles: 'color' } ); // Reverts attribute and style.
   * viewConsumable.revert( p, { classes: [ 'baz', 'bar' ] } ); // Multiple names can be reverted.
   * viewConsumable.revert( textNode ); // Reverts text node.
   * viewConsumable.revert( docFragment ); // Reverts document fragment.
   * ```
   *
   * Reverting classes and styles as attribute will revert all classes/styles that were previously added for
   * consumption.
   *
   * ```ts
   * viewConsumable.revert( p, { attributes: 'class' } ); // Reverts all classes added for consumption.
   * viewConsumable.revert( p, { attributes: 'style' } ); // Reverts all styles added for consumption.
   * ```
   *
   * @param consumables Used only if first parameter is {@link module:engine/view/element~Element view element} instance.
   * @param consumables.name If set to true element's name will be included.
   * @param consumables.attributes Attribute name or array of attribute names.
   * @param consumables.classes Class name or array of class names.
   * @param consumables.styles Style name or array of style names.
   */
  revert(e, t) {
    const n = this._consumables.get(e);
    n !== void 0 && (e.is("$text") || e.is("documentFragment") ? this._consumables.set(e, !0) : n.revert(t));
  }
  /**
   * Creates consumable object from {@link module:engine/view/element~Element view element}. Consumable object will include
   * element's name and all its attributes, classes and styles.
   */
  static consumablesFromElement(e) {
    const t = {
      element: e,
      name: !0,
      attributes: [],
      classes: [],
      styles: []
    }, n = e.getAttributeKeys();
    for (const o of n)
      o == "style" || o == "class" || t.attributes.push(o);
    const r = e.getClassNames();
    for (const o of r)
      t.classes.push(o);
    const s = e.getStyleNames();
    for (const o of s)
      t.styles.push(o);
    return t;
  }
  /**
   * Creates {@link module:engine/conversion/viewconsumable~ViewConsumable ViewConsumable} instance from
   * {@link module:engine/view/node~Node node} or {@link module:engine/view/documentfragment~DocumentFragment document fragment}.
   * Instance will contain all elements, child nodes, attributes, styles and classes added for consumption.
   *
   * @param from View node or document fragment from which `ViewConsumable` will be created.
   * @param instance If provided, given `ViewConsumable` instance will be used
   * to add all consumables. It will be returned instead of a new instance.
   */
  static createFrom(e, t) {
    if (t || (t = new fl()), e.is("$text"))
      return t.add(e), t;
    e.is("element") && t.add(e, fl.consumablesFromElement(e)), e.is("documentFragment") && t.add(e);
    for (const n of e.getChildren())
      t = fl.createFrom(n, t);
    return t;
  }
}
const Uu = ["attributes", "classes", "styles"];
class o8 {
  /**
   * Creates ViewElementConsumables instance.
   *
   * @param from View node or document fragment from which `ViewElementConsumables` is being created.
   */
  constructor(e) {
    this.element = e, this._canConsumeName = null, this._consumables = {
      attributes: /* @__PURE__ */ new Map(),
      styles: /* @__PURE__ */ new Map(),
      classes: /* @__PURE__ */ new Map()
    };
  }
  /**
   * Adds consumable parts of the {@link module:engine/view/element~Element view element}.
   * Element's name itself can be marked to be consumed (when element's name is consumed its attributes, classes and
   * styles still could be consumed):
   *
   * ```ts
   * consumables.add( { name: true } );
   * ```
   *
   * Attributes classes and styles:
   *
   * ```ts
   * consumables.add( { attributes: 'title', classes: 'foo', styles: 'color' } );
   * consumables.add( { attributes: [ 'title', 'name' ], classes: [ 'foo', 'bar' ] );
   * ```
   *
   * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `viewconsumable-invalid-attribute` when `class` or `style`
   * attribute is provided - it should be handled separately by providing `style` and `class` in consumables object.
   *
   * @param consumables Object describing which parts of the element can be consumed.
   * @param consumables.name If set to `true` element's name will be added as consumable.
   * @param consumables.attributes Attribute name or array of attribute names to add as consumable.
   * @param consumables.classes Class name or array of class names to add as consumable.
   * @param consumables.styles Style name or array of style names to add as consumable.
   */
  add(e) {
    e.name && (this._canConsumeName = !0);
    for (const t of Uu)
      t in e && this._add(t, e[t]);
  }
  /**
   * Tests if parts of the {@link module:engine/view/node~Node view node} can be consumed.
   *
   * Element's name can be tested:
   *
   * ```ts
   * consumables.test( { name: true } );
   * ```
   *
   * Attributes classes and styles:
   *
   * ```ts
   * consumables.test( { attributes: 'title', classes: 'foo', styles: 'color' } );
   * consumables.test( { attributes: [ 'title', 'name' ], classes: [ 'foo', 'bar' ] );
   * ```
   *
   * @param consumables Object describing which parts of the element should be tested.
   * @param consumables.name If set to `true` element's name will be tested.
   * @param consumables.attributes Attribute name or array of attribute names to test.
   * @param consumables.classes Class name or array of class names to test.
   * @param consumables.styles Style name or array of style names to test.
   * @returns `true` when all tested items can be consumed, `null` when even one of the items
   * was never marked for consumption and `false` when even one of the items was already consumed.
   */
  test(e) {
    if (e.name && !this._canConsumeName)
      return this._canConsumeName;
    for (const t of Uu)
      if (t in e) {
        const n = this._test(t, e[t]);
        if (n !== !0)
          return n;
      }
    return !0;
  }
  /**
   * Consumes parts of {@link module:engine/view/element~Element view element}. This function does not check if consumable item
   * is already consumed - it consumes all consumable items provided.
   * Element's name can be consumed:
   *
   * ```ts
   * consumables.consume( { name: true } );
   * ```
   *
   * Attributes classes and styles:
   *
   * ```ts
   * consumables.consume( { attributes: 'title', classes: 'foo', styles: 'color' } );
   * consumables.consume( { attributes: [ 'title', 'name' ], classes: [ 'foo', 'bar' ] );
   * ```
   *
   * @param consumables Object describing which parts of the element should be consumed.
   * @param consumables.name If set to `true` element's name will be consumed.
   * @param consumables.attributes Attribute name or array of attribute names to consume.
   * @param consumables.classes Class name or array of class names to consume.
   * @param consumables.styles Style name or array of style names to consume.
   */
  consume(e) {
    e.name && (this._canConsumeName = !1);
    for (const t of Uu)
      t in e && this._consume(t, e[t]);
  }
  /**
   * Revert already consumed parts of {@link module:engine/view/element~Element view Element}, so they can be consumed once again.
   * Element's name can be reverted:
   *
   * ```ts
   * consumables.revert( { name: true } );
   * ```
   *
   * Attributes classes and styles:
   *
   * ```ts
   * consumables.revert( { attributes: 'title', classes: 'foo', styles: 'color' } );
   * consumables.revert( { attributes: [ 'title', 'name' ], classes: [ 'foo', 'bar' ] );
   * ```
   *
   * @param consumables Object describing which parts of the element should be reverted.
   * @param consumables.name If set to `true` element's name will be reverted.
   * @param consumables.attributes Attribute name or array of attribute names to revert.
   * @param consumables.classes Class name or array of class names to revert.
   * @param consumables.styles Style name or array of style names to revert.
   */
  revert(e) {
    e.name && (this._canConsumeName = !0);
    for (const t of Uu)
      t in e && this._revert(t, e[t]);
  }
  /**
   * Helper method that adds consumables of a given type: attribute, class or style.
   *
   * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `viewconsumable-invalid-attribute` when `class` or `style`
   * type is provided - it should be handled separately by providing actual style/class type.
   *
   * @param type Type of the consumable item: `attributes`, `classes` or `styles`.
   * @param item Consumable item or array of items.
   */
  _add(e, t) {
    const n = Fn(t) ? t : [t], r = this._consumables[e];
    for (const s of n) {
      if (e === "attributes" && (s === "class" || s === "style"))
        throw new B("viewconsumable-invalid-attribute", this);
      if (r.set(s, !0), e === "styles")
        for (const o of this.element.document.stylesProcessor.getRelatedStyles(s))
          r.set(o, !0);
    }
  }
  /**
   * Helper method that tests consumables of a given type: attribute, class or style.
   *
   * @param type Type of the consumable item: `attributes`, `classes` or `styles`.
   * @param item Consumable item or array of items.
   * @returns Returns `true` if all items can be consumed, `null` when one of the items cannot be
   * consumed and `false` when one of the items is already consumed.
   */
  _test(e, t) {
    const n = Fn(t) ? t : [t], r = this._consumables[e];
    for (const s of n)
      if (e === "attributes" && (s === "class" || s === "style")) {
        const o = s == "class" ? "classes" : "styles", l = this._test(o, [...this._consumables[o].keys()]);
        if (l !== !0)
          return l;
      } else {
        const o = r.get(s);
        if (o === void 0)
          return null;
        if (!o)
          return !1;
      }
    return !0;
  }
  /**
   * Helper method that consumes items of a given type: attribute, class or style.
   *
   * @param type Type of the consumable item: `attributes`, `classes` or `styles`.
   * @param item Consumable item or array of items.
   */
  _consume(e, t) {
    const n = Fn(t) ? t : [t], r = this._consumables[e];
    for (const s of n)
      if (e === "attributes" && (s === "class" || s === "style")) {
        const o = s == "class" ? "classes" : "styles";
        this._consume(o, [...this._consumables[o].keys()]);
      } else if (r.set(s, !1), e == "styles")
        for (const o of this.element.document.stylesProcessor.getRelatedStyles(s))
          r.set(o, !1);
  }
  /**
   * Helper method that reverts items of a given type: attribute, class or style.
   *
   * @param type Type of the consumable item: `attributes`, `classes` or , `styles`.
   * @param item Consumable item or array of items.
   */
  _revert(e, t) {
    const n = Fn(t) ? t : [t], r = this._consumables[e];
    for (const s of n)
      if (e === "attributes" && (s === "class" || s === "style")) {
        const o = s == "class" ? "classes" : "styles";
        this._revert(o, [...this._consumables[o].keys()]);
      } else
        r.get(s) === !1 && r.set(s, !0);
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class a8 extends Nt() {
  /**
   * Creates a schema instance.
   */
  constructor() {
    super(), this._sourceDefinitions = {}, this._attributeProperties = {}, this.decorate("checkChild"), this.decorate("checkAttribute"), this.on("checkAttribute", (e, t) => {
      t[0] = new Ds(t[0]);
    }, { priority: "highest" }), this.on("checkChild", (e, t) => {
      t[0] = new Ds(t[0]), t[1] = this.getDefinition(t[1]);
    }, { priority: "highest" });
  }
  /**
   * Registers a schema item. Can only be called once for every item name.
   *
   * ```ts
   * schema.register( 'paragraph', {
   * 	inheritAllFrom: '$block'
   * } );
   * ```
   */
  register(e, t) {
    if (this._sourceDefinitions[e])
      throw new B("schema-cannot-register-item-twice", this, {
        itemName: e
      });
    this._sourceDefinitions[e] = [
      Object.assign({}, t)
    ], this._clearCache();
  }
  /**
   * Extends a {@link #register registered} item's definition.
   *
   * Extending properties such as `allowIn` will add more items to the existing properties,
   * while redefining properties such as `isBlock` will override the previously defined ones.
   *
   * ```ts
   * schema.register( 'foo', {
   * 	allowIn: '$root',
   * 	isBlock: true;
   * } );
   * schema.extend( 'foo', {
   * 	allowIn: 'blockQuote',
   * 	isBlock: false
   * } );
   *
   * schema.getDefinition( 'foo' );
   * //	{
   * //		allowIn: [ '$root', 'blockQuote' ],
   * // 		isBlock: false
   * //	}
   * ```
   */
  extend(e, t) {
    if (!this._sourceDefinitions[e])
      throw new B("schema-cannot-extend-missing-item", this, {
        itemName: e
      });
    this._sourceDefinitions[e].push(Object.assign({}, t)), this._clearCache();
  }
  /**
   * Returns data of all registered items.
   *
   * This method should normally be used for reflection purposes (e.g. defining a clone of a certain element,
   * checking a list of all block elements, etc).
   * Use specific methods (such as {@link #checkChild `checkChild()`} or {@link #isLimit `isLimit()`})
   * in other cases.
   */
  getDefinitions() {
    return this._compiledDefinitions || this._compile(), this._compiledDefinitions;
  }
  /**
   * Returns a definition of the given item or `undefined` if an item is not registered.
   *
   * This method should normally be used for reflection purposes (e.g. defining a clone of a certain element,
   * checking a list of all block elements, etc).
   * Use specific methods (such as {@link #checkChild `checkChild()`} or {@link #isLimit `isLimit()`})
   * in other cases.
   */
  getDefinition(e) {
    let t;
    return typeof e == "string" ? t = e : "is" in e && (e.is("$text") || e.is("$textProxy")) ? t = "$text" : t = e.name, this.getDefinitions()[t];
  }
  /**
   * Returns `true` if the given item is registered in the schema.
   *
   * ```ts
   * schema.isRegistered( 'paragraph' ); // -> true
   * schema.isRegistered( editor.model.document.getRoot() ); // -> true
   * schema.isRegistered( 'foo' ); // -> false
   * ```
   */
  isRegistered(e) {
    return !!this.getDefinition(e);
  }
  /**
   * Returns `true` if the given item is defined to be
   * a block by the {@link module:engine/model/schema~SchemaItemDefinition}'s `isBlock` property.
   *
   * ```ts
   * schema.isBlock( 'paragraph' ); // -> true
   * schema.isBlock( '$root' ); // -> false
   *
   * const paragraphElement = writer.createElement( 'paragraph' );
   * schema.isBlock( paragraphElement ); // -> true
   * ```
   *
   * See the {@glink framework/deep-dive/schema#block-elements Block elements} section of
   * the {@glink framework/deep-dive/schema Schema deep-dive} guide for more details.
   */
  isBlock(e) {
    const t = this.getDefinition(e);
    return !!(t && t.isBlock);
  }
  /**
   * Returns `true` if the given item should be treated as a limit element.
   *
   * It considers an item to be a limit element if its
   * {@link module:engine/model/schema~SchemaItemDefinition}'s
   * {@link module:engine/model/schema~SchemaItemDefinition#isLimit `isLimit`} or
   * {@link module:engine/model/schema~SchemaItemDefinition#isObject `isObject`} property
   * was set to `true`.
   *
   * ```ts
   * schema.isLimit( 'paragraph' ); // -> false
   * schema.isLimit( '$root' ); // -> true
   * schema.isLimit( editor.model.document.getRoot() ); // -> true
   * schema.isLimit( 'imageBlock' ); // -> true
   * ```
   *
   * See the {@glink framework/deep-dive/schema#limit-elements Limit elements} section of
   * the {@glink framework/deep-dive/schema Schema deep-dive} guide for more details.
   */
  isLimit(e) {
    const t = this.getDefinition(e);
    return t ? !!(t.isLimit || t.isObject) : !1;
  }
  /**
   * Returns `true` if the given item should be treated as an object element.
   *
   * It considers an item to be an object element if its
   * {@link module:engine/model/schema~SchemaItemDefinition}'s
   * {@link module:engine/model/schema~SchemaItemDefinition#isObject `isObject`} property
   * was set to `true`.
   *
   * ```ts
   * schema.isObject( 'paragraph' ); // -> false
   * schema.isObject( 'imageBlock' ); // -> true
   *
   * const imageElement = writer.createElement( 'imageBlock' );
   * schema.isObject( imageElement ); // -> true
   * ```
   *
   * See the {@glink framework/deep-dive/schema#object-elements Object elements} section of
   * the {@glink framework/deep-dive/schema Schema deep-dive} guide for more details.
   */
  isObject(e) {
    const t = this.getDefinition(e);
    return t ? !!(t.isObject || t.isLimit && t.isSelectable && t.isContent) : !1;
  }
  /**
   * Returns `true` if the given item is defined to be
   * an inline element by the {@link module:engine/model/schema~SchemaItemDefinition}'s `isInline` property.
   *
   * ```ts
   * schema.isInline( 'paragraph' ); // -> false
   * schema.isInline( 'softBreak' ); // -> true
   *
   * const text = writer.createText( 'foo' );
   * schema.isInline( text ); // -> true
   * ```
   *
   * See the {@glink framework/deep-dive/schema#inline-elements Inline elements} section of
   * the {@glink framework/deep-dive/schema Schema deep-dive} guide for more details.
   */
  isInline(e) {
    const t = this.getDefinition(e);
    return !!(t && t.isInline);
  }
  /**
   * Returns `true` if the given item is defined to be
   * a selectable element by the {@link module:engine/model/schema~SchemaItemDefinition}'s `isSelectable` property.
   *
   * ```ts
   * schema.isSelectable( 'paragraph' ); // -> false
   * schema.isSelectable( 'heading1' ); // -> false
   * schema.isSelectable( 'imageBlock' ); // -> true
   * schema.isSelectable( 'tableCell' ); // -> true
   *
   * const text = writer.createText( 'foo' );
   * schema.isSelectable( text ); // -> false
   * ```
   *
   * See the {@glink framework/deep-dive/schema#selectable-elements Selectable elements section} of
   * the {@glink framework/deep-dive/schema Schema deep-dive} guide for more details.
   */
  isSelectable(e) {
    const t = this.getDefinition(e);
    return t ? !!(t.isSelectable || t.isObject) : !1;
  }
  /**
   * Returns `true` if the given item is defined to be
   * a content by the {@link module:engine/model/schema~SchemaItemDefinition}'s `isContent` property.
   *
   * ```ts
   * schema.isContent( 'paragraph' ); // -> false
   * schema.isContent( 'heading1' ); // -> false
   * schema.isContent( 'imageBlock' ); // -> true
   * schema.isContent( 'horizontalLine' ); // -> true
   *
   * const text = writer.createText( 'foo' );
   * schema.isContent( text ); // -> true
   * ```
   *
   * See the {@glink framework/deep-dive/schema#content-elements Content elements section} of
   * the {@glink framework/deep-dive/schema Schema deep-dive} guide for more details.
   */
  isContent(e) {
    const t = this.getDefinition(e);
    return t ? !!(t.isContent || t.isObject) : !1;
  }
  /**
   * Checks whether the given node (`child`) can be a child of the given context.
   *
   * ```ts
   * schema.checkChild( model.document.getRoot(), paragraph ); // -> false
   *
   * schema.register( 'paragraph', {
   * 	allowIn: '$root'
   * } );
   * schema.checkChild( model.document.getRoot(), paragraph ); // -> true
   * ```
   *
   * Note: When verifying whether the given node can be a child of the given context, the
   * schema also verifies the entire context &mdash; from its root to its last element. Therefore, it is possible
   * for `checkChild()` to return `false` even though the context's last element can contain the checked child.
   * It happens if one of the context's elements does not allow its child.
   *
   * @fires checkChild
   * @param context The context in which the child will be checked.
   * @param def The child to check.
   */
  checkChild(e, t) {
    return t ? this._checkContextMatch(t, e) : !1;
  }
  /**
   * Checks whether the given attribute can be applied in the given context (on the last
   * item of the context).
   *
   * ```ts
   * schema.checkAttribute( textNode, 'bold' ); // -> false
   *
   * schema.extend( '$text', {
   * 	allowAttributes: 'bold'
   * } );
   * schema.checkAttribute( textNode, 'bold' ); // -> true
   * ```
   *
   * @fires checkAttribute
   * @param context The context in which the attribute will be checked.
   */
  checkAttribute(e, t) {
    const n = this.getDefinition(e.last);
    return n ? n.allowAttributes.includes(t) : !1;
  }
  /**
   * Checks whether the given element (`elementToMerge`) can be merged with the specified base element (`positionOrBaseElement`).
   *
   * In other words &mdash; whether `elementToMerge`'s children {@link #checkChild are allowed} in the `positionOrBaseElement`.
   *
   * This check ensures that elements merged with {@link module:engine/model/writer~Writer#merge `Writer#merge()`}
   * will be valid.
   *
   * Instead of elements, you can pass the instance of the {@link module:engine/model/position~Position} class as the
   * `positionOrBaseElement`. It means that the elements before and after the position will be checked whether they can be merged.
   *
   * @param positionOrBaseElement The position or base element to which the `elementToMerge` will be merged.
   * @param elementToMerge The element to merge. Required if `positionOrBaseElement` is an element.
   */
  checkMerge(e, t) {
    if (e instanceof oe) {
      const n = e.nodeBefore, r = e.nodeAfter;
      if (!(n instanceof gt))
        throw new B("schema-check-merge-no-element-before", this);
      if (!(r instanceof gt))
        throw new B("schema-check-merge-no-element-after", this);
      return this.checkMerge(n, r);
    }
    for (const n of t.getChildren())
      if (!this.checkChild(e, n))
        return !1;
    return !0;
  }
  /**
   * Allows registering a callback to the {@link #checkChild} method calls.
   *
   * Callbacks allow you to implement rules which are not otherwise possible to achieve
   * by using the declarative API of {@link module:engine/model/schema~SchemaItemDefinition}.
   * For example, by using this method you can disallow elements in specific contexts.
   *
   * This method is a shorthand for using the {@link #event:checkChild} event. For even better control,
   * you can use that event instead.
   *
   * Example:
   *
   * ```ts
   * // Disallow heading1 directly inside a blockQuote.
   * schema.addChildCheck( ( context, childDefinition ) => {
   * 	if ( context.endsWith( 'blockQuote' ) && childDefinition.name == 'heading1' ) {
   * 		return false;
   * 	}
   * } );
   * ```
   *
   * Which translates to:
   *
   * ```ts
   * schema.on( 'checkChild', ( evt, args ) => {
   * 	const context = args[ 0 ];
   * 	const childDefinition = args[ 1 ];
   *
   * 	if ( context.endsWith( 'blockQuote' ) && childDefinition && childDefinition.name == 'heading1' ) {
   * 		// Prevent next listeners from being called.
   * 		evt.stop();
   * 		// Set the checkChild()'s return value.
   * 		evt.return = false;
   * 	}
   * }, { priority: 'high' } );
   * ```
   *
   * @param callback The callback to be called. It is called with two parameters:
   * {@link module:engine/model/schema~SchemaContext} (context) instance and
   * {@link module:engine/model/schema~SchemaCompiledItemDefinition} (child-to-check definition).
   * The callback may return `true/false` to override `checkChild()`'s return value. If it does not return
   * a boolean value, the default algorithm (or other callbacks) will define `checkChild()`'s return value.
   */
  addChildCheck(e) {
    this.on("checkChild", (t, [n, r]) => {
      if (!r)
        return;
      const s = e(n, r);
      typeof s == "boolean" && (t.stop(), t.return = s);
    }, { priority: "high" });
  }
  /**
   * Allows registering a callback to the {@link #checkAttribute} method calls.
   *
   * Callbacks allow you to implement rules which are not otherwise possible to achieve
   * by using the declarative API of {@link module:engine/model/schema~SchemaItemDefinition}.
   * For example, by using this method you can disallow attribute if node to which it is applied
   * is contained within some other element (e.g. you want to disallow `bold` on `$text` within `heading1`).
   *
   * This method is a shorthand for using the {@link #event:checkAttribute} event. For even better control,
   * you can use that event instead.
   *
   * Example:
   *
   * ```ts
   * // Disallow bold on $text inside heading1.
   * schema.addAttributeCheck( ( context, attributeName ) => {
   * 	if ( context.endsWith( 'heading1 $text' ) && attributeName == 'bold' ) {
   * 		return false;
   * 	}
   * } );
   * ```
   *
   * Which translates to:
   *
   * ```ts
   * schema.on( 'checkAttribute', ( evt, args ) => {
   * 	const context = args[ 0 ];
   * 	const attributeName = args[ 1 ];
   *
   * 	if ( context.endsWith( 'heading1 $text' ) && attributeName == 'bold' ) {
   * 		// Prevent next listeners from being called.
   * 		evt.stop();
   * 		// Set the checkAttribute()'s return value.
   * 		evt.return = false;
   * 	}
   * }, { priority: 'high' } );
   * ```
   *
   * @param callback The callback to be called. It is called with two parameters:
   * {@link module:engine/model/schema~SchemaContext} (context) instance and attribute name.
   * The callback may return `true/false` to override `checkAttribute()`'s return value. If it does not return
   * a boolean value, the default algorithm (or other callbacks) will define `checkAttribute()`'s return value.
   */
  addAttributeCheck(e) {
    this.on("checkAttribute", (t, [n, r]) => {
      const s = e(n, r);
      typeof s == "boolean" && (t.stop(), t.return = s);
    }, { priority: "high" });
  }
  /**
   * This method allows assigning additional metadata to the model attributes. For example,
   * {@link module:engine/model/schema~AttributeProperties `AttributeProperties#isFormatting` property} is
   * used to mark formatting attributes (like `bold` or `italic`).
   *
   * ```ts
   * // Mark bold as a formatting attribute.
   * schema.setAttributeProperties( 'bold', {
   * 	isFormatting: true
   * } );
   *
   * // Override code not to be considered a formatting markup.
   * schema.setAttributeProperties( 'code', {
   * 	isFormatting: false
   * } );
   * ```
   *
   * Properties are not limited to members defined in the
   * {@link module:engine/model/schema~AttributeProperties `AttributeProperties` type} and you can also use custom properties:
   *
   * ```ts
   * schema.setAttributeProperties( 'blockQuote', {
   * 	customProperty: 'value'
   * } );
   * ```
   *
   * Subsequent calls with the same attribute will extend its custom properties:
   *
   * ```ts
   * schema.setAttributeProperties( 'blockQuote', {
   * 	one: 1
   * } );
   *
   * schema.setAttributeProperties( 'blockQuote', {
   * 	two: 2
   * } );
   *
   * console.log( schema.getAttributeProperties( 'blockQuote' ) );
   * // Logs: { one: 1, two: 2 }
   * ```
   *
   * @param attributeName A name of the attribute to receive the properties.
   * @param properties A dictionary of properties.
   */
  setAttributeProperties(e, t) {
    this._attributeProperties[e] = Object.assign(this.getAttributeProperties(e), t);
  }
  /**
   * Returns properties associated with a given model attribute. See {@link #setAttributeProperties `setAttributeProperties()`}.
   *
   * @param attributeName A name of the attribute.
   */
  getAttributeProperties(e) {
    return this._attributeProperties[e] || {};
  }
  /**
   * Returns the lowest {@link module:engine/model/schema~Schema#isLimit limit element} containing the entire
   * selection/range/position or the root otherwise.
   *
   * @param selectionOrRangeOrPosition The selection/range/position to check.
   * @returns The lowest limit element containing the entire `selectionOrRangeOrPosition`.
   */
  getLimitElement(e) {
    let t;
    for (e instanceof oe ? t = e.parent : t = (e instanceof X ? [e] : Array.from(e.getRanges())).reduce((r, s) => {
      const o = s.getCommonAncestor();
      return r ? r.getCommonAncestor(o, { includeSelf: !0 }) : o;
    }, null); !this.isLimit(t) && t.parent; )
      t = t.parent;
    return t;
  }
  /**
   * Checks whether the attribute is allowed in selection:
   *
   * * if the selection is not collapsed, then checks if the attribute is allowed on any of nodes in that range,
   * * if the selection is collapsed, then checks if on the selection position there's a text with the
   * specified attribute allowed.
   *
   * @param selection Selection which will be checked.
   * @param attribute The name of the attribute to check.
   */
  checkAttributeInSelection(e, t) {
    if (e.isCollapsed) {
      const r = [
        ...e.getFirstPosition().getAncestors(),
        new Dt("", e.getAttributes())
      ];
      return this.checkAttribute(r, t);
    } else {
      const n = e.getRanges();
      for (const r of n)
        for (const s of r)
          if (this.checkAttribute(s.item, t))
            return !0;
    }
    return !1;
  }
  /**
   * Transforms the given set of ranges into a set of ranges where the given attribute is allowed (and can be applied).
   *
   * @param ranges Ranges to be validated.
   * @param attribute The name of the attribute to check.
   * @returns Ranges in which the attribute is allowed.
   */
  *getValidRanges(e, t) {
    e = C8(e);
    for (const n of e)
      yield* this._getValidRangesForRange(n, t);
  }
  /**
   * Basing on given `position`, finds and returns a {@link module:engine/model/range~Range range} which is
   * nearest to that `position` and is a correct range for selection.
   *
   * The correct selection range might be collapsed when it is located in a position where the text node can be placed.
   * Non-collapsed range is returned when selection can be placed around element marked as an "object" in
   * the {@link module:engine/model/schema~Schema schema}.
   *
   * Direction of searching for the nearest correct selection range can be specified as:
   *
   * * `both` - searching will be performed in both ways,
   * * `forward` - searching will be performed only forward,
   * * `backward` - searching will be performed only backward.
   *
   * When valid selection range cannot be found, `null` is returned.
   *
   * @param position Reference position where new selection range should be looked for.
   * @param direction Search direction.
   * @returns Nearest selection range or `null` if one cannot be found.
   */
  getNearestSelectionRange(e, t = "both") {
    if (this.checkChild(e, "$text"))
      return new X(e);
    let n, r;
    const s = e.getAncestors().reverse().find((o) => this.isLimit(o)) || e.root;
    (t == "both" || t == "backward") && (n = new ir({
      boundaries: X._createIn(s),
      startPosition: e,
      direction: "backward"
    })), (t == "both" || t == "forward") && (r = new ir({
      boundaries: X._createIn(s),
      startPosition: e
    }));
    for (const o of E8(n, r)) {
      const l = o.walker == n ? "elementEnd" : "elementStart", u = o.value;
      if (u.type == l && this.isObject(u.item))
        return X._createOn(u.item);
      if (this.checkChild(u.nextPosition, "$text"))
        return new X(u.nextPosition);
    }
    return null;
  }
  /**
   * Tries to find position ancestors that allow to insert a given node.
   * It starts searching from the given position and goes node by node to the top of the model tree
   * as long as a {@link module:engine/model/schema~Schema#isLimit limit element}, an
   * {@link module:engine/model/schema~Schema#isObject object element} or a topmost ancestor is not reached.
   *
   * @param position The position that the search will start from.
   * @param node The node for which an allowed parent should be found or its name.
   * @returns Allowed parent or null if nothing was found.
   */
  findAllowedParent(e, t) {
    let n = e.parent;
    for (; n; ) {
      if (this.checkChild(n, t))
        return n;
      if (this.isLimit(n))
        return null;
      n = n.parent;
    }
    return null;
  }
  /**
   * Sets attributes allowed by the schema on a given node.
   *
   * @param node A node to set attributes on.
   * @param attributes Attributes keys and values.
   * @param writer An instance of the model writer.
   */
  setAllowedAttributes(e, t, n) {
    const r = n.model;
    for (const [s, o] of Object.entries(t))
      r.schema.checkAttribute(e, s) && n.setAttribute(s, o, e);
  }
  /**
   * Removes attributes disallowed by the schema.
   *
   * @param nodes Nodes that will be filtered.
   */
  removeDisallowedAttributes(e, t) {
    for (const n of e)
      if (n.is("$text"))
        fb(this, n, t);
      else {
        const s = X._createIn(n).getPositions();
        for (const o of s) {
          const l = o.nodeBefore || o.parent;
          fb(this, l, t);
        }
      }
  }
  /**
   * Gets attributes of a node that have a given property.
   *
   * @param node Node to get attributes from.
   * @param propertyName Name of the property that attribute must have to return it.
   * @param propertyValue Desired value of the property that we want to check.
   * When `undefined` attributes will be returned if they have set a given property no matter what the value is. If specified it will
   * return attributes which given property's value is equal to this parameter.
   * @returns Object with attributes' names as key and attributes' values as value.
   */
  getAttributesWithProperty(e, t, n) {
    const r = {};
    for (const [s, o] of e.getAttributes()) {
      const l = this.getAttributeProperties(s);
      l[t] !== void 0 && (n === void 0 || n === l[t]) && (r[s] = o);
    }
    return r;
  }
  /**
   * Creates an instance of the schema context.
   */
  createContext(e) {
    return new Ds(e);
  }
  _clearCache() {
    this._compiledDefinitions = null;
  }
  _compile() {
    const e = {}, t = this._sourceDefinitions, n = Object.keys(t);
    for (const r of n)
      e[r] = l8(t[r], r);
    for (const r of n)
      c8(e, r);
    for (const r of n)
      u8(e, r);
    for (const r of n)
      d8(e, r);
    for (const r of n)
      h8(e, r), f8(e, r);
    for (const r of n)
      m8(e, r), g8(e, r), p8(e, r);
    this._compiledDefinitions = e;
  }
  _checkContextMatch(e, t, n = t.length - 1) {
    const r = t.getItem(n);
    if (e.allowIn.includes(r.name)) {
      if (n == 0)
        return !0;
      {
        const s = this.getDefinition(r);
        return this._checkContextMatch(s, t, n - 1);
      }
    } else
      return !1;
  }
  /**
   * Takes a flat range and an attribute name. Traverses the range recursively and deeply to find and return all ranges
   * inside the given range on which the attribute can be applied.
   *
   * This is a helper function for {@link ~Schema#getValidRanges}.
   *
   * @param range The range to process.
   * @param attribute The name of the attribute to check.
   * @returns Ranges in which the attribute is allowed.
   */
  *_getValidRangesForRange(e, t) {
    let n = e.start, r = e.start;
    for (const s of e.getItems({ shallow: !0 }))
      s.is("element") && (yield* this._getValidRangesForRange(X._createIn(s), t)), this.checkAttribute(s, t) || (n.isEqual(r) || (yield new X(n, r)), n = oe._createAfter(s)), r = oe._createAfter(s);
    n.isEqual(r) || (yield new X(n, r));
  }
}
class Ds {
  /**
   * Creates an instance of the context.
   */
  constructor(e) {
    if (e instanceof Ds)
      return e;
    let t;
    typeof e == "string" ? t = [e] : Array.isArray(e) ? t = e : t = e.getAncestors({ includeSelf: !0 }), this._items = t.map(y8);
  }
  /**
   * The number of items.
   */
  get length() {
    return this._items.length;
  }
  /**
   * The last item (the lowest node).
   */
  get last() {
    return this._items[this._items.length - 1];
  }
  /**
   * Iterable interface.
   *
   * Iterates over all context items.
   */
  [Symbol.iterator]() {
    return this._items[Symbol.iterator]();
  }
  /**
   * Returns a new schema context instance with an additional item.
   *
   * Item can be added as:
   *
   * ```ts
   * const context = new SchemaContext( [ '$root' ] );
   *
   * // An element.
   * const fooElement = writer.createElement( 'fooElement' );
   * const newContext = context.push( fooElement ); // [ '$root', 'fooElement' ]
   *
   * // A text node.
   * const text = writer.createText( 'foobar' );
   * const newContext = context.push( text ); // [ '$root', '$text' ]
   *
   * // A string (element name).
   * const newContext = context.push( 'barElement' ); // [ '$root', 'barElement' ]
   * ```
   *
   * **Note** {@link module:engine/model/node~Node} that is already in the model tree will be added as the only item
   * (without ancestors).
   *
   * @param item An item that will be added to the current context.
   * @returns A new schema context instance with an additional item.
   */
  push(e) {
    const t = new Ds([e]);
    return t._items = [...this._items, ...t._items], t;
  }
  /**
   * Gets an item on the given index.
   */
  getItem(e) {
    return this._items[e];
  }
  /**
   * Returns the names of items.
   */
  *getNames() {
    yield* this._items.map((e) => e.name);
  }
  /**
   * Checks whether the context ends with the given nodes.
   *
   * ```ts
   * const ctx = new SchemaContext( [ rootElement, paragraphElement, textNode ] );
   *
   * ctx.endsWith( '$text' ); // -> true
   * ctx.endsWith( 'paragraph $text' ); // -> true
   * ctx.endsWith( '$root' ); // -> false
   * ctx.endsWith( 'paragraph' ); // -> false
   * ```
   */
  endsWith(e) {
    return Array.from(this.getNames()).join(" ").endsWith(e);
  }
  /**
   * Checks whether the context starts with the given nodes.
   *
   * ```ts
   * const ctx = new SchemaContext( [ rootElement, paragraphElement, textNode ] );
   *
   * ctx.endsWith( '$root' ); // -> true
   * ctx.endsWith( '$root paragraph' ); // -> true
   * ctx.endsWith( '$text' ); // -> false
   * ctx.endsWith( 'paragraph' ); // -> false
   * ```
   */
  startsWith(e) {
    return Array.from(this.getNames()).join(" ").startsWith(e);
  }
}
function l8(i, e) {
  const t = {
    name: e,
    allowIn: [],
    allowContentOf: [],
    allowWhere: [],
    allowAttributes: [],
    allowAttributesOf: [],
    allowChildren: [],
    inheritTypesFrom: []
  };
  return _8(i, t), Ts(i, t, "allowIn"), Ts(i, t, "allowContentOf"), Ts(i, t, "allowWhere"), Ts(i, t, "allowAttributes"), Ts(i, t, "allowAttributesOf"), Ts(i, t, "allowChildren"), Ts(i, t, "inheritTypesFrom"), v8(i, t), t;
}
function c8(i, e) {
  const t = i[e];
  for (const n of t.allowChildren) {
    const r = i[n];
    r && r.allowIn.push(e);
  }
  t.allowChildren.length = 0;
}
function u8(i, e) {
  for (const t of i[e].allowContentOf)
    i[t] && w8(i, t).forEach((r) => {
      r.allowIn.push(e);
    });
  delete i[e].allowContentOf;
}
function d8(i, e) {
  for (const t of i[e].allowWhere) {
    const n = i[t];
    if (n) {
      const r = n.allowIn;
      i[e].allowIn.push(...r);
    }
  }
  delete i[e].allowWhere;
}
function h8(i, e) {
  for (const t of i[e].allowAttributesOf) {
    const n = i[t];
    if (n) {
      const r = n.allowAttributes;
      i[e].allowAttributes.push(...r);
    }
  }
  delete i[e].allowAttributesOf;
}
function f8(i, e) {
  const t = i[e];
  for (const n of t.inheritTypesFrom) {
    const r = i[n];
    if (r) {
      const s = Object.keys(r).filter((o) => o.startsWith("is"));
      for (const o of s)
        o in t || (t[o] = r[o]);
    }
  }
  delete t.inheritTypesFrom;
}
function m8(i, e) {
  const t = i[e], n = t.allowIn.filter((r) => i[r]);
  t.allowIn = Array.from(new Set(n));
}
function g8(i, e) {
  const t = i[e];
  for (const n of t.allowIn)
    i[n].allowChildren.push(e);
}
function p8(i, e) {
  const t = i[e];
  t.allowAttributes = Array.from(new Set(t.allowAttributes));
}
function _8(i, e) {
  for (const t of i) {
    const n = Object.keys(t).filter((r) => r.startsWith("is"));
    for (const r of n)
      e[r] = !!t[r];
  }
}
function Ts(i, e, t) {
  for (const n of i) {
    const r = n[t];
    typeof r == "string" ? e[t].push(r) : Array.isArray(r) && e[t].push(...r);
  }
}
function v8(i, e) {
  for (const t of i) {
    const n = t.inheritAllFrom;
    n && (e.allowContentOf.push(n), e.allowWhere.push(n), e.allowAttributesOf.push(n), e.inheritTypesFrom.push(n));
  }
}
function w8(i, e) {
  const t = i[e];
  return b8(i).filter((n) => n.allowIn.includes(t.name));
}
function b8(i) {
  return Object.keys(i).map((e) => i[e]);
}
function y8(i) {
  return typeof i == "string" || i.is("documentFragment") ? {
    name: typeof i == "string" ? i : "$documentFragment",
    *getAttributeKeys() {
    },
    getAttribute() {
    }
  } : {
    // '$text' means text nodes and text proxies.
    name: i.is("element") ? i.name : "$text",
    *getAttributeKeys() {
      yield* i.getAttributeKeys();
    },
    getAttribute(e) {
      return i.getAttribute(e);
    }
  };
}
function* E8(i, e) {
  let t = !1;
  for (; !t; ) {
    if (t = !0, i) {
      const n = i.next();
      n.done || (t = !1, yield {
        walker: i,
        value: n.value
      });
    }
    if (e) {
      const n = e.next();
      n.done || (t = !1, yield {
        walker: e,
        value: n.value
      });
    }
  }
}
function* C8(i) {
  for (const e of i)
    yield* e.getMinimalFlatRanges();
}
function fb(i, e, t) {
  for (const n of e.getAttributeKeys())
    i.checkAttribute(e, n) || t.removeAttribute(n, e);
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class S8 extends kt() {
  /**
   * Creates an upcast dispatcher that operates using the passed API.
   *
   * @see module:engine/conversion/upcastdispatcher~UpcastConversionApi
   * @param conversionApi Additional properties for an interface that will be passed to events fired
   * by the upcast dispatcher.
   */
  constructor(e) {
    super(), this._splitParts = /* @__PURE__ */ new Map(), this._cursorParents = /* @__PURE__ */ new Map(), this._modelCursor = null, this._emptyElementsToKeep = /* @__PURE__ */ new Set(), this.conversionApi = {
      ...e,
      consumable: null,
      writer: null,
      store: null,
      convertItem: (t, n) => this._convertItem(t, n),
      convertChildren: (t, n) => this._convertChildren(t, n),
      safeInsert: (t, n) => this._safeInsert(t, n),
      updateConversionResult: (t, n) => this._updateConversionResult(t, n),
      // Advanced API - use only if custom position handling is needed.
      splitToAllowedParent: (t, n) => this._splitToAllowedParent(t, n),
      getSplitParts: (t) => this._getSplitParts(t),
      keepEmptyElement: (t) => this._keepEmptyElement(t)
    };
  }
  /**
   * Starts the conversion process. The entry point for the conversion.
   *
   * @fires element
   * @fires text
   * @fires documentFragment
   * @param viewElement The part of the view to be converted.
   * @param writer An instance of the model writer.
   * @param context Elements will be converted according to this context.
   * @returns Model data that is the result of the conversion process
   * wrapped in `DocumentFragment`. Converted marker elements will be set as the document fragment's
   * {@link module:engine/model/documentfragment~DocumentFragment#markers static markers map}.
   */
  convert(e, t, n = ["$root"]) {
    this.fire("viewCleanup", e), this._modelCursor = x8(n, t), this.conversionApi.writer = t, this.conversionApi.consumable = fl.createFrom(e), this.conversionApi.store = {};
    const { modelRange: r } = this._convertItem(e, this._modelCursor), s = t.createDocumentFragment();
    if (r) {
      this._removeEmptyElements();
      for (const o of Array.from(this._modelCursor.parent.getChildren()))
        t.append(o, s);
      s.markers = T8(s, t);
    }
    return this._modelCursor = null, this._splitParts.clear(), this._cursorParents.clear(), this._emptyElementsToKeep.clear(), this.conversionApi.writer = null, this.conversionApi.store = null, s;
  }
  /**
   * @see module:engine/conversion/upcastdispatcher~UpcastConversionApi#convertItem
   */
  _convertItem(e, t) {
    const n = { viewItem: e, modelCursor: t, modelRange: null };
    if (e.is("element") ? this.fire(`element:${e.name}`, n, this.conversionApi) : e.is("$text") ? this.fire("text", n, this.conversionApi) : this.fire("documentFragment", n, this.conversionApi), n.modelRange && !(n.modelRange instanceof X))
      throw new B("view-conversion-dispatcher-incorrect-result", this);
    return { modelRange: n.modelRange, modelCursor: n.modelCursor };
  }
  /**
   * @see module:engine/conversion/upcastdispatcher~UpcastConversionApi#convertChildren
   */
  _convertChildren(e, t) {
    let n = t.is("position") ? t : oe._createAt(t, 0);
    const r = new X(n);
    for (const s of Array.from(e.getChildren())) {
      const o = this._convertItem(s, n);
      o.modelRange instanceof X && (r.end = o.modelRange.end, n = o.modelCursor);
    }
    return { modelRange: r, modelCursor: n };
  }
  /**
   * @see module:engine/conversion/upcastdispatcher~UpcastConversionApi#safeInsert
   */
  _safeInsert(e, t) {
    const n = this._splitToAllowedParent(e, t);
    return n ? (this.conversionApi.writer.insert(e, n.position), !0) : !1;
  }
  /**
   * @see module:engine/conversion/upcastdispatcher~UpcastConversionApi#updateConversionResult
   */
  _updateConversionResult(e, t) {
    const n = this._getSplitParts(e), r = this.conversionApi.writer;
    t.modelRange || (t.modelRange = r.createRange(r.createPositionBefore(e), r.createPositionAfter(n[n.length - 1])));
    const s = this._cursorParents.get(e);
    s ? t.modelCursor = r.createPositionAt(s, 0) : t.modelCursor = t.modelRange.end;
  }
  /**
   * @see module:engine/conversion/upcastdispatcher~UpcastConversionApi#splitToAllowedParent
   */
  _splitToAllowedParent(e, t) {
    const { schema: n, writer: r } = this.conversionApi;
    let s = n.findAllowedParent(t, e);
    if (s) {
      if (s === t.parent)
        return { position: t };
      this._modelCursor.parent.getAncestors().includes(s) && (s = null);
    }
    if (!s)
      return aC(t, e, n) ? {
        position: lC(t, r)
      } : null;
    const o = this.conversionApi.writer.split(t, s), l = [];
    for (const h of o.range.getWalker())
      if (h.type == "elementEnd")
        l.push(h.item);
      else {
        const f = l.pop(), m = h.item;
        this._registerSplitPair(f, m);
      }
    const u = o.range.end.parent;
    return this._cursorParents.set(e, u), {
      position: o.position,
      cursorParent: u
    };
  }
  /**
   * Registers that a `splitPart` element is a split part of the `originalPart` element.
   *
   * The data set by this method is used by {@link #_getSplitParts} and {@link #_removeEmptyElements}.
   */
  _registerSplitPair(e, t) {
    this._splitParts.has(e) || this._splitParts.set(e, [e]);
    const n = this._splitParts.get(e);
    this._splitParts.set(t, n), n.push(t);
  }
  /**
   * @see module:engine/conversion/upcastdispatcher~UpcastConversionApi#getSplitParts
   */
  _getSplitParts(e) {
    let t;
    return this._splitParts.has(e) ? t = this._splitParts.get(e) : t = [e], t;
  }
  /**
   * Mark an element that were created during the splitting to not get removed on conversion end even if it is empty.
   */
  _keepEmptyElement(e) {
    this._emptyElementsToKeep.add(e);
  }
  /**
   * Checks if there are any empty elements created while splitting and removes them.
   *
   * This method works recursively to re-check empty elements again after at least one element was removed in the initial call,
   * as some elements might have become empty after other empty elements were removed from them.
   */
  _removeEmptyElements() {
    let e = !1;
    for (const t of this._splitParts.keys())
      t.isEmpty && !this._emptyElementsToKeep.has(t) && (this.conversionApi.writer.remove(t), this._splitParts.delete(t), e = !0);
    e && this._removeEmptyElements();
  }
}
function T8(i, e) {
  const t = /* @__PURE__ */ new Set(), n = /* @__PURE__ */ new Map(), r = X._createIn(i).getItems();
  for (const s of r)
    s.is("element", "$marker") && t.add(s);
  for (const s of t) {
    const o = s.getAttribute("data-name"), l = e.createPositionBefore(s);
    n.has(o) ? n.get(o).end = l.clone() : n.set(o, new X(l.clone())), e.remove(s);
  }
  return n;
}
function x8(i, e) {
  let t;
  for (const n of new Ds(i)) {
    const r = {};
    for (const o of n.getAttributeKeys())
      r[o] = n.getAttribute(o);
    const s = e.createElement(n.name, r);
    t && e.insert(s, t), t = oe._createAt(s, 0);
  }
  return t;
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class k8 {
  /**
   * Returns an HTML string created from the document fragment.
   */
  getHtml(e) {
    const n = document.implementation.createHTMLDocument("").createElement("div");
    return n.appendChild(e), n.innerHTML;
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class A8 {
  /**
   * Creates a new instance of the HTML data processor class.
   *
   * @param document The view document instance.
   */
  constructor(e) {
    this.skipComments = !0, this.domParser = new DOMParser(), this.domConverter = new WE(e, { renderingMode: "data" }), this.htmlWriter = new k8();
  }
  /**
   * Converts a provided {@link module:engine/view/documentfragment~DocumentFragment document fragment}
   * to data format &mdash; in this case to an HTML string.
   *
   * @returns HTML string.
   */
  toData(e) {
    const t = this.domConverter.viewToDom(e);
    return this.htmlWriter.getHtml(t);
  }
  /**
   * Converts the provided HTML string to a view tree.
   *
   * @param data An HTML string.
   * @returns A converted view element.
   */
  toView(e) {
    const t = this._toDom(e);
    return this.domConverter.domToView(t, { skipComments: this.skipComments });
  }
  /**
   * Registers a {@link module:engine/view/matcher~MatcherPattern} for view elements whose content should be treated as raw data
   * and not processed during the conversion from the DOM to the view elements.
   *
   * The raw data can be later accessed by a
   * {@link module:engine/view/element~Element#getCustomProperty custom property of a view element} called `"$rawContent"`.
   *
   * @param pattern Pattern matching all view elements whose content should be treated as raw data.
   */
  registerRawContentMatcher(e) {
    this.domConverter.registerRawContentMatcher(e);
  }
  /**
   * If the processor is set to use marked fillers, it will insert `&nbsp;` fillers wrapped in `<span>` elements
   * (`<span data-cke-filler="true">&nbsp;</span>`) instead of regular `&nbsp;` characters.
   *
   * This mode allows for a more precise handling of the block fillers (so they do not leak into the editor content) but
   * bloats the editor data with additional markup.
   *
   * This mode may be required by some features and will be turned on by them automatically.
   *
   * @param type Whether to use the default or the marked `&nbsp;` block fillers.
   */
  useFillerType(e) {
    this.domConverter.blockFillerMode = e == "marked" ? "markedNbsp" : "nbsp";
  }
  /**
   * Converts an HTML string to its DOM representation. Returns a document fragment containing nodes parsed from
   * the provided data.
   */
  _toDom(e) {
    e.match(/<(?:html|body|head|meta)(?:\s[^>]*)?>/i) || (e = `<body>${e}</body>`);
    const t = this.domParser.parseFromString(e, "text/html"), n = t.createDocumentFragment(), r = t.body.childNodes;
    for (; r.length > 0; )
      n.appendChild(r[0]);
    return n;
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class P8 extends kt() {
  /**
   * Creates a data controller instance.
   *
   * @param model Data model.
   * @param stylesProcessor The styles processor instance.
   */
  constructor(e, t) {
    super(), this.model = e, this.mapper = new GE(), this.downcastDispatcher = new YE({
      mapper: this.mapper,
      schema: e.schema
    }), this.downcastDispatcher.on("insert:$text", ZE(), { priority: "lowest" }), this.downcastDispatcher.on("insert", QE(), { priority: "lowest" }), this.upcastDispatcher = new S8({
      schema: e.schema
    }), this.viewDocument = new DE(t), this.stylesProcessor = t, this.htmlProcessor = new A8(this.viewDocument), this.processor = this.htmlProcessor, this._viewWriter = new VE(this.viewDocument), this.upcastDispatcher.on("text", $L(), { priority: "lowest" }), this.upcastDispatcher.on("element", cb(), { priority: "lowest" }), this.upcastDispatcher.on("documentFragment", cb(), { priority: "lowest" }), Nt().prototype.decorate.call(this, "init"), Nt().prototype.decorate.call(this, "set"), Nt().prototype.decorate.call(this, "get"), Nt().prototype.decorate.call(this, "toView"), Nt().prototype.decorate.call(this, "toModel"), this.on("init", () => {
      this.fire("ready");
    }, { priority: "lowest" }), this.on("ready", () => {
      this.model.enqueueChange({ isUndoable: !1 }, oC);
    }, { priority: "lowest" });
  }
  /**
   * Returns the model's data converted by downcast dispatchers attached to {@link #downcastDispatcher} and
   * formatted by the {@link #processor data processor}.
   *
   * A warning is logged when you try to retrieve data for a detached root, as most probably this is a mistake. A detached root should
   * be treated like it is removed, and you should not save its data. Note, that the detached root data is always an empty string.
   *
   * @fires get
   * @param options Additional configuration for the retrieved data. `DataController` provides two optional
   * properties: `rootName` and `trim`. Other properties of this object are specified by various editor features.
   * @param options.rootName Root name. Default 'main'.
   * @param options.trim Whether returned data should be trimmed. This option is set to `empty` by default,
   * which means whenever editor content is considered empty, an empty string will be returned. To turn off trimming completely
   * use `'none'`. In such cases the exact content will be returned (for example a `<p>&nbsp;</p>` for an empty editor).
   * @returns Output data.
   */
  get(e = {}) {
    const { rootName: t = "main", trim: n = "empty" } = e;
    if (!this._checkIfRootsExists([t]))
      throw new B("datacontroller-get-non-existent-root", this);
    const r = this.model.document.getRoot(t);
    return r.isAttached() || Yt("datacontroller-get-detached-root", this), n === "empty" && !this.model.hasContent(r, { ignoreWhitespaces: !0 }) ? "" : this.stringify(r, e);
  }
  /**
   * Returns the content of the given {@link module:engine/model/element~Element model's element} or
   * {@link module:engine/model/documentfragment~DocumentFragment model document fragment} converted by the downcast converters
   * attached to the {@link #downcastDispatcher} and formatted by the {@link #processor data processor}.
   *
   * @param modelElementOrFragment The element whose content will be stringified.
   * @param options Additional configuration passed to the conversion process.
   * @returns Output data.
   */
  stringify(e, t = {}) {
    const n = this.toView(e, t);
    return this.processor.toData(n);
  }
  /**
   * Returns the content of the given {@link module:engine/model/element~Element model element} or
   * {@link module:engine/model/documentfragment~DocumentFragment model document fragment} converted by the downcast
   * converters attached to {@link #downcastDispatcher} into a
   * {@link module:engine/view/documentfragment~DocumentFragment view document fragment}.
   *
   * @fires toView
   * @param modelElementOrFragment Element or document fragment whose content will be converted.
   * @param options Additional configuration that will be available through the
   * {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi#options} during the conversion process.
   * @returns Output view DocumentFragment.
   */
  toView(e, t = {}) {
    const n = this.viewDocument, r = this._viewWriter;
    this.mapper.clearBindings();
    const s = X._createIn(e), o = new Ns(n);
    this.mapper.bindElements(e, o);
    const l = e.is("documentFragment") ? e.markers : I8(e);
    return this.downcastDispatcher.convert(s, l, r, t), o;
  }
  /**
   * Sets the initial input data parsed by the {@link #processor data processor} and
   * converted by the {@link #upcastDispatcher view-to-model converters}.
   * Initial data can be only set to a document whose {@link module:engine/model/document~Document#version} is equal 0.
   *
   * **Note** This method is {@link module:utils/observablemixin~Observable#decorate decorated} which is
   * used by e.g. collaborative editing plugin that syncs remote data on init.
   *
   * When data is passed as a string, it is initialized on the default `main` root:
   *
   * ```ts
   * dataController.init( '<p>Foo</p>' ); // Initializes data on the `main` root only, as no other is specified.
   * ```
   *
   * To initialize data on a different root or multiple roots at once, an object containing `rootName` - `data` pairs should be passed:
   *
   * ```ts
   * dataController.init( { main: '<p>Foo</p>', title: '<h1>Bar</h1>' } ); // Initializes data on both the `main` and `title` roots.
   * ```
   *
   * @fires init
   * @param data Input data as a string or an object containing the `rootName` - `data`
   * pairs to initialize data on multiple roots at once.
   * @returns Promise that is resolved after the data is set on the editor.
   */
  init(e) {
    if (this.model.document.version)
      throw new B("datacontroller-init-document-not-empty", this);
    let t = {};
    if (typeof e == "string" ? t.main = e : t = e, !this._checkIfRootsExists(Object.keys(t)))
      throw new B("datacontroller-init-non-existent-root", this);
    return this.model.enqueueChange({ isUndoable: !1 }, (n) => {
      for (const r of Object.keys(t)) {
        const s = this.model.document.getRoot(r);
        n.insert(this.parse(t[r], s), s, 0);
      }
    }), Promise.resolve();
  }
  /**
   * Sets the input data parsed by the {@link #processor data processor} and
   * converted by the {@link #upcastDispatcher view-to-model converters}.
   * This method can be used any time to replace existing editor data with the new one without clearing the
   * {@link module:engine/model/document~Document#history document history}.
   *
   * This method also creates a batch with all the changes applied. If all you need is to parse data, use
   * the {@link #parse} method.
   *
   * When data is passed as a string it is set on the default `main` root:
   *
   * ```ts
   * dataController.set( '<p>Foo</p>' ); // Sets data on the `main` root, as no other is specified.
   * ```
   *
   * To set data on a different root or multiple roots at once, an object containing `rootName` - `data` pairs should be passed:
   *
   * ```ts
   * dataController.set( { main: '<p>Foo</p>', title: '<h1>Bar</h1>' } ); // Sets data on the `main` and `title` roots as specified.
   * ```
   *
   * To set the data with a preserved undo stack and add the change to the undo stack, set `{ isUndoable: true }` as a `batchType` option.
   *
   * ```ts
   * dataController.set( '<p>Foo</p>', { batchType: { isUndoable: true } } );
   * ```
   *
   * @fires set
   * @param data Input data as a string or an object containing the `rootName` - `data`
   * pairs to set data on multiple roots at once.
   * @param options Options for setting data.
   * @param options.batchType The batch type that will be used to create a batch for the changes applied by this method.
   * By default, the batch will be set as {@link module:engine/model/batch~Batch#isUndoable not undoable} and the undo stack will be
   * cleared after the new data is applied (all undo steps will be removed). If the batch type `isUndoable` flag is be set to `true`,
   * the undo stack will be preserved instead and not cleared when new data is applied.
   */
  set(e, t = {}) {
    let n = {};
    if (typeof e == "string" ? n.main = e : n = e, !this._checkIfRootsExists(Object.keys(n)))
      throw new B("datacontroller-set-non-existent-root", this);
    this.model.enqueueChange(t.batchType || {}, (r) => {
      r.setSelection(null), r.removeSelectionAttribute(this.model.document.selection.getAttributeKeys());
      for (const s of Object.keys(n)) {
        const o = this.model.document.getRoot(s);
        r.remove(r.createRangeIn(o)), r.insert(this.parse(n[s], o), o, 0);
      }
    });
  }
  /**
   * Returns the data parsed by the {@link #processor data processor} and then converted by upcast converters
   * attached to the {@link #upcastDispatcher}.
   *
   * @see #set
   * @param data Data to parse.
   * @param context Base context in which the view will be converted to the model.
   * See: {@link module:engine/conversion/upcastdispatcher~UpcastDispatcher#convert}.
   * @returns Parsed data.
   */
  parse(e, t = "$root") {
    const n = this.processor.toView(e);
    return this.toModel(n, t);
  }
  /**
   * Returns the result of the given {@link module:engine/view/element~Element view element} or
   * {@link module:engine/view/documentfragment~DocumentFragment view document fragment} converted by the
   * {@link #upcastDispatcher view-to-model converters}, wrapped by {@link module:engine/model/documentfragment~DocumentFragment}.
   *
   * When marker elements were converted during the conversion process, it will be set as a document fragment's
   * {@link module:engine/model/documentfragment~DocumentFragment#markers static markers map}.
   *
   * @fires toModel
   * @param viewElementOrFragment The element or document fragment whose content will be converted.
   * @param context Base context in which the view will be converted to the model.
   * See: {@link module:engine/conversion/upcastdispatcher~UpcastDispatcher#convert}.
   * @returns Output document fragment.
   */
  toModel(e, t = "$root") {
    return this.model.change((n) => this.upcastDispatcher.convert(e, n, t));
  }
  /**
   * Adds the style processor normalization rules.
   *
   * You can implement your own rules as well as use one of the available processor rules:
   *
   * * background: {@link module:engine/view/styles/background~addBackgroundRules}
   * * border: {@link module:engine/view/styles/border~addBorderRules}
   * * margin: {@link module:engine/view/styles/margin~addMarginRules}
   * * padding: {@link module:engine/view/styles/padding~addPaddingRules}
   */
  addStyleProcessorRules(e) {
    e(this.stylesProcessor);
  }
  /**
   * Registers a {@link module:engine/view/matcher~MatcherPattern} on an {@link #htmlProcessor htmlProcessor}
   * and a {@link #processor processor} for view elements whose content should be treated as raw data
   * and not processed during the conversion from DOM to view elements.
   *
   * The raw data can be later accessed by the {@link module:engine/view/element~Element#getCustomProperty view element custom property}
   * `"$rawContent"`.
   *
   * @param pattern Pattern matching all view elements whose content should be treated as a raw data.
   */
  registerRawContentMatcher(e) {
    this.processor && this.processor !== this.htmlProcessor && this.processor.registerRawContentMatcher(e), this.htmlProcessor.registerRawContentMatcher(e);
  }
  /**
   * Removes all event listeners set by the DataController.
   */
  destroy() {
    this.stopListening();
  }
  /**
   * Checks whether all provided root names are actually existing editor roots.
   *
   * @param rootNames Root names to check.
   * @returns Whether all provided root names are existing editor roots.
   */
  _checkIfRootsExists(e) {
    for (const t of e)
      if (!this.model.document.getRoot(t))
        return !1;
    return !0;
  }
}
function I8(i) {
  const e = [], t = i.root.document;
  if (!t)
    return /* @__PURE__ */ new Map();
  const n = X._createIn(i);
  for (const r of t.model.markers) {
    const s = r.getRange(), o = s.isCollapsed, l = s.start.isEqual(n.start) || s.end.isEqual(n.end);
    if (o && l)
      e.push([r.name, s]);
    else {
      const u = n.getIntersection(s);
      u && e.push([r.name, u]);
    }
  }
  return e.sort(([r, s], [o, l]) => {
    if (s.end.compareWith(l.start) !== "after")
      return 1;
    if (s.start.compareWith(l.end) !== "before")
      return -1;
    switch (s.start.compareWith(l.start)) {
      case "before":
        return 1;
      case "after":
        return -1;
      default:
        switch (s.end.compareWith(l.end)) {
          case "before":
            return 1;
          case "after":
            return -1;
          default:
            return o.localeCompare(r);
        }
    }
  }), new Map(e);
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class R8 {
  /**
   * Creates a new conversion instance.
   */
  constructor(e, t) {
    this._helpers = /* @__PURE__ */ new Map(), this._downcast = In(e), this._createConversionHelpers({ name: "downcast", dispatchers: this._downcast, isDowncast: !0 }), this._upcast = In(t), this._createConversionHelpers({ name: "upcast", dispatchers: this._upcast, isDowncast: !1 });
  }
  /**
   * Define an alias for registered dispatcher.
   *
   * ```ts
   * const conversion = new Conversion(
   * 	[ dataDowncastDispatcher, editingDowncastDispatcher ],
   * 	upcastDispatcher
   * );
   *
   * conversion.addAlias( 'dataDowncast', dataDowncastDispatcher );
   * ```
   *
   * @param alias An alias of a dispatcher.
   * @param dispatcher Dispatcher which should have an alias.
   */
  addAlias(e, t) {
    const n = this._downcast.includes(t);
    if (!this._upcast.includes(t) && !n)
      throw new B("conversion-add-alias-dispatcher-not-registered", this);
    this._createConversionHelpers({ name: e, dispatchers: [t], isDowncast: n });
  }
  /**
   * Provides a chainable API to assign converters to a conversion dispatchers group.
   *
   * If the given group name has not been registered, the
   * {@link module:utils/ckeditorerror~CKEditorError `conversion-for-unknown-group` error} is thrown.
   *
   * You can use conversion helpers available directly in the `for()` chain or your custom ones via
   * the {@link module:engine/conversion/conversionhelpers~ConversionHelpers#add `add()`} method.
   *
   * # Using built-in conversion helpers
   *
   * The `for()` chain comes with a set of conversion helpers which you can use like this:
   *
   * ```ts
   * editor.conversion.for( 'downcast' )
   * 	.elementToElement( config1 )        // Adds an element-to-element downcast converter.
   * 	.attributeToElement( config2 );     // Adds an attribute-to-element downcast converter.
   *
   * editor.conversion.for( 'upcast' )
   * 	.elementToAttribute( config3 );     // Adds an element-to-attribute upcast converter.
   * ```
   *
   * Refer to the documentation of built-in conversion helpers to learn about their configuration options.
   *
   * * downcast (model-to-view) conversion helpers:
   *
   *	* {@link module:engine/conversion/downcasthelpers~DowncastHelpers#elementToElement `elementToElement()`},
   *	* {@link module:engine/conversion/downcasthelpers~DowncastHelpers#attributeToElement `attributeToElement()`},
   *	* {@link module:engine/conversion/downcasthelpers~DowncastHelpers#attributeToAttribute `attributeToAttribute()`}.
   *	* {@link module:engine/conversion/downcasthelpers~DowncastHelpers#markerToElement `markerToElement()`}.
   *	* {@link module:engine/conversion/downcasthelpers~DowncastHelpers#markerToHighlight `markerToHighlight()`}.
   *
   * * upcast (view-to-model) conversion helpers:
   *
   *	* {@link module:engine/conversion/upcasthelpers~UpcastHelpers#elementToElement `elementToElement()`},
   *	* {@link module:engine/conversion/upcasthelpers~UpcastHelpers#elementToAttribute `elementToAttribute()`},
   *	* {@link module:engine/conversion/upcasthelpers~UpcastHelpers#attributeToAttribute `attributeToAttribute()`}.
   *	* {@link module:engine/conversion/upcasthelpers~UpcastHelpers#elementToMarker `elementToMarker()`}.
   *
   * # Using custom conversion helpers
   *
   * If you need to implement an atypical converter, you can do so by calling:
   *
   * ```ts
   * editor.conversion.for( direction ).add( customHelper );
   * ```
   *
   * The `.add()` method takes exactly one parameter, which is a function. This function should accept one parameter that
   * is a dispatcher instance. The function should add an actual converter to the passed dispatcher instance.
   *
   * Example:
   *
   * ```ts
   * editor.conversion.for( 'upcast' ).add( dispatcher => {
   * 	dispatcher.on( 'element:a',  ( evt, data, conversionApi ) => {
   * 		// Do something with a view <a> element.
   * 	} );
   * } );
   * ```
   *
   * Refer to the documentation of {@link module:engine/conversion/upcastdispatcher~UpcastDispatcher}
   * and {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher} to learn how to write
   * custom converters.
   *
   * @param groupName The name of dispatchers group to add the converters to.
   */
  for(e) {
    if (!this._helpers.has(e))
      throw new B("conversion-for-unknown-group", this);
    return this._helpers.get(e);
  }
  /**
   * Sets up converters between the model and the view that convert a model element to a view element (and vice versa).
   * For example, the model `<paragraph>Foo</paragraph>` is turned into `<p>Foo</p>` in the view.
   *
   * ```ts
   * // A simple conversion from the `paragraph` model element to the `<p>` view element (and vice versa).
   * editor.conversion.elementToElement( { model: 'paragraph', view: 'p' } );
   *
   * // Override other converters by specifying a converter definition with a higher priority.
   * editor.conversion.elementToElement( { model: 'paragraph', view: 'div', converterPriority: 'high' } );
   *
   * // View specified as an object instead of a string.
   * editor.conversion.elementToElement( {
   * 	model: 'fancyParagraph',
   * 	view: {
   * 		name: 'p',
   * 		classes: 'fancy'
   * 	}
   * } );
   *
   * // Use `upcastAlso` to define other view elements that should also be converted to a `paragraph` element.
   * editor.conversion.elementToElement( {
   * 	model: 'paragraph',
   * 	view: 'p',
   * 	upcastAlso: [
   * 		'div',
   * 		{
   * 			// Any element with the `display: block` style.
   * 			styles: {
   * 				display: 'block'
   * 			}
   * 		}
   * 	]
   * } );
   *
   * // `upcastAlso` set as callback enables a conversion of a wide range of different view elements.
   * editor.conversion.elementToElement( {
   * 	model: 'heading',
   * 	view: 'h2',
   * 	// Convert "heading-like" paragraphs to headings.
   * 	upcastAlso: viewElement => {
   * 		const fontSize = viewElement.getStyle( 'font-size' );
   *
   * 		if ( !fontSize ) {
   * 			return null;
   * 		}
   *
   * 		const match = fontSize.match( /(\d+)\s*px/ );
   *
   * 		if ( !match ) {
   * 			return null;
   * 		}
   *
   * 		const size = Number( match[ 1 ] );
   *
   * 		if ( size > 26 ) {
   * 			// Returned value can be an object with the matched properties.
   * 			// These properties will be "consumed" during the conversion.
   * 			// See `engine.view.Matcher~MatcherPattern` and `engine.view.Matcher#match` for more details.
   *
   * 			return { name: true, styles: [ 'font-size' ] };
   * 		}
   *
   * 		return null;
   * 	}
   * } );
   * ```
   *
   * `definition.model` is a `String` with a model element name to convert from or to.
   *
   * @param definition The converter definition.
   */
  elementToElement(e) {
    this.for("downcast").elementToElement(e);
    for (const { model: t, view: n } of Cm(e))
      this.for("upcast").elementToElement({
        model: t,
        view: n,
        converterPriority: e.converterPriority
      });
  }
  /**
   * Sets up converters between the model and the view that convert a model attribute to a view element (and vice versa).
   * For example, a model text node with `"Foo"` as data and the `bold` attribute will be turned to `<strong>Foo</strong>` in the view.
   *
   * ```ts
   * // A simple conversion from the `bold=true` attribute to the `<strong>` view element (and vice versa).
   * editor.conversion.attributeToElement( { model: 'bold', view: 'strong' } );
   *
   * // Override other converters by specifying a converter definition with a higher priority.
   * editor.conversion.attributeToElement( { model: 'bold', view: 'b', converterPriority: 'high' } );
   *
   * // View specified as an object instead of a string.
   * editor.conversion.attributeToElement( {
   * 	model: 'bold',
   * 	view: {
   * 		name: 'span',
   * 		classes: 'bold'
   * 	}
   * } );
   *
   * // Use `config.model.name` to define the conversion only from a given node type, `$text` in this case.
   * // The same attribute on different elements may then be handled by a different converter.
   * editor.conversion.attributeToElement( {
   * 	model: {
   * 		key: 'textDecoration',
   * 		values: [ 'underline', 'lineThrough' ],
   * 		name: '$text'
   * 	},
   * 	view: {
   * 		underline: {
   * 			name: 'span',
   * 			styles: {
   * 				'text-decoration': 'underline'
   * 			}
   * 		},
   * 		lineThrough: {
   * 			name: 'span',
   * 			styles: {
   * 				'text-decoration': 'line-through'
   * 			}
   * 		}
   * 	}
   * } );
   *
   * // Use `upcastAlso` to define other view elements that should also be converted to the `bold` attribute.
   * editor.conversion.attributeToElement( {
   * 	model: 'bold',
   * 	view: 'strong',
   * 	upcastAlso: [
   * 		'b',
   * 		{
   * 			name: 'span',
   * 			classes: 'bold'
   * 		},
   * 		{
   * 			name: 'span',
   * 			styles: {
   * 				'font-weight': 'bold'
   * 			}
   * 		},
   * 		viewElement => {
   * 			const fontWeight = viewElement.getStyle( 'font-weight' );
   *
   * 			if ( viewElement.is( 'element', 'span' ) && fontWeight && /\d+/.test() && Number( fontWeight ) > 500 ) {
   * 				// Returned value can be an object with the matched properties.
   * 				// These properties will be "consumed" during the conversion.
   * 				// See `engine.view.Matcher~MatcherPattern` and `engine.view.Matcher#match` for more details.
   *
   * 				return {
   * 					name: true,
   * 					styles: [ 'font-weight' ]
   * 				};
   * 			}
   * 		}
   * 	]
   * } );
   *
   * // Conversion from and to a model attribute key whose value is an enum (`fontSize=big|small`).
   * // `upcastAlso` set as callback enables a conversion of a wide range of different view elements.
   * editor.conversion.attributeToElement( {
   * 	model: {
   * 		key: 'fontSize',
   * 		values: [ 'big', 'small' ]
   * 	},
   * 	view: {
   * 		big: {
   * 			name: 'span',
   * 			styles: {
   * 				'font-size': '1.2em'
   * 			}
   * 		},
   * 		small: {
   * 			name: 'span',
   * 			styles: {
   * 				'font-size': '0.8em'
   * 			}
   * 		}
   * 	},
   * 	upcastAlso: {
   * 		big: viewElement => {
   * 			const fontSize = viewElement.getStyle( 'font-size' );
   *
   * 			if ( !fontSize ) {
   * 				return null;
   * 			}
   *
   * 			const match = fontSize.match( /(\d+)\s*px/ );
   *
   * 			if ( !match ) {
   * 				return null;
   * 			}
   *
   * 			const size = Number( match[ 1 ] );
   *
   * 			if ( viewElement.is( 'element', 'span' ) && size > 10 ) {
   * 				// Returned value can be an object with the matched properties.
   * 				// These properties will be "consumed" during the conversion.
   * 				// See `engine.view.Matcher~MatcherPattern` and `engine.view.Matcher#match` for more details.
   *
   * 				return { name: true, styles: [ 'font-size' ] };
   * 			}
   *
   * 			return null;
   * 		},
   * 		small: viewElement => {
   * 			const fontSize = viewElement.getStyle( 'font-size' );
   *
   * 			if ( !fontSize ) {
   * 				return null;
   * 			}
   *
   * 			const match = fontSize.match( /(\d+)\s*px/ );
   *
   * 			if ( !match ) {
   * 				return null;
   * 			}
   *
   * 			const size = Number( match[ 1 ] );
   *
   * 			if ( viewElement.is( 'element', 'span' ) && size < 10 ) {
   * 				// Returned value can be an object with the matched properties.
   * 				// These properties will be "consumed" during the conversion.
   * 				// See `engine.view.Matcher~MatcherPattern` and `engine.view.Matcher#match` for more details.
   *
   * 				return { name: true, styles: [ 'font-size' ] };
   * 			}
   *
   * 			return null;
   * 		}
   * 	}
   * } );
   * ```
   *
   * The `definition.model` parameter specifies which model attribute should be converted from or to. It can be a `{ key, value }` object
   * describing the attribute key and value to convert or a `String` specifying just the attribute key (in such a case
   * `value` is set to `true`).
   *
   * @param definition The converter definition.
   */
  attributeToElement(e) {
    this.for("downcast").attributeToElement(e);
    for (const { model: t, view: n } of Cm(e))
      this.for("upcast").elementToAttribute({
        view: n,
        model: t,
        converterPriority: e.converterPriority
      });
  }
  /**
   * Sets up converters between the model and the view that convert a model attribute to a view attribute (and vice versa). For example,
   * `<imageBlock src='foo.jpg'></imageBlock>` is converted to `<img src='foo.jpg'></img>` (the same attribute key and value).
   * This type of converters is intended to be used with {@link module:engine/model/element~Element model element} nodes.
   * To convert the text attributes,
   * the {@link module:engine/conversion/conversion~Conversion#attributeToElement `attributeToElement converter`}should be set up.
   *
   * ```ts
   * // A simple conversion from the `source` model attribute to the `src` view attribute (and vice versa).
   * editor.conversion.attributeToAttribute( { model: 'source', view: 'src' } );
   *
   * // Attribute values are strictly specified.
   * editor.conversion.attributeToAttribute( {
   * 	model: {
   * 		name: 'imageInline',
   * 		key: 'aside',
   * 		values: [ 'aside' ]
   * 	},
   * 	view: {
   * 		aside: {
   * 			name: 'img',
   * 			key: 'class',
   * 			value: [ 'aside', 'half-size' ]
   * 		}
   * 	}
   * } );
   *
   * // Set the style attribute.
   * editor.conversion.attributeToAttribute( {
   * 	model: {
   * 		name: 'imageInline',
   * 		key: 'aside',
   * 		values: [ 'aside' ]
   * 	},
   * 	view: {
   * 		aside: {
   * 			name: 'img',
   * 			key: 'style',
   * 			value: {
   * 				float: 'right',
   * 				width: '50%',
   * 				margin: '5px'
   * 			}
   * 		}
   * 	}
   * } );
   *
   * // Conversion from and to a model attribute key whose value is an enum (`align=right|center`).
   * // Use `upcastAlso` to define other view elements that should also be converted to the `align=right` attribute.
   * editor.conversion.attributeToAttribute( {
   * 	model: {
   * 		key: 'align',
   * 		values: [ 'right', 'center' ]
   * 	},
   * 	view: {
   * 		right: {
   * 			key: 'class',
   * 			value: 'align-right'
   * 		},
   * 		center: {
   * 			key: 'class',
   * 			value: 'align-center'
   * 		}
   * 	},
   * 	upcastAlso: {
   * 		right: {
   * 			styles: {
   * 				'text-align': 'right'
   * 			}
   * 		},
   * 		center: {
   * 			styles: {
   * 				'text-align': 'center'
   * 			}
   * 		}
   * 	}
   * } );
   * ```
   *
   * The `definition.model` parameter specifies which model attribute should be converted from and to.
   * It can be a `{ key, [ values ], [ name ] }` object or a `String`, which will be treated like `{ key: definition.model }`.
   * The `key` property is the model attribute key to convert from and to.
   * The `values` are the possible model attribute values. If the `values` parameter is not set, the model attribute value
   * will be the same as the view attribute value.
   * If `name` is set, the conversion will be set up only for model elements with the given name.
   *
   * The `definition.view` parameter specifies which view attribute should be converted from and to.
   * It can be a `{ key, value, [ name ] }` object or a `String`, which will be treated like `{ key: definition.view }`.
   * The `key` property is the view attribute key to convert from and to.
   * The `value` is the view attribute value to convert from and to. If `definition.value` is not set, the view attribute value will be
   * the same as the model attribute value.
   * If `key` is `'class'`, `value` can be a `String` or an array of `String`s.
   * If `key` is `'style'`, `value` is an object with key-value pairs.
   * In other cases, `value` is a `String`.
   * If `name` is set, the conversion will be set up only for model elements with the given name.
   * If `definition.model.values` is set, `definition.view` is an object that assigns values from `definition.model.values`
   * to `{ key, value, [ name ] }` objects.
   *
   * `definition.upcastAlso` specifies which other matching view elements should also be upcast to the given model configuration.
   * If `definition.model.values` is set, `definition.upcastAlso` should be an object assigning values from `definition.model.values`
   * to {@link module:engine/view/matcher~MatcherPattern}s or arrays of {@link module:engine/view/matcher~MatcherPattern}s.
   *
   * **Note:** `definition.model` and `definition.view` form should be mirrored, so the same types of parameters should
   * be given in both parameters.
   *
   * @param definition The converter definition.
   * @param definition.model The model attribute to convert from and to.
   * @param definition.view The view attribute to convert from and to.
   * @param definition.upcastAlso Any view element matching `definition.upcastAlso` will also be converted to the given model attribute.
   * `definition.upcastAlso` is used only if `config.model.values` is specified.
   */
  attributeToAttribute(e) {
    this.for("downcast").attributeToAttribute(e);
    for (const { model: t, view: n } of Cm(e))
      this.for("upcast").attributeToAttribute({
        view: n,
        model: t
      });
  }
  /**
   * Creates and caches conversion helpers for given dispatchers group.
   *
   * @param options.name Group name.
   */
  _createConversionHelpers({ name: e, dispatchers: t, isDowncast: n }) {
    if (this._helpers.has(e))
      throw new B("conversion-group-exists", this);
    const r = n ? new aL(t) : new FL(t);
    this._helpers.set(e, r);
  }
}
function* Cm(i) {
  if (i.model.values)
    for (const e of i.model.values) {
      const t = { key: i.model.key, value: e }, n = i.view[e], r = i.upcastAlso ? i.upcastAlso[e] : void 0;
      yield* mb(t, n, r);
    }
  else
    yield* mb(i.model, i.view, i.upcastAlso);
}
function* mb(i, e, t) {
  if (yield { model: i, view: e }, t)
    for (const n of In(t))
      yield { model: i, view: n };
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class fi {
  /**
   * Base operation constructor.
   *
   * @param baseVersion Document {@link module:engine/model/document~Document#version} on which operation
   * can be applied or `null` if the operation operates on detached (non-document) tree.
   */
  constructor(e) {
    this.baseVersion = e, this.isDocumentOperation = this.baseVersion !== null, this.batch = null;
  }
  /**
   * Checks whether the operation's parameters are correct and the operation can be correctly executed. Throws
   * an error if operation is not valid.
   *
   * @internal
   */
  _validate() {
  }
  /**
   * Custom toJSON method to solve child-parent circular dependencies.
   *
   * @returns Clone of this object with the operation property replaced with string.
   */
  toJSON() {
    const e = Object.assign({}, this);
    return e.__className = this.constructor.className, delete e.batch, delete e.isDocumentOperation, e;
  }
  /**
   * Name of the operation class used for serialization.
   */
  static get className() {
    return "Operation";
  }
  /**
   * Creates `Operation` object from deserialized object, i.e. from parsed JSON string.
   *
   * @param json Deserialized JSON object.
   * @param doc Document on which this operation will be applied.
   */
  static fromJSON(e, t) {
    return new this(e.baseVersion);
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function fp(i, e) {
  const t = mC(e), n = t.reduce((o, l) => o + l.offsetSize, 0), r = i.parent;
  xl(i);
  const s = i.index;
  return r._insertChild(s, t), Tl(r, s + t.length), Tl(r, s), new X(i, i.getShiftedBy(n));
}
function fC(i) {
  if (!i.isFlat)
    throw new B("operation-utils-remove-range-not-flat", this);
  const e = i.start.parent;
  xl(i.start), xl(i.end);
  const t = e._removeChildren(i.start.index, i.end.index - i.start.index);
  return Tl(e, i.start.index), t;
}
function Sl(i, e) {
  if (!i.isFlat)
    throw new B("operation-utils-move-range-not-flat", this);
  const t = fC(i);
  return e = e._getTransformedByDeletion(i.start, i.end.offset - i.start.offset), fp(e, t);
}
function O8(i, e, t) {
  xl(i.start), xl(i.end);
  for (const n of i.getItems({ shallow: !0 })) {
    const r = n.is("$textProxy") ? n.textNode : n;
    t !== null ? r._setAttribute(e, t) : r._removeAttribute(e), Tl(r.parent, r.index);
  }
  Tl(i.end.parent, i.end.index);
}
function mC(i) {
  const e = [];
  function t(n) {
    if (typeof n == "string")
      e.push(new Dt(n));
    else if (n instanceof Bi)
      e.push(new Dt(n.data, n.getAttributes()));
    else if (n instanceof Ks)
      e.push(n);
    else if (di(n))
      for (const r of n)
        t(r);
  }
  t(i);
  for (let n = 1; n < e.length; n++) {
    const r = e[n], s = e[n - 1];
    r instanceof Dt && s instanceof Dt && gC(r, s) && (e.splice(n - 1, 2, new Dt(s.data + r.data, s.getAttributes())), n--);
  }
  return e;
}
function Tl(i, e) {
  const t = i.getChild(e - 1), n = i.getChild(e);
  if (t && n && t.is("$text") && n.is("$text") && gC(t, n)) {
    const r = new Dt(t.data + n.data, t.getAttributes());
    i._removeChildren(e - 1, 2), i._insertChild(e - 1, r);
  }
}
function xl(i) {
  const e = i.textNode, t = i.parent;
  if (e) {
    const n = i.offset - e.startOffset, r = e.index;
    t._removeChildren(r, 1);
    const s = new Dt(e.data.substr(0, n), e.getAttributes()), o = new Dt(e.data.substr(n), e.getAttributes());
    t._insertChild(r, [s, o]);
  }
}
function gC(i, e) {
  const t = i.getAttributes(), n = e.getAttributes();
  for (const r of t) {
    if (r[1] !== e.getAttribute(r[0]))
      return !1;
    n.next();
  }
  return n.next().done;
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class it extends fi {
  /**
   * Creates a move operation.
   *
   * @param sourcePosition Position before the first {@link module:engine/model/item~Item model item} to move.
   * @param howMany Offset size of moved range. Moved range will start from `sourcePosition` and end at
   * `sourcePosition` with offset shifted by `howMany`.
   * @param targetPosition Position at which moved nodes will be inserted.
   * @param baseVersion Document {@link module:engine/model/document~Document#version} on which operation
   * can be applied or `null` if the operation operates on detached (non-document) tree.
   */
  constructor(e, t, n, r) {
    super(r), this.sourcePosition = e.clone(), this.sourcePosition.stickiness = "toNext", this.howMany = t, this.targetPosition = n.clone(), this.targetPosition.stickiness = "toNone";
  }
  /**
   * @inheritDoc
   */
  get type() {
    return this.targetPosition.root.rootName == "$graveyard" ? "remove" : this.sourcePosition.root.rootName == "$graveyard" ? "reinsert" : "move";
  }
  /**
   * Creates and returns an operation that has the same parameters as this operation.
   */
  clone() {
    return new it(this.sourcePosition, this.howMany, this.targetPosition, this.baseVersion);
  }
  /**
   * Returns the start position of the moved range after it got moved. This may be different than
   * {@link module:engine/model/operation/moveoperation~MoveOperation#targetPosition} in some cases, i.e. when a range is moved
   * inside the same parent but {@link module:engine/model/operation/moveoperation~MoveOperation#targetPosition targetPosition}
   * is after {@link module:engine/model/operation/moveoperation~MoveOperation#sourcePosition sourcePosition}.
   *
   * ```
   *  vv              vv
   * abcdefg ===> adefbcg
   *      ^          ^
   *      targetPos  movedRangeStart
   *      offset 6   offset 4
   *```
   */
  getMovedRangeStart() {
    return this.targetPosition._getTransformedByDeletion(this.sourcePosition, this.howMany);
  }
  /**
   * See {@link module:engine/model/operation/operation~Operation#getReversed `Operation#getReversed()`}.
   */
  getReversed() {
    const e = this.sourcePosition._getTransformedByInsertion(this.targetPosition, this.howMany);
    return new it(this.getMovedRangeStart(), this.howMany, e, this.baseVersion + 1);
  }
  /**
   * @inheritDoc
   * @internal
   */
  _validate() {
    const e = this.sourcePosition.parent, t = this.targetPosition.parent, n = this.sourcePosition.offset, r = this.targetPosition.offset;
    if (n + this.howMany > e.maxOffset)
      throw new B("move-operation-nodes-do-not-exist", this);
    if (e === t && n < r && r < n + this.howMany)
      throw new B("move-operation-range-into-itself", this);
    if (this.sourcePosition.root == this.targetPosition.root && Pn(this.sourcePosition.getParentPath(), this.targetPosition.getParentPath()) == "prefix") {
      const s = this.sourcePosition.path.length - 1;
      if (this.targetPosition.path[s] >= n && this.targetPosition.path[s] < n + this.howMany)
        throw new B("move-operation-node-into-itself", this);
    }
  }
  /**
   * @inheritDoc
   * @internal
   */
  _execute() {
    Sl(X._createFromPositionAndShift(this.sourcePosition, this.howMany), this.targetPosition);
  }
  /**
   * @inheritDoc
   */
  toJSON() {
    const e = super.toJSON();
    return e.sourcePosition = this.sourcePosition.toJSON(), e.targetPosition = this.targetPosition.toJSON(), e;
  }
  /**
   * @inheritDoc
   */
  static get className() {
    return "MoveOperation";
  }
  /**
   * Creates `MoveOperation` object from deserialized object, i.e. from parsed JSON string.
   *
   * @param json Deserialized JSON object.
   * @param document Document on which this operation will be applied.
   */
  static fromJSON(e, t) {
    const n = oe.fromJSON(e.sourcePosition, t), r = oe.fromJSON(e.targetPosition, t);
    return new this(n, e.howMany, r, e.baseVersion);
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class pn extends fi {
  /**
   * Creates an insert operation.
   *
   * @param position Position of insertion.
   * @param nodes The list of nodes to be inserted.
   * @param baseVersion Document {@link module:engine/model/document~Document#version} on which operation
   * can be applied or `null` if the operation operates on detached (non-document) tree.
   */
  constructor(e, t, n) {
    super(n), this.position = e.clone(), this.position.stickiness = "toNone", this.nodes = new dl(mC(t)), this.shouldReceiveAttributes = !1;
  }
  /**
   * @inheritDoc
   */
  get type() {
    return "insert";
  }
  /**
   * Total offset size of inserted nodes.
   */
  get howMany() {
    return this.nodes.maxOffset;
  }
  /**
   * Creates and returns an operation that has the same parameters as this operation.
   */
  clone() {
    const e = new dl([...this.nodes].map((n) => n._clone(!0))), t = new pn(this.position, e, this.baseVersion);
    return t.shouldReceiveAttributes = this.shouldReceiveAttributes, t;
  }
  /**
   * See {@link module:engine/model/operation/operation~Operation#getReversed `Operation#getReversed()`}.
   */
  getReversed() {
    const e = this.position.root.document.graveyard, t = new oe(e, [0]);
    return new it(this.position, this.nodes.maxOffset, t, this.baseVersion + 1);
  }
  /**
   * @inheritDoc
   * @internal
   */
  _validate() {
    const e = this.position.parent;
    if (!e || e.maxOffset < this.position.offset)
      throw new B("insert-operation-position-invalid", this);
  }
  /**
   * @inheritDoc
   * @internal
   */
  _execute() {
    const e = this.nodes;
    this.nodes = new dl([...e].map((t) => t._clone(!0))), fp(this.position, e);
  }
  /**
   * @inheritDoc
   */
  toJSON() {
    const e = super.toJSON();
    return e.position = this.position.toJSON(), e.nodes = this.nodes.toJSON(), e;
  }
  /**
   * @inheritDoc
   */
  static get className() {
    return "InsertOperation";
  }
  /**
   * Creates `InsertOperation` object from deserialized object, i.e. from parsed JSON string.
   *
   * @param json Deserialized JSON object.
   * @param document Document on which this operation will be applied.
   */
  static fromJSON(e, t) {
    const n = [];
    for (const s of e.nodes)
      s.name ? n.push(gt.fromJSON(s)) : n.push(Dt.fromJSON(s));
    const r = new pn(oe.fromJSON(e.position, t), n, e.baseVersion);
    return r.shouldReceiveAttributes = e.shouldReceiveAttributes, r;
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class bt extends fi {
  /**
   * Creates a split operation.
   *
   * @param splitPosition Position at which an element should be split.
   * @param howMany Total offset size of elements that are in the split element after `position`.
   * @param insertionPosition Position at which the clone of split element (or element from graveyard) will be inserted.
   * @param graveyardPosition Position in the graveyard root before the element which
   * should be used as a parent of the nodes after `position`. If it is not set, a copy of the the `position` parent will be used.
   * @param baseVersion Document {@link module:engine/model/document~Document#version} on which operation
   * can be applied or `null` if the operation operates on detached (non-document) tree.
   */
  constructor(e, t, n, r, s) {
    super(s), this.splitPosition = e.clone(), this.splitPosition.stickiness = "toNext", this.howMany = t, this.insertionPosition = n, this.graveyardPosition = r ? r.clone() : null, this.graveyardPosition && (this.graveyardPosition.stickiness = "toNext");
  }
  /**
   * @inheritDoc
   */
  get type() {
    return "split";
  }
  /**
   * Position inside the new clone of a split element.
   *
   * This is a position where nodes that are after the split position will be moved to.
   */
  get moveTargetPosition() {
    const e = this.insertionPosition.path.slice();
    return e.push(0), new oe(this.insertionPosition.root, e);
  }
  /**
   * Artificial range that contains all the nodes from the split element that will be moved to the new element.
   * The range starts at {@link #splitPosition} and ends in the same parent, at `POSITIVE_INFINITY` offset.
   */
  get movedRange() {
    const e = this.splitPosition.getShiftedBy(Number.POSITIVE_INFINITY);
    return new X(this.splitPosition, e);
  }
  /**
   * Creates and returns an operation that has the same parameters as this operation.
   *
   * @returns Clone of this operation.
   */
  clone() {
    return new bt(this.splitPosition, this.howMany, this.insertionPosition, this.graveyardPosition, this.baseVersion);
  }
  /**
   * See {@link module:engine/model/operation/operation~Operation#getReversed `Operation#getReversed()`}.
   */
  getReversed() {
    const e = this.splitPosition.root.document.graveyard, t = new oe(e, [0]);
    return new Kt(this.moveTargetPosition, this.howMany, this.splitPosition, t, this.baseVersion + 1);
  }
  /**
   * @inheritDoc
   * @internal
   */
  _validate() {
    const e = this.splitPosition.parent, t = this.splitPosition.offset;
    if (!e || e.maxOffset < t)
      throw new B("split-operation-position-invalid", this);
    if (e.parent) {
      if (this.howMany != e.maxOffset - this.splitPosition.offset)
        throw new B("split-operation-how-many-invalid", this);
      if (this.graveyardPosition && !this.graveyardPosition.nodeAfter)
        throw new B("split-operation-graveyard-position-invalid", this);
    } else
      throw new B("split-operation-split-in-root", this);
  }
  /**
   * @inheritDoc
   * @internal
   */
  _execute() {
    const e = this.splitPosition.parent;
    if (this.graveyardPosition)
      Sl(X._createFromPositionAndShift(this.graveyardPosition, 1), this.insertionPosition);
    else {
      const n = e._clone();
      fp(this.insertionPosition, n);
    }
    const t = new X(oe._createAt(e, this.splitPosition.offset), oe._createAt(e, e.maxOffset));
    Sl(t, this.moveTargetPosition);
  }
  /**
   * @inheritDoc
   */
  toJSON() {
    const e = super.toJSON();
    return e.splitPosition = this.splitPosition.toJSON(), e.insertionPosition = this.insertionPosition.toJSON(), this.graveyardPosition && (e.graveyardPosition = this.graveyardPosition.toJSON()), e;
  }
  /**
   * @inheritDoc
   */
  static get className() {
    return "SplitOperation";
  }
  /**
   * Helper function that returns a default insertion position basing on given `splitPosition`. The default insertion
   * position is after the split element.
   */
  static getInsertionPosition(e) {
    const t = e.path.slice(0, -1);
    return t[t.length - 1]++, new oe(e.root, t, "toPrevious");
  }
  /**
   * Creates `SplitOperation` object from deserialized object, i.e. from parsed JSON string.
   *
   * @param json Deserialized JSON object.
   * @param document Document on which this operation will be applied.
   */
  static fromJSON(e, t) {
    const n = oe.fromJSON(e.splitPosition, t), r = oe.fromJSON(e.insertionPosition, t), s = e.graveyardPosition ? oe.fromJSON(e.graveyardPosition, t) : null;
    return new this(n, e.howMany, r, s, e.baseVersion);
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class Kt extends fi {
  /**
   * Creates a merge operation.
   *
   * @param sourcePosition Position inside the merged element. All nodes from that
   * element after that position will be moved to {@link #targetPosition}.
   * @param howMany Summary offset size of nodes which will be moved from the merged element to the new parent.
   * @param targetPosition Position which the nodes from the merged elements will be moved to.
   * @param graveyardPosition Position in graveyard to which the merged element will be moved.
   * @param baseVersion Document {@link module:engine/model/document~Document#version} on which operation
   * can be applied or `null` if the operation operates on detached (non-document) tree.
   */
  constructor(e, t, n, r, s) {
    super(s), this.sourcePosition = e.clone(), this.sourcePosition.stickiness = "toPrevious", this.howMany = t, this.targetPosition = n.clone(), this.targetPosition.stickiness = "toNext", this.graveyardPosition = r.clone();
  }
  /**
   * @inheritDoc
   */
  get type() {
    return "merge";
  }
  /**
   * Position before the merged element (which will be deleted).
   */
  get deletionPosition() {
    return new oe(this.sourcePosition.root, this.sourcePosition.path.slice(0, -1));
  }
  /**
   * Artificial range that contains all the nodes from the merged element that will be moved to {@link ~MergeOperation#sourcePosition}.
   * The range starts at {@link ~MergeOperation#sourcePosition} and ends in the same parent, at `POSITIVE_INFINITY` offset.
   */
  get movedRange() {
    const e = this.sourcePosition.getShiftedBy(Number.POSITIVE_INFINITY);
    return new X(this.sourcePosition, e);
  }
  /**
   * Creates and returns an operation that has the same parameters as this operation.
   */
  clone() {
    return new Kt(this.sourcePosition, this.howMany, this.targetPosition, this.graveyardPosition, this.baseVersion);
  }
  /**
   * See {@link module:engine/model/operation/operation~Operation#getReversed `Operation#getReversed()`}.
   */
  getReversed() {
    const e = this.targetPosition._getTransformedByMergeOperation(this), t = this.sourcePosition.path.slice(0, -1), n = new oe(this.sourcePosition.root, t)._getTransformedByMergeOperation(this);
    return new bt(e, this.howMany, n, this.graveyardPosition, this.baseVersion + 1);
  }
  /**
   * @inheritDoc
   * @internal
   */
  _validate() {
    const e = this.sourcePosition.parent, t = this.targetPosition.parent;
    if (e.parent)
      if (t.parent) {
        if (this.howMany != e.maxOffset)
          throw new B("merge-operation-how-many-invalid", this);
      } else
        throw new B("merge-operation-target-position-invalid", this);
    else
      throw new B("merge-operation-source-position-invalid", this);
  }
  /**
   * @inheritDoc
   * @internal
   */
  _execute() {
    const e = this.sourcePosition.parent, t = X._createIn(e);
    Sl(t, this.targetPosition), Sl(X._createOn(e), this.graveyardPosition);
  }
  /**
   * @inheritDoc
   */
  toJSON() {
    const e = super.toJSON();
    return e.sourcePosition = e.sourcePosition.toJSON(), e.targetPosition = e.targetPosition.toJSON(), e.graveyardPosition = e.graveyardPosition.toJSON(), e;
  }
  /**
   * @inheritDoc
   */
  static get className() {
    return "MergeOperation";
  }
  /**
   * Creates `MergeOperation` object from deserialized object, i.e. from parsed JSON string.
   *
   * @param json Deserialized JSON object.
   * @param document Document on which this operation will be applied.
   */
  static fromJSON(e, t) {
    const n = oe.fromJSON(e.sourcePosition, t), r = oe.fromJSON(e.targetPosition, t), s = oe.fromJSON(e.graveyardPosition, t);
    return new this(n, e.howMany, r, s, e.baseVersion);
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class Xn extends fi {
  /**
   * @param name Marker name.
   * @param oldRange Marker range before the change.
   * @param newRange Marker range after the change.
   * @param markers Marker collection on which change should be executed.
   * @param affectsData Specifies whether the marker operation affects the data produced by the data pipeline
   * (is persisted in the editor's data).
   * @param baseVersion Document {@link module:engine/model/document~Document#version} on which operation
   * can be applied or `null` if the operation operates on detached (non-document) tree.
   */
  constructor(e, t, n, r, s, o) {
    super(o), this.name = e, this.oldRange = t ? t.clone() : null, this.newRange = n ? n.clone() : null, this.affectsData = s, this._markers = r;
  }
  /**
   * @inheritDoc
   */
  get type() {
    return "marker";
  }
  /**
   * Creates and returns an operation that has the same parameters as this operation.
   */
  clone() {
    return new Xn(this.name, this.oldRange, this.newRange, this._markers, this.affectsData, this.baseVersion);
  }
  /**
   * See {@link module:engine/model/operation/operation~Operation#getReversed `Operation#getReversed()`}.
   */
  getReversed() {
    return new Xn(this.name, this.newRange, this.oldRange, this._markers, this.affectsData, this.baseVersion + 1);
  }
  /**
   * @inheritDoc
   * @internal
   */
  _execute() {
    this.newRange ? this._markers._set(this.name, this.newRange, !0, this.affectsData) : this._markers._remove(this.name);
  }
  /**
   * @inheritDoc
   * @internal
   */
  toJSON() {
    const e = super.toJSON();
    return this.oldRange && (e.oldRange = this.oldRange.toJSON()), this.newRange && (e.newRange = this.newRange.toJSON()), delete e._markers, e;
  }
  /**
   * @inheritDoc
   */
  static get className() {
    return "MarkerOperation";
  }
  /**
   * Creates `MarkerOperation` object from deserialized object, i.e. from parsed JSON string.
   *
   * @param json Deserialized JSON object.
   * @param document Document on which this operation will be applied.
   */
  static fromJSON(e, t) {
    return new Xn(e.name, e.oldRange ? X.fromJSON(e.oldRange, t) : null, e.newRange ? X.fromJSON(e.newRange, t) : null, t.model.markers, e.affectsData, e.baseVersion);
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class tn extends fi {
  /**
   * Creates an operation that changes, removes or adds attributes.
   *
   * If only `newValue` is set, attribute will be added on a node. Note that all nodes in operation's range must not
   * have an attribute with the same key as the added attribute.
   *
   * If only `oldValue` is set, then attribute with given key will be removed. Note that all nodes in operation's range
   * must have an attribute with that key added.
   *
   * If both `newValue` and `oldValue` are set, then the operation will change the attribute value. Note that all nodes in
   * operation's ranges must already have an attribute with given key and `oldValue` as value
   *
   * @param range Range on which the operation should be applied. Must be a flat range.
   * @param key Key of an attribute to change or remove.
   * @param oldValue Old value of the attribute with given key or `null`, if attribute was not set before.
   * @param newValue New value of the attribute with given key or `null`, if operation should remove attribute.
   * @param baseVersion Document {@link module:engine/model/document~Document#version} on which operation
   * can be applied or `null` if the operation operates on detached (non-document) tree.
   */
  constructor(e, t, n, r, s) {
    super(s), this.range = e.clone(), this.key = t, this.oldValue = n === void 0 ? null : n, this.newValue = r === void 0 ? null : r;
  }
  /**
   * @inheritDoc
   */
  get type() {
    return this.oldValue === null ? "addAttribute" : this.newValue === null ? "removeAttribute" : "changeAttribute";
  }
  /**
   * Creates and returns an operation that has the same parameters as this operation.
   */
  clone() {
    return new tn(this.range, this.key, this.oldValue, this.newValue, this.baseVersion);
  }
  /**
   * See {@link module:engine/model/operation/operation~Operation#getReversed `Operation#getReversed()`}.
   */
  getReversed() {
    return new tn(this.range, this.key, this.newValue, this.oldValue, this.baseVersion + 1);
  }
  /**
   * @inheritDoc
   */
  toJSON() {
    const e = super.toJSON();
    return e.range = this.range.toJSON(), e;
  }
  /**
   * @inheritDoc
   * @internal
   */
  _validate() {
    if (!this.range.isFlat)
      throw new B("attribute-operation-range-not-flat", this);
    for (const e of this.range.getItems({ shallow: !0 })) {
      if (this.oldValue !== null && !Rw(e.getAttribute(this.key), this.oldValue))
        throw new B("attribute-operation-wrong-old-value", this, { item: e, key: this.key, value: this.oldValue });
      if (this.oldValue === null && this.newValue !== null && e.hasAttribute(this.key))
        throw new B("attribute-operation-attribute-exists", this, { node: e, key: this.key });
    }
  }
  /**
   * @inheritDoc
   * @internal
   */
  _execute() {
    Rw(this.oldValue, this.newValue) || O8(this.range, this.key, this.newValue);
  }
  /**
   * @inheritDoc
   */
  static get className() {
    return "AttributeOperation";
  }
  /**
   * Creates `AttributeOperation` object from deserialized object, i.e. from parsed JSON string.
   *
   * @param json Deserialized JSON object.
   * @param document Document on which this operation will be applied.
   */
  static fromJSON(e, t) {
    return new tn(X.fromJSON(e.range, t), e.key, e.oldValue, e.newValue, e.baseVersion);
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class un extends fi {
  get type() {
    return "noop";
  }
  /**
   * Creates and returns an operation that has the same parameters as this operation.
   */
  clone() {
    return new un(this.baseVersion);
  }
  /**
   * See {@link module:engine/model/operation/operation~Operation#getReversed `Operation#getReversed()`}.
   */
  getReversed() {
    return new un(this.baseVersion + 1);
  }
  /** @internal */
  _execute() {
  }
  /**
   * @inheritDoc
   */
  static get className() {
    return "NoOperation";
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class Zn extends fi {
  /**
   * Creates an operation that changes element's name.
   *
   * @param position Position before an element to change.
   * @param oldName Current name of the element.
   * @param newName New name for the element.
   * @param baseVersion Document {@link module:engine/model/document~Document#version} on which operation
   * can be applied or `null` if the operation operates on detached (non-document) tree.
   */
  constructor(e, t, n, r) {
    super(r), this.position = e, this.position.stickiness = "toNext", this.oldName = t, this.newName = n;
  }
  /**
   * @inheritDoc
   */
  get type() {
    return "rename";
  }
  /**
   * Creates and returns an operation that has the same parameters as this operation.
   *
   * @returns Clone of this operation.
   */
  clone() {
    return new Zn(this.position.clone(), this.oldName, this.newName, this.baseVersion);
  }
  /**
   * See {@link module:engine/model/operation/operation~Operation#getReversed `Operation#getReversed()`}.
   */
  getReversed() {
    return new Zn(this.position.clone(), this.newName, this.oldName, this.baseVersion + 1);
  }
  /**
   * @inheritDoc
   * @internal
   */
  _validate() {
    const e = this.position.nodeAfter;
    if (e instanceof gt) {
      if (e.name !== this.oldName)
        throw new B("rename-operation-wrong-name", this);
    } else
      throw new B("rename-operation-wrong-position", this);
  }
  /**
   * @inheritDoc
   * @internal
   */
  _execute() {
    const e = this.position.nodeAfter;
    e.name = this.newName;
  }
  /**
   * @inheritDoc
   */
  toJSON() {
    const e = super.toJSON();
    return e.position = this.position.toJSON(), e;
  }
  /**
   * @inheritDoc
   */
  static get className() {
    return "RenameOperation";
  }
  /**
   * Creates `RenameOperation` object from deserialized object, i.e. from parsed JSON string.
   *
   * @param json Deserialized JSON object.
   * @param document Document on which this operation will be applied.
   */
  static fromJSON(e, t) {
    return new Zn(oe.fromJSON(e.position, t), e.oldName, e.newName, e.baseVersion);
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class Ar extends fi {
  /**
   * Creates an operation that changes, removes or adds attributes on root element.
   *
   * @see module:engine/model/operation/attributeoperation~AttributeOperation
   * @param root Root element to change.
   * @param key Key of an attribute to change or remove.
   * @param oldValue Old value of the attribute with given key or `null`, if attribute was not set before.
   * @param newValue New value of the attribute with given key or `null`, if operation should remove attribute.
   * @param baseVersion Document {@link module:engine/model/document~Document#version} on which operation
   * can be applied or `null` if the operation operates on detached (non-document) tree.
   */
  constructor(e, t, n, r, s) {
    super(s), this.root = e, this.key = t, this.oldValue = n === void 0 ? null : n, this.newValue = r === void 0 ? null : r;
  }
  /**
   * @inheritDoc
   */
  get type() {
    return this.oldValue === null ? "addRootAttribute" : this.newValue === null ? "removeRootAttribute" : "changeRootAttribute";
  }
  /**
   * Creates and returns an operation that has the same parameters as this operation.
   *
   * @returns Clone of this operation.
   */
  clone() {
    return new Ar(this.root, this.key, this.oldValue, this.newValue, this.baseVersion);
  }
  /**
   * See {@link module:engine/model/operation/operation~Operation#getReversed `Operation#getReversed()`}.
   */
  getReversed() {
    return new Ar(this.root, this.key, this.newValue, this.oldValue, this.baseVersion + 1);
  }
  /**
   * @inheritDoc
   * @internal
   */
  _validate() {
    if (this.root != this.root.root || this.root.is("documentFragment"))
      throw new B("rootattribute-operation-not-a-root", this, { root: this.root, key: this.key });
    if (this.oldValue !== null && this.root.getAttribute(this.key) !== this.oldValue)
      throw new B("rootattribute-operation-wrong-old-value", this, { root: this.root, key: this.key });
    if (this.oldValue === null && this.newValue !== null && this.root.hasAttribute(this.key))
      throw new B("rootattribute-operation-attribute-exists", this, { root: this.root, key: this.key });
  }
  /**
   * @inheritDoc
   * @internal
   */
  _execute() {
    this.newValue !== null ? this.root._setAttribute(this.key, this.newValue) : this.root._removeAttribute(this.key);
  }
  /**
   * @inheritDoc
   */
  toJSON() {
    const e = super.toJSON();
    return e.root = this.root.toJSON(), e;
  }
  /**
   * @inheritDoc
   */
  static get className() {
    return "RootAttributeOperation";
  }
  /**
   * Creates `RootAttributeOperation` object from deserialized object, i.e. from parsed JSON string.
   *
   * @param json Deserialized JSON object.
   * @param document Document on which this operation will be applied.
   */
  static fromJSON(e, t) {
    if (!t.getRoot(e.root))
      throw new B("rootattribute-operation-fromjson-no-root", this, { rootName: e.root });
    return new Ar(t.getRoot(e.root), e.key, e.oldValue, e.newValue, e.baseVersion);
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class sr extends fi {
  /**
   * Creates an operation that creates or removes a root element.
   *
   * @param rootName Root name to create or detach.
   * @param elementName Root element name.
   * @param isAdd Specifies whether the operation adds (`true`) or detaches the root (`false`).
   * @param document Document which owns the root.
   * @param baseVersion Document {@link module:engine/model/document~Document#version} on which operation can be applied.
   */
  constructor(e, t, n, r, s) {
    if (super(s), this.rootName = e, this.elementName = t, this.isAdd = n, this._document = r, !this._document.getRoot(this.rootName)) {
      const o = this._document.createRoot(this.elementName, this.rootName);
      o._isAttached = !1;
    }
  }
  /**
   * @inheritDoc
   */
  get type() {
    return this.isAdd ? "addRoot" : "detachRoot";
  }
  /**
   * @inheritDoc
   */
  clone() {
    return new sr(this.rootName, this.elementName, this.isAdd, this._document, this.baseVersion);
  }
  /**
   * @inheritDoc
   */
  getReversed() {
    return new sr(this.rootName, this.elementName, !this.isAdd, this._document, this.baseVersion + 1);
  }
  /**
   * @inheritDoc
   */
  _validate() {
    const e = this._document.getRoot(this.rootName);
    if (e.isAttached() && this.isAdd)
      throw new B("root-operation-root-attached", this);
    if (!e.isAttached() && !this.isAdd)
      throw new B("root-operation-root-detached", this);
  }
  /**
   * @inheritDoc
   */
  _execute() {
    this._document.getRoot(this.rootName)._isAttached = this.isAdd;
  }
  /**
   * @inheritDoc
   */
  toJSON() {
    const e = super.toJSON();
    return delete e._document, e;
  }
  /**
   * @inheritDoc
   */
  static get className() {
    return "RootOperation";
  }
  /**
   * Creates `RootOperation` object from deserialized object, i.e. from parsed JSON string.
   *
   * @param json Deserialized JSON object.
   * @param document Document on which this operation will be applied.
   */
  static fromJSON(e, t) {
    return new sr(e.rootName, e.elementName, e.isAdd, t, e.baseVersion);
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const Ri = {};
Ri[tn.className] = tn;
Ri[pn.className] = pn;
Ri[Xn.className] = Xn;
Ri[it.className] = it;
Ri[un.className] = un;
Ri[fi.className] = fi;
Ri[Zn.className] = Zn;
Ri[Ar.className] = Ar;
Ri[sr.className] = sr;
Ri[bt.className] = bt;
Ri[Kt.className] = Kt;
class M8 {
  /**
   * Creates an operation instance from a JSON object (parsed JSON string).
   *
   * @param json Deserialized JSON object.
   * @param document Document on which this operation will be applied.
   */
  static fromJSON(e, t) {
    return Ri[e.__className].fromJSON(e, t);
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const _g = /* @__PURE__ */ new Map();
function nt(i, e, t) {
  let n = _g.get(i);
  n || (n = /* @__PURE__ */ new Map(), _g.set(i, n)), n.set(e, t);
}
function N8(i, e) {
  const t = _g.get(i);
  return t && t.has(e) ? t.get(e) : D8;
}
function D8(i) {
  return [i];
}
function gb(i, e, t = {}) {
  const n = N8(i.constructor, e.constructor);
  try {
    return i = i.clone(), n(i, e, t);
  } catch (r) {
    throw r;
  }
}
function B8(i, e, t) {
  i = i.slice(), e = e.slice();
  const n = new V8(t.document, t.useRelations, t.forceWeakRemove);
  n.setOriginalOperations(i), n.setOriginalOperations(e);
  const r = n.originalOperations;
  if (i.length == 0 || e.length == 0)
    return { operationsA: i, operationsB: e, originalOperations: r };
  const s = /* @__PURE__ */ new WeakMap();
  for (const u of i)
    s.set(u, 0);
  const o = {
    nextBaseVersionA: i[i.length - 1].baseVersion + 1,
    nextBaseVersionB: e[e.length - 1].baseVersion + 1,
    originalOperationsACount: i.length,
    originalOperationsBCount: e.length
  };
  let l = 0;
  for (; l < i.length; ) {
    const u = i[l], h = s.get(u);
    if (h == e.length) {
      l++;
      continue;
    }
    const f = e[h], m = gb(u, f, n.getContext(u, f, !0)), v = gb(f, u, n.getContext(f, u, !1));
    n.updateRelation(u, f), n.setOriginalOperations(m, u), n.setOriginalOperations(v, f);
    for (const C of m)
      s.set(C, h + v.length);
    i.splice(l, 1, ...m), e.splice(h, 1, ...v);
  }
  if (t.padWithNoOps) {
    const u = i.length - o.originalOperationsACount, h = e.length - o.originalOperationsBCount;
    _b(i, h - u), _b(e, u - h);
  }
  return pb(i, o.nextBaseVersionB), pb(e, o.nextBaseVersionA), { operationsA: i, operationsB: e, originalOperations: r };
}
class V8 {
  /**
   * Creates `ContextFactory` instance.
   *
   * @param document Document which the operations change.
   * @param useRelations Whether during transformation relations should be used (used during undo for
   * better conflict resolution).
   * @param forceWeakRemove If set to `false`, remove operation will be always stronger than move operation,
   * so the removed nodes won't end up back in the document root. When set to `true`, context data will be used.
   */
  constructor(e, t, n = !1) {
    this.originalOperations = /* @__PURE__ */ new Map(), this._history = e.history, this._useRelations = t, this._forceWeakRemove = !!n, this._relations = /* @__PURE__ */ new Map();
  }
  /**
   * Sets "original operation" for given operations.
   *
   * During transformation process, operations are cloned, then changed, then processed again, sometimes broken into two
   * or multiple operations. When gathering additional data it is important that all operations can be somehow linked
   * so a cloned and transformed "version" still kept track of the data assigned earlier to it.
   *
   * The original operation object will be used as such an universal linking id. Throughout the transformation process
   * all cloned operations will refer to "the original operation" when storing and reading additional data.
   *
   * If `takeFrom` is not set, each operation from `operations` array will be assigned itself as "the original operation".
   * This should be used as an initialization step.
   *
   * If `takeFrom` is set, each operation from `operations` will be assigned the same original operation as assigned
   * for `takeFrom` operation. This should be used to update original operations. It should be used in a way that
   * `operations` are the result of `takeFrom` transformation to ensure proper "original operation propagation".
   */
  setOriginalOperations(e, t = null) {
    const n = t ? this.originalOperations.get(t) : null;
    for (const r of e)
      this.originalOperations.set(r, n || r);
  }
  /**
   * Saves a relation between operations `opA` and `opB`.
   *
   * Relations are then later used to help solve conflicts when operations are transformed.
   */
  updateRelation(e, t) {
    if (e instanceof it)
      t instanceof Kt ? e.targetPosition.isEqual(t.sourcePosition) || t.movedRange.containsPosition(e.targetPosition) ? this._setRelation(e, t, "insertAtSource") : e.targetPosition.isEqual(t.deletionPosition) ? this._setRelation(e, t, "insertBetween") : e.targetPosition.isAfter(t.sourcePosition) && this._setRelation(e, t, "moveTargetAfter") : t instanceof it && (e.targetPosition.isEqual(t.sourcePosition) || e.targetPosition.isBefore(t.sourcePosition) ? this._setRelation(e, t, "insertBefore") : this._setRelation(e, t, "insertAfter"));
    else if (e instanceof bt) {
      if (t instanceof Kt)
        e.splitPosition.isBefore(t.sourcePosition) && this._setRelation(e, t, "splitBefore");
      else if (t instanceof it)
        if (e.splitPosition.isEqual(t.sourcePosition) || e.splitPosition.isBefore(t.sourcePosition))
          this._setRelation(e, t, "splitBefore");
        else {
          const n = X._createFromPositionAndShift(t.sourcePosition, t.howMany);
          if (e.splitPosition.hasSameParentAs(t.sourcePosition) && n.containsPosition(e.splitPosition)) {
            const r = n.end.offset - e.splitPosition.offset, s = e.splitPosition.offset - n.start.offset;
            this._setRelation(e, t, { howMany: r, offset: s });
          }
        }
    } else if (e instanceof Kt)
      t instanceof Kt ? (e.targetPosition.isEqual(t.sourcePosition) || this._setRelation(e, t, "mergeTargetNotMoved"), e.sourcePosition.isEqual(t.targetPosition) && this._setRelation(e, t, "mergeSourceNotMoved"), e.sourcePosition.isEqual(t.sourcePosition) && this._setRelation(e, t, "mergeSameElement")) : t instanceof bt && e.sourcePosition.isEqual(t.splitPosition) && this._setRelation(e, t, "splitAtSource");
    else if (e instanceof Xn) {
      const n = e.newRange;
      if (!n)
        return;
      if (t instanceof it) {
        const r = X._createFromPositionAndShift(t.sourcePosition, t.howMany), s = r.containsPosition(n.start) || r.start.isEqual(n.start), o = r.containsPosition(n.end) || r.end.isEqual(n.end);
        (s || o) && !r.containsRange(n) && this._setRelation(e, t, {
          side: s ? "left" : "right",
          path: s ? n.start.path.slice() : n.end.path.slice()
        });
      } else if (t instanceof Kt) {
        const r = n.start.isEqual(t.targetPosition), s = n.start.isEqual(t.deletionPosition), o = n.end.isEqual(t.deletionPosition), l = n.end.isEqual(t.sourcePosition);
        (r || s || o || l) && this._setRelation(e, t, {
          wasInLeftElement: r,
          wasStartBeforeMergedElement: s,
          wasEndBeforeMergedElement: o,
          wasInRightElement: l
        });
      }
    }
  }
  /**
   * Evaluates and returns contextual information about two given operations `opA` and `opB` which are about to be transformed.
   */
  getContext(e, t, n) {
    return {
      aIsStrong: n,
      aWasUndone: this._wasUndone(e),
      bWasUndone: this._wasUndone(t),
      abRelation: this._useRelations ? this._getRelation(e, t) : null,
      baRelation: this._useRelations ? this._getRelation(t, e) : null,
      forceWeakRemove: this._forceWeakRemove
    };
  }
  /**
   * Returns whether given operation `op` has already been undone.
   *
   * Information whether an operation was undone gives more context when making a decision when two operations are in conflict.
   */
  _wasUndone(e) {
    const t = this.originalOperations.get(e);
    return t.wasUndone || this._history.isUndoneOperation(t);
  }
  /**
   * Returns a relation between `opA` and an operation which is undone by `opB`. This can be `String` value if a relation
   * was set earlier or `null` if there was no relation between those operations.
   *
   * This is a little tricky to understand, so let's compare it to `ContextFactory#_wasUndone`.
   *
   * When `wasUndone( opB )` is used, we check if the `opB` has already been undone. It is obvious, that the
   * undoing operation must happen after the undone operation. So, essentially, we have `opB`, we take document history,
   * we look forward in the future and ask if in that future `opB` was undone.
   *
   * Relations is a backward process to `wasUndone()`.
   *
   * Long story short - using relations is asking what happened in the past. Looking back. This time we have an undoing
   * operation `opB` which has undone some other operation. When there is a transformation `opA` x `opB` and there is
   * a conflict to solve and `opB` is an undoing operation, we can look back in the history and see what was a relation
   * between `opA` and the operation which `opB` undone. Basing on that relation from the past, we can now make
   * a better decision when resolving a conflict between two operations, because we know more about the context of
   * those two operations.
   *
   * This is why this function does not return a relation directly between `opA` and `opB` because we need to look
   * back to search for a meaningful contextual information.
   */
  _getRelation(e, t) {
    const n = this.originalOperations.get(t), r = this._history.getUndoneOperation(n);
    if (!r)
      return null;
    const s = this.originalOperations.get(e), o = this._relations.get(s);
    return o && o.get(r) || null;
  }
  /**
   * Helper function for `ContextFactory#updateRelations`.
   */
  _setRelation(e, t, n) {
    const r = this.originalOperations.get(e), s = this.originalOperations.get(t);
    let o = this._relations.get(r);
    o || (o = /* @__PURE__ */ new Map(), this._relations.set(r, o)), o.set(s, n);
  }
}
function pb(i, e) {
  for (const t of i)
    t.baseVersion = e++;
}
function _b(i, e) {
  for (let t = 0; t < e; t++)
    i.push(new un(0));
}
nt(tn, tn, (i, e, t) => {
  if (i.key === e.key && i.range.start.hasSameParentAs(e.range.start)) {
    const n = i.range.getDifference(e.range).map((s) => new tn(s, i.key, i.oldValue, i.newValue, 0)), r = i.range.getIntersection(e.range);
    return r && t.aIsStrong && n.push(new tn(r, e.key, e.newValue, i.newValue, 0)), n.length == 0 ? [new un(0)] : n;
  } else
    return [i];
});
nt(tn, pn, (i, e) => {
  if (i.range.start.hasSameParentAs(e.position) && i.range.containsPosition(e.position)) {
    const n = i.range._getTransformedByInsertion(e.position, e.howMany, !e.shouldReceiveAttributes).map((r) => new tn(r, i.key, i.oldValue, i.newValue, i.baseVersion));
    if (e.shouldReceiveAttributes) {
      const r = pC(e, i.key, i.oldValue);
      r && n.unshift(r);
    }
    return n;
  }
  return i.range = i.range._getTransformedByInsertion(e.position, e.howMany, !1)[0], [i];
});
function pC(i, e, t) {
  const r = i.nodes.getNode(0).getAttribute(e);
  if (r == t)
    return null;
  const s = new X(i.position, i.position.getShiftedBy(i.howMany));
  return new tn(s, e, r, t, 0);
}
nt(tn, Kt, (i, e) => {
  const t = [];
  i.range.start.hasSameParentAs(e.deletionPosition) && (i.range.containsPosition(e.deletionPosition) || i.range.start.isEqual(e.deletionPosition)) && t.push(X._createFromPositionAndShift(e.graveyardPosition, 1));
  const n = i.range._getTransformedByMergeOperation(e);
  return n.isCollapsed || t.push(n), t.map((r) => new tn(r, i.key, i.oldValue, i.newValue, i.baseVersion));
});
nt(tn, it, (i, e) => L8(i.range, e).map((n) => new tn(n, i.key, i.oldValue, i.newValue, i.baseVersion)));
function L8(i, e) {
  const t = X._createFromPositionAndShift(e.sourcePosition, e.howMany);
  let n = null, r = [];
  t.containsRange(i, !0) ? n = i : i.start.hasSameParentAs(t.start) ? (r = i.getDifference(t), n = i.getIntersection(t)) : r = [i];
  const s = [];
  for (let o of r) {
    o = o._getTransformedByDeletion(e.sourcePosition, e.howMany);
    const l = e.getMovedRangeStart(), u = o.start.hasSameParentAs(l), h = o._getTransformedByInsertion(l, e.howMany, u);
    s.push(...h);
  }
  return n && s.push(n._getTransformedByMove(e.sourcePosition, e.targetPosition, e.howMany, !1)[0]), s;
}
nt(tn, bt, (i, e) => {
  if (i.range.end.isEqual(e.insertionPosition))
    return e.graveyardPosition || i.range.end.offset++, [i];
  if (i.range.start.hasSameParentAs(e.splitPosition) && i.range.containsPosition(e.splitPosition)) {
    const t = i.clone();
    return t.range = new X(e.moveTargetPosition.clone(), i.range.end._getCombined(e.splitPosition, e.moveTargetPosition)), i.range.end = e.splitPosition.clone(), i.range.end.stickiness = "toPrevious", [i, t];
  }
  return i.range = i.range._getTransformedBySplitOperation(e), [i];
});
nt(pn, tn, (i, e) => {
  const t = [i];
  if (i.shouldReceiveAttributes && i.position.hasSameParentAs(e.range.start) && e.range.containsPosition(i.position)) {
    const n = pC(i, e.key, e.newValue);
    n && t.push(n);
  }
  return t;
});
nt(pn, pn, (i, e, t) => i.position.isEqual(e.position) && t.aIsStrong ? [i] : (i.position = i.position._getTransformedByInsertOperation(e), [i]));
nt(pn, it, (i, e) => (i.position = i.position._getTransformedByMoveOperation(e), [i]));
nt(pn, bt, (i, e) => (i.position = i.position._getTransformedBySplitOperation(e), [i]));
nt(pn, Kt, (i, e) => (i.position = i.position._getTransformedByMergeOperation(e), [i]));
nt(Xn, pn, (i, e) => (i.oldRange && (i.oldRange = i.oldRange._getTransformedByInsertOperation(e)[0]), i.newRange && (i.newRange = i.newRange._getTransformedByInsertOperation(e)[0]), [i]));
nt(Xn, Xn, (i, e, t) => {
  if (i.name == e.name)
    if (t.aIsStrong)
      i.oldRange = e.newRange ? e.newRange.clone() : null;
    else
      return [new un(0)];
  return [i];
});
nt(Xn, Kt, (i, e) => (i.oldRange && (i.oldRange = i.oldRange._getTransformedByMergeOperation(e)), i.newRange && (i.newRange = i.newRange._getTransformedByMergeOperation(e)), [i]));
nt(Xn, it, (i, e, t) => {
  if (i.oldRange && (i.oldRange = X._createFromRanges(i.oldRange._getTransformedByMoveOperation(e))), i.newRange) {
    if (t.abRelation) {
      const n = X._createFromRanges(i.newRange._getTransformedByMoveOperation(e));
      if (t.abRelation.side == "left" && e.targetPosition.isEqual(i.newRange.start))
        return i.newRange.end = n.end, i.newRange.start.path = t.abRelation.path, [i];
      if (t.abRelation.side == "right" && e.targetPosition.isEqual(i.newRange.end))
        return i.newRange.start = n.start, i.newRange.end.path = t.abRelation.path, [i];
    }
    i.newRange = X._createFromRanges(i.newRange._getTransformedByMoveOperation(e));
  }
  return [i];
});
nt(Xn, bt, (i, e, t) => {
  if (i.oldRange && (i.oldRange = i.oldRange._getTransformedBySplitOperation(e)), i.newRange) {
    if (t.abRelation) {
      const n = i.newRange._getTransformedBySplitOperation(e);
      return i.newRange.start.isEqual(e.splitPosition) && t.abRelation.wasStartBeforeMergedElement ? i.newRange.start = oe._createAt(e.insertionPosition) : i.newRange.start.isEqual(e.splitPosition) && !t.abRelation.wasInLeftElement && (i.newRange.start = oe._createAt(e.moveTargetPosition)), i.newRange.end.isEqual(e.splitPosition) && t.abRelation.wasInRightElement ? i.newRange.end = oe._createAt(e.moveTargetPosition) : i.newRange.end.isEqual(e.splitPosition) && t.abRelation.wasEndBeforeMergedElement ? i.newRange.end = oe._createAt(e.insertionPosition) : i.newRange.end = n.end, [i];
    }
    i.newRange = i.newRange._getTransformedBySplitOperation(e);
  }
  return [i];
});
nt(Kt, pn, (i, e) => (i.sourcePosition.hasSameParentAs(e.position) && (i.howMany += e.howMany), i.sourcePosition = i.sourcePosition._getTransformedByInsertOperation(e), i.targetPosition = i.targetPosition._getTransformedByInsertOperation(e), [i]));
nt(Kt, Kt, (i, e, t) => {
  if (i.sourcePosition.isEqual(e.sourcePosition) && i.targetPosition.isEqual(e.targetPosition))
    if (t.bWasUndone) {
      const n = e.graveyardPosition.path.slice();
      return n.push(0), i.sourcePosition = new oe(e.graveyardPosition.root, n), i.howMany = 0, [i];
    } else
      return [new un(0)];
  if (i.sourcePosition.isEqual(e.sourcePosition) && !i.targetPosition.isEqual(e.targetPosition) && !t.bWasUndone && t.abRelation != "splitAtSource") {
    const n = i.targetPosition.root.rootName == "$graveyard", r = e.targetPosition.root.rootName == "$graveyard";
    if (r && !n || !(n && !r) && t.aIsStrong) {
      const u = e.targetPosition._getTransformedByMergeOperation(e), h = i.targetPosition._getTransformedByMergeOperation(e);
      return [new it(u, i.howMany, h, 0)];
    } else
      return [new un(0)];
  }
  return i.sourcePosition.hasSameParentAs(e.targetPosition) && (i.howMany += e.howMany), i.sourcePosition = i.sourcePosition._getTransformedByMergeOperation(e), i.targetPosition = i.targetPosition._getTransformedByMergeOperation(e), (!i.graveyardPosition.isEqual(e.graveyardPosition) || !t.aIsStrong) && (i.graveyardPosition = i.graveyardPosition._getTransformedByMergeOperation(e)), [i];
});
nt(Kt, it, (i, e, t) => {
  const n = X._createFromPositionAndShift(e.sourcePosition, e.howMany);
  return e.type == "remove" && !t.bWasUndone && !t.forceWeakRemove && i.deletionPosition.hasSameParentAs(e.sourcePosition) && n.containsPosition(i.sourcePosition) ? [new un(0)] : (i.sourcePosition.hasSameParentAs(e.targetPosition) && (i.howMany += e.howMany), i.sourcePosition.hasSameParentAs(e.sourcePosition) && (i.howMany -= e.howMany), i.sourcePosition = i.sourcePosition._getTransformedByMoveOperation(e), i.targetPosition = i.targetPosition._getTransformedByMoveOperation(e), i.graveyardPosition.isEqual(e.targetPosition) || (i.graveyardPosition = i.graveyardPosition._getTransformedByMoveOperation(e)), [i]);
});
nt(Kt, bt, (i, e, t) => {
  if (e.graveyardPosition && (i.graveyardPosition = i.graveyardPosition._getTransformedByDeletion(e.graveyardPosition, 1), i.deletionPosition.isEqual(e.graveyardPosition) && (i.howMany = e.howMany)), i.targetPosition.isEqual(e.splitPosition)) {
    const n = e.howMany != 0, r = e.graveyardPosition && i.deletionPosition.isEqual(e.graveyardPosition);
    if (n || r || t.abRelation == "mergeTargetNotMoved")
      return i.sourcePosition = i.sourcePosition._getTransformedBySplitOperation(e), [i];
  }
  if (i.sourcePosition.isEqual(e.splitPosition)) {
    if (t.abRelation == "mergeSourceNotMoved")
      return i.howMany = 0, i.targetPosition = i.targetPosition._getTransformedBySplitOperation(e), [i];
    if (t.abRelation == "mergeSameElement" || i.sourcePosition.offset > 0)
      return i.sourcePosition = e.moveTargetPosition.clone(), i.targetPosition = i.targetPosition._getTransformedBySplitOperation(e), [i];
  }
  return i.sourcePosition.hasSameParentAs(e.splitPosition) && (i.howMany = e.splitPosition.offset), i.sourcePosition = i.sourcePosition._getTransformedBySplitOperation(e), i.targetPosition = i.targetPosition._getTransformedBySplitOperation(e), [i];
});
nt(it, pn, (i, e) => {
  const n = X._createFromPositionAndShift(i.sourcePosition, i.howMany)._getTransformedByInsertOperation(e, !1)[0];
  return i.sourcePosition = n.start, i.howMany = n.end.offset - n.start.offset, i.targetPosition.isEqual(e.position) || (i.targetPosition = i.targetPosition._getTransformedByInsertOperation(e)), [i];
});
nt(it, it, (i, e, t) => {
  const n = X._createFromPositionAndShift(i.sourcePosition, i.howMany), r = X._createFromPositionAndShift(e.sourcePosition, e.howMany);
  let s = t.aIsStrong, o = !t.aIsStrong;
  t.abRelation == "insertBefore" || t.baRelation == "insertAfter" ? o = !0 : (t.abRelation == "insertAfter" || t.baRelation == "insertBefore") && (o = !1);
  let l;
  if (i.targetPosition.isEqual(e.targetPosition) && o ? l = i.targetPosition._getTransformedByDeletion(e.sourcePosition, e.howMany) : l = i.targetPosition._getTransformedByMove(e.sourcePosition, e.targetPosition, e.howMany), vb(i, e) && vb(e, i))
    return [e.getReversed()];
  if (n.containsPosition(e.targetPosition) && n.containsRange(r, !0))
    return n.start = n.start._getTransformedByMove(e.sourcePosition, e.targetPosition, e.howMany), n.end = n.end._getTransformedByMove(e.sourcePosition, e.targetPosition, e.howMany), No([n], l);
  if (r.containsPosition(i.targetPosition) && r.containsRange(n, !0))
    return n.start = n.start._getCombined(e.sourcePosition, e.getMovedRangeStart()), n.end = n.end._getCombined(e.sourcePosition, e.getMovedRangeStart()), No([n], l);
  const f = Pn(i.sourcePosition.getParentPath(), e.sourcePosition.getParentPath());
  if (f == "prefix" || f == "extension")
    return n.start = n.start._getTransformedByMove(e.sourcePosition, e.targetPosition, e.howMany), n.end = n.end._getTransformedByMove(e.sourcePosition, e.targetPosition, e.howMany), No([n], l);
  i.type == "remove" && e.type != "remove" && !t.aWasUndone && !t.forceWeakRemove ? s = !0 : i.type != "remove" && e.type == "remove" && !t.bWasUndone && !t.forceWeakRemove && (s = !1);
  const m = [], v = n.getDifference(r);
  for (const k of v) {
    k.start = k.start._getTransformedByDeletion(e.sourcePosition, e.howMany), k.end = k.end._getTransformedByDeletion(e.sourcePosition, e.howMany);
    const S = Pn(k.start.getParentPath(), e.getMovedRangeStart().getParentPath()) == "same", x = k._getTransformedByInsertion(e.getMovedRangeStart(), e.howMany, S);
    m.push(...x);
  }
  const C = n.getIntersection(r);
  return C !== null && s && (C.start = C.start._getCombined(e.sourcePosition, e.getMovedRangeStart()), C.end = C.end._getCombined(e.sourcePosition, e.getMovedRangeStart()), m.length === 0 ? m.push(C) : m.length == 1 ? r.start.isBefore(n.start) || r.start.isEqual(n.start) ? m.unshift(C) : m.push(C) : m.splice(1, 0, C)), m.length === 0 ? [new un(i.baseVersion)] : No(m, l);
});
nt(it, bt, (i, e, t) => {
  let n = i.targetPosition.clone();
  (!i.targetPosition.isEqual(e.insertionPosition) || !e.graveyardPosition || t.abRelation == "moveTargetAfter") && (n = i.targetPosition._getTransformedBySplitOperation(e));
  const r = X._createFromPositionAndShift(i.sourcePosition, i.howMany);
  if (r.end.isEqual(e.insertionPosition))
    return e.graveyardPosition || i.howMany++, i.targetPosition = n, [i];
  if (r.start.hasSameParentAs(e.splitPosition) && r.containsPosition(e.splitPosition)) {
    let l = new X(e.splitPosition, r.end);
    l = l._getTransformedBySplitOperation(e);
    const u = [
      new X(r.start, e.splitPosition),
      l
    ];
    return No(u, n);
  }
  i.targetPosition.isEqual(e.splitPosition) && t.abRelation == "insertAtSource" && (n = e.moveTargetPosition), i.targetPosition.isEqual(e.insertionPosition) && t.abRelation == "insertBetween" && (n = i.targetPosition);
  const o = [r._getTransformedBySplitOperation(e)];
  if (e.graveyardPosition) {
    const l = r.start.isEqual(e.graveyardPosition) || r.containsPosition(e.graveyardPosition);
    i.howMany > 1 && l && !t.aWasUndone && o.push(X._createFromPositionAndShift(e.insertionPosition, 1));
  }
  return No(o, n);
});
nt(it, Kt, (i, e, t) => {
  const n = X._createFromPositionAndShift(i.sourcePosition, i.howMany);
  if (e.deletionPosition.hasSameParentAs(i.sourcePosition) && n.containsPosition(e.sourcePosition)) {
    if (i.type == "remove" && !t.forceWeakRemove) {
      if (!t.aWasUndone) {
        const o = [];
        let l = e.graveyardPosition.clone(), u = e.targetPosition._getTransformedByMergeOperation(e);
        i.howMany > 1 && (o.push(new it(i.sourcePosition, i.howMany - 1, i.targetPosition, 0)), l = l._getTransformedByMove(i.sourcePosition, i.targetPosition, i.howMany - 1), u = u._getTransformedByMove(i.sourcePosition, i.targetPosition, i.howMany - 1));
        const h = e.deletionPosition._getCombined(i.sourcePosition, i.targetPosition), f = new it(l, 1, h, 0), m = f.getMovedRangeStart().path.slice();
        m.push(0);
        const v = new oe(f.targetPosition.root, m);
        u = u._getTransformedByMove(l, h, 1);
        const C = new it(u, e.howMany, v, 0);
        return o.push(f), o.push(C), o;
      }
    } else if (i.howMany == 1)
      return t.bWasUndone ? (i.sourcePosition = e.graveyardPosition.clone(), i.targetPosition = i.targetPosition._getTransformedByMergeOperation(e), [i]) : [new un(0)];
  }
  const s = X._createFromPositionAndShift(i.sourcePosition, i.howMany)._getTransformedByMergeOperation(e);
  return i.sourcePosition = s.start, i.howMany = s.end.offset - s.start.offset, i.targetPosition = i.targetPosition._getTransformedByMergeOperation(e), [i];
});
nt(Zn, pn, (i, e) => (i.position = i.position._getTransformedByInsertOperation(e), [i]));
nt(Zn, Kt, (i, e) => i.position.isEqual(e.deletionPosition) ? (i.position = e.graveyardPosition.clone(), i.position.stickiness = "toNext", [i]) : (i.position = i.position._getTransformedByMergeOperation(e), [i]));
nt(Zn, it, (i, e) => (i.position = i.position._getTransformedByMoveOperation(e), [i]));
nt(Zn, Zn, (i, e, t) => {
  if (i.position.isEqual(e.position))
    if (t.aIsStrong)
      i.oldName = e.newName;
    else
      return [new un(0)];
  return [i];
});
nt(Zn, bt, (i, e) => {
  const t = i.position.path, n = e.splitPosition.getParentPath();
  if (Pn(t, n) == "same" && !e.graveyardPosition) {
    const r = new Zn(i.position.getShiftedBy(1), i.oldName, i.newName, 0);
    return [i, r];
  }
  return i.position = i.position._getTransformedBySplitOperation(e), [i];
});
nt(Ar, Ar, (i, e, t) => {
  if (i.root === e.root && i.key === e.key) {
    if (!t.aIsStrong || i.newValue === e.newValue)
      return [new un(0)];
    i.oldValue = e.newValue;
  }
  return [i];
});
nt(sr, sr, (i, e, t) => i.rootName === e.rootName && i.isAdd === e.isAdd && !t.bWasUndone ? [new un(0)] : [i]);
nt(bt, pn, (i, e) => (i.splitPosition.hasSameParentAs(e.position) && i.splitPosition.offset < e.position.offset && (i.howMany += e.howMany), i.splitPosition = i.splitPosition._getTransformedByInsertOperation(e), i.insertionPosition = i.insertionPosition._getTransformedByInsertOperation(e), [i]));
nt(bt, Kt, (i, e, t) => {
  if (!i.graveyardPosition && !t.bWasUndone && i.splitPosition.hasSameParentAs(e.sourcePosition)) {
    const n = e.graveyardPosition.path.slice();
    n.push(0);
    const r = new oe(e.graveyardPosition.root, n), s = bt.getInsertionPosition(new oe(e.graveyardPosition.root, n)), o = new bt(r, 0, s, null, 0);
    return i.splitPosition = i.splitPosition._getTransformedByMergeOperation(e), i.insertionPosition = bt.getInsertionPosition(i.splitPosition), i.graveyardPosition = o.insertionPosition.clone(), i.graveyardPosition.stickiness = "toNext", [o, i];
  }
  return i.splitPosition.hasSameParentAs(e.deletionPosition) && !i.splitPosition.isAfter(e.deletionPosition) && i.howMany--, i.splitPosition.hasSameParentAs(e.targetPosition) && (i.howMany += e.howMany), i.splitPosition = i.splitPosition._getTransformedByMergeOperation(e), i.insertionPosition = bt.getInsertionPosition(i.splitPosition), i.graveyardPosition && (i.graveyardPosition = i.graveyardPosition._getTransformedByMergeOperation(e)), [i];
});
nt(bt, it, (i, e, t) => {
  const n = X._createFromPositionAndShift(e.sourcePosition, e.howMany);
  if (i.graveyardPosition) {
    const s = n.start.isEqual(i.graveyardPosition) || n.containsPosition(i.graveyardPosition);
    if (!t.bWasUndone && s) {
      const o = i.splitPosition._getTransformedByMoveOperation(e), l = i.graveyardPosition._getTransformedByMoveOperation(e), u = l.path.slice();
      u.push(0);
      const h = new oe(l.root, u);
      return [new it(o, i.howMany, h, 0)];
    }
    i.graveyardPosition = i.graveyardPosition._getTransformedByMoveOperation(e);
  }
  const r = i.splitPosition.isEqual(e.targetPosition);
  if (r && (t.baRelation == "insertAtSource" || t.abRelation == "splitBefore"))
    return i.howMany += e.howMany, i.splitPosition = i.splitPosition._getTransformedByDeletion(e.sourcePosition, e.howMany), i.insertionPosition = bt.getInsertionPosition(i.splitPosition), [i];
  if (r && t.abRelation && t.abRelation.howMany) {
    const { howMany: s, offset: o } = t.abRelation;
    return i.howMany += s, i.splitPosition = i.splitPosition.getShiftedBy(o), [i];
  }
  if (i.splitPosition.hasSameParentAs(e.sourcePosition) && n.containsPosition(i.splitPosition)) {
    const s = e.howMany - (i.splitPosition.offset - e.sourcePosition.offset);
    return i.howMany -= s, i.splitPosition.hasSameParentAs(e.targetPosition) && i.splitPosition.offset < e.targetPosition.offset && (i.howMany += e.howMany), i.splitPosition = e.sourcePosition.clone(), i.insertionPosition = bt.getInsertionPosition(i.splitPosition), [i];
  }
  return e.sourcePosition.isEqual(e.targetPosition) || (i.splitPosition.hasSameParentAs(e.sourcePosition) && i.splitPosition.offset <= e.sourcePosition.offset && (i.howMany -= e.howMany), i.splitPosition.hasSameParentAs(e.targetPosition) && i.splitPosition.offset < e.targetPosition.offset && (i.howMany += e.howMany)), i.splitPosition.stickiness = "toNone", i.splitPosition = i.splitPosition._getTransformedByMoveOperation(e), i.splitPosition.stickiness = "toNext", i.graveyardPosition ? i.insertionPosition = i.insertionPosition._getTransformedByMoveOperation(e) : i.insertionPosition = bt.getInsertionPosition(i.splitPosition), [i];
});
nt(bt, bt, (i, e, t) => {
  if (i.splitPosition.isEqual(e.splitPosition)) {
    if (!i.graveyardPosition && !e.graveyardPosition)
      return [new un(0)];
    if (i.graveyardPosition && e.graveyardPosition && i.graveyardPosition.isEqual(e.graveyardPosition))
      return [new un(0)];
    if (t.abRelation == "splitBefore")
      return i.howMany = 0, i.graveyardPosition = i.graveyardPosition._getTransformedBySplitOperation(e), [i];
  }
  if (i.graveyardPosition && e.graveyardPosition && i.graveyardPosition.isEqual(e.graveyardPosition)) {
    const n = i.splitPosition.root.rootName == "$graveyard", r = e.splitPosition.root.rootName == "$graveyard";
    if (r && !n || !(n && !r) && t.aIsStrong) {
      const u = [];
      return e.howMany && u.push(new it(e.moveTargetPosition, e.howMany, e.splitPosition, 0)), i.howMany && u.push(new it(i.splitPosition, i.howMany, i.moveTargetPosition, 0)), u;
    } else
      return [new un(0)];
  }
  if (i.graveyardPosition && (i.graveyardPosition = i.graveyardPosition._getTransformedBySplitOperation(e)), i.splitPosition.isEqual(e.insertionPosition) && t.abRelation == "splitBefore")
    return i.howMany++, [i];
  if (e.splitPosition.isEqual(i.insertionPosition) && t.baRelation == "splitBefore") {
    const n = e.insertionPosition.path.slice();
    n.push(0);
    const r = new oe(e.insertionPosition.root, n), s = new it(i.insertionPosition, 1, r, 0);
    return [i, s];
  }
  return i.splitPosition.hasSameParentAs(e.splitPosition) && i.splitPosition.offset < e.splitPosition.offset && (i.howMany -= e.howMany), i.splitPosition = i.splitPosition._getTransformedBySplitOperation(e), i.insertionPosition = bt.getInsertionPosition(i.splitPosition), [i];
});
function vb(i, e) {
  return i.targetPosition._getTransformedByDeletion(e.sourcePosition, e.howMany) === null;
}
function No(i, e) {
  const t = [];
  for (let n = 0; n < i.length; n++) {
    const r = i[n], s = new it(r.start, r.end.offset - r.start.offset, e, 0);
    t.push(s);
    for (let o = n + 1; o < i.length; o++)
      i[o] = i[o]._getTransformedByMove(s.sourcePosition, s.targetPosition, s.howMany)[0];
    e = e._getTransformedByMove(s.sourcePosition, s.targetPosition, s.howMany);
  }
  return t;
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class En extends kt(oe) {
  /**
   * Creates a live position.
   *
   * @see module:engine/model/position~Position
   */
  constructor(e, t, n = "toNone") {
    if (super(e, t, n), !this.root.is("rootElement"))
      throw new B("model-liveposition-root-not-rootelement", e);
    F8.call(this);
  }
  /**
   * Unbinds all events previously bound by `LivePosition`. Use it whenever you don't need `LivePosition` instance
   * anymore (i.e. when leaving scope in which it was declared or before re-assigning variable that was
   * referring to it).
   */
  detach() {
    this.stopListening();
  }
  /**
   * Creates a {@link module:engine/model/position~Position position instance}, which is equal to this live position.
   */
  toPosition() {
    return new oe(this.root, this.path.slice(), this.stickiness);
  }
  /**
   * Creates a `LivePosition` instance that is equal to position.
   */
  static fromPosition(e, t) {
    return new this(e.root, e.path.slice(), t || e.stickiness);
  }
}
En.prototype.is = function(i) {
  return i === "livePosition" || i === "model:livePosition" || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
  i == "position" || i === "model:position";
};
function F8() {
  this.listenTo(this.root.document.model, "applyOperation", (i, e) => {
    const t = e[0];
    t.isDocumentOperation && $8.call(this, t);
  }, { priority: "low" });
}
function $8(i) {
  const e = this.getTransformedByOperation(i);
  if (!this.isEqual(e)) {
    const t = this.toPosition();
    this.path = e.path, this.root = e.root, this.fire("change", t);
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class ko {
  /**
   * Creates a batch instance.
   *
   * @see module:engine/model/model~Model#enqueueChange
   * @see module:engine/model/model~Model#change
   * @param type A set of flags that specify the type of the batch. Batch type can alter how some of the features work
   * when encountering a given `Batch` instance (for example, when a feature listens to applied operations).
   */
  constructor(e = {}) {
    typeof e == "string" && (e = e === "transparent" ? { isUndoable: !1 } : {}, Yt("batch-constructor-deprecated-string-type"));
    const { isUndoable: t = !0, isLocal: n = !0, isUndo: r = !1, isTyping: s = !1 } = e;
    this.operations = [], this.isUndoable = t, this.isLocal = n, this.isUndo = r, this.isTyping = s;
  }
  /**
   * The type of the batch.
   *
   * **This property has been deprecated and is always set to the `'default'` value.**
   *
   * It can be one of the following values:
   * * `'default'` &ndash; All "normal" batches. This is the most commonly used type.
   * * `'transparent'` &ndash; A batch that should be ignored by other features, i.e. an initial batch or collaborative editing
   * changes.
   *
   * @deprecated
   */
  get type() {
    return Yt("batch-type-deprecated"), "default";
  }
  /**
   * Returns the base version of this batch, which is equal to the base version of the first operation in the batch.
   * If there are no operations in the batch or neither operation has the base version set, it returns `null`.
   */
  get baseVersion() {
    for (const e of this.operations)
      if (e.baseVersion !== null)
        return e.baseVersion;
    return null;
  }
  /**
   * Adds an operation to the batch instance.
   *
   * @param operation An operation to add.
   * @returns The added operation.
   */
  addOperation(e) {
    return e.batch = this, this.operations.push(e), e;
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class z8 {
  /**
   * Creates a `Differ` instance.
   *
   * @param markerCollection Model's marker collection.
   */
  constructor(e) {
    this._changesInElement = /* @__PURE__ */ new Map(), this._elementSnapshots = /* @__PURE__ */ new Map(), this._changedMarkers = /* @__PURE__ */ new Map(), this._changedRoots = /* @__PURE__ */ new Map(), this._changeCount = 0, this._cachedChanges = null, this._cachedChangesWithGraveyard = null, this._refreshedItems = /* @__PURE__ */ new Set(), this._markerCollection = e;
  }
  /**
   * Informs whether there are any changes buffered in `Differ`.
   */
  get isEmpty() {
    return this._changesInElement.size == 0 && this._changedMarkers.size == 0 && this._changedRoots.size == 0;
  }
  /**
   * Buffers the given operation. An operation has to be buffered before it is executed.
   *
   * @param operationToBuffer An operation to buffer.
   */
  bufferOperation(e) {
    const t = e;
    switch (t.type) {
      case "insert": {
        if (this._isInInsertedElement(t.position.parent))
          return;
        this._markInsert(t.position.parent, t.position.offset, t.nodes.maxOffset);
        break;
      }
      case "addAttribute":
      case "removeAttribute":
      case "changeAttribute": {
        for (const n of t.range.getItems({ shallow: !0 }))
          this._isInInsertedElement(n.parent) || this._markAttribute(n);
        break;
      }
      case "remove":
      case "move":
      case "reinsert": {
        if (t.sourcePosition.isEqual(t.targetPosition) || t.sourcePosition.getShiftedBy(t.howMany).isEqual(t.targetPosition))
          return;
        const n = this._isInInsertedElement(t.sourcePosition.parent), r = this._isInInsertedElement(t.targetPosition.parent);
        n || this._markRemove(t.sourcePosition.parent, t.sourcePosition.offset, t.howMany), r || this._markInsert(t.targetPosition.parent, t.getMovedRangeStart().offset, t.howMany);
        break;
      }
      case "rename": {
        if (this._isInInsertedElement(t.position.parent))
          return;
        this._markRemove(t.position.parent, t.position.offset, 1), this._markInsert(t.position.parent, t.position.offset, 1);
        const n = X._createFromPositionAndShift(t.position, 1);
        for (const r of this._markerCollection.getMarkersIntersectingRange(n)) {
          const s = r.getData();
          this.bufferMarkerChange(r.name, s, s);
        }
        break;
      }
      case "split": {
        const n = t.splitPosition.parent;
        this._isInInsertedElement(n) || this._markRemove(n, t.splitPosition.offset, t.howMany), this._isInInsertedElement(t.insertionPosition.parent) || this._markInsert(t.insertionPosition.parent, t.insertionPosition.offset, 1), t.graveyardPosition && this._markRemove(t.graveyardPosition.parent, t.graveyardPosition.offset, 1);
        break;
      }
      case "merge": {
        const n = t.sourcePosition.parent;
        this._isInInsertedElement(n.parent) || this._markRemove(n.parent, n.startOffset, 1);
        const r = t.graveyardPosition.parent;
        this._markInsert(r, t.graveyardPosition.offset, 1);
        const s = t.targetPosition.parent;
        this._isInInsertedElement(s) || this._markInsert(s, t.targetPosition.offset, n.maxOffset);
        break;
      }
      case "detachRoot":
      case "addRoot": {
        this._bufferRootStateChange(t.rootName, t.isAdd);
        break;
      }
      case "addRootAttribute":
      case "removeRootAttribute":
      case "changeRootAttribute": {
        const n = t.root.rootName;
        this._bufferRootAttributeChange(n, t.key, t.oldValue, t.newValue);
        break;
      }
    }
    this._cachedChanges = null;
  }
  /**
   * Buffers a marker change.
   *
   * @param markerName The name of the marker that changed.
   * @param oldMarkerData Marker data before the change.
   * @param newMarkerData Marker data after the change.
   */
  bufferMarkerChange(e, t, n) {
    const r = this._changedMarkers.get(e);
    r ? (r.newMarkerData = n, r.oldMarkerData.range == null && n.range == null && this._changedMarkers.delete(e)) : this._changedMarkers.set(e, {
      newMarkerData: n,
      oldMarkerData: t
    });
  }
  /**
   * Returns all markers that should be removed as a result of buffered changes.
   *
   * @returns Markers to remove. Each array item is an object containing the `name` and `range` properties.
   */
  getMarkersToRemove() {
    const e = [];
    for (const [t, n] of this._changedMarkers)
      n.oldMarkerData.range != null && e.push({ name: t, range: n.oldMarkerData.range });
    return e;
  }
  /**
   * Returns all markers which should be added as a result of buffered changes.
   *
   * @returns Markers to add. Each array item is an object containing the `name` and `range` properties.
   */
  getMarkersToAdd() {
    const e = [];
    for (const [t, n] of this._changedMarkers)
      n.newMarkerData.range != null && e.push({ name: t, range: n.newMarkerData.range });
    return e;
  }
  /**
   * Returns all markers which changed.
   */
  getChangedMarkers() {
    return Array.from(this._changedMarkers).map(([e, t]) => ({
      name: e,
      data: {
        oldRange: t.oldMarkerData.range,
        newRange: t.newMarkerData.range
      }
    }));
  }
  /**
   * Checks whether some of the buffered changes affect the editor data.
   *
   * Types of changes which affect the editor data:
   *
   * * model structure changes,
   * * attribute changes,
   * * a root is added or detached,
   * * changes of markers which were defined as `affectsData`,
   * * changes of markers' `affectsData` property.
   */
  hasDataChanges() {
    if (this._changesInElement.size > 0 || this._changedRoots.size > 0)
      return !0;
    for (const { newMarkerData: e, oldMarkerData: t } of this._changedMarkers.values()) {
      if (e.affectsData !== t.affectsData)
        return !0;
      if (e.affectsData) {
        const n = e.range && !t.range, r = !e.range && t.range, s = e.range && t.range && !e.range.isEqual(t.range);
        if (n || r || s)
          return !0;
      }
    }
    return !1;
  }
  /**
   * Calculates the diff between the old model tree state (the state before the first buffered operations since the last {@link #reset}
   * call) and the new model tree state (actual one). It should be called after all buffered operations are executed.
   *
   * The diff set is returned as an array of {@link module:engine/model/differ~DiffItem diff items}, each describing a change done
   * on the model. The items are sorted by the position on which the change happened. If a position
   * {@link module:engine/model/position~Position#isBefore is before} another one, it will be on an earlier index in the diff set.
   *
   * **Note**: Elements inside inserted element will not have a separate diff item, only the top most element change will be reported.
   *
   * Because calculating the diff is a costly operation, the result is cached. If no new operation was buffered since the
   * previous {@link #getChanges} call, the next call will return the cached value.
   *
   * @param options Additional options.
   * @param options.includeChangesInGraveyard If set to `true`, also changes that happened
   * in the graveyard root will be returned. By default, changes in the graveyard root are not returned.
   * @returns Diff between the old and the new model tree state.
   */
  getChanges(e = {}) {
    if (this._cachedChanges)
      return e.includeChangesInGraveyard ? this._cachedChangesWithGraveyard.slice() : this._cachedChanges.slice();
    let t = [];
    for (const n of this._changesInElement.keys()) {
      const r = this._changesInElement.get(n).sort((f, m) => f.offset === m.offset ? f.type != m.type ? f.type == "remove" ? -1 : 1 : 0 : f.offset < m.offset ? -1 : 1), s = this._elementSnapshots.get(n), o = wb(n.getChildren()), l = W8(s.length, r);
      let u = 0, h = 0;
      for (const f of l)
        if (f === "i")
          t.push(this._getInsertDiff(n, u, o[u])), u++;
        else if (f === "r")
          t.push(this._getRemoveDiff(n, u, s[h])), h++;
        else if (f === "a") {
          const m = o[u].attributes, v = s[h].attributes;
          let C;
          if (o[u].name == "$text")
            C = new X(oe._createAt(n, u), oe._createAt(n, u + 1));
          else {
            const k = n.offsetToIndex(u);
            C = new X(oe._createAt(n, u), oe._createAt(n.getChild(k), 0));
          }
          t.push(...this._getAttributesDiff(C, v, m)), u++, h++;
        } else
          u++, h++;
    }
    t.sort((n, r) => n.position.root != r.position.root ? n.position.root.rootName < r.position.root.rootName ? -1 : 1 : n.position.isEqual(r.position) ? n.changeCount - r.changeCount : n.position.isBefore(r.position) ? -1 : 1);
    for (let n = 1, r = 0; n < t.length; n++) {
      const s = t[r], o = t[n], l = s.type == "remove" && o.type == "remove" && s.name == "$text" && o.name == "$text" && s.position.isEqual(o.position), u = s.type == "insert" && o.type == "insert" && s.name == "$text" && o.name == "$text" && s.position.parent == o.position.parent && s.position.offset + s.length == o.position.offset, h = s.type == "attribute" && o.type == "attribute" && s.position.parent == o.position.parent && s.range.isFlat && o.range.isFlat && s.position.offset + s.length == o.position.offset && s.attributeKey == o.attributeKey && s.attributeOldValue == o.attributeOldValue && s.attributeNewValue == o.attributeNewValue;
      l || u || h ? (s.length++, h && (s.range.end = s.range.end.getShiftedBy(1)), t[n] = null) : r = n;
    }
    t = t.filter((n) => n);
    for (const n of t)
      delete n.changeCount, n.type == "attribute" && (delete n.position, delete n.length);
    return this._changeCount = 0, this._cachedChangesWithGraveyard = t, this._cachedChanges = t.filter(j8), e.includeChangesInGraveyard ? this._cachedChangesWithGraveyard.slice() : this._cachedChanges.slice();
  }
  /**
   * Returns all roots that have changed (either were attached, or detached, or their attributes changed).
   *
   * @returns Diff between the old and the new roots state.
   */
  getChangedRoots() {
    return Array.from(this._changedRoots.values()).map((e) => {
      const t = { ...e };
      return t.state !== void 0 && delete t.attributes, t;
    });
  }
  /**
   * Returns a set of model items that were marked to get refreshed.
   */
  getRefreshedItems() {
    return new Set(this._refreshedItems);
  }
  /**
   * Resets `Differ`. Removes all buffered changes.
   */
  reset() {
    this._changesInElement.clear(), this._elementSnapshots.clear(), this._changedMarkers.clear(), this._changedRoots.clear(), this._refreshedItems = /* @__PURE__ */ new Set(), this._cachedChanges = null;
  }
  /**
   * Buffers the root state change after the root was attached or detached
   */
  _bufferRootStateChange(e, t) {
    if (!this._changedRoots.has(e)) {
      this._changedRoots.set(e, { name: e, state: t ? "attached" : "detached" });
      return;
    }
    const n = this._changedRoots.get(e);
    n.state !== void 0 ? (delete n.state, n.attributes === void 0 && this._changedRoots.delete(e)) : n.state = t ? "attached" : "detached";
  }
  /**
   * Buffers a root attribute change.
   */
  _bufferRootAttributeChange(e, t, n, r) {
    const s = this._changedRoots.get(e) || { name: e }, o = s.attributes || {};
    if (o[t]) {
      const l = o[t];
      r === l.oldValue ? delete o[t] : l.newValue = r;
    } else
      o[t] = { oldValue: n, newValue: r };
    Object.entries(o).length === 0 ? (delete s.attributes, s.state === void 0 && this._changedRoots.delete(e)) : (s.attributes = o, this._changedRoots.set(e, s));
  }
  /**
   * Marks the given `item` in differ to be "refreshed". It means that the item will be marked as removed and inserted
   * in the differ changes set, so it will be effectively re-converted when the differ changes are handled by a dispatcher.
   *
   * @internal
   * @param item Item to refresh.
   */
  _refreshItem(e) {
    if (this._isInInsertedElement(e.parent))
      return;
    this._markRemove(e.parent, e.startOffset, e.offsetSize), this._markInsert(e.parent, e.startOffset, e.offsetSize), this._refreshedItems.add(e);
    const t = X._createOn(e);
    for (const n of this._markerCollection.getMarkersIntersectingRange(t)) {
      const r = n.getData();
      this.bufferMarkerChange(n.name, r, r);
    }
    this._cachedChanges = null;
  }
  /**
   * Saves and handles an insert change.
   */
  _markInsert(e, t, n) {
    const r = { type: "insert", offset: t, howMany: n, count: this._changeCount++ };
    this._markChange(e, r);
  }
  /**
   * Saves and handles a remove change.
   */
  _markRemove(e, t, n) {
    const r = { type: "remove", offset: t, howMany: n, count: this._changeCount++ };
    this._markChange(e, r), this._removeAllNestedChanges(e, t, n);
  }
  /**
   * Saves and handles an attribute change.
   */
  _markAttribute(e) {
    const t = { type: "attribute", offset: e.startOffset, howMany: e.offsetSize, count: this._changeCount++ };
    this._markChange(e.parent, t);
  }
  /**
   * Saves and handles a model change.
   */
  _markChange(e, t) {
    this._makeSnapshot(e);
    const n = this._getChangesForElement(e);
    this._handleChange(t, n), n.push(t);
    for (let r = 0; r < n.length; r++)
      n[r].howMany < 1 && (n.splice(r, 1), r--);
  }
  /**
   * Gets an array of changes that have already been saved for a given element.
   */
  _getChangesForElement(e) {
    let t;
    return this._changesInElement.has(e) ? t = this._changesInElement.get(e) : (t = [], this._changesInElement.set(e, t)), t;
  }
  /**
   * Saves a children snapshot for a given element.
   */
  _makeSnapshot(e) {
    this._elementSnapshots.has(e) || this._elementSnapshots.set(e, wb(e.getChildren()));
  }
  /**
   * For a given newly saved change, compares it with a change already done on the element and modifies the incoming
   * change and/or the old change.
   *
   * @param inc Incoming (new) change.
   * @param changes An array containing all the changes done on that element.
   */
  _handleChange(e, t) {
    e.nodesToHandle = e.howMany;
    for (const n of t) {
      const r = e.offset + e.howMany, s = n.offset + n.howMany;
      if (e.type == "insert" && (n.type == "insert" && (e.offset <= n.offset ? n.offset += e.howMany : e.offset < s && (n.howMany += e.nodesToHandle, e.nodesToHandle = 0)), n.type == "remove" && e.offset < n.offset && (n.offset += e.howMany), n.type == "attribute")) {
        if (e.offset <= n.offset)
          n.offset += e.howMany;
        else if (e.offset < s) {
          const o = n.howMany;
          n.howMany = e.offset - n.offset, t.unshift({
            type: "attribute",
            offset: r,
            howMany: o - n.howMany,
            count: this._changeCount++
          });
        }
      }
      if (e.type == "remove") {
        if (n.type == "insert") {
          if (r <= n.offset)
            n.offset -= e.howMany;
          else if (r <= s)
            if (e.offset < n.offset) {
              const o = r - n.offset;
              n.offset = e.offset, n.howMany -= o, e.nodesToHandle -= o;
            } else
              n.howMany -= e.nodesToHandle, e.nodesToHandle = 0;
          else if (e.offset <= n.offset)
            e.nodesToHandle -= n.howMany, n.howMany = 0;
          else if (e.offset < s) {
            const o = s - e.offset;
            n.howMany -= o, e.nodesToHandle -= o;
          }
        }
        if (n.type == "remove" && (r <= n.offset ? n.offset -= e.howMany : e.offset < n.offset && (e.nodesToHandle += n.howMany, n.howMany = 0)), n.type == "attribute") {
          if (r <= n.offset)
            n.offset -= e.howMany;
          else if (e.offset < n.offset) {
            const o = r - n.offset;
            n.offset = e.offset, n.howMany -= o;
          } else if (e.offset < s)
            if (r <= s) {
              const o = n.howMany;
              n.howMany = e.offset - n.offset;
              const l = o - n.howMany - e.nodesToHandle;
              t.unshift({
                type: "attribute",
                offset: e.offset,
                howMany: l,
                count: this._changeCount++
              });
            } else
              n.howMany -= s - e.offset;
        }
      }
      if (e.type == "attribute") {
        if (n.type == "insert")
          if (e.offset < n.offset && r > n.offset) {
            if (r > s) {
              const o = {
                type: "attribute",
                offset: s,
                howMany: r - s,
                count: this._changeCount++
              };
              this._handleChange(o, t), t.push(o);
            }
            e.nodesToHandle = n.offset - e.offset, e.howMany = e.nodesToHandle;
          } else
            e.offset >= n.offset && e.offset < s && (r > s ? (e.nodesToHandle = r - s, e.offset = s) : e.nodesToHandle = 0);
        if (n.type == "remove" && e.offset < n.offset && r > n.offset) {
          const o = {
            type: "attribute",
            offset: n.offset,
            howMany: r - n.offset,
            count: this._changeCount++
          };
          this._handleChange(o, t), t.push(o), e.nodesToHandle = n.offset - e.offset, e.howMany = e.nodesToHandle;
        }
        n.type == "attribute" && (e.offset >= n.offset && r <= s ? (e.nodesToHandle = 0, e.howMany = 0, e.offset = 0) : e.offset <= n.offset && r >= s && (n.howMany = 0));
      }
    }
    e.howMany = e.nodesToHandle, delete e.nodesToHandle;
  }
  /**
   * Returns an object with a single insert change description.
   *
   * @param parent The element in which the change happened.
   * @param offset The offset at which change happened.
   * @param elementSnapshot The snapshot of the removed element a character.
   * @returns The diff item.
   */
  _getInsertDiff(e, t, n) {
    return {
      type: "insert",
      position: oe._createAt(e, t),
      name: n.name,
      attributes: new Map(n.attributes),
      length: 1,
      changeCount: this._changeCount++
    };
  }
  /**
   * Returns an object with a single remove change description.
   *
   * @param parent The element in which change happened.
   * @param offset The offset at which change happened.
   * @param elementSnapshot The snapshot of the removed element a character.
   * @returns The diff item.
   */
  _getRemoveDiff(e, t, n) {
    return {
      type: "remove",
      position: oe._createAt(e, t),
      name: n.name,
      attributes: new Map(n.attributes),
      length: 1,
      changeCount: this._changeCount++
    };
  }
  /**
   * Returns an array of objects where each one is a single attribute change description.
   *
   * @param range The range where the change happened.
   * @param oldAttributes A map, map iterator or compatible object that contains attributes before the change.
   * @param newAttributes A map, map iterator or compatible object that contains attributes after the change.
   * @returns An array containing one or more diff items.
   */
  _getAttributesDiff(e, t, n) {
    const r = [];
    n = new Map(n);
    for (const [s, o] of t) {
      const l = n.has(s) ? n.get(s) : null;
      l !== o && r.push({
        type: "attribute",
        position: e.start,
        range: e.clone(),
        length: 1,
        attributeKey: s,
        attributeOldValue: o,
        attributeNewValue: l,
        changeCount: this._changeCount++
      }), n.delete(s);
    }
    for (const [s, o] of n)
      r.push({
        type: "attribute",
        position: e.start,
        range: e.clone(),
        length: 1,
        attributeKey: s,
        attributeOldValue: null,
        attributeNewValue: o,
        changeCount: this._changeCount++
      });
    return r;
  }
  /**
   * Checks whether given element or any of its parents is an element that is buffered as an inserted element.
   */
  _isInInsertedElement(e) {
    const t = e.parent;
    if (!t)
      return !1;
    const n = this._changesInElement.get(t), r = e.startOffset;
    if (n) {
      for (const s of n)
        if (s.type == "insert" && r >= s.offset && r < s.offset + s.howMany)
          return !0;
    }
    return this._isInInsertedElement(t);
  }
  /**
   * Removes deeply all buffered changes that are registered in elements from range specified by `parent`, `offset`
   * and `howMany`.
   */
  _removeAllNestedChanges(e, t, n) {
    const r = new X(oe._createAt(e, t), oe._createAt(e, t + n));
    for (const s of r.getItems({ shallow: !0 }))
      s.is("element") && (this._elementSnapshots.delete(s), this._changesInElement.delete(s), this._removeAllNestedChanges(s, 0, s.maxOffset));
  }
}
function wb(i) {
  const e = [];
  for (const t of i)
    if (t.is("$text"))
      for (let n = 0; n < t.data.length; n++)
        e.push({
          name: "$text",
          attributes: new Map(t.getAttributes())
        });
    else
      e.push({
        name: t.name,
        attributes: new Map(t.getAttributes())
      });
  return e;
}
function W8(i, e) {
  const t = [];
  let n = 0, r = 0;
  for (const s of e) {
    if (s.offset > n) {
      for (let o = 0; o < s.offset - n; o++)
        t.push("e");
      r += s.offset - n;
    }
    if (s.type == "insert") {
      for (let o = 0; o < s.howMany; o++)
        t.push("i");
      n = s.offset + s.howMany;
    } else if (s.type == "remove") {
      for (let o = 0; o < s.howMany; o++)
        t.push("r");
      n = s.offset, r += s.howMany;
    } else
      t.push(..."a".repeat(s.howMany).split("")), n = s.offset + s.howMany, r += s.howMany;
  }
  if (r < i)
    for (let s = 0; s < i - r - n; s++)
      t.push("e");
  return t;
}
function j8(i) {
  const e = "position" in i && i.position.root.rootName == "$graveyard", t = "range" in i && i.range.root.rootName == "$graveyard";
  return !e && !t;
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class U8 {
  constructor() {
    this._operations = [], this._undoPairs = /* @__PURE__ */ new Map(), this._undoneOperations = /* @__PURE__ */ new Set(), this._baseVersionToOperationIndex = /* @__PURE__ */ new Map(), this._version = 0, this._gaps = /* @__PURE__ */ new Map();
  }
  /**
   * The version of the last operation in the history.
   *
   * The history version is incremented automatically when a new operation is added to the history.
   * Setting the version manually should be done only in rare circumstances when a gap is planned
   * between history versions. When doing so, a gap will be created and the history will accept adding
   * an operation with base version equal to the new history version.
   */
  get version() {
    return this._version;
  }
  set version(e) {
    this._operations.length && e > this._version + 1 && this._gaps.set(this._version, e), this._version = e;
  }
  /**
   * The last history operation.
   */
  get lastOperation() {
    return this._operations[this._operations.length - 1];
  }
  /**
   * Adds an operation to the history and increments the history version.
   *
   * The operation's base version should be equal to the history version. Otherwise an error is thrown.
   */
  addOperation(e) {
    if (e.baseVersion !== this.version)
      throw new B("model-document-history-addoperation-incorrect-version", this, {
        operation: e,
        historyVersion: this.version
      });
    this._operations.push(e), this._version++, this._baseVersionToOperationIndex.set(e.baseVersion, this._operations.length - 1);
  }
  /**
   * Returns operations from the given range of operation base versions that were added to the history.
   *
   * Note that there may be gaps in operations base versions.
   *
   * @param fromBaseVersion Base version from which operations should be returned (inclusive).
   * @param toBaseVersion Base version up to which operations should be returned (exclusive).
   * @returns History operations for the given range, in chronological order.
   */
  getOperations(e, t = this.version) {
    if (!this._operations.length)
      return [];
    const n = this._operations[0];
    e === void 0 && (e = n.baseVersion);
    let r = t - 1;
    for (const [l, u] of this._gaps)
      e > l && e < u && (e = u), r > l && r < u && (r = l - 1);
    if (r < n.baseVersion || e > this.lastOperation.baseVersion)
      return [];
    let s = this._baseVersionToOperationIndex.get(e);
    s === void 0 && (s = 0);
    let o = this._baseVersionToOperationIndex.get(r);
    return o === void 0 && (o = this._operations.length - 1), this._operations.slice(
      s,
      // The `toIndex` should be included in the returned operations, so add `1`.
      o + 1
    );
  }
  /**
   * Returns operation from the history that bases on given `baseVersion`.
   *
   * @param baseVersion Base version of the operation to get.
   * @returns Operation with given base version or `undefined` if there is no such operation in history.
   */
  getOperation(e) {
    const t = this._baseVersionToOperationIndex.get(e);
    if (t !== void 0)
      return this._operations[t];
  }
  /**
   * Marks in history that one operation is an operation that is undoing the other operation. By marking operation this way,
   * history is keeping more context information about operations, which helps in operational transformation.
   *
   * @param undoneOperation Operation which is undone by `undoingOperation`.
   * @param undoingOperation Operation which undoes `undoneOperation`.
   */
  setOperationAsUndone(e, t) {
    this._undoPairs.set(t, e), this._undoneOperations.add(e);
  }
  /**
   * Checks whether given `operation` is undoing any other operation.
   *
   * @param operation Operation to check.
   * @returns `true` if given `operation` is undoing any other operation, `false` otherwise.
   */
  isUndoingOperation(e) {
    return this._undoPairs.has(e);
  }
  /**
   * Checks whether given `operation` has been undone by any other operation.
   *
   * @param operation Operation to check.
   * @returns `true` if given `operation` has been undone any other operation, `false` otherwise.
   */
  isUndoneOperation(e) {
    return this._undoneOperations.has(e);
  }
  /**
   * For given `undoingOperation`, returns the operation which has been undone by it.
   *
   * @returns Operation that has been undone by given `undoingOperation` or `undefined`
   * if given `undoingOperation` is not undoing any other operation.
   */
  getUndoneOperation(e) {
    return this._undoPairs.get(e);
  }
  /**
   * Resets the history of operations.
   */
  reset() {
    this._version = 0, this._undoPairs = /* @__PURE__ */ new Map(), this._operations = [], this._undoneOperations = /* @__PURE__ */ new Set(), this._gaps = /* @__PURE__ */ new Map(), this._baseVersionToOperationIndex = /* @__PURE__ */ new Map();
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class Pd extends gt {
  /**
   * Creates root element.
   *
   * @param document Document that is an owner of this root.
   * @param name Node name.
   * @param rootName Unique root name used to identify this root element by {@link module:engine/model/document~Document}.
   */
  constructor(e, t, n = "main") {
    super(t), this._isAttached = !0, this._document = e, this.rootName = n;
  }
  /**
   * {@link module:engine/model/document~Document Document} that owns this root element.
   */
  get document() {
    return this._document;
  }
  /**
   * Informs if the root element is currently attached to the document, or not.
   *
   * A detached root is equivalent to being removed and cannot contain any children or markers.
   *
   * By default, a newly added root is attached. It can be detached using
   * {@link module:engine/model/writer~Writer#detachRoot `Writer#detachRoot`}. A detached root can be re-attached again using
   * {@link module:engine/model/writer~Writer#addRoot `Writer#addRoot`}.
   */
  isAttached() {
    return this._isAttached;
  }
  /**
   * Converts `RootElement` instance to `string` containing its name.
   *
   * @returns `RootElement` instance converted to `string`.
   */
  toJSON() {
    return this.rootName;
  }
}
Pd.prototype.is = function(i, e) {
  return e ? e === this.name && (i === "rootElement" || i === "model:rootElement" || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
  i === "element" || i === "model:element") : i === "rootElement" || i === "model:rootElement" || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
  i === "element" || i === "model:element" || i === "node" || i === "model:node";
};
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const Sm = "$graveyard";
class H8 extends kt() {
  /**
   * Creates an empty document instance with no {@link #roots} (other than
   * the {@link #graveyard graveyard root}).
   */
  constructor(e) {
    super(), this.model = e, this.history = new U8(), this.selection = new zi(this), this.roots = new Br({ idProperty: "rootName" }), this.differ = new z8(e.markers), this._postFixers = /* @__PURE__ */ new Set(), this._hasSelectionChangedFromTheLastChangeBlock = !1, this.createRoot("$root", Sm), this.listenTo(e, "applyOperation", (t, n) => {
      const r = n[0];
      r.isDocumentOperation && this.differ.bufferOperation(r);
    }, { priority: "high" }), this.listenTo(e, "applyOperation", (t, n) => {
      const r = n[0];
      r.isDocumentOperation && this.history.addOperation(r);
    }, { priority: "low" }), this.listenTo(this.selection, "change", () => {
      this._hasSelectionChangedFromTheLastChangeBlock = !0;
    }), this.listenTo(e.markers, "update", (t, n, r, s, o) => {
      const l = { ...n.getData(), range: s };
      this.differ.bufferMarkerChange(n.name, o, l), r === null && n.on("change", (u, h) => {
        const f = n.getData();
        this.differ.bufferMarkerChange(n.name, { ...f, range: h }, f);
      });
    }), this.registerPostFixer((t) => {
      let n = !1;
      for (const r of this.roots)
        !r.isAttached() && !r.isEmpty && (t.remove(t.createRangeIn(r)), n = !0);
      for (const r of this.model.markers)
        r.getRange().root.isAttached() || (t.removeMarker(r), n = !0);
      return n;
    });
  }
  /**
   * The document version. Every applied operation increases the version number. It is used to
   * ensure that operations are applied on a proper document version.
   *
   * This property is equal to {@link module:engine/model/history~History#version `model.Document#history#version`}.
   *
   * If the {@link module:engine/model/operation/operation~Operation#baseVersion base version} does not match the document version,
   * a {@link module:utils/ckeditorerror~CKEditorError model-document-applyoperation-wrong-version} error is thrown.
   */
  get version() {
    return this.history.version;
  }
  set version(e) {
    this.history.version = e;
  }
  /**
   * The graveyard tree root. A document always has a graveyard root that stores removed nodes.
   */
  get graveyard() {
    return this.getRoot(Sm);
  }
  /**
   * Creates a new root.
   *
   * **Note:** do not use this method after the editor has been initialized! If you want to dynamically add a root, use
   * {@link module:engine/model/writer~Writer#addRoot `model.Writer#addRoot`} instead.
   *
   * @param elementName The element name. Defaults to `'$root'` which also has some basic schema defined
   * (e.g. `$block` elements are allowed inside the `$root`). Make sure to define a proper schema if you use a different name.
   * @param rootName A unique root name.
   * @returns The created root.
   */
  createRoot(e = "$root", t = "main") {
    if (this.roots.get(t))
      throw new B("model-document-createroot-name-exists", this, { name: t });
    const n = new Pd(this, e, t);
    return this.roots.add(n), n;
  }
  /**
   * Removes all event listeners set by the document instance.
   */
  destroy() {
    this.selection.destroy(), this.stopListening();
  }
  /**
   * Returns a root by its name.
   *
   * Detached roots are returned by this method. This is to be able to operate on the detached root (for example, to be able to create
   * a position inside such a root for undo feature purposes).
   *
   * @param name The root name of the root to return.
   * @returns The root registered under a given name or `null` when there is no root with the given name.
   */
  getRoot(e = "main") {
    return this.roots.get(e);
  }
  /**
   * Returns an array with names of all roots added to the document (except the {@link #graveyard graveyard root}).
   *
   * Detached roots **are not** returned by this method by default. This is to make sure that all features or algorithms that operate
   * on the document data know which roots are still a part of the document and should be processed.
   *
   * @param includeDetached Specified whether detached roots should be returned as well.
   * @returns Roots names.
   */
  getRootNames(e = !1) {
    return Array.from(this.roots).filter((t) => t.rootName != Sm && (e || t.isAttached())).map((t) => t.rootName);
  }
  /**
   * Used to register a post-fixer callback. A post-fixer mechanism guarantees that the features
   * will operate on a correct model state.
   *
   * An execution of a feature may lead to an incorrect document tree state. The callbacks are used to fix the document tree after
   * it has changed. Post-fixers are fired just after all changes from the outermost change block were applied but
   * before the {@link module:engine/model/document~Document#event:change change event} is fired. If a post-fixer callback made
   * a change, it should return `true`. When this happens, all post-fixers are fired again to check if something else should
   * not be fixed in the new document tree state.
   *
   * As a parameter, a post-fixer callback receives a {@link module:engine/model/writer~Writer writer} instance connected with the
   * executed changes block. Thanks to that, all changes done by the callback will be added to the same
   * {@link module:engine/model/batch~Batch batch} (and undo step) as the original changes. This makes post-fixer changes transparent
   * for the user.
   *
   * An example of a post-fixer is a callback that checks if all the data were removed from the editor. If so, the
   * callback should add an empty paragraph so that the editor is never empty:
   *
   * ```ts
   * document.registerPostFixer( writer => {
   * 	const changes = document.differ.getChanges();
   *
   * 	// Check if the changes lead to an empty root in the editor.
   * 	for ( const entry of changes ) {
   * 		if ( entry.type == 'remove' && entry.position.root.isEmpty ) {
   * 			writer.insertElement( 'paragraph', entry.position.root, 0 );
   *
   * 			// It is fine to return early, even if multiple roots would need to be fixed.
   * 			// All post-fixers will be fired again, so if there are more empty roots, those will be fixed, too.
   * 			return true;
   * 		}
   * 	}
   *
   * 	return false;
   * } );
   * ```
   */
  registerPostFixer(e) {
    this._postFixers.add(e);
  }
  /**
   * A custom `toJSON()` method to solve child-parent circular dependencies.
   *
   * @returns A clone of this object with the document property changed to a string.
   */
  toJSON() {
    const e = aE(this);
    return e.selection = "[engine.model.DocumentSelection]", e.model = "[engine.model.Model]", e;
  }
  /**
   * Check if there were any changes done on document, and if so, call post-fixers,
   * fire `change` event for features and conversion and then reset the differ.
   * Fire `change:data` event when at least one operation or buffered marker changes the data.
   *
   * @internal
   * @fires change
   * @fires change:data
   * @param writer The writer on which post-fixers will be called.
   */
  _handleChangeBlock(e) {
    this._hasDocumentChangedFromTheLastChangeBlock() && (this._callPostFixers(e), this.selection.refresh(), this.differ.hasDataChanges() ? this.fire("change:data", e.batch) : this.fire("change", e.batch), this.selection.refresh(), this.differ.reset()), this._hasSelectionChangedFromTheLastChangeBlock = !1;
  }
  /**
   * Returns whether there is a buffered change or if the selection has changed from the last
   * {@link module:engine/model/model~Model#enqueueChange `enqueueChange()` block}
   * or {@link module:engine/model/model~Model#change `change()` block}.
   *
   * @returns Returns `true` if document has changed from the last `change()` or `enqueueChange()` block.
   */
  _hasDocumentChangedFromTheLastChangeBlock() {
    return !this.differ.isEmpty || this._hasSelectionChangedFromTheLastChangeBlock;
  }
  /**
   * Returns the default root for this document which is either the first root that was added to the document using
   * {@link #createRoot} or the {@link #graveyard graveyard root} if no other roots were created.
   *
   * @returns The default root for this document.
   */
  _getDefaultRoot() {
    for (const e of this.roots)
      if (e !== this.graveyard)
        return e;
    return this.graveyard;
  }
  /**
   * Returns the default range for this selection. The default range is a collapsed range that starts and ends
   * at the beginning of this selection's document {@link #_getDefaultRoot default root}.
   *
   * @internal
   */
  _getDefaultRange() {
    const e = this._getDefaultRoot(), t = this.model, n = t.schema, r = t.createPositionFromPath(e, [0]);
    return n.getNearestSelectionRange(r) || t.createRange(r);
  }
  /**
   * Checks whether a given {@link module:engine/model/range~Range range} is a valid range for
   * the {@link #selection document's selection}.
   *
   * @internal
   * @param range A range to check.
   * @returns `true` if `range` is valid, `false` otherwise.
   */
  _validateSelectionRange(e) {
    return bb(e.start) && bb(e.end);
  }
  /**
   * Performs post-fixer loops. Executes post-fixer callbacks as long as none of them has done any changes to the model.
   *
   * @param writer The writer on which post-fixer callbacks will be called.
   */
  _callPostFixers(e) {
    let t = !1;
    do
      for (const n of this._postFixers)
        if (this.selection.refresh(), t = n(e), t)
          break;
    while (t);
  }
}
function bb(i) {
  const e = i.textNode;
  if (e) {
    const t = e.data, n = i.offset - e.startOffset;
    return !rp(t, n) && !sp(t, n);
  }
  return !0;
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class q8 extends kt() {
  constructor() {
    super(...arguments), this._markers = /* @__PURE__ */ new Map();
  }
  /**
   * Iterable interface.
   *
   * Iterates over all {@link ~Marker markers} added to the collection.
   */
  [Symbol.iterator]() {
    return this._markers.values();
  }
  /**
   * Checks if given {@link ~Marker marker} or marker name is in the collection.
   *
   * @param markerOrName Name of marker or marker instance to check.
   * @returns `true` if marker is in the collection, `false` otherwise.
   */
  has(e) {
    const t = e instanceof Ro ? e.name : e;
    return this._markers.has(t);
  }
  /**
   * Returns {@link ~Marker marker} with given `markerName`.
   *
   * @param markerName Name of marker to get.
   * @returns Marker with given name or `null` if such marker was
   * not added to the collection.
   */
  get(e) {
    return this._markers.get(e) || null;
  }
  /**
   * Creates and adds a {@link ~Marker marker} to the `MarkerCollection` with given name on given
   * {@link module:engine/model/range~Range range}.
   *
   * If `MarkerCollection` already had a marker with given name (or {@link ~Marker marker} was passed), the marker in
   * collection is updated and {@link module:engine/model/markercollection~MarkerCollection#event:update} event is fired
   * but only if there was a change (marker range or {@link module:engine/model/markercollection~Marker#managedUsingOperations}
   * flag has changed.
   *
   * @internal
   * @fires update
   * @param markerOrName Name of marker to set or marker instance to update.
   * @param range Marker range.
   * @param managedUsingOperations Specifies whether the marker is managed using operations.
   * @param affectsData Specifies whether the marker affects the data produced by the data pipeline
   * (is persisted in the editor's data).
   * @returns `Marker` instance which was added or updated.
   */
  _set(e, t, n = !1, r = !1) {
    const s = e instanceof Ro ? e.name : e;
    if (s.includes(","))
      throw new B("markercollection-incorrect-marker-name", this);
    const o = this._markers.get(s);
    if (o) {
      const h = o.getData(), f = o.getRange();
      let m = !1;
      return f.isEqual(t) || (o._attachLiveRange(ur.fromRange(t)), m = !0), n != o.managedUsingOperations && (o._managedUsingOperations = n, m = !0), typeof r == "boolean" && r != o.affectsData && (o._affectsData = r, m = !0), m && this.fire(`update:${s}`, o, f, t, h), o;
    }
    const l = ur.fromRange(t), u = new Ro(s, l, n, r);
    return this._markers.set(s, u), this.fire(`update:${s}`, u, null, t, { ...u.getData(), range: null }), u;
  }
  /**
   * Removes given {@link ~Marker marker} or a marker with given name from the `MarkerCollection`.
   *
   * @internal
   * @fires update
   * @param markerOrName Marker or name of a marker to remove.
   * @returns `true` if marker was found and removed, `false` otherwise.
   */
  _remove(e) {
    const t = e instanceof Ro ? e.name : e, n = this._markers.get(t);
    return n ? (this._markers.delete(t), this.fire(`update:${t}`, n, n.getRange(), null, n.getData()), this._destroyMarker(n), !0) : !1;
  }
  /**
   * Fires an {@link module:engine/model/markercollection~MarkerCollection#event:update} event for the given {@link ~Marker marker}
   * but does not change the marker. Useful to force {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher downcast
   * conversion} for the marker.
   *
   * @internal
   * @fires update
   * @param markerOrName Marker or name of a marker to refresh.
   */
  _refresh(e) {
    const t = e instanceof Ro ? e.name : e, n = this._markers.get(t);
    if (!n)
      throw new B("markercollection-refresh-marker-not-exists", this);
    const r = n.getRange();
    this.fire(`update:${t}`, n, r, r, n.getData());
  }
  /**
   * Returns iterator that iterates over all markers, which ranges contain given {@link module:engine/model/position~Position position}.
   */
  *getMarkersAtPosition(e) {
    for (const t of this)
      t.getRange().containsPosition(e) && (yield t);
  }
  /**
   * Returns iterator that iterates over all markers, which intersects with given {@link module:engine/model/range~Range range}.
   */
  *getMarkersIntersectingRange(e) {
    for (const t of this)
      t.getRange().getIntersection(e) !== null && (yield t);
  }
  /**
   * Destroys marker collection and all markers inside it.
   */
  destroy() {
    for (const e of this._markers.values())
      this._destroyMarker(e);
    this._markers = null, this.stopListening();
  }
  /**
   * Iterates over all markers that starts with given `prefix`.
   *
   * ```ts
   * const markerFooA = markersCollection.set( 'foo:a', rangeFooA );
   * const markerFooB = markersCollection.set( 'foo:b', rangeFooB );
   * const markerBarA = markersCollection.set( 'bar:a', rangeBarA );
   * const markerFooBarA = markersCollection.set( 'foobar:a', rangeFooBarA );
   * Array.from( markersCollection.getMarkersGroup( 'foo' ) ); // [ markerFooA, markerFooB ]
   * Array.from( markersCollection.getMarkersGroup( 'a' ) ); // []
   * ```
   */
  *getMarkersGroup(e) {
    for (const t of this._markers.values())
      t.name.startsWith(e + ":") && (yield t);
  }
  /**
   * Destroys the marker.
   */
  _destroyMarker(e) {
    e.stopListening(), e._detachLiveRange();
  }
}
class Ro extends kt(ls) {
  /**
   * Creates a marker instance.
   *
   * @param name Marker name.
   * @param liveRange Range marked by the marker.
   * @param managedUsingOperations Specifies whether the marker is managed using operations.
   * @param affectsData Specifies whether the marker affects the data produced by the data pipeline (is persisted in the editor's data).
   */
  constructor(e, t, n, r) {
    super(), this.name = e, this._liveRange = this._attachLiveRange(t), this._managedUsingOperations = n, this._affectsData = r;
  }
  /**
   * A value indicating if the marker is managed using operations.
   * See {@link ~Marker marker class description} to learn more about marker types.
   * See {@link module:engine/model/writer~Writer#addMarker}.
   */
  get managedUsingOperations() {
    if (!this._liveRange)
      throw new B("marker-destroyed", this);
    return this._managedUsingOperations;
  }
  /**
   * A value indicating if the marker changes the data.
   */
  get affectsData() {
    if (!this._liveRange)
      throw new B("marker-destroyed", this);
    return this._affectsData;
  }
  /**
   * Returns the marker data (properties defining the marker).
   */
  getData() {
    return {
      range: this.getRange(),
      affectsData: this.affectsData,
      managedUsingOperations: this.managedUsingOperations
    };
  }
  /**
   * Returns current marker start position.
   */
  getStart() {
    if (!this._liveRange)
      throw new B("marker-destroyed", this);
    return this._liveRange.start.clone();
  }
  /**
   * Returns current marker end position.
   */
  getEnd() {
    if (!this._liveRange)
      throw new B("marker-destroyed", this);
    return this._liveRange.end.clone();
  }
  /**
   * Returns a range that represents the current state of the marker.
   *
   * Keep in mind that returned value is a {@link module:engine/model/range~Range Range}, not a
   * {@link module:engine/model/liverange~LiveRange LiveRange}. This means that it is up-to-date and relevant only
   * until next model document change. Do not store values returned by this method. Instead, store {@link ~Marker#name}
   * and get `Marker` instance from {@link module:engine/model/markercollection~MarkerCollection MarkerCollection} every
   * time there is a need to read marker properties. This will guarantee that the marker has not been removed and
   * that it's data is up-to-date.
   */
  getRange() {
    if (!this._liveRange)
      throw new B("marker-destroyed", this);
    return this._liveRange.toRange();
  }
  /**
   * Binds new live range to the marker and detach the old one if is attached.
   *
   * @internal
   * @param liveRange Live range to attach
   * @returns Attached live range.
   */
  _attachLiveRange(e) {
    return this._liveRange && this._detachLiveRange(), e.delegate("change:range").to(this), e.delegate("change:content").to(this), this._liveRange = e, e;
  }
  /**
   * Unbinds and destroys currently attached live range.
   *
   * @internal
   */
  _detachLiveRange() {
    this._liveRange.stopDelegating("change:range", this), this._liveRange.stopDelegating("change:content", this), this._liveRange.detach(), this._liveRange = null;
  }
}
Ro.prototype.is = function(i) {
  return i === "marker" || i === "model:marker";
};
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class K8 extends fi {
  /**
   * Creates an insert operation.
   *
   * @param sourcePosition Position before the first {@link module:engine/model/item~Item model item} to move.
   * @param howMany Offset size of moved range. Moved range will start from `sourcePosition` and end at
   * `sourcePosition` with offset shifted by `howMany`.
   */
  constructor(e, t) {
    super(null), this.sourcePosition = e.clone(), this.howMany = t;
  }
  /**
   * @inheritDoc
   */
  get type() {
    return "detach";
  }
  /**
   * @inheritDoc
   */
  toJSON() {
    const e = super.toJSON();
    return e.sourcePosition = this.sourcePosition.toJSON(), e;
  }
  /**
   * @inheritDoc
   * @internal
   */
  _validate() {
    if (this.sourcePosition.root.document)
      throw new B("detach-operation-on-document-node", this);
  }
  /**
   * @inheritDoc
   * @internal
   */
  _execute() {
    fC(X._createFromPositionAndShift(this.sourcePosition, this.howMany));
  }
  /**
   * @inheritDoc
   */
  static get className() {
    return "DetachOperation";
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class kr extends ls {
  /**
   * Creates an empty `DocumentFragment`.
   *
   * **Note:** Constructor of this class shouldn't be used directly in the code.
   * Use the {@link module:engine/model/writer~Writer#createDocumentFragment} method instead.
   *
   * @internal
   * @param children Nodes to be contained inside the `DocumentFragment`.
   */
  constructor(e) {
    super(), this.markers = /* @__PURE__ */ new Map(), this._children = new dl(), e && this._insertChild(0, e);
  }
  /**
   * Returns an iterator that iterates over all nodes contained inside this document fragment.
   */
  [Symbol.iterator]() {
    return this.getChildren();
  }
  /**
   * Number of this document fragment's children.
   */
  get childCount() {
    return this._children.length;
  }
  /**
   * Sum of {@link module:engine/model/node~Node#offsetSize offset sizes} of all of this document fragment's children.
   */
  get maxOffset() {
    return this._children.maxOffset;
  }
  /**
   * Is `true` if there are no nodes inside this document fragment, `false` otherwise.
   */
  get isEmpty() {
    return this.childCount === 0;
  }
  /**
   * Artificial next sibling. Returns `null`. Added for compatibility reasons.
   */
  get nextSibling() {
    return null;
  }
  /**
   * Artificial previous sibling. Returns `null`. Added for compatibility reasons.
   */
  get previousSibling() {
    return null;
  }
  /**
   * Artificial root of `DocumentFragment`. Returns itself. Added for compatibility reasons.
   */
  get root() {
    return this;
  }
  /**
   * Artificial parent of `DocumentFragment`. Returns `null`. Added for compatibility reasons.
   */
  get parent() {
    return null;
  }
  /**
   * Artificial owner of `DocumentFragment`. Returns `null`. Added for compatibility reasons.
   */
  get document() {
    return null;
  }
  /**
   * Returns `false` as `DocumentFragment` by definition is not attached to a document. Added for compatibility reasons.
   */
  isAttached() {
    return !1;
  }
  /**
   * Returns empty array. Added for compatibility reasons.
   */
  getAncestors() {
    return [];
  }
  /**
   * Gets the child at the given index. Returns `null` if incorrect index was passed.
   *
   * @param index Index of child.
   * @returns Child node.
   */
  getChild(e) {
    return this._children.getNode(e);
  }
  /**
   * Returns an iterator that iterates over all of this document fragment's children.
   */
  getChildren() {
    return this._children[Symbol.iterator]();
  }
  /**
   * Returns an index of the given child node. Returns `null` if given node is not a child of this document fragment.
   *
   * @param node Child node to look for.
   * @returns Child node's index.
   */
  getChildIndex(e) {
    return this._children.getNodeIndex(e);
  }
  /**
   * Returns the starting offset of given child. Starting offset is equal to the sum of
   * {@link module:engine/model/node~Node#offsetSize offset sizes} of all node's siblings that are before it. Returns `null` if
   * given node is not a child of this document fragment.
   *
   * @param node Child node to look for.
   * @returns Child node's starting offset.
   */
  getChildStartOffset(e) {
    return this._children.getNodeStartOffset(e);
  }
  /**
   * Returns path to a `DocumentFragment`, which is an empty array. Added for compatibility reasons.
   */
  getPath() {
    return [];
  }
  /**
   * Returns a descendant node by its path relative to this element.
   *
   * ```ts
   * // <this>a<b>c</b></this>
   * this.getNodeByPath( [ 0 ] );     // -> "a"
   * this.getNodeByPath( [ 1 ] );     // -> <b>
   * this.getNodeByPath( [ 1, 0 ] );  // -> "c"
   * ```
   *
   * @param relativePath Path of the node to find, relative to this element.
   */
  getNodeByPath(e) {
    let t = this;
    for (const n of e)
      t = t.getChild(t.offsetToIndex(n));
    return t;
  }
  /**
   * Converts offset "position" to index "position".
   *
   * Returns index of a node that occupies given offset. If given offset is too low, returns `0`. If given offset is
   * too high, returns index after last child.
   *
   * ```ts
   * const textNode = new Text( 'foo' );
   * const pElement = new Element( 'p' );
   * const docFrag = new DocumentFragment( [ textNode, pElement ] );
   * docFrag.offsetToIndex( -1 ); // Returns 0, because offset is too low.
   * docFrag.offsetToIndex( 0 ); // Returns 0, because offset 0 is taken by `textNode` which is at index 0.
   * docFrag.offsetToIndex( 1 ); // Returns 0, because `textNode` has `offsetSize` equal to 3, so it occupies offset 1 too.
   * docFrag.offsetToIndex( 2 ); // Returns 0.
   * docFrag.offsetToIndex( 3 ); // Returns 1.
   * docFrag.offsetToIndex( 4 ); // Returns 2. There are no nodes at offset 4, so last available index is returned.
   * ```
   *
   * @param offset Offset to look for.
   * @returns Index of a node that occupies given offset.
   */
  offsetToIndex(e) {
    return this._children.offsetToIndex(e);
  }
  /**
   * Converts `DocumentFragment` instance to plain object and returns it.
   * Takes care of converting all of this document fragment's children.
   *
   * @returns `DocumentFragment` instance converted to plain object.
   */
  toJSON() {
    const e = [];
    for (const t of this._children)
      e.push(t.toJSON());
    return e;
  }
  /**
   * Creates a `DocumentFragment` instance from given plain object (i.e. parsed JSON string).
   * Converts `DocumentFragment` children to proper nodes.
   *
   * @param json Plain object to be converted to `DocumentFragment`.
   * @returns `DocumentFragment` instance created using given plain object.
   */
  static fromJSON(e) {
    const t = [];
    for (const n of e)
      n.name ? t.push(gt.fromJSON(n)) : t.push(Dt.fromJSON(n));
    return new kr(t);
  }
  /**
   * {@link #_insertChild Inserts} one or more nodes at the end of this document fragment.
   *
   * @internal
   * @param items Items to be inserted.
   */
  _appendChild(e) {
    this._insertChild(this.childCount, e);
  }
  /**
   * Inserts one or more nodes at the given index and sets {@link module:engine/model/node~Node#parent parent} of these nodes
   * to this document fragment.
   *
   * @internal
   * @param index Index at which nodes should be inserted.
   * @param items Items to be inserted.
   */
  _insertChild(e, t) {
    const n = G8(t);
    for (const r of n)
      r.parent !== null && r._remove(), r.parent = this;
    this._children._insertNodes(e, n);
  }
  /**
   * Removes one or more nodes starting at the given index
   * and sets {@link module:engine/model/node~Node#parent parent} of these nodes to `null`.
   *
   * @internal
   * @param index Index of the first node to remove.
   * @param howMany Number of nodes to remove.
   * @returns Array containing removed nodes.
   */
  _removeChildren(e, t = 1) {
    const n = this._children._removeNodes(e, t);
    for (const r of n)
      r.parent = null;
    return n;
  }
}
kr.prototype.is = function(i) {
  return i === "documentFragment" || i === "model:documentFragment";
};
function G8(i) {
  return typeof i == "string" ? [new Dt(i)] : (di(i) || (i = [i]), Array.from(i).map((e) => typeof e == "string" ? new Dt(e) : e instanceof Bi ? new Dt(e.data, e.getAttributes()) : e));
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class Y8 {
  /**
   * Creates a writer instance.
   *
   * **Note:** It is not recommended to use it directly. Use {@link module:engine/model/model~Model#change `Model#change()`} or
   * {@link module:engine/model/model~Model#enqueueChange `Model#enqueueChange()`} instead.
   *
   * @internal
   */
  constructor(e, t) {
    this.model = e, this.batch = t;
  }
  /**
   * Creates a new {@link module:engine/model/text~Text text node}.
   *
   * ```ts
   * writer.createText( 'foo' );
   * writer.createText( 'foo', { bold: true } );
   * ```
   *
   * @param data Text data.
   * @param attributes Text attributes.
   * @returns {module:engine/model/text~Text} Created text node.
   */
  createText(e, t) {
    return new Dt(e, t);
  }
  /**
   * Creates a new {@link module:engine/model/element~Element element}.
   *
   * ```ts
   * writer.createElement( 'paragraph' );
   * writer.createElement( 'paragraph', { alignment: 'center' } );
   * ```
   *
   * @param name Name of the element.
   * @param attributes Elements attributes.
   * @returns Created element.
   */
  createElement(e, t) {
    return new gt(e, t);
  }
  /**
   * Creates a new {@link module:engine/model/documentfragment~DocumentFragment document fragment}.
   *
   * @returns Created document fragment.
   */
  createDocumentFragment() {
    return new kr();
  }
  /**
   * Creates a copy of the element and returns it. Created element has the same name and attributes as the original element.
   * If clone is deep, the original element's children are also cloned. If not, then empty element is returned.
   *
   * @param element The element to clone.
   * @param deep If set to `true` clones element and all its children recursively. When set to `false`,
   * element will be cloned without any child.
   */
  cloneElement(e, t = !0) {
    return e._clone(t);
  }
  /**
   * Inserts item on given position.
   *
   * ```ts
   * const paragraph = writer.createElement( 'paragraph' );
   * writer.insert( paragraph, position );
   * ```
   *
   * Instead of using position you can use parent and offset:
   *
   * ```ts
   * const text = writer.createText( 'foo' );
   * writer.insert( text, paragraph, 5 );
   * ```
   *
   * You can also use `end` instead of the offset to insert at the end:
   *
   * ```ts
   * const text = writer.createText( 'foo' );
   * writer.insert( text, paragraph, 'end' );
   * ```
   *
   * Or insert before or after another element:
   *
   * ```ts
   * const paragraph = writer.createElement( 'paragraph' );
   * writer.insert( paragraph, anotherParagraph, 'after' );
   * ```
   *
   * These parameters works the same way as {@link #createPositionAt `writer.createPositionAt()`}.
   *
   * Note that if the item already has parent it will be removed from the previous parent.
   *
   * Note that you cannot re-insert a node from a document to a different document or a document fragment. In this case,
   * `model-writer-insert-forbidden-move` is thrown.
   *
   * If you want to move {@link module:engine/model/range~Range range} instead of an
   * {@link module:engine/model/item~Item item} use {@link module:engine/model/writer~Writer#move `Writer#move()`}.
   *
   * **Note:** For a paste-like content insertion mechanism see
   * {@link module:engine/model/model~Model#insertContent `model.insertContent()`}.
   *
   * @param item Item or document fragment to insert.
   * @param offset Offset or one of the flags. Used only when second parameter is a {@link module:engine/model/item~Item model item}.
   */
  insert(e, t, n = 0) {
    if (this._assertWriterUsedCorrectly(), e instanceof Dt && e.data == "")
      return;
    const r = oe._createAt(t, n);
    if (e.parent)
      if (Cb(e.root, r.root)) {
        this.move(X._createOn(e), r);
        return;
      } else {
        if (e.root.document)
          throw new B("model-writer-insert-forbidden-move", this);
        this.remove(e);
      }
    const s = r.root.document ? r.root.document.version : null, o = new pn(r, e, s);
    if (e instanceof Dt && (o.shouldReceiveAttributes = !0), this.batch.addOperation(o), this.model.applyOperation(o), e instanceof kr)
      for (const [l, u] of e.markers) {
        const h = oe._createAt(u.root, 0), m = { range: new X(u.start._getCombined(h, r), u.end._getCombined(h, r)), usingOperation: !0, affectsData: !0 };
        this.model.markers.has(l) ? this.updateMarker(l, m) : this.addMarker(l, m);
      }
  }
  insertText(e, t, n, r) {
    t instanceof kr || t instanceof gt || t instanceof oe ? this.insert(this.createText(e), t, n) : this.insert(this.createText(e, t), n, r);
  }
  insertElement(e, t, n, r) {
    t instanceof kr || t instanceof gt || t instanceof oe ? this.insert(this.createElement(e), t, n) : this.insert(this.createElement(e, t), n, r);
  }
  /**
   * Inserts item at the end of the given parent.
   *
   * ```ts
   * const paragraph = writer.createElement( 'paragraph' );
   * writer.append( paragraph, root );
   * ```
   *
   * Note that if the item already has parent it will be removed from the previous parent.
   *
   * If you want to move {@link module:engine/model/range~Range range} instead of an
   * {@link module:engine/model/item~Item item} use {@link module:engine/model/writer~Writer#move `Writer#move()`}.
   *
   * @param item Item or document fragment to insert.
   */
  append(e, t) {
    this.insert(e, t, "end");
  }
  appendText(e, t, n) {
    t instanceof kr || t instanceof gt ? this.insert(this.createText(e), t, "end") : this.insert(this.createText(e, t), n, "end");
  }
  appendElement(e, t, n) {
    t instanceof kr || t instanceof gt ? this.insert(this.createElement(e), t, "end") : this.insert(this.createElement(e, t), n, "end");
  }
  /**
   * Sets value of the attribute with given key on a {@link module:engine/model/item~Item model item}
   * or on a {@link module:engine/model/range~Range range}.
   *
   * @param key Attribute key.
   * @param value Attribute new value.
   * @param itemOrRange Model item or range on which the attribute will be set.
   */
  setAttribute(e, t, n) {
    if (this._assertWriterUsedCorrectly(), n instanceof X) {
      const r = n.getMinimalFlatRanges();
      for (const s of r)
        yb(this, e, t, s);
    } else
      Eb(this, e, t, n);
  }
  /**
   * Sets values of attributes on a {@link module:engine/model/item~Item model item}
   * or on a {@link module:engine/model/range~Range range}.
   *
   * ```ts
   * writer.setAttributes( {
   * 	bold: true,
   * 	italic: true
   * }, range );
   * ```
   *
   * @param attributes Attributes keys and values.
   * @param itemOrRange Model item or range on which the attributes will be set.
   */
  setAttributes(e, t) {
    for (const [n, r] of Or(e))
      this.setAttribute(n, r, t);
  }
  /**
   * Removes an attribute with given key from a {@link module:engine/model/item~Item model item}
   * or from a {@link module:engine/model/range~Range range}.
   *
   * @param key Attribute key.
   * @param itemOrRange Model item or range from which the attribute will be removed.
   */
  removeAttribute(e, t) {
    if (this._assertWriterUsedCorrectly(), t instanceof X) {
      const n = t.getMinimalFlatRanges();
      for (const r of n)
        yb(this, e, null, r);
    } else
      Eb(this, e, null, t);
  }
  /**
   * Removes all attributes from all elements in the range or from the given item.
   *
   * @param itemOrRange Model item or range from which all attributes will be removed.
   */
  clearAttributes(e) {
    this._assertWriterUsedCorrectly();
    const t = (n) => {
      for (const r of n.getAttributeKeys())
        this.removeAttribute(r, n);
    };
    if (!(e instanceof X))
      t(e);
    else
      for (const n of e.getItems())
        t(n);
  }
  /**
   * Moves all items in the source range to the target position.
   *
   * ```ts
   * writer.move( sourceRange, targetPosition );
   * ```
   *
   * Instead of the target position you can use parent and offset or define that range should be moved to the end
   * or before or after chosen item:
   *
   * ```ts
   * // Moves all items in the range to the paragraph at offset 5:
   * writer.move( sourceRange, paragraph, 5 );
   * // Moves all items in the range to the end of a blockquote:
   * writer.move( sourceRange, blockquote, 'end' );
   * // Moves all items in the range to a position after an image:
   * writer.move( sourceRange, image, 'after' );
   * ```
   *
   * These parameters work the same way as {@link #createPositionAt `writer.createPositionAt()`}.
   *
   * Note that items can be moved only within the same tree. It means that you can move items within the same root
   * (element or document fragment) or between {@link module:engine/model/document~Document#roots documents roots},
   * but you can not move items from document fragment to the document or from one detached element to another. Use
   * {@link module:engine/model/writer~Writer#insert} in such cases.
   *
   * @param range Source range.
   * @param offset Offset or one of the flags. Used only when second parameter is a {@link module:engine/model/item~Item model item}.
   */
  move(e, t, n) {
    if (this._assertWriterUsedCorrectly(), !(e instanceof X))
      throw new B("writer-move-invalid-range", this);
    if (!e.isFlat)
      throw new B("writer-move-range-not-flat", this);
    const r = oe._createAt(t, n);
    if (r.isEqual(e.start))
      return;
    if (this._addOperationForAffectedMarkers("move", e), !Cb(e.root, r.root))
      throw new B("writer-move-different-document", this);
    const s = e.root.document ? e.root.document.version : null, o = new it(e.start, e.end.offset - e.start.offset, r, s);
    this.batch.addOperation(o), this.model.applyOperation(o);
  }
  /**
   * Removes given model {@link module:engine/model/item~Item item} or {@link module:engine/model/range~Range range}.
   *
   * @param itemOrRange Model item or range to remove.
   */
  remove(e) {
    this._assertWriterUsedCorrectly();
    const n = (e instanceof X ? e : X._createOn(e)).getMinimalFlatRanges().reverse();
    for (const r of n)
      this._addOperationForAffectedMarkers("move", r), J8(r.start, r.end.offset - r.start.offset, this.batch, this.model);
  }
  /**
   * Merges two siblings at the given position.
   *
   * Node before and after the position have to be an element. Otherwise `writer-merge-no-element-before` or
   * `writer-merge-no-element-after` error will be thrown.
   *
   * @param position Position between merged elements.
   */
  merge(e) {
    this._assertWriterUsedCorrectly();
    const t = e.nodeBefore, n = e.nodeAfter;
    if (this._addOperationForAffectedMarkers("merge", e), !(t instanceof gt))
      throw new B("writer-merge-no-element-before", this);
    if (!(n instanceof gt))
      throw new B("writer-merge-no-element-after", this);
    e.root.document ? this._merge(e) : this._mergeDetached(e);
  }
  /**
   * Shortcut for {@link module:engine/model/model~Model#createPositionFromPath `Model#createPositionFromPath()`}.
   *
   * @param root Root of the position.
   * @param path Position path. See {@link module:engine/model/position~Position#path}.
   * @param stickiness Position stickiness. See {@link module:engine/model/position~PositionStickiness}.
   */
  createPositionFromPath(e, t, n) {
    return this.model.createPositionFromPath(e, t, n);
  }
  /**
   * Shortcut for {@link module:engine/model/model~Model#createPositionAt `Model#createPositionAt()`}.
   *
   * @param offset Offset or one of the flags. Used only when first parameter is a {@link module:engine/model/item~Item model item}.
   */
  createPositionAt(e, t) {
    return this.model.createPositionAt(e, t);
  }
  /**
   * Shortcut for {@link module:engine/model/model~Model#createPositionAfter `Model#createPositionAfter()`}.
   *
   * @param item Item after which the position should be placed.
   */
  createPositionAfter(e) {
    return this.model.createPositionAfter(e);
  }
  /**
   * Shortcut for {@link module:engine/model/model~Model#createPositionBefore `Model#createPositionBefore()`}.
   *
   * @param item Item after which the position should be placed.
   */
  createPositionBefore(e) {
    return this.model.createPositionBefore(e);
  }
  /**
   * Shortcut for {@link module:engine/model/model~Model#createRange `Model#createRange()`}.
   *
   * @param start Start position.
   * @param end End position. If not set, range will be collapsed at `start` position.
   */
  createRange(e, t) {
    return this.model.createRange(e, t);
  }
  /**
   * Shortcut for {@link module:engine/model/model~Model#createRangeIn `Model#createRangeIn()`}.
   *
   * @param element Element which is a parent for the range.
   */
  createRangeIn(e) {
    return this.model.createRangeIn(e);
  }
  /**
   * Shortcut for {@link module:engine/model/model~Model#createRangeOn `Model#createRangeOn()`}.
   *
   * @param element Element which is a parent for the range.
   */
  createRangeOn(e) {
    return this.model.createRangeOn(e);
  }
  createSelection(...e) {
    return this.model.createSelection(...e);
  }
  /**
   * Performs merge action in a detached tree.
   *
   * @param position Position between merged elements.
   */
  _mergeDetached(e) {
    const t = e.nodeBefore, n = e.nodeAfter;
    this.move(X._createIn(n), oe._createAt(t, "end")), this.remove(n);
  }
  /**
   * Performs merge action in a non-detached tree.
   *
   * @param position Position between merged elements.
   */
  _merge(e) {
    const t = oe._createAt(e.nodeBefore, "end"), n = oe._createAt(e.nodeAfter, 0), r = e.root.document.graveyard, s = new oe(r, [0]), o = e.root.document.version, l = new Kt(n, e.nodeAfter.maxOffset, t, s, o);
    this.batch.addOperation(l), this.model.applyOperation(l);
  }
  /**
   * Renames the given element.
   *
   * @param element The element to rename.
   * @param newName New element name.
   */
  rename(e, t) {
    if (this._assertWriterUsedCorrectly(), !(e instanceof gt))
      throw new B("writer-rename-not-element-instance", this);
    const n = e.root.document ? e.root.document.version : null, r = new Zn(oe._createBefore(e), e.name, t, n);
    this.batch.addOperation(r), this.model.applyOperation(r);
  }
  /**
   * Splits elements starting from the given position and going to the top of the model tree as long as given
   * `limitElement` is reached. When `limitElement` is not defined then only the parent of the given position will be split.
   *
   * The element needs to have a parent. It cannot be a root element nor a document fragment.
   * The `writer-split-element-no-parent` error will be thrown if you try to split an element with no parent.
   *
   * @param position Position of split.
   * @param limitElement Stop splitting when this element will be reached.
   * @returns Split result with properties:
   * * `position` - Position between split elements.
   * * `range` - Range that stars from the end of the first split element and ends at the beginning of the first copy element.
   */
  split(e, t) {
    this._assertWriterUsedCorrectly();
    let n = e.parent;
    if (!n.parent)
      throw new B("writer-split-element-no-parent", this);
    if (t || (t = n.parent), !e.parent.getAncestors({ includeSelf: !0 }).includes(t))
      throw new B("writer-split-invalid-limit-element", this);
    let r, s;
    do {
      const o = n.root.document ? n.root.document.version : null, l = n.maxOffset - e.offset, u = bt.getInsertionPosition(e), h = new bt(e, l, u, null, o);
      this.batch.addOperation(h), this.model.applyOperation(h), !r && !s && (r = n, s = e.parent.nextSibling), e = this.createPositionAfter(e.parent), n = e.parent;
    } while (n !== t);
    return {
      position: e,
      range: new X(oe._createAt(r, "end"), oe._createAt(s, 0))
    };
  }
  /**
   * Wraps the given range with the given element or with a new element (if a string was passed).
   *
   * **Note:** range to wrap should be a "flat range" (see {@link module:engine/model/range~Range#isFlat `Range#isFlat`}).
   * If not, an error will be thrown.
   *
   * @param range Range to wrap.
   * @param elementOrString Element or name of element to wrap the range with.
   */
  wrap(e, t) {
    if (this._assertWriterUsedCorrectly(), !e.isFlat)
      throw new B("writer-wrap-range-not-flat", this);
    const n = t instanceof gt ? t : new gt(t);
    if (n.childCount > 0)
      throw new B("writer-wrap-element-not-empty", this);
    if (n.parent !== null)
      throw new B("writer-wrap-element-attached", this);
    this.insert(n, e.start);
    const r = new X(e.start.getShiftedBy(1), e.end.getShiftedBy(1));
    this.move(r, oe._createAt(n, 0));
  }
  /**
   * Unwraps children of the given element – all its children are moved before it and then the element is removed.
   * Throws error if you try to unwrap an element which does not have a parent.
   *
   * @param element Element to unwrap.
   */
  unwrap(e) {
    if (this._assertWriterUsedCorrectly(), e.parent === null)
      throw new B("writer-unwrap-element-no-parent", this);
    this.move(X._createIn(e), this.createPositionAfter(e)), this.remove(e);
  }
  /**
   * Adds a {@link module:engine/model/markercollection~Marker marker}. Marker is a named range, which tracks
   * changes in the document and updates its range automatically, when model tree changes.
   *
   * As the first parameter you can set marker name.
   *
   * The required `options.usingOperation` parameter lets you decide if the marker should be managed by operations or not. See
   * {@link module:engine/model/markercollection~Marker marker class description} to learn about the difference between
   * markers managed by operations and not-managed by operations.
   *
   * The `options.affectsData` parameter, which defaults to `false`, allows you to define if a marker affects the data. It should be
   * `true` when the marker change changes the data returned by the
   * {@link module:core/editor/utils/dataapimixin~DataApi#getData `editor.getData()`} method.
   * When set to `true` it fires the {@link module:engine/model/document~Document#event:change:data `change:data`} event.
   * When set to `false` it fires the {@link module:engine/model/document~Document#event:change `change`} event.
   *
   * Create marker directly base on marker's name:
   *
   * ```ts
   * addMarker( markerName, { range, usingOperation: false } );
   * ```
   *
   * Create marker using operation:
   *
   * ```ts
   * addMarker( markerName, { range, usingOperation: true } );
   * ```
   *
   * Create marker that affects the editor data:
   *
   * ```ts
   * addMarker( markerName, { range, usingOperation: false, affectsData: true } );
   * ```
   *
   * Note: For efficiency reasons, it's best to create and keep as little markers as possible.
   *
   * @see module:engine/model/markercollection~Marker
   * @param name Name of a marker to create - must be unique.
   * @param options.usingOperation Flag indicating that the marker should be added by MarkerOperation.
   * See {@link module:engine/model/markercollection~Marker#managedUsingOperations}.
   * @param options.range Marker range.
   * @param options.affectsData Flag indicating that the marker changes the editor data.
   * @returns Marker that was set.
   */
  addMarker(e, t) {
    if (this._assertWriterUsedCorrectly(), !t || typeof t.usingOperation != "boolean")
      throw new B("writer-addmarker-no-usingoperation", this);
    const n = t.usingOperation, r = t.range, s = t.affectsData === void 0 ? !1 : t.affectsData;
    if (this.model.markers.has(e))
      throw new B("writer-addmarker-marker-exists", this);
    if (!r)
      throw new B("writer-addmarker-no-range", this);
    return n ? (Ja(this, e, null, r, s), this.model.markers.get(e)) : this.model.markers._set(e, r, n, s);
  }
  /**
   * Adds, updates or refreshes a {@link module:engine/model/markercollection~Marker marker}. Marker is a named range, which tracks
   * changes in the document and updates its range automatically, when model tree changes. Still, it is possible to change the
   * marker's range directly using this method.
   *
   * As the first parameter you can set marker name or instance. If none of them is provided, new marker, with a unique
   * name is created and returned.
   *
   * **Note**: If you want to change the {@link module:engine/view/element~Element view element} of the marker while its data in the model
   * remains the same, use the dedicated {@link module:engine/controller/editingcontroller~EditingController#reconvertMarker} method.
   *
   * The `options.usingOperation` parameter lets you change if the marker should be managed by operations or not. See
   * {@link module:engine/model/markercollection~Marker marker class description} to learn about the difference between
   * markers managed by operations and not-managed by operations. It is possible to change this option for an existing marker.
   *
   * The `options.affectsData` parameter, which defaults to `false`, allows you to define if a marker affects the data. It should be
   * `true` when the marker change changes the data returned by
   * the {@link module:core/editor/utils/dataapimixin~DataApi#getData `editor.getData()`} method.
   * When set to `true` it fires the {@link module:engine/model/document~Document#event:change:data `change:data`} event.
   * When set to `false` it fires the {@link module:engine/model/document~Document#event:change `change`} event.
   *
   * Update marker directly base on marker's name:
   *
   * ```ts
   * updateMarker( markerName, { range } );
   * ```
   *
   * Update marker using operation:
   *
   * ```ts
   * updateMarker( marker, { range, usingOperation: true } );
   * updateMarker( markerName, { range, usingOperation: true } );
   * ```
   *
   * Change marker's option (start using operations to manage it):
   *
   * ```ts
   * updateMarker( marker, { usingOperation: true } );
   * ```
   *
   * Change marker's option (inform the engine, that the marker does not affect the data anymore):
   *
   * ```ts
   * updateMarker( markerName, { affectsData: false } );
   * ```
   *
   * @see module:engine/model/markercollection~Marker
   * @param markerOrName Name of a marker to update, or a marker instance.
   * @param options If options object is not defined then marker will be refreshed by triggering
   * downcast conversion for this marker with the same data.
   * @param options.range Marker range to update.
   * @param options.usingOperation Flag indicated whether the marker should be added by MarkerOperation.
   * See {@link module:engine/model/markercollection~Marker#managedUsingOperations}.
   * @param options.affectsData Flag indicating that the marker changes the editor data.
   */
  updateMarker(e, t) {
    this._assertWriterUsedCorrectly();
    const n = typeof e == "string" ? e : e.name, r = this.model.markers.get(n);
    if (!r)
      throw new B("writer-updatemarker-marker-not-exists", this);
    if (!t) {
      Yt("writer-updatemarker-reconvert-using-editingcontroller", { markerName: n }), this.model.markers._refresh(r);
      return;
    }
    const s = typeof t.usingOperation == "boolean", o = typeof t.affectsData == "boolean", l = o ? t.affectsData : r.affectsData;
    if (!s && !t.range && !o)
      throw new B("writer-updatemarker-wrong-options", this);
    const u = r.getRange(), h = t.range ? t.range : u;
    if (s && t.usingOperation !== r.managedUsingOperations) {
      t.usingOperation ? Ja(this, n, null, h, l) : (Ja(this, n, u, null, l), this.model.markers._set(n, h, void 0, l));
      return;
    }
    r.managedUsingOperations ? Ja(this, n, u, h, l) : this.model.markers._set(n, h, void 0, l);
  }
  /**
   * Removes given {@link module:engine/model/markercollection~Marker marker} or marker with given name.
   * The marker is removed accordingly to how it has been created, so if the marker was created using operation,
   * it will be destroyed using operation.
   *
   * @param markerOrName Marker or marker name to remove.
   */
  removeMarker(e) {
    this._assertWriterUsedCorrectly();
    const t = typeof e == "string" ? e : e.name;
    if (!this.model.markers.has(t))
      throw new B("writer-removemarker-no-marker", this);
    const n = this.model.markers.get(t);
    if (!n.managedUsingOperations) {
      this.model.markers._remove(t);
      return;
    }
    const r = n.getRange();
    Ja(this, t, r, null, n.affectsData);
  }
  /**
   * Adds a new root to the document (or re-attaches a {@link #detachRoot detached root}).
   *
   * Throws an error, if trying to add a root that is already added and attached.
   *
   * @param rootName Name of the added root.
   * @param elementName The element name. Defaults to `'$root'` which also has some basic schema defined
   * (e.g. `$block` elements are allowed inside the `$root`). Make sure to define a proper schema if you use a different name.
   * @returns The added root element.
   */
  addRoot(e, t = "$root") {
    this._assertWriterUsedCorrectly();
    const n = this.model.document.getRoot(e);
    if (n && n.isAttached())
      throw new B("writer-addroot-root-exists", this);
    const r = this.model.document, s = new sr(e, t, !0, r, r.version);
    return this.batch.addOperation(s), this.model.applyOperation(s), this.model.document.getRoot(e);
  }
  /**
   * Detaches the root from the document.
   *
   * All content and markers are removed from the root upon detaching. New content and new markers cannot be added to the root, as long
   * as it is detached.
   *
   * A root cannot be fully removed from the document, it can be only detached. A root is permanently removed only after you
   * re-initialize the editor and do not specify the root in the initial data.
   *
   * A detached root can be re-attached using {@link #addRoot}.
   *
   * Throws an error if the root does not exist or the root is already detached.
   *
   * @param rootOrName Name of the detached root.
   */
  detachRoot(e) {
    this._assertWriterUsedCorrectly();
    const t = typeof e == "string" ? this.model.document.getRoot(e) : e;
    if (!t || !t.isAttached())
      throw new B("writer-detachroot-no-root", this);
    for (const s of this.model.markers)
      s.getRange().root === t && this.removeMarker(s);
    for (const s of t.getAttributeKeys())
      this.removeAttribute(s, t);
    this.remove(this.createRangeIn(t));
    const n = this.model.document, r = new sr(t.rootName, t.name, !1, n, n.version);
    this.batch.addOperation(r), this.model.applyOperation(r);
  }
  setSelection(...e) {
    this._assertWriterUsedCorrectly(), this.model.document.selection._setTo(...e);
  }
  /**
   * Moves {@link module:engine/model/documentselection~DocumentSelection#focus} to the specified location.
   *
   * The location can be specified in the same form as
   * {@link #createPositionAt `writer.createPositionAt()`} parameters.
   *
   * @param itemOrPosition
   * @param offset Offset or one of the flags. Used only when first parameter is a {@link module:engine/model/item~Item model item}.
   */
  setSelectionFocus(e, t) {
    this._assertWriterUsedCorrectly(), this.model.document.selection._setFocus(e, t);
  }
  setSelectionAttribute(e, t) {
    if (this._assertWriterUsedCorrectly(), typeof e == "string")
      this._setSelectionAttribute(e, t);
    else
      for (const [n, r] of Or(e))
        this._setSelectionAttribute(n, r);
  }
  /**
   * Removes attribute(s) with given key(s) from the selection.
   *
   * Remove one attribute:
   *
   * ```ts
   * writer.removeSelectionAttribute( 'italic' );
   * ```
   *
   * Remove multiple attributes:
   *
   * ```ts
   * writer.removeSelectionAttribute( [ 'italic', 'bold' ] );
   * ```
   *
   * @param keyOrIterableOfKeys Key of the attribute to remove or an iterable of attribute keys to remove.
   */
  removeSelectionAttribute(e) {
    if (this._assertWriterUsedCorrectly(), typeof e == "string")
      this._removeSelectionAttribute(e);
    else
      for (const t of e)
        this._removeSelectionAttribute(t);
  }
  /**
   * Temporarily changes the {@link module:engine/model/documentselection~DocumentSelection#isGravityOverridden gravity}
   * of the selection from left to right.
   *
   * The gravity defines from which direction the selection inherits its attributes. If it's the default left gravity,
   * then the selection (after being moved by the user) inherits attributes from its left-hand side.
   * This method allows to temporarily override this behavior by forcing the gravity to the right.
   *
   * For the following model fragment:
   *
   * ```xml
   * <$text bold="true" linkHref="url">bar[]</$text><$text bold="true">biz</$text>
   * ```
   *
   * * Default gravity: selection will have the `bold` and `linkHref` attributes.
   * * Overridden gravity: selection will have `bold` attribute.
   *
   * **Note**: It returns an unique identifier which is required to restore the gravity. It guarantees the symmetry
   * of the process.
   *
   * @returns The unique id which allows restoring the gravity.
   */
  overrideSelectionGravity() {
    return this.model.document.selection._overrideGravity();
  }
  /**
   * Restores {@link ~Writer#overrideSelectionGravity} gravity to default.
   *
   * Restoring the gravity is only possible using the unique identifier returned by
   * {@link ~Writer#overrideSelectionGravity}. Note that the gravity remains overridden as long as won't be restored
   * the same number of times it was overridden.
   *
   * @param uid The unique id returned by {@link ~Writer#overrideSelectionGravity}.
   */
  restoreSelectionGravity(e) {
    this.model.document.selection._restoreGravity(e);
  }
  /**
   * @param key Key of the attribute to remove.
   * @param value Attribute value.
   */
  _setSelectionAttribute(e, t) {
    const n = this.model.document.selection;
    if (n.isCollapsed && n.anchor.parent.isEmpty) {
      const r = zi._getStoreAttributeKey(e);
      this.setAttribute(r, t, n.anchor.parent);
    }
    n._setAttribute(e, t);
  }
  /**
   * @param key Key of the attribute to remove.
   */
  _removeSelectionAttribute(e) {
    const t = this.model.document.selection;
    if (t.isCollapsed && t.anchor.parent.isEmpty) {
      const n = zi._getStoreAttributeKey(e);
      this.removeAttribute(n, t.anchor.parent);
    }
    t._removeAttribute(e);
  }
  /**
   * Throws `writer-detached-writer-tries-to-modify-model` error when the writer is used outside of the `change()` block.
   */
  _assertWriterUsedCorrectly() {
    if (this.model._currentWriter !== this)
      throw new B("writer-incorrect-use", this);
  }
  /**
   * For given action `type` and `positionOrRange` where the action happens, this function finds all affected markers
   * and applies a marker operation with the new marker range equal to the current range. Thanks to this, the marker range
   * can be later correctly processed during undo.
   *
   * @param type Writer action type.
   * @param positionOrRange Position or range where the writer action happens.
   */
  _addOperationForAffectedMarkers(e, t) {
    for (const n of this.model.markers) {
      if (!n.managedUsingOperations)
        continue;
      const r = n.getRange();
      let s = !1;
      if (e === "move") {
        const o = t;
        s = o.containsPosition(r.start) || o.start.isEqual(r.start) || o.containsPosition(r.end) || o.end.isEqual(r.end);
      } else {
        const o = t, l = o.nodeBefore, u = o.nodeAfter, h = r.start.parent == l && r.start.isAtEnd, f = r.end.parent == u && r.end.offset == 0, m = r.end.nodeAfter == u, v = r.start.nodeAfter == u;
        s = h || f || m || v;
      }
      s && this.updateMarker(n.name, { range: r });
    }
  }
}
function yb(i, e, t, n) {
  const r = i.model, s = r.document;
  let o = n.start, l, u, h;
  for (const m of n.getWalker({ shallow: !0 }))
    h = m.item.getAttribute(e), l && u != h && (u != t && f(), o = l), l = m.nextPosition, u = h;
  l instanceof oe && l != o && u != t && f();
  function f() {
    const m = new X(o, l), v = m.root.document ? s.version : null, C = new tn(m, e, u, t, v);
    i.batch.addOperation(C), r.applyOperation(C);
  }
}
function Eb(i, e, t, n) {
  const r = i.model, s = r.document, o = n.getAttribute(e);
  let l, u;
  if (o != t) {
    if (n.root === n) {
      const f = n.document ? s.version : null;
      u = new Ar(n, e, o, t, f);
    } else {
      l = new X(oe._createBefore(n), i.createPositionAfter(n));
      const f = l.root.document ? s.version : null;
      u = new tn(l, e, o, t, f);
    }
    i.batch.addOperation(u), r.applyOperation(u);
  }
}
function Ja(i, e, t, n, r) {
  const s = i.model, o = s.document, l = new Xn(e, t, n, s.markers, !!r, o.version);
  i.batch.addOperation(l), s.applyOperation(l);
}
function J8(i, e, t, n) {
  let r;
  if (i.root.document) {
    const s = n.document, o = new oe(s.graveyard, [0]);
    r = new it(i, e, o, s.version);
  } else
    r = new K8(i, e);
  t.addOperation(r), n.applyOperation(r);
}
function Cb(i, e) {
  return i === e || i instanceof Pd && e instanceof Pd;
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function X8(i, e, t = {}) {
  if (e.isCollapsed)
    return;
  const n = e.getFirstRange();
  if (n.root.rootName == "$graveyard")
    return;
  const r = i.schema;
  i.change((s) => {
    if (!t.doNotResetEntireContent && oF(r, e)) {
      sF(s, e);
      return;
    }
    const o = {};
    if (!t.doNotAutoparagraph) {
      const h = e.getSelectedElement();
      h && Object.assign(o, r.getAttributesWithProperty(h, "copyOnReplace", !0));
    }
    const [l, u] = Z8(n);
    l.isTouching(u) || s.remove(s.createRange(l, u)), t.leaveUnmerged || (eF(s, l, u), r.removeDisallowedAttributes(l.parent.getChildren(), s)), bC(s, e, l), !t.doNotAutoparagraph && iF(r, l) && wC(s, l, e, o), l.detach(), u.detach();
  });
}
function Z8(i) {
  const e = i.root.document.model, t = i.start;
  let n = i.end;
  if (e.hasContent(i, { ignoreMarkers: !0 })) {
    const r = Q8(n);
    if (r && n.isTouching(e.createPositionAt(r, 0))) {
      const s = e.createSelection(i);
      e.modifySelection(s, { direction: "backward" });
      const o = s.getLastPosition(), l = e.createRange(o, n);
      e.hasContent(l, { ignoreMarkers: !0 }) || (n = o);
    }
  }
  return [
    En.fromPosition(t, "toPrevious"),
    En.fromPosition(n, "toNext")
  ];
}
function Q8(i) {
  const e = i.parent, t = e.root.document.model.schema, n = e.getAncestors({ parentFirst: !0, includeSelf: !0 });
  for (const r of n) {
    if (t.isLimit(r))
      return null;
    if (t.isBlock(r))
      return r;
  }
}
function eF(i, e, t) {
  const n = i.model;
  if (!mp(i.model.schema, e, t))
    return;
  const [r, s] = nF(e, t);
  !r || !s || (!n.hasContent(r, { ignoreMarkers: !0 }) && n.hasContent(s, { ignoreMarkers: !0 }) ? vC(i, e, t, r.parent) : _C(i, e, t, r.parent));
}
function _C(i, e, t, n) {
  const r = e.parent, s = t.parent;
  if (!(r == n || s == n)) {
    for (e = i.createPositionAfter(r), t = i.createPositionBefore(s), t.isEqual(e) || i.insert(s, e), i.merge(e); t.parent.isEmpty; ) {
      const o = t.parent;
      t = i.createPositionBefore(o), i.remove(o);
    }
    mp(i.model.schema, e, t) && _C(i, e, t, n);
  }
}
function vC(i, e, t, n) {
  const r = e.parent, s = t.parent;
  if (!(r == n || s == n)) {
    for (e = i.createPositionAfter(r), t = i.createPositionBefore(s), t.isEqual(e) || i.insert(r, t); e.parent.isEmpty; ) {
      const o = e.parent;
      e = i.createPositionBefore(o), i.remove(o);
    }
    t = i.createPositionBefore(s), tF(i, t), mp(i.model.schema, e, t) && vC(i, e, t, n);
  }
}
function tF(i, e) {
  const t = e.nodeBefore, n = e.nodeAfter;
  t.name != n.name && i.rename(t, n.name), i.clearAttributes(t), i.setAttributes(Object.fromEntries(n.getAttributes()), t), i.merge(e);
}
function mp(i, e, t) {
  const n = e.parent, r = t.parent;
  return n == r || i.isLimit(n) || i.isLimit(r) ? !1 : rF(e, t, i);
}
function nF(i, e) {
  const t = i.getAncestors(), n = e.getAncestors();
  let r = 0;
  for (; t[r] && t[r] == n[r]; )
    r++;
  return [t[r], n[r]];
}
function iF(i, e) {
  const t = i.checkChild(e, "$text"), n = i.checkChild(e, "paragraph");
  return !t && n;
}
function rF(i, e, t) {
  const n = new X(i, e);
  for (const r of n.getWalker())
    if (t.isLimit(r.item))
      return !1;
  return !0;
}
function wC(i, e, t, n = {}) {
  const r = i.createElement("paragraph");
  i.model.schema.setAllowedAttributes(r, n, i), i.insert(r, e), bC(i, t, i.createPositionAt(r, 0));
}
function sF(i, e) {
  const t = i.model.schema.getLimitElement(e);
  i.remove(i.createRangeIn(t)), wC(i, i.createPositionAt(t, 0), e);
}
function oF(i, e) {
  const t = i.getLimitElement(e);
  if (!e.containsEntireContent(t))
    return !1;
  const n = e.getFirstRange();
  return n.start.parent == n.end.parent ? !1 : i.checkChild(t, "paragraph");
}
function bC(i, e, t) {
  e instanceof zi ? i.setSelection(t) : e.setTo(t);
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function aF(i, e) {
  return i.change((t) => {
    const n = t.createDocumentFragment(), r = e.getFirstRange();
    if (!r || r.isCollapsed)
      return n;
    const s = r.start.root, o = r.start.getCommonPath(r.end), l = s.getNodeByPath(o);
    let u;
    r.start.parent == r.end.parent ? u = r : u = t.createRange(t.createPositionAt(l, r.start.path[o.length]), t.createPositionAt(l, r.end.path[o.length] + 1));
    const h = u.end.offset - u.start.offset;
    for (const f of u.getItems({ shallow: !0 }))
      f.is("$textProxy") ? t.appendText(f.data, f.getAttributes(), n) : t.append(t.cloneElement(f, !0), n);
    if (u != r) {
      const f = r._getTransformedByMove(u.start, t.createPositionAt(n, 0), h)[0], m = t.createRange(t.createPositionAt(n, 0), f.start), v = t.createRange(f.end, t.createPositionAt(n, "end"));
      Sb(v, t), Sb(m, t);
    }
    return n;
  });
}
function Sb(i, e) {
  const t = [];
  Array.from(i.getItems({ direction: "backward" })).map((n) => e.createRangeOn(n)).filter((n) => (n.start.isAfter(i.start) || n.start.isEqual(i.start)) && (n.end.isBefore(i.end) || n.end.isEqual(i.end))).forEach((n) => {
    t.push(n.start.parent), e.remove(n);
  }), t.forEach((n) => {
    let r = n;
    for (; r.parent && r.isEmpty; ) {
      const s = e.createRangeOn(r);
      r = r.parent, e.remove(s);
    }
  });
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function lF(i, e, t) {
  return i.change((n) => {
    const r = t || i.document.selection;
    r.isCollapsed || i.deleteContent(r, { doNotAutoparagraph: !0 });
    const s = new cF(i, n, r.anchor), o = [];
    let l;
    if (e.is("documentFragment")) {
      if (e.markers.size) {
        const f = [];
        for (const [m, v] of e.markers) {
          const { start: C, end: k } = v, S = C.isEqual(k);
          f.push({ position: C, name: m, isCollapsed: S }, { position: k, name: m, isCollapsed: S });
        }
        f.sort(({ position: m }, { position: v }) => m.isBefore(v) ? 1 : -1);
        for (const { position: m, name: v, isCollapsed: C } of f) {
          let k = null, S = null;
          const x = m.parent === e && m.isAtStart, N = m.parent === e && m.isAtEnd;
          !x && !N ? (k = n.createElement("$marker"), n.insert(k, m)) : C && (S = x ? "start" : "end"), o.push({
            name: v,
            element: k,
            collapsed: S
          });
        }
      }
      l = e.getChildren();
    } else
      l = [e];
    s.handleNodes(l);
    let u = s.getSelectionRange();
    if (e.is("documentFragment") && o.length) {
      const f = u ? ur.fromRange(u) : null, m = {};
      for (let v = o.length - 1; v >= 0; v--) {
        const { name: C, element: k, collapsed: S } = o[v], x = !m[C];
        if (x && (m[C] = []), k) {
          const N = n.createPositionAt(k, "before");
          m[C].push(N), n.remove(k);
        } else {
          const N = s.getAffectedRange();
          if (!N) {
            S && m[C].push(s.position);
            continue;
          }
          S ? m[C].push(N[S]) : m[C].push(x ? N.start : N.end);
        }
      }
      for (const [v, [C, k]] of Object.entries(m))
        C && k && C.root === k.root && n.addMarker(v, {
          usingOperation: !0,
          affectsData: !0,
          range: new X(C, k)
        });
      f && (u = f.toRange(), f.detach());
    }
    /* istanbul ignore else -- @preserve */
    u && (r instanceof zi ? n.setSelection(u) : r.setTo(u));
    const h = s.getAffectedRange() || i.createRange(r.anchor);
    return s.destroy(), h;
  });
}
class cF {
  constructor(e, t, n) {
    this._firstNode = null, this._lastNode = null, this._lastAutoParagraph = null, this._filterAttributesOf = [], this._affectedStart = null, this._affectedEnd = null, this._nodeToSelect = null, this.model = e, this.writer = t, this.position = n, this.canMergeWith = /* @__PURE__ */ new Set([this.position.parent]), this.schema = e.schema, this._documentFragment = t.createDocumentFragment(), this._documentFragmentPosition = t.createPositionAt(this._documentFragment, 0);
  }
  /**
   * Handles insertion of a set of nodes.
   *
   * @param nodes Nodes to insert.
   */
  handleNodes(e) {
    for (const t of Array.from(e))
      this._handleNode(t);
    this._insertPartialFragment(), this._lastAutoParagraph && this._updateLastNodeFromAutoParagraph(this._lastAutoParagraph), this._mergeOnRight(), this.schema.removeDisallowedAttributes(this._filterAttributesOf, this.writer), this._filterAttributesOf = [];
  }
  /**
   * Updates the last node after the auto paragraphing.
   *
   * @param node The last auto paragraphing node.
   */
  _updateLastNodeFromAutoParagraph(e) {
    const t = this.writer.createPositionAfter(this._lastNode), n = this.writer.createPositionAfter(e);
    if (n.isAfter(t)) {
      this._lastNode = e;
      /* istanbul ignore if -- @preserve */
      if (this.position.parent != e || !this.position.isAtEnd)
        throw new B("insertcontent-invalid-insertion-position", this);
      this.position = n, this._setAffectedBoundaries(this.position);
    }
  }
  /**
   * Returns range to be selected after insertion.
   * Returns `null` if there is no valid range to select after insertion.
   */
  getSelectionRange() {
    return this._nodeToSelect ? X._createOn(this._nodeToSelect) : this.model.schema.getNearestSelectionRange(this.position);
  }
  /**
   * Returns a range which contains all the performed changes. This is a range that, if removed, would return the model to the state
   * before the insertion. Returns `null` if no changes were done.
   */
  getAffectedRange() {
    return this._affectedStart ? new X(this._affectedStart, this._affectedEnd) : null;
  }
  /**
   * Destroys `Insertion` instance.
   */
  destroy() {
    this._affectedStart && this._affectedStart.detach(), this._affectedEnd && this._affectedEnd.detach();
  }
  /**
   * Handles insertion of a single node.
   */
  _handleNode(e) {
    if (this.schema.isObject(e)) {
      this._handleObject(e);
      return;
    }
    let t = this._checkAndAutoParagraphToAllowedPosition(e);
    if (!t && (t = this._checkAndSplitToAllowedPosition(e), !t)) {
      this._handleDisallowedNode(e);
      return;
    }
    this._appendToFragment(e), this._firstNode || (this._firstNode = e), this._lastNode = e;
  }
  /**
   * Inserts the temporary DocumentFragment into the model.
   */
  _insertPartialFragment() {
    if (this._documentFragment.isEmpty)
      return;
    const e = En.fromPosition(this.position, "toNext");
    this._setAffectedBoundaries(this.position), this._documentFragment.getChild(0) == this._firstNode && (this.writer.insert(this._firstNode, this.position), this._mergeOnLeft(), this.position = e.toPosition()), this._documentFragment.isEmpty || this.writer.insert(this._documentFragment, this.position), this._documentFragmentPosition = this.writer.createPositionAt(this._documentFragment, 0), this.position = e.toPosition(), e.detach();
  }
  /**
   * @param node The object element.
   */
  _handleObject(e) {
    this._checkAndSplitToAllowedPosition(e) ? this._appendToFragment(e) : this._tryAutoparagraphing(e);
  }
  /**
   * @param node The disallowed node which needs to be handled.
   */
  _handleDisallowedNode(e) {
    e.is("element") ? this.handleNodes(e.getChildren()) : this._tryAutoparagraphing(e);
  }
  /**
   * Append a node to the temporary DocumentFragment.
   *
   * @param node The node to insert.
   */
  _appendToFragment(e) {
    /* istanbul ignore if -- @preserve */
    if (!this.schema.checkChild(this.position, e))
      throw new B("insertcontent-wrong-position", this, { node: e, position: this.position });
    this.writer.insert(e, this._documentFragmentPosition), this._documentFragmentPosition = this._documentFragmentPosition.getShiftedBy(e.offsetSize), this.schema.isObject(e) && !this.schema.checkChild(this.position, "$text") ? this._nodeToSelect = e : this._nodeToSelect = null, this._filterAttributesOf.push(e);
  }
  /**
   * Sets `_affectedStart` and `_affectedEnd` to the given `position`. Should be used before a change is done during insertion process to
   * mark the affected range.
   *
   * This method is used before inserting a node or splitting a parent node. `_affectedStart` and `_affectedEnd` are also changed
   * during merging, but the logic there is more complicated so it is left out of this function.
   */
  _setAffectedBoundaries(e) {
    this._affectedStart || (this._affectedStart = En.fromPosition(e, "toPrevious")), (!this._affectedEnd || this._affectedEnd.isBefore(e)) && (this._affectedEnd && this._affectedEnd.detach(), this._affectedEnd = En.fromPosition(e, "toNext"));
  }
  /**
   * Merges the previous sibling of the first node if it should be merged.
   *
   * After the content was inserted we may try to merge it with its siblings.
   * This should happen only if the selection was in those elements initially.
   */
  _mergeOnLeft() {
    const e = this._firstNode;
    if (!(e instanceof gt) || !this._canMergeLeft(e))
      return;
    const t = En._createBefore(e);
    t.stickiness = "toNext";
    const n = En.fromPosition(this.position, "toNext");
    this._affectedStart.isEqual(t) && (this._affectedStart.detach(), this._affectedStart = En._createAt(t.nodeBefore, "end", "toPrevious")), this._firstNode === this._lastNode && (this._firstNode = t.nodeBefore, this._lastNode = t.nodeBefore), this.writer.merge(t), t.isEqual(this._affectedEnd) && this._firstNode === this._lastNode && (this._affectedEnd.detach(), this._affectedEnd = En._createAt(t.nodeBefore, "end", "toNext")), this.position = n.toPosition(), n.detach(), this._filterAttributesOf.push(this.position.parent), t.detach();
  }
  /**
   * Merges the next sibling of the last node if it should be merged.
   *
   * After the content was inserted we may try to merge it with its siblings.
   * This should happen only if the selection was in those elements initially.
   */
  _mergeOnRight() {
    const e = this._lastNode;
    if (!(e instanceof gt) || !this._canMergeRight(e))
      return;
    const t = En._createAfter(e);
    t.stickiness = "toNext";
    /* istanbul ignore if -- @preserve */
    if (!this.position.isEqual(t))
      throw new B("insertcontent-invalid-insertion-position", this);
    this.position = oe._createAt(t.nodeBefore, "end");
    const n = En.fromPosition(this.position, "toPrevious");
    this._affectedEnd.isEqual(t) && (this._affectedEnd.detach(), this._affectedEnd = En._createAt(t.nodeBefore, "end", "toNext")), this._firstNode === this._lastNode && (this._firstNode = t.nodeBefore, this._lastNode = t.nodeBefore), this.writer.merge(t), t.getShiftedBy(-1).isEqual(this._affectedStart) && this._firstNode === this._lastNode && (this._affectedStart.detach(), this._affectedStart = En._createAt(t.nodeBefore, 0, "toPrevious")), this.position = n.toPosition(), n.detach(), this._filterAttributesOf.push(this.position.parent), t.detach();
  }
  /**
   * Checks whether specified node can be merged with previous sibling element.
   *
   * @param node The node which could potentially be merged.
   */
  _canMergeLeft(e) {
    const t = e.previousSibling;
    return t instanceof gt && this.canMergeWith.has(t) && this.model.schema.checkMerge(t, e);
  }
  /**
   * Checks whether specified node can be merged with next sibling element.
   *
   * @param node The node which could potentially be merged.
   */
  _canMergeRight(e) {
    const t = e.nextSibling;
    return t instanceof gt && this.canMergeWith.has(t) && this.model.schema.checkMerge(e, t);
  }
  /**
   * Tries wrapping the node in a new paragraph and inserting it this way.
   *
   * @param node The node which needs to be autoparagraphed.
   */
  _tryAutoparagraphing(e) {
    const t = this.writer.createElement("paragraph");
    this._getAllowedIn(this.position.parent, t) && this.schema.checkChild(t, e) && (t._appendChild(e), this._handleNode(t));
  }
  /**
   * Checks if a node can be inserted in the given position or it would be accepted if a paragraph would be inserted.
   * It also handles inserting the paragraph.
   *
   * @returns Whether an allowed position was found.
   * `false` is returned if the node isn't allowed at the current position or in auto paragraph, `true` if was.
   */
  _checkAndAutoParagraphToAllowedPosition(e) {
    if (this.schema.checkChild(this.position.parent, e))
      return !0;
    if (!this.schema.checkChild(this.position.parent, "paragraph") || !this.schema.checkChild("paragraph", e))
      return !1;
    this._insertPartialFragment();
    const t = this.writer.createElement("paragraph");
    return this.writer.insert(t, this.position), this._setAffectedBoundaries(this.position), this._lastAutoParagraph = t, this.position = this.writer.createPositionAt(t, 0), !0;
  }
  /**
   * @returns Whether an allowed position was found.
   * `false` is returned if the node isn't allowed at any position up in the tree, `true` if was.
   */
  _checkAndSplitToAllowedPosition(e) {
    const t = this._getAllowedIn(this.position.parent, e);
    if (!t)
      return !1;
    for (t != this.position.parent && this._insertPartialFragment(); t != this.position.parent; )
      if (this.position.isAtStart) {
        const n = this.position.parent;
        this.position = this.writer.createPositionBefore(n), n.isEmpty && n.parent === t && this.writer.remove(n);
      } else if (this.position.isAtEnd)
        this.position = this.writer.createPositionAfter(this.position.parent);
      else {
        const n = this.writer.createPositionAfter(this.position.parent);
        this._setAffectedBoundaries(this.position), this.writer.split(this.position), this.position = n, this.canMergeWith.add(this.position.nodeAfter);
      }
    return !0;
  }
  /**
   * Gets the element in which the given node is allowed. It checks the passed element and all its ancestors.
   *
   * @param contextElement The element in which context the node should be checked.
   * @param childNode The node to check.
   */
  _getAllowedIn(e, t) {
    return this.schema.checkChild(e, t) ? e : this.schema.isLimit(e) ? null : this._getAllowedIn(e.parent, t);
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function yC(i, e, t = "auto") {
  const n = i.getSelectedElement();
  if (n && e.schema.isObject(n) && !e.schema.isInline(n))
    return t == "before" || t == "after" ? e.createRange(e.createPositionAt(n, t)) : e.createRangeOn(n);
  const r = Rn(i.getSelectedBlocks());
  if (!r)
    return e.createRange(i.focus);
  if (r.isEmpty)
    return e.createRange(e.createPositionAt(r, 0));
  const s = e.createPositionAfter(r);
  return i.focus.isTouching(s) ? e.createRange(s) : e.createRange(e.createPositionBefore(r));
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function uF(i, e, t, n = {}) {
  if (!i.schema.isObject(e))
    throw new B("insertobject-element-not-an-object", i, { object: e });
  const r = t || i.document.selection;
  let s = r;
  n.findOptimalPosition && i.schema.isBlock(e) && (s = i.createSelection(yC(r, i, n.findOptimalPosition)));
  const o = Rn(r.getSelectedBlocks()), l = {};
  return o && Object.assign(l, i.schema.getAttributesWithProperty(o, "copyOnReplace", !0)), i.change((u) => {
    s.isCollapsed || i.deleteContent(s, { doNotAutoparagraph: !0 });
    let h = e;
    const f = s.anchor.parent;
    !i.schema.checkChild(f, e) && i.schema.checkChild(f, "paragraph") && i.schema.checkChild("paragraph", e) && (h = u.createElement("paragraph"), u.insert(e, h)), i.schema.setAllowedAttributes(h, l, u);
    const m = i.insertContent(h, s);
    return m.isCollapsed || n.setSelection && dF(u, e, n.setSelection, l), m;
  });
}
function dF(i, e, t, n) {
  const r = i.model;
  if (t == "on") {
    i.setSelection(e, "on");
    return;
  }
  if (t != "after")
    throw new B("insertobject-invalid-place-parameter-value", r);
  let s = e.nextSibling;
  if (r.schema.isInline(e)) {
    i.setSelection(e, "after");
    return;
  }
  !(s && r.schema.checkChild(s, "$text")) && r.schema.checkChild(e.parent, "paragraph") && (s = i.createElement("paragraph"), r.schema.setAllowedAttributes(s, n, i), r.insertContent(s, i.createPositionAfter(e))), s && i.setSelection(s, 0);
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const hF = ' ,.?!:;"-()';
function fF(i, e, t = {}) {
  const n = i.schema, r = t.direction != "backward", s = t.unit ? t.unit : "character", o = !!t.treatEmojiAsSingleUnit, l = e.focus, u = new ir({
    boundaries: _F(l, r),
    singleCharacters: !0,
    direction: r ? "forward" : "backward"
  }), h = { walker: u, schema: n, isForward: r, unit: s, treatEmojiAsSingleUnit: o };
  let f;
  for (; f = u.next(); ) {
    if (f.done)
      return;
    const m = mF(h, f.value);
    if (m) {
      e instanceof zi ? i.change((v) => {
        v.setSelectionFocus(m);
      }) : e.setFocus(m);
      return;
    }
  }
}
function mF(i, e) {
  const { isForward: t, walker: n, unit: r, schema: s, treatEmojiAsSingleUnit: o } = i, { type: l, item: u, nextPosition: h } = e;
  if (l == "text")
    return i.unit === "word" ? pF(n, t) : gF(n, r, o);
  if (l == (t ? "elementStart" : "elementEnd")) {
    if (s.isSelectable(u))
      return oe._createAt(u, t ? "after" : "before");
    if (s.checkChild(h, "$text"))
      return h;
  } else {
    if (s.isLimit(u)) {
      n.skip(() => !0);
      return;
    }
    if (s.checkChild(h, "$text"))
      return h;
  }
}
function gF(i, e, t) {
  const n = i.position.textNode;
  if (n) {
    const r = n.data;
    let s = i.position.offset - n.startOffset;
    for (; rp(r, s) || e == "character" && sp(r, s) || t && AE(r, s); )
      i.next(), s = i.position.offset - n.startOffset;
  }
  return i.position;
}
function pF(i, e) {
  let t = i.position.textNode;
  for (t || (t = e ? i.position.nodeAfter : i.position.nodeBefore); t && t.is("$text"); ) {
    const n = i.position.offset - t.startOffset;
    if (wF(t, n, e))
      t = e ? i.position.nodeAfter : i.position.nodeBefore;
    else {
      if (vF(t.data, n, e))
        break;
      i.next();
    }
  }
  return i.position;
}
function _F(i, e) {
  const t = i.root, n = oe._createAt(t, e ? "end" : 0);
  return e ? new X(i, n) : new X(n, i);
}
function vF(i, e, t) {
  const n = e + (t ? 0 : -1);
  return hF.includes(i.charAt(n));
}
function wF(i, e, t) {
  return e === (t ? i.offsetSize : 0);
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
let bF = class extends Nt() {
  // @if CK_DEBUG_ENGINE // private _operationLogs: Array<string>;
  // @if CK_DEBUG_ENGINE // private _appliedOperations: Array<Operation>;
  constructor() {
    super(), this.markers = new q8(), this.document = new H8(this), this.schema = new a8(), this._pendingChanges = [], this._currentWriter = null, ["deleteContent", "modifySelection", "getSelectedContent", "applyOperation"].forEach((e) => this.decorate(e)), this.on("applyOperation", (e, t) => {
      t[0]._validate();
    }, { priority: "highest" }), this.schema.register("$root", {
      isLimit: !0
    }), this.schema.register("$container", {
      allowIn: ["$root", "$container"]
    }), this.schema.register("$block", {
      allowIn: ["$root", "$container"],
      isBlock: !0
    }), this.schema.register("$blockObject", {
      allowWhere: "$block",
      isBlock: !0,
      isObject: !0
    }), this.schema.register("$inlineObject", {
      allowWhere: "$text",
      allowAttributesOf: "$text",
      isInline: !0,
      isObject: !0
    }), this.schema.register("$text", {
      allowIn: "$block",
      isInline: !0,
      isContent: !0
    }), this.schema.register("$clipboardHolder", {
      allowContentOf: "$root",
      allowChildren: "$text",
      isLimit: !0
    }), this.schema.register("$documentFragment", {
      allowContentOf: "$root",
      allowChildren: "$text",
      isLimit: !0
    }), this.schema.register("$marker"), this.schema.addChildCheck((e, t) => {
      if (t.name === "$marker")
        return !0;
    }), ZL(this), this.document.registerPostFixer(oC), this.on("insertContent", (e, [t, n]) => {
      e.return = lF(this, t, n);
    }), this.on("insertObject", (e, [t, n, r]) => {
      e.return = uF(this, t, n, r);
    });
  }
  /**
   * The `change()` method is the primary way of changing the model. You should use it to modify all document nodes
   * (including detached nodes – i.e. nodes not added to the {@link module:engine/model/model~Model#document model document}),
   * the {@link module:engine/model/document~Document#selection document's selection}, and
   * {@link module:engine/model/model~Model#markers model markers}.
   *
   * ```ts
   * model.change( writer => {
   * 	writer.insertText( 'foo', paragraph, 'end' );
   * } );
   * ```
   *
   * All changes inside the change block use the same {@link module:engine/model/batch~Batch} so they are combined
   * into a single undo step.
   *
   * ```ts
   * model.change( writer => {
   * 	writer.insertText( 'foo', paragraph, 'end' ); // foo.
   *
   * 	model.change( writer => {
   * 		writer.insertText( 'bar', paragraph, 'end' ); // foobar.
   * 	} );
   *
   * 	writer.insertText( 'bom', paragraph, 'end' ); // foobarbom.
   * } );
   * ```
   *
   * The callback of the `change()` block is executed synchronously.
   *
   * You can also return a value from the change block.
   *
   * ```ts
   * const img = model.change( writer => {
   * 	return writer.createElement( 'img' );
   * } );
   * ```
   *
   * @see #enqueueChange
   * @typeParam TReturn The return type of the provided callback.
   * @param callback Callback function which may modify the model.
   */
  change(e) {
    try {
      return this._pendingChanges.length === 0 ? (this._pendingChanges.push({ batch: new ko(), callback: e }), this._runPendingChanges()[0]) : e(this._currentWriter);
    } catch (t) {
      /* istanbul ignore next -- @preserve */
      B.rethrowUnexpectedError(t, this);
    }
  }
  enqueueChange(e, t) {
    try {
      e ? typeof e == "function" ? (t = e, e = new ko()) : e instanceof ko || (e = new ko(e)) : e = new ko(), this._pendingChanges.push({ batch: e, callback: t }), this._pendingChanges.length == 1 && this._runPendingChanges();
    } catch (n) {
      /* istanbul ignore next -- @preserve */
      B.rethrowUnexpectedError(n, this);
    }
  }
  /**
   * {@link module:utils/observablemixin~Observable#decorate Decorated} function for applying
   * {@link module:engine/model/operation/operation~Operation operations} to the model.
   *
   * This is a low-level way of changing the model. It is exposed for very specific use cases (like the undo feature).
   * Normally, to modify the model, you will want to use {@link module:engine/model/writer~Writer `Writer`}.
   * See also {@glink framework/architecture/editing-engine#changing-the-model Changing the model} section
   * of the {@glink framework/architecture/editing-engine Editing architecture} guide.
   *
   * @param operation The operation to apply.
   */
  applyOperation(e) {
    e._execute();
  }
  // @if CK_DEBUG_ENGINE // public getAppliedOperation(): string {
  // @if CK_DEBUG_ENGINE // 	if ( !this._appliedOperations ) {
  // @if CK_DEBUG_ENGINE // 		return '';
  // @if CK_DEBUG_ENGINE // 	}
  // @if CK_DEBUG_ENGINE // 	return this._appliedOperations.map( operation => JSON.stringify( operation ) ).join( '-------' );
  // @if CK_DEBUG_ENGINE // }
  // @if CK_DEBUG_ENGINE // public createReplayer( stringifiedOperations: string ): typeof OperationReplayer {
  // @if CK_DEBUG_ENGINE // 	return new OperationReplayer( this, '-------', stringifiedOperations );
  // @if CK_DEBUG_ENGINE // }
  /**
   * Inserts content at the position in the editor specified by the selection, as one would expect the paste
   * functionality to work.
   *
   * **Note**: If you want to insert an {@glink framework/deep-dive/schema#object-elements object element}
   * (e.g. a {@link module:widget/utils~toWidget widget}), see {@link #insertObject} instead.
   *
   * This is a high-level method. It takes the {@link #schema schema} into consideration when inserting
   * the content, clears the given selection's content before inserting nodes and moves the selection
   * to its target position at the end of the process.
   * It can split elements, merge them, wrap bare text nodes with paragraphs, etc. &mdash; just like the
   * pasting feature should do.
   *
   * For lower-level methods see {@link module:engine/model/writer~Writer `Writer`}.
   *
   * This method, unlike {@link module:engine/model/writer~Writer `Writer`}'s methods, does not have to be used
   * inside a {@link #change `change()` block}.
   *
   * # Conversion and schema
   *
   * Inserting elements and text nodes into the model is not enough to make CKEditor 5 render that content
   * to the user. CKEditor 5 implements a model-view-controller architecture and what `model.insertContent()` does
   * is only adding nodes to the model. Additionally, you need to define
   * {@glink framework/architecture/editing-engine#conversion converters} between the model and view
   * and define those nodes in the {@glink framework/architecture/editing-engine#schema schema}.
   *
   * So, while this method may seem similar to CKEditor 4 `editor.insertHtml()` (in fact, both methods
   * are used for paste-like content insertion), the CKEditor 5 method cannot be use to insert arbitrary HTML
   * unless converters are defined for all elements and attributes in that HTML.
   *
   * # Examples
   *
   * Using `insertContent()` with a manually created model structure:
   *
   * ```ts
   * // Let's create a document fragment containing such content as:
   * //
   * // <paragraph>foo</paragraph>
   * // <blockQuote>
   * //    <paragraph>bar</paragraph>
   * // </blockQuote>
   * const docFrag = editor.model.change( writer => {
   * 	const p1 = writer.createElement( 'paragraph' );
   * 	const p2 = writer.createElement( 'paragraph' );
   * 	const blockQuote = writer.createElement( 'blockQuote' );
   * 	const docFrag = writer.createDocumentFragment();
   *
   * 	writer.append( p1, docFrag );
   * 	writer.append( blockQuote, docFrag );
   * 	writer.append( p2, blockQuote );
   * 	writer.insertText( 'foo', p1 );
   * 	writer.insertText( 'bar', p2 );
   *
   * 	return docFrag;
   * } );
   *
   * // insertContent() does not have to be used in a change() block. It can, though,
   * // so this code could be moved to the callback defined above.
   * editor.model.insertContent( docFrag );
   * ```
   *
   * Using `insertContent()` with an HTML string converted to a model document fragment (similar to the pasting mechanism):
   *
   * ```ts
   * // You can create your own HtmlDataProcessor instance or use editor.data.processor
   * // if you have not overridden the default one (which is the HtmlDataProcessor instance).
   * const htmlDP = new HtmlDataProcessor( viewDocument );
   *
   * // Convert an HTML string to a view document fragment:
   * const viewFragment = htmlDP.toView( htmlString );
   *
   * // Convert the view document fragment to a model document fragment
   * // in the context of $root. This conversion takes the schema into
   * // account so if, for example, the view document fragment contained a bare text node,
   * // this text node cannot be a child of $root, so it will be automatically
   * // wrapped with a <paragraph>. You can define the context yourself (in the second parameter),
   * // and e.g. convert the content like it would happen in a <paragraph>.
   * // Note: The clipboard feature uses a custom context called $clipboardHolder
   * // which has a loosened schema.
   * const modelFragment = editor.data.toModel( viewFragment );
   *
   * editor.model.insertContent( modelFragment );
   * ```
   *
   * By default this method will use the document selection but it can also be used with a position, range or selection instance.
   *
   * ```ts
   * // Insert text at the current document selection position.
   * editor.model.change( writer => {
   * 	editor.model.insertContent( writer.createText( 'x' ) );
   * } );
   *
   * // Insert text at a given position - the document selection will not be modified.
   * editor.model.change( writer => {
   * 	editor.model.insertContent( writer.createText( 'x' ), doc.getRoot(), 2 );
   *
   * 	// Which is a shorthand for:
   * 	editor.model.insertContent( writer.createText( 'x' ), writer.createPositionAt( doc.getRoot(), 2 ) );
   * } );
   * ```
   *
   * If you want the document selection to be moved to the inserted content, use the
   * {@link module:engine/model/writer~Writer#setSelection `setSelection()`} method of the writer after inserting
   * the content:
   *
   * ```ts
   * editor.model.change( writer => {
   * 	const paragraph = writer.createElement( 'paragraph' );
   *
   * 	// Insert an empty paragraph at the beginning of the root.
   * 	editor.model.insertContent( paragraph, writer.createPositionAt( editor.model.document.getRoot(), 0 ) );
   *
   * 	// Move the document selection to the inserted paragraph.
   * 	writer.setSelection( paragraph, 'in' );
   * } );
   * ```
   *
   * If an instance of the {@link module:engine/model/selection~Selection model selection} is passed as `selectable`,
   * the new content will be inserted at the passed selection (instead of document selection):
   *
   * ```ts
   * editor.model.change( writer => {
   * 	// Create a selection in a paragraph that will be used as a place of insertion.
   * 	const selection = writer.createSelection( paragraph, 'in' );
   *
   * 	// Insert the new text at the created selection.
   * 	editor.model.insertContent( writer.createText( 'x' ), selection );
   *
   * 	// insertContent() modifies the passed selection instance so it can be used to set the document selection.
   * 	// Note: This is not necessary when you passed the document selection to insertContent().
   * 	writer.setSelection( selection );
   * } );
   * ```
   *
   * @fires insertContent
   * @param content The content to insert.
   * @param selectable The selection into which the content should be inserted.
   * If not provided the current model document selection will be used.
   * @param placeOrOffset To be used when a model item was passed as `selectable`.
   * This param defines a position in relation to that item.
   * at the insertion position.
   */
  insertContent(e, t, n, ...r) {
    const s = Tb(t, n);
    return this.fire("insertContent", [e, s, n, ...r]);
  }
  /**
   * Inserts an {@glink framework/deep-dive/schema#object-elements object element} at a specific position in the editor content.
   *
   * This is a high-level API:
   * * It takes the {@link #schema schema} into consideration,
   * * It clears the content of passed `selectable` before inserting,
   * * It can move the selection at the end of the process,
   * * It will copy the selected block's attributes to preserve them upon insertion,
   * * It can split elements or wrap inline objects with paragraphs if they are not allowed in target position,
   * * etc.
   *
   * # Notes
   *
   * * If you want to insert a non-object content, see {@link #insertContent} instead.
   * * For lower-level API, see {@link module:engine/model/writer~Writer `Writer`}.
   * * Unlike {@link module:engine/model/writer~Writer `Writer`}, this method does not have to be used inside
   * a {@link #change `change()` block}.
   * * Inserting object into the model is not enough to make CKEditor 5 render that content to the user.
   * CKEditor 5 implements a model-view-controller architecture and what `model.insertObject()` does
   * is only adding nodes to the model. Additionally, you need to define
   * {@glink framework/architecture/editing-engine#conversion converters} between the model and view
   * and define those nodes in the {@glink framework/architecture/editing-engine#schema schema}.
   *
   * # Examples
   *
   * Use the following code to insert an object at the current selection and keep the selection on the inserted element:
   *
   * ```ts
   * const rawHtmlEmbedElement = writer.createElement( 'rawHtml' );
   *
   * model.insertObject( rawHtmlEmbedElement, null, null, {
   * 	setSelection: 'on'
   * } );
   * ```
   *
   * Use the following code to insert an object at the current selection and nudge the selection after the inserted object:
   *
   * ```ts
   * const pageBreakElement = writer.createElement( 'pageBreak' );
   *
   * model.insertObject( pageBreakElement, null, null, {
   * 	setSelection: 'after'
   * } );
   * ```
   *
   * Use the following code to insert an object at the current selection and avoid splitting the content (non-destructive insertion):
   *
   * ```ts
   * const tableElement = writer.createElement( 'table' );
   *
   * model.insertObject( tableElement, null, null, {
   * 	findOptimalPosition: 'auto'
   * } );
   * ```
   *
   * Use the following code to insert an object at the specific range (also: replace the content of the range):
   *
   * ```ts
   * const tableElement = writer.createElement( 'table' );
   * const range = model.createRangeOn( model.document.getRoot().getChild( 1 ) );
   *
   * model.insertObject( tableElement, range );
   * ```
   *
   * @param element An object to be inserted into the model document.
   * @param selectable A selectable where the content should be inserted. If not specified, the current
   * {@link module:engine/model/document~Document#selection document selection} will be used instead.
   * @param placeOrOffset Specifies the exact place or offset for the insertion to take place, relative to `selectable`.
   * @param options Additional options.
   * @param options.findOptimalPosition An option that, when set, adjusts the insertion position (relative to
   * `selectable` and `placeOrOffset`) so that the content of `selectable` is not split upon insertion (a.k.a. non-destructive insertion).
   * * When `'auto'`, the algorithm will decide whether to insert the object before or after `selectable` to avoid content splitting.
   * * When `'before'`, the closest position before `selectable` will be used that will not result in content splitting.
   * * When `'after'`, the closest position after `selectable` will be used that will not result in content splitting.
   *
   * Note that this option only works for block objects. Inline objects are inserted into text and do not split blocks.
   * @param options.setSelection An option that, when set, moves the
   * {@link module:engine/model/document~Document#selection document selection} after inserting the object.
   * * When `'on'`, the document selection will be set on the inserted object.
   * * When `'after'`, the document selection will move to the closest text node after the inserted object. If there is no
   * such text node, a paragraph will be created and the document selection will be moved inside it.
   * at the insertion position.
   */
  insertObject(e, t, n, r, ...s) {
    const o = Tb(t, n);
    return this.fire("insertObject", [e, o, r, r, ...s]);
  }
  /**
   * Deletes content of the selection and merge siblings. The resulting selection is always collapsed.
   *
   * **Note:** For the sake of predictability, the resulting selection should always be collapsed.
   * In cases where a feature wants to modify deleting behavior so selection isn't collapsed
   * (e.g. a table feature may want to keep row selection after pressing <kbd>Backspace</kbd>),
   * then that behavior should be implemented in the view's listener. At the same time, the table feature
   * will need to modify this method's behavior too, e.g. to "delete contents and then collapse
   * the selection inside the last selected cell" or "delete the row and collapse selection somewhere near".
   * That needs to be done in order to ensure that other features which use `deleteContent()` will work well with tables.
   *
   * @fires deleteContent
   * @param selection Selection of which the content should be deleted.
   * @param options.leaveUnmerged Whether to merge elements after removing the content of the selection.
   *
   * For example `<heading1>x[x</heading1><paragraph>y]y</paragraph>` will become:
   *
   * * `<heading1>x^y</heading1>` with the option disabled (`leaveUnmerged == false`)
   * * `<heading1>x^</heading1><paragraph>y</paragraph>` with enabled (`leaveUnmerged == true`).
   *
   * Note: {@link module:engine/model/schema~Schema#isObject object} and {@link module:engine/model/schema~Schema#isLimit limit}
   * elements will not be merged.
   *
   * @param options.doNotResetEntireContent Whether to skip replacing the entire content with a
   * paragraph when the entire content was selected.
   *
   * For example `<heading1>[x</heading1><paragraph>y]</paragraph>` will become:
   *
   * * `<paragraph>^</paragraph>` with the option disabled (`doNotResetEntireContent == false`)
   * * `<heading1>^</heading1>` with enabled (`doNotResetEntireContent == true`)
   *
   * @param options.doNotAutoparagraph Whether to create a paragraph if after content deletion selection is moved
   * to a place where text cannot be inserted.
   *
   * For example `<paragraph>x</paragraph>[<imageBlock src="foo.jpg"></imageBlock>]` will become:
   *
   * * `<paragraph>x</paragraph><paragraph>[]</paragraph>` with the option disabled (`doNotAutoparagraph == false`)
   * * `<paragraph>x[]</paragraph>` with the option enabled (`doNotAutoparagraph == true`).
   *
   * **Note:** if there is no valid position for the selection, the paragraph will always be created:
   *
   * `[<imageBlock src="foo.jpg"></imageBlock>]` -> `<paragraph>[]</paragraph>`.
   *
   * @param options.direction The direction in which the content is being consumed.
   * Deleting backward corresponds to using the <kbd>Backspace</kbd> key, while deleting content forward corresponds to
   * the <kbd>Shift</kbd>+<kbd>Backspace</kbd> keystroke.
   */
  deleteContent(e, t) {
    X8(this, e, t);
  }
  /**
   * Modifies the selection. Currently, the supported modifications are:
   *
   * * Extending. The selection focus is moved in the specified `options.direction` with a step specified in `options.unit`.
   * Possible values for `unit` are:
   *  * `'character'` (default) - moves selection by one user-perceived character. In most cases this means moving by one
   *  character in `String` sense. However, unicode also defines "combing marks". These are special symbols, that combines
   *  with a symbol before it ("base character") to create one user-perceived character. For example, `q̣̇` is a normal
   *  letter `q` with two "combining marks": upper dot (`Ux0307`) and lower dot (`Ux0323`). For most actions, i.e. extending
   *  selection by one position, it is correct to include both "base character" and all of it's "combining marks". That is
   *  why `'character'` value is most natural and common method of modifying selection.
   *  * `'codePoint'` - moves selection by one unicode code point. In contrary to, `'character'` unit, this will insert
   *  selection between "base character" and "combining mark", because "combining marks" have their own unicode code points.
   *  However, for technical reasons, unicode code points with values above `UxFFFF` are represented in native `String` by
   *  two characters, called "surrogate pairs". Halves of "surrogate pairs" have a meaning only when placed next to each other.
   *  For example `𨭎` is represented in `String` by `\uD862\uDF4E`. Both `\uD862` and `\uDF4E` do not have any meaning
   *  outside the pair (are rendered as ? when alone). Position between them would be incorrect. In this case, selection
   *  extension will include whole "surrogate pair".
   *  * `'word'` - moves selection by a whole word.
   *
   * **Note:** if you extend a forward selection in a backward direction you will in fact shrink it.
   *
   * @fires modifySelection
   * @param selection The selection to modify.
   * @param options.direction The direction in which the selection should be modified.
   * @param options.unit The unit by which selection should be modified.
   * @param options.treatEmojiAsSingleUnit Whether multi-characer emoji sequences should be handled as single unit.
   */
  modifySelection(e, t) {
    fF(this, e, t);
  }
  /**
   * Gets a clone of the selected content.
   *
   * For example, for the following selection:
   *
   * ```html
   * <paragraph>x</paragraph>
   * <blockQuote>
   * 	<paragraph>y</paragraph>
   * 	<heading1>fir[st</heading1>
   * </blockQuote>
   * <paragraph>se]cond</paragraph>
   * <paragraph>z</paragraph>
   * ```
   *
   * It will return a document fragment with such a content:
   *
   * ```html
   * <blockQuote>
   * 	<heading1>st</heading1>
   * </blockQuote>
   * <paragraph>se</paragraph>
   * ```
   *
   * @fires getSelectedContent
   * @param selection The selection of which content will be returned.
   */
  getSelectedContent(e) {
    return aF(this, e);
  }
  /**
   * Checks whether the given {@link module:engine/model/range~Range range} or
   * {@link module:engine/model/element~Element element} has any meaningful content.
   *
   * Meaningful content is:
   *
   * * any text node (`options.ignoreWhitespaces` allows controlling whether this text node must also contain
   * any non-whitespace characters),
   * * or any {@link module:engine/model/schema~Schema#isContent content element},
   * * or any {@link module:engine/model/markercollection~Marker marker} which
   * {@link module:engine/model/markercollection~Marker#_affectsData affects data}.
   *
   * This means that a range containing an empty `<paragraph></paragraph>` is not considered to have a meaningful content.
   * However, a range containing an `<imageBlock></imageBlock>` (which would normally be marked in the schema as an object element)
   * is considered non-empty.
   *
   * @param rangeOrElement Range or element to check.
   * @param options.ignoreWhitespaces Whether text node with whitespaces only should be considered empty.
   * @param options.ignoreMarkers Whether markers should be ignored.
   */
  hasContent(e, t = {}) {
    const n = e instanceof X ? e : X._createIn(e);
    if (n.isCollapsed)
      return !1;
    const { ignoreWhitespaces: r = !1, ignoreMarkers: s = !1 } = t;
    if (!s) {
      for (const o of this.markers.getMarkersIntersectingRange(n))
        if (o.affectsData)
          return !0;
    }
    for (const o of n.getItems())
      if (this.schema.isContent(o))
        if (o.is("$textProxy"))
          if (r) {
            if (o.data.search(/\S/) !== -1)
              return !0;
          } else
            return !0;
        else
          return !0;
    return !1;
  }
  /**
   * Creates a position from the given root and path in that root.
   *
   * Note: This method is also available as
   * {@link module:engine/model/writer~Writer#createPositionFromPath `Writer#createPositionFromPath()`}.
   *
   * @param root Root of the position.
   * @param path Position path. See {@link module:engine/model/position~Position#path}.
   * @param stickiness Position stickiness. See {@link module:engine/model/position~PositionStickiness}.
   */
  createPositionFromPath(e, t, n) {
    return new oe(e, t, n);
  }
  /**
   * Creates position at the given location. The location can be specified as:
   *
   * * a {@link module:engine/model/position~Position position},
   * * a parent element and offset in that element,
   * * a parent element and `'end'` (the position will be set at the end of that element),
   * * a {@link module:engine/model/item~Item model item} and `'before'` or `'after'`
   * (the position will be set before or after the given model item).
   *
   * This method is a shortcut to other factory methods such as:
   *
   * * {@link module:engine/model/model~Model#createPositionBefore `createPositionBefore()`},
   * * {@link module:engine/model/model~Model#createPositionAfter `createPositionAfter()`}.
   *
   * Note: This method is also available as
   * {@link module:engine/model/writer~Writer#createPositionAt `Writer#createPositionAt()`},
   *
   * @param itemOrPosition
   * @param offset Offset or one of the flags. Used only when first parameter is a {@link module:engine/model/item~Item model item}.
   */
  createPositionAt(e, t) {
    return oe._createAt(e, t);
  }
  /**
   * Creates a new position after the given {@link module:engine/model/item~Item model item}.
   *
   * Note: This method is also available as
   * {@link module:engine/model/writer~Writer#createPositionAfter `Writer#createPositionAfter()`}.
   *
   * @param item Item after which the position should be placed.
   */
  createPositionAfter(e) {
    return oe._createAfter(e);
  }
  /**
   * Creates a new position before the given {@link module:engine/model/item~Item model item}.
   *
   * Note: This method is also available as
   * {@link module:engine/model/writer~Writer#createPositionBefore `Writer#createPositionBefore()`}.
   *
   * @param item Item before which the position should be placed.
   */
  createPositionBefore(e) {
    return oe._createBefore(e);
  }
  /**
   * Creates a range spanning from the `start` position to the `end` position.
   *
   * Note: This method is also available as
   * {@link module:engine/model/writer~Writer#createRange `Writer#createRange()`}:
   *
   * ```ts
   * model.change( writer => {
   * 	const range = writer.createRange( start, end );
   * } );
   * ```
   *
   * @param start Start position.
   * @param end End position. If not set, the range will be collapsed to the `start` position.
   */
  createRange(e, t) {
    return new X(e, t);
  }
  /**
   * Creates a range inside the given element which starts before the first child of
   * that element and ends after the last child of that element.
   *
   * Note: This method is also available as
   * {@link module:engine/model/writer~Writer#createRangeIn `Writer#createRangeIn()`}:
   *
   * ```ts
   * model.change( writer => {
   * 	const range = writer.createRangeIn( paragraph );
   * } );
   * ```
   *
   * @param element Element which is a parent for the range.
   */
  createRangeIn(e) {
    return X._createIn(e);
  }
  /**
   * Creates a range that starts before the given {@link module:engine/model/item~Item model item} and ends after it.
   *
   * Note: This method is also available on `writer` instance as
   * {@link module:engine/model/writer~Writer#createRangeOn `Writer.createRangeOn()`}:
   *
   * ```ts
   * model.change( writer => {
   * 	const range = writer.createRangeOn( paragraph );
   * } );
   * ```
   *
   * @param item
   */
  createRangeOn(e) {
    return X._createOn(e);
  }
  createSelection(...e) {
    return new Vi(...e);
  }
  /**
   * Creates a {@link module:engine/model/batch~Batch} instance.
   *
   * **Note:** In most cases creating a batch instance is not necessary as they are created when using:
   *
   * * {@link #change `change()`},
   * * {@link #enqueueChange `enqueueChange()`}.
   *
   * @param type {@link module:engine/model/batch~Batch#constructor The type} of the batch.
   */
  createBatch(e) {
    return new ko(e);
  }
  /**
   * Creates an operation instance from a JSON object (parsed JSON string).
   *
   * This is an alias for {@link module:engine/model/operation/operationfactory~OperationFactory.fromJSON `OperationFactory.fromJSON()`}.
   *
   * @param json Deserialized JSON object.
   */
  createOperationFromJSON(e) {
    return M8.fromJSON(e, this.document);
  }
  /**
   * Removes all events listeners set by model instance and destroys {@link module:engine/model/document~Document}.
   */
  destroy() {
    this.document.destroy(), this.stopListening();
  }
  /**
   * Common part of {@link module:engine/model/model~Model#change} and {@link module:engine/model/model~Model#enqueueChange}
   * which calls callbacks and returns array of values returned by these callbacks.
   *
   */
  _runPendingChanges() {
    const e = [];
    this.fire("_beforeChanges");
    try {
      for (; this._pendingChanges.length; ) {
        const t = this._pendingChanges[0].batch;
        this._currentWriter = new Y8(this, t);
        const n = this._pendingChanges[0].callback(this._currentWriter);
        e.push(n), this.document._handleChangeBlock(this._currentWriter), this._pendingChanges.shift(), this._currentWriter = null;
      }
    } finally {
      this._pendingChanges.length = 0, this._currentWriter = null, this.fire("_afterChanges");
    }
    return e;
  }
};
function Tb(i, e) {
  if (i)
    return i instanceof Vi || i instanceof zi ? i : i instanceof Ks ? new Vi(i, e) : new Vi(i);
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class yF extends qs {
  constructor() {
    super(...arguments), this.domEventType = "click";
  }
  /**
   * @inheritDoc
   */
  onDomEvent(e) {
    this.fire(e.type, e);
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class uh extends qs {
  constructor() {
    super(...arguments), this.domEventType = ["mousedown", "mouseup", "mouseover", "mouseout"];
  }
  /**
   * @inheritDoc
   */
  onDomEvent(e) {
    this.fire(e.type, e);
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class gp {
  /**
   * @param document The view document instance in which this upcast writer operates.
   */
  constructor(e) {
    this.document = e;
  }
  /**
   * Creates a new {@link module:engine/view/documentfragment~DocumentFragment} instance.
   *
   * @param children A list of nodes to be inserted into the created document fragment.
   * @returns The created document fragment.
   */
  createDocumentFragment(e) {
    return new Ns(this.document, e);
  }
  /**
   * Creates a new {@link module:engine/view/element~Element} instance.
   *
   * Attributes can be passed in various formats:
   *
   * ```ts
   * upcastWriter.createElement( 'div', { class: 'editor', contentEditable: 'true' } ); // object
   * upcastWriter.createElement( 'div', [ [ 'class', 'editor' ], [ 'contentEditable', 'true' ] ] ); // map-like iterator
   * upcastWriter.createElement( 'div', mapOfAttributes ); // map
   * ```
   *
   * @param name Node name.
   * @param attrs Collection of attributes.
   * @param children A list of nodes to be inserted into created element.
   * @returns Created element.
   */
  createElement(e, t, n) {
    return new $i(this.document, e, t, n);
  }
  /**
   * Creates a new {@link module:engine/view/text~Text} instance.
   *
   * @param data The text's data.
   * @returns The created text node.
   */
  createText(e) {
    return new Bt(this.document, e);
  }
  /**
   * Clones the provided element.
   *
   * @see module:engine/view/element~Element#_clone
   * @param element Element to be cloned.
   * @param deep If set to `true` clones element and all its children recursively. When set to `false`,
   * element will be cloned without any children.
   * @returns Clone of this element.
   */
  clone(e, t = !1) {
    return e._clone(t);
  }
  /**
   * Appends a child node or a list of child nodes at the end of this node
   * and sets the parent of these nodes to this element.
   *
   * @see module:engine/view/element~Element#_appendChild
   * @param items Items to be inserted.
   * @param element Element to which items will be appended.
   * @returns Number of appended nodes.
   */
  appendChild(e, t) {
    return t._appendChild(e);
  }
  /**
   * Inserts a child node or a list of child nodes on the given index and sets the parent of these nodes to
   * this element.
   *
   * @see module:engine/view/element~Element#_insertChild
   * @param index Offset at which nodes should be inserted.
   * @param items Items to be inserted.
   * @param element Element to which items will be inserted.
   * @returns Number of inserted nodes.
   */
  insertChild(e, t, n) {
    return n._insertChild(e, t);
  }
  /**
   * Removes the given number of child nodes starting at the given index and set the parent of these nodes to `null`.
   *
   * @see module:engine/view/element~Element#_removeChildren
   * @param index Offset from which nodes will be removed.
   * @param howMany Number of nodes to remove.
   * @param element Element which children will be removed.
   * @returns The array containing removed nodes.
   */
  removeChildren(e, t, n) {
    return n._removeChildren(e, t);
  }
  /**
   * Removes given element from the view structure. Will not have effect on detached elements.
   *
   * @param element Element which will be removed.
   * @returns The array containing removed nodes.
   */
  remove(e) {
    const t = e.parent;
    return t ? this.removeChildren(t.getChildIndex(e), 1, t) : [];
  }
  /**
   * Replaces given element with the new one in the view structure. Will not have effect on detached elements.
   *
   * @param oldElement Element which will be replaced.
   * @param newElement Element which will be inserted in the place of the old element.
   * @returns Whether old element was successfully replaced.
   */
  replace(e, t) {
    const n = e.parent;
    if (n) {
      const r = n.getChildIndex(e);
      return this.removeChildren(r, 1, n), this.insertChild(r, t, n), !0;
    }
    return !1;
  }
  /**
   * Removes given element from view structure and places its children in its position.
   * It does nothing if element has no parent.
   *
   * @param element Element to unwrap.
   */
  unwrapElement(e) {
    const t = e.parent;
    if (t) {
      const n = t.getChildIndex(e);
      this.remove(e), this.insertChild(n, e.getChildren(), t);
    }
  }
  /**
   * Renames element by creating a copy of a given element but with its name changed and then moving contents of the
   * old element to the new one.
   *
   * Since this function creates a new element and removes the given one, the new element is returned to keep reference.
   *
   * @param newName New element name.
   * @param  element Element to be renamed.
   * @returns New element or null if the old element was not replaced (happens for detached elements).
   */
  rename(e, t) {
    const n = new $i(this.document, e, t.getAttributes(), t.getChildren());
    return this.replace(t, n) ? n : null;
  }
  /**
   * Adds or overwrites element's attribute with a specified key and value.
   *
   * ```ts
   * writer.setAttribute( 'href', 'http://ckeditor.com', linkElement );
   * ```
   *
   * @see module:engine/view/element~Element#_setAttribute
   * @param key Attribute key.
   * @param value Attribute value.
   * @param element Element for which attribute will be set.
   */
  setAttribute(e, t, n) {
    n._setAttribute(e, t);
  }
  /**
   * Removes attribute from the element.
   *
   * ```ts
   * writer.removeAttribute( 'href', linkElement );
   * ```
   *
   * @see module:engine/view/element~Element#_removeAttribute
   * @param key Attribute key.
   * @param element Element from which attribute will be removed.
   */
  removeAttribute(e, t) {
    t._removeAttribute(e);
  }
  /**
   * Adds specified class to the element.
   *
   * ```ts
   * writer.addClass( 'foo', linkElement );
   * writer.addClass( [ 'foo', 'bar' ], linkElement );
   * ```
   *
   * @see module:engine/view/element~Element#_addClass
   * @param className Single class name or array of class names which will be added.
   * @param element Element for which class will be added.
   */
  addClass(e, t) {
    t._addClass(e);
  }
  /**
   * Removes specified class from the element.
   *
   * ```ts
   * writer.removeClass( 'foo', linkElement );
   * writer.removeClass( [ 'foo', 'bar' ], linkElement );
   * ```
   *
   * @see module:engine/view/element~Element#_removeClass
   * @param className Single class name or array of class names which will be removed.
   * @param element Element from which class will be removed.
   */
  removeClass(e, t) {
    t._removeClass(e);
  }
  setStyle(e, t, n) {
    ui(e) && n === void 0 ? t._setStyle(e) : n._setStyle(e, t);
  }
  /**
   * Removes specified style from the element.
   *
   * ```ts
   * writer.removeStyle( 'color', element );  // Removes 'color' style.
   * writer.removeStyle( [ 'color', 'border-top' ], element ); // Removes both 'color' and 'border-top' styles.
   * ```
   *
   * **Note**: This method can work with normalized style names if
   * {@link module:engine/controller/datacontroller~DataController#addStyleProcessorRules a particular style processor rule is enabled}.
   * See {@link module:engine/view/stylesmap~StylesMap#remove `StylesMap#remove()`} for details.
   *
   * @see module:engine/view/element~Element#_removeStyle
   * @param property Style property name or names to be removed.
   * @param element Element from which style will be removed.
   */
  removeStyle(e, t) {
    t._removeStyle(e);
  }
  /**
   * Sets a custom property on element. Unlike attributes, custom properties are not rendered to the DOM,
   * so they can be used to add special data to elements.
   *
   * @see module:engine/view/element~Element#_setCustomProperty
   * @param key Custom property name/key.
   * @param value Custom property value to be stored.
   * @param element Element for which custom property will be set.
   */
  setCustomProperty(e, t, n) {
    n._setCustomProperty(e, t);
  }
  /**
   * Removes a custom property stored under the given key.
   *
   * @see module:engine/view/element~Element#_removeCustomProperty
   * @param key Name/key of the custom property to be removed.
   * @param element Element from which the custom property will be removed.
   * @returns Returns true if property was removed.
   */
  removeCustomProperty(e, t) {
    return t._removeCustomProperty(e);
  }
  /**
   * Creates position at the given location. The location can be specified as:
   *
   * * a {@link module:engine/view/position~Position position},
   * * parent element and offset (offset defaults to `0`),
   * * parent element and `'end'` (sets position at the end of that element),
   * * {@link module:engine/view/item~Item view item} and `'before'` or `'after'` (sets position before or after given view item).
   *
   * This method is a shortcut to other constructors such as:
   *
   * * {@link #createPositionBefore},
   * * {@link #createPositionAfter},
   *
   * @param offset Offset or one of the flags. Used only when first parameter is a {@link module:engine/view/item~Item view item}.
   */
  createPositionAt(e, t) {
    return _e._createAt(e, t);
  }
  /**
   * Creates a new position after given view item.
   *
   * @param item View item after which the position should be located.
   */
  createPositionAfter(e) {
    return _e._createAfter(e);
  }
  /**
   * Creates a new position before given view item.
   *
   * @param item View item before which the position should be located.
   */
  createPositionBefore(e) {
    return _e._createBefore(e);
  }
  /**
   * Creates a range spanning from `start` position to `end` position.
   *
   * **Note:** This factory method creates it's own {@link module:engine/view/position~Position} instances basing on passed values.
   *
   * @param start Start position.
   * @param end End position. If not set, range will be collapsed at `start` position.
   */
  createRange(e, t) {
    return new We(e, t);
  }
  /**
   * Creates a range that starts before given {@link module:engine/view/item~Item view item} and ends after it.
   */
  createRangeOn(e) {
    return We._createOn(e);
  }
  /**
   * Creates a range inside an {@link module:engine/view/element~Element element} which starts before the first child of
   * that element and ends after the last child of that element.
   *
   * @param element Element which is a parent for the range.
   */
  createRangeIn(e) {
    return We._createIn(e);
  }
  createSelection(...e) {
    return new is(...e);
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class EF {
  /**
   * Creates collection instance.
   */
  constructor() {
    this._commands = /* @__PURE__ */ new Map();
  }
  /**
   * Registers a new command.
   *
   * @param commandName The name of the command.
   */
  add(e, t) {
    this._commands.set(e, t);
  }
  /**
   * Retrieves a command from the collection.
   *
   * @param commandName The name of the command.
   */
  get(e) {
    return this._commands.get(e);
  }
  /**
   * Executes a command.
   *
   * @param commandName The name of the command.
   * @param commandParams Command parameters.
   * @returns The value returned by the {@link module:core/command~Command#execute `command.execute()`}.
   */
  execute(e, ...t) {
    const n = this.get(e);
    if (!n)
      throw new B("commandcollection-command-not-found", this, { commandName: e });
    return n.execute(...t);
  }
  /**
   * Returns iterator of command names.
   */
  *names() {
    yield* this._commands.keys();
  }
  /**
   * Returns iterator of command instances.
   */
  *commands() {
    yield* this._commands.values();
  }
  /**
   * Iterable interface.
   *
   * Returns `[ commandName, commandInstance ]` pairs.
   */
  [Symbol.iterator]() {
    return this._commands[Symbol.iterator]();
  }
  /**
   * Destroys all collection commands.
   */
  destroy() {
    for (const e of this.commands())
      e.destroy();
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class CF extends cr {
  /**
   * Creates an instance of the keystroke handler.
   */
  constructor(e) {
    super(), this.editor = e;
  }
  /**
   * Registers a handler for the specified keystroke.
   *
   * The handler can be specified as a command name or a callback.
   *
   * @param keystroke Keystroke defined in a format accepted by
   * the {@link module:utils/keyboard~parseKeystroke} function.
   * @param callback If a string is passed, then the keystroke will
   * {@link module:core/editor/editor~Editor#execute execute a command}.
   * If a function, then it will be called with the
   * {@link module:engine/view/observer/keyobserver~KeyEventData key event data} object and
   * a `cancel()` helper to both `preventDefault()` and `stopPropagation()` of the event.
   * @param options Additional options.
   * @param options.priority The priority of the keystroke callback. The higher the priority value
   * the sooner the callback will be executed. Keystrokes having the same priority
   * are called in the order they were added.
   */
  set(e, t, n = {}) {
    if (typeof t == "string") {
      const r = t;
      t = (s, o) => {
        this.editor.execute(r), o();
      };
    }
    super.set(e, t, n);
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class dh extends Nt() {
  /**
   * Creates a new instance of the editor class.
   *
   * Usually, not to be used directly. See the static {@link module:core/editor/editor~Editor.create `create()`} method.
   *
   * @param config The editor configuration.
   */
  constructor(e = {}) {
    super();
    const t = this.constructor, n = e.language || t.defaultConfig && t.defaultConfig.language;
    this._context = e.context || new zl({ language: n }), this._context._addEditor(this, !e.context);
    const r = Array.from(t.builtinPlugins || []);
    this.config = new fE(e, t.defaultConfig), this.config.define("plugins", r), this.config.define(this._context._getEditorConfig()), this.plugins = new PE(this, r, this._context.plugins), this.locale = this._context.locale, this.t = this.locale.t, this._readOnlyLocks = /* @__PURE__ */ new Set(), this.commands = new EF(), this.set("state", "initializing"), this.once("ready", () => this.state = "ready", { priority: "high" }), this.once("destroy", () => this.state = "destroyed", { priority: "high" }), this.model = new bF();
    const s = new lV();
    this.data = new P8(this.model, s), this.editing = new r8(this.model, s), this.editing.view.document.bind("isReadOnly").to(this), this.conversion = new R8([this.editing.downcastDispatcher, this.data.downcastDispatcher], this.data.upcastDispatcher), this.conversion.addAlias("dataDowncast", this.data.downcastDispatcher), this.conversion.addAlias("editingDowncast", this.editing.downcastDispatcher), this.keystrokes = new CF(this), this.keystrokes.listenTo(this.editing.view.document);
  }
  /**
   * Defines whether the editor is in the read-only mode.
   *
   * In read-only mode the editor {@link #commands commands} are disabled so it is not possible
   * to modify the document by using them. Also, the editable element(s) become non-editable.
   *
   * In order to make the editor read-only, you need to call the {@link #enableReadOnlyMode} method:
   *
   * ```ts
   * editor.enableReadOnlyMode( 'feature-id' );
   * ```
   *
   * Later, to turn off the read-only mode, call {@link #disableReadOnlyMode}:
   *
   * ```ts
   * editor.disableReadOnlyMode( 'feature-id' );
   * ```
   *
   * @readonly
   * @observable
   */
  get isReadOnly() {
    return this._readOnlyLocks.size > 0;
  }
  set isReadOnly(e) {
    throw new B("editor-isreadonly-has-no-setter");
  }
  /**
   * Turns on the read-only mode in the editor.
   *
   * Editor can be switched to or out of the read-only mode by many features, under various circumstances. The editor supports locking
   * mechanism for the read-only mode. It enables easy control over the read-only mode when many features wants to turn it on or off at
   * the same time, without conflicting with each other. It guarantees that you will not make the editor editable accidentally (which
   * could lead to errors).
   *
   * Each read-only mode request is identified by a unique id (also called "lock"). If multiple plugins requested to turn on the
   * read-only mode, then, the editor will become editable only after all these plugins turn the read-only mode off (using the same ids).
   *
   * Note, that you cannot force the editor to disable the read-only mode if other plugins set it.
   *
   * After the first `enableReadOnlyMode()` call, the {@link #isReadOnly `isReadOnly` property} will be set to `true`:
   *
   * ```ts
   * editor.isReadOnly; // `false`.
   * editor.enableReadOnlyMode( 'my-feature-id' );
   * editor.isReadOnly; // `true`.
   * ```
   *
   * You can turn off the read-only mode ("clear the lock") using the {@link #disableReadOnlyMode `disableReadOnlyMode()`} method:
   *
   * ```ts
   * editor.enableReadOnlyMode( 'my-feature-id' );
   * // ...
   * editor.disableReadOnlyMode( 'my-feature-id' );
   * editor.isReadOnly; // `false`.
   * ```
   *
   * All "locks" need to be removed to enable editing:
   *
   * ```ts
   * editor.enableReadOnlyMode( 'my-feature-id' );
   * editor.enableReadOnlyMode( 'my-other-feature-id' );
   * // ...
   * editor.disableReadOnlyMode( 'my-feature-id' );
   * editor.isReadOnly; // `true`.
   * editor.disableReadOnlyMode( 'my-other-feature-id' );
   * editor.isReadOnly; // `false`.
   * ```
   *
   * @param lockId A unique ID for setting the editor to the read-only state.
   */
  enableReadOnlyMode(e) {
    if (typeof e != "string" && typeof e != "symbol")
      throw new B("editor-read-only-lock-id-invalid", null, { lockId: e });
    this._readOnlyLocks.has(e) || (this._readOnlyLocks.add(e), this._readOnlyLocks.size === 1 && this.fire("change:isReadOnly", "isReadOnly", !0, !1));
  }
  /**
   * Removes the read-only lock from the editor with given lock ID.
   *
   * When no lock is present on the editor anymore, then the {@link #isReadOnly `isReadOnly` property} will be set to `false`.
   *
   * @param lockId The lock ID for setting the editor to the read-only state.
   */
  disableReadOnlyMode(e) {
    if (typeof e != "string" && typeof e != "symbol")
      throw new B("editor-read-only-lock-id-invalid", null, { lockId: e });
    this._readOnlyLocks.has(e) && (this._readOnlyLocks.delete(e), this._readOnlyLocks.size === 0 && this.fire("change:isReadOnly", "isReadOnly", !1, !0));
  }
  /**
   * Loads and initializes plugins specified in the configuration.
   *
   * @returns A promise which resolves once the initialization is completed, providing an array of loaded plugins.
   */
  initPlugins() {
    const e = this.config, t = e.get("plugins"), n = e.get("removePlugins") || [], r = e.get("extraPlugins") || [], s = e.get("substitutePlugins") || [];
    return this.plugins.init(t.concat(r), n, s);
  }
  /**
   * Destroys the editor instance, releasing all resources used by it.
   *
   * **Note** The editor cannot be destroyed during the initialization phase so if it is called
   * while the editor {@link #state is being initialized}, it will wait for the editor initialization before destroying it.
   *
   * @fires destroy
   * @returns A promise that resolves once the editor instance is fully destroyed.
   */
  destroy() {
    let e = Promise.resolve();
    return this.state == "initializing" && (e = new Promise((t) => this.once("ready", t))), e.then(() => {
      this.fire("destroy"), this.stopListening(), this.commands.destroy();
    }).then(() => this.plugins.destroy()).then(() => {
      this.model.destroy(), this.data.destroy(), this.editing.destroy(), this.keystrokes.destroy();
    }).then(() => this._context._removeEditor(this));
  }
  /**
   * Executes the specified command with given parameters.
   *
   * Shorthand for:
   *
   * ```ts
   * editor.commands.get( commandName ).execute( ... );
   * ```
   *
   * @param commandName The name of the command to execute.
   * @param commandParams Command parameters.
   * @returns The value returned by the {@link module:core/commandcollection~CommandCollection#execute `commands.execute()`}.
   */
  execute(e, ...t) {
    try {
      return this.commands.execute(e, ...t);
    } catch (n) {
      /* istanbul ignore next -- @preserve */
      B.rethrowUnexpectedError(n, this);
    }
  }
  /**
   * Focuses the editor.
   *
   * **Note** To explicitly focus the editing area of the editor, use the
   * {@link module:engine/view/view~View#focus `editor.editing.view.focus()`} method of the editing view.
   *
   * Check out the {@glink framework/deep-dive/ui/focus-tracking#focus-in-the-editor-ui Focus in the editor UI} section
   * of the {@glink framework/deep-dive/ui/focus-tracking Deep dive into focus tracking} guide to learn more.
   */
  focus() {
    this.editing.view.focus();
  }
  /* istanbul ignore next -- @preserve */
  /**
   * Creates and initializes a new editor instance.
   *
   * This is an abstract method. Every editor type needs to implement its own initialization logic.
   *
   * See the `create()` methods of the existing editor types to learn how to use them:
   *
   * * {@link module:editor-classic/classiceditor~ClassicEditor.create `ClassicEditor.create()`}
   * * {@link module:editor-balloon/ballooneditor~BalloonEditor.create `BalloonEditor.create()`}
   * * {@link module:editor-decoupled/decouplededitor~DecoupledEditor.create `DecoupledEditor.create()`}
   * * {@link module:editor-inline/inlineeditor~InlineEditor.create `InlineEditor.create()`}
   */
  static create(...e) {
    throw new Error("This is an abstract method.");
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function pp(i) {
  if (!Ls(i.updateSourceElement))
    throw new B("attachtoform-missing-elementapi-interface", i);
  const e = i.sourceElement;
  if (SF(e) && e.form) {
    let t;
    const n = e.form, r = () => i.updateSourceElement();
    Ls(n.submit) && (t = n.submit, n.submit = () => {
      r(), t.apply(n);
    }), n.addEventListener("submit", r), i.on("destroy", () => {
      n.removeEventListener("submit", r), t && (n.submit = t);
    });
  }
}
function SF(i) {
  return !!i && i.tagName.toLowerCase() === "textarea";
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function Bs(i) {
  class e extends i {
    setData(n) {
      this.data.set(n);
    }
    getData(n) {
      return this.data.get(n);
    }
  }
  return e;
}
{
  const i = Bs(Object);
  Bs.setData = i.prototype.setData, Bs.getData = i.prototype.getData;
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function jo(i) {
  class e extends i {
    updateSourceElement(n = this.data.get()) {
      if (!this.sourceElement)
        throw new B("editor-missing-sourceelement", this);
      const r = this.config.get("updateSourceElementOnDestroy"), s = this.sourceElement instanceof HTMLTextAreaElement;
      if (!r && !s) {
        Bw(this.sourceElement, "");
        return;
      }
      Bw(this.sourceElement, n);
    }
  }
  return e;
}
jo.updateSourceElement = jo(Object).prototype.updateSourceElement;
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function _p(i, e) {
  if (e.ckeditorInstance)
    throw new B("editor-source-element-already-used", i);
  e.ckeditorInstance = i, i.once("destroy", () => {
    delete e.ckeditorInstance;
  });
}
const TF = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m11.591 10.177 4.243 4.242a1 1 0 0 1-1.415 1.415l-4.242-4.243-4.243 4.243a1 1 0 0 1-1.414-1.415l4.243-4.242L4.52 5.934A1 1 0 0 1 5.934 4.52l4.243 4.243 4.242-4.243a1 1 0 1 1 1.415 1.414l-4.243 4.243z"/></svg>', xF = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 16h9a1 1 0 0 1 0 2H2a1 1 0 0 1 0-2z"/><path d="M17 1a2 2 0 0 1 2 2v9a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V3a2 2 0 0 1 2-2h14zm0 1.5H3a.5.5 0 0 0-.492.41L2.5 3v9a.5.5 0 0 0 .41.492L3 12.5h14a.5.5 0 0 0 .492-.41L17.5 12V3a.5.5 0 0 0-.41-.492L17 2.5z" fill-opacity=".6"/></svg>', kF = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M6.972 16.615a.997.997 0 0 1-.744-.292l-4.596-4.596a1 1 0 1 1 1.414-1.414l3.926 3.926 9.937-9.937a1 1 0 0 1 1.414 1.415L7.717 16.323a.997.997 0 0 1-.745.292z"/></svg>', AF = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m11.333 2 .19 2.263a5.899 5.899 0 0 1 1.458.604L14.714 3.4 16.6 5.286l-1.467 1.733c.263.452.468.942.605 1.46L18 8.666v2.666l-2.263.19a5.899 5.899 0 0 1-.604 1.458l1.467 1.733-1.886 1.886-1.733-1.467a5.899 5.899 0 0 1-1.46.605L11.334 18H8.667l-.19-2.263a5.899 5.899 0 0 1-1.458-.604L5.286 16.6 3.4 14.714l1.467-1.733a5.899 5.899 0 0 1-.604-1.458L2 11.333V8.667l2.262-.189a5.899 5.899 0 0 1 .605-1.459L3.4 5.286 5.286 3.4l1.733 1.467a5.899 5.899 0 0 1 1.46-.605L8.666 2h2.666zM10 6.267a3.733 3.733 0 1 0 0 7.466 3.733 3.733 0 0 0 0-7.466z"/></svg>', PF = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m8.636 9.531-2.758 3.94a.5.5 0 0 0 .122.696l3.224 2.284h1.314l2.636-3.736L8.636 9.53zm.288 8.451L5.14 15.396a2 2 0 0 1-.491-2.786l6.673-9.53a2 2 0 0 1 2.785-.49l3.742 2.62a2 2 0 0 1 .491 2.785l-7.269 10.053-2.147-.066z"/><path d="M4 18h5.523v-1H4zm-2 0h1v-1H2z"/></svg>', IF = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M5.085 6.22 2.943 4.078a.75.75 0 1 1 1.06-1.06l2.592 2.59A11.094 11.094 0 0 1 10 5.068c4.738 0 8.578 3.101 8.578 5.083 0 1.197-1.401 2.803-3.555 3.887l1.714 1.713a.75.75 0 0 1-.09 1.138.488.488 0 0 1-.15.084.75.75 0 0 1-.821-.16L6.17 7.304c-.258.11-.51.233-.757.365l6.239 6.24-.006.005.78.78c-.388.094-.78.166-1.174.215l-1.11-1.11h.011L4.55 8.197a7.2 7.2 0 0 0-.665.514l-.112.098 4.897 4.897-.005.006 1.276 1.276a10.164 10.164 0 0 1-1.477-.117l-.479-.479-.009.009-4.863-4.863-.022.031a2.563 2.563 0 0 0-.124.2c-.043.077-.08.158-.108.241a.534.534 0 0 0-.028.133.29.29 0 0 0 .008.072.927.927 0 0 0 .082.226c.067.133.145.26.234.379l3.242 3.365.025.01.59.623c-3.265-.918-5.59-3.155-5.59-4.668 0-1.194 1.448-2.838 3.663-3.93zm7.07.531a4.632 4.632 0 0 1 1.108 5.992l.345.344.046-.018a9.313 9.313 0 0 0 2-1.112c.256-.187.5-.392.727-.613.137-.134.27-.277.392-.431.072-.091.141-.185.203-.286.057-.093.107-.19.148-.292a.72.72 0 0 0 .036-.12.29.29 0 0 0 .008-.072.492.492 0 0 0-.028-.133.999.999 0 0 0-.036-.096 2.165 2.165 0 0 0-.071-.145 2.917 2.917 0 0 0-.125-.2 3.592 3.592 0 0 0-.263-.335 5.444 5.444 0 0 0-.53-.523 7.955 7.955 0 0 0-1.054-.768 9.766 9.766 0 0 0-1.879-.891c-.337-.118-.68-.219-1.027-.301zm-2.85.21-.069.002a.508.508 0 0 0-.254.097.496.496 0 0 0-.104.679.498.498 0 0 0 .326.199l.045.005c.091.003.181.003.272.012a2.45 2.45 0 0 1 2.017 1.513c.024.061.043.125.069.185a.494.494 0 0 0 .45.287h.008a.496.496 0 0 0 .35-.158.482.482 0 0 0 .13-.335.638.638 0 0 0-.048-.219 3.379 3.379 0 0 0-.36-.723 3.438 3.438 0 0 0-2.791-1.543l-.028-.001h-.013z"/></svg>', RF = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M6.91 10.54c.26-.23.64-.21.88.03l3.36 3.14 2.23-2.06a.64.64 0 0 1 .87 0l2.52 2.97V4.5H3.2v10.12l3.71-4.08zm10.27-7.51c.6 0 1.09.47 1.09 1.05v11.84c0 .59-.49 1.06-1.09 1.06H2.79c-.6 0-1.09-.47-1.09-1.06V4.08c0-.58.49-1.05 1.1-1.05h14.38zm-5.22 5.56a1.96 1.96 0 1 1 3.4-1.96 1.96 1.96 0 0 1-3.4 1.96z"/></svg>', OF = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m9.239 13.938-2.88-1.663a.75.75 0 0 1 .75-1.3L9 12.067V4.75a.75.75 0 1 1 1.5 0v7.318l1.89-1.093a.75.75 0 0 1 .75 1.3l-2.879 1.663a.752.752 0 0 1-.511.187.752.752 0 0 1-.511-.187zM4.25 17a.75.75 0 1 1 0-1.5h10.5a.75.75 0 0 1 0 1.5H4.25z"/></svg>', MF = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M9.75 11.875a.752.752 0 0 1 .508.184l2.883 1.666a.75.75 0 0 1-.659 1.344l-.091-.044-1.892-1.093.001 4.318a.75.75 0 1 1-1.5 0v-4.317l-1.89 1.092a.75.75 0 0 1-.75-1.3l2.879-1.663a.752.752 0 0 1 .51-.187zM15.25 9a.75.75 0 1 1 0 1.5H4.75a.75.75 0 1 1 0-1.5h10.5zM9.75.375a.75.75 0 0 1 .75.75v4.318l1.89-1.093.092-.045a.75.75 0 0 1 .659 1.344l-2.883 1.667a.752.752 0 0 1-.508.184.752.752 0 0 1-.511-.187L6.359 5.65a.75.75 0 0 1 .75-1.299L9 5.442V1.125a.75.75 0 0 1 .75-.75z"/></svg>', NF = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m10.261 7.062 2.88 1.663a.75.75 0 0 1-.75 1.3L10.5 8.933v7.317a.75.75 0 1 1-1.5 0V8.932l-1.89 1.093a.75.75 0 0 1-.75-1.3l2.879-1.663a.752.752 0 0 1 .511-.187.752.752 0 0 1 .511.187zM15.25 4a.75.75 0 1 1 0 1.5H4.75a.75.75 0 0 1 0-1.5h10.5z"/></svg>', DF = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 8c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 4c0 .414.336.75.75.75h9.929a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0-8c0 .414.336.75.75.75h9.929a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75z"/></svg>', BF = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 8c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm2.286 4c0 .414.336.75.75.75h9.928a.75.75 0 1 0 0-1.5H5.036a.75.75 0 0 0-.75.75zm0-8c0 .414.336.75.75.75h9.928a.75.75 0 1 0 0-1.5H5.036a.75.75 0 0 0-.75.75z"/></svg>', VF = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M18 3.75a.75.75 0 0 1-.75.75H2.75a.75.75 0 1 1 0-1.5h14.5a.75.75 0 0 1 .75.75zm0 8a.75.75 0 0 1-.75.75H2.75a.75.75 0 1 1 0-1.5h14.5a.75.75 0 0 1 .75.75zm0 4a.75.75 0 0 1-.75.75H7.321a.75.75 0 1 1 0-1.5h9.929a.75.75 0 0 1 .75.75zm0-8a.75.75 0 0 1-.75.75H7.321a.75.75 0 1 1 0-1.5h9.929a.75.75 0 0 1 .75.75z"/></svg>', LF = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 8c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 4c0 .414.336.75.75.75h9.929a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0-8c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75z"/></svg>', FF = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm0 12h16v1.5H2z"/><path d="M12.003 7v5.5a1 1 0 0 1-1 1H2.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H3.5V12h6.997V7.5z"/></svg>', $F = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm0 12h16v1.5H2z"/><path d="M15.003 7v5.5a1 1 0 0 1-1 1H5.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H6.5V12h6.997V7.5z"/></svg>', zF = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm0 12h16v1.5H2z"/><path d="M18.003 7v5.5a1 1 0 0 1-1 1H8.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H9.5V12h6.997V7.5z"/></svg>', WF = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm0 12h16v1.5H2z"/><path d="M18 7v5.5a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h14a1 1 0 0 1 1 1zm-1.505.5H3.504V12h12.991V7.5z"/></svg>', jF = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm11.5 9H18v1.5h-4.5zM2 15h16v1.5H2z"/><path d="M12.003 7v5.5a1 1 0 0 1-1 1H2.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H3.5V12h6.997V7.5z"/></svg>', UF = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm11.5 9H18v1.5h-4.5zm0-3H18v1.5h-4.5zm0-3H18v1.5h-4.5zM2 15h16v1.5H2z"/><path d="M12.003 7v5.5a1 1 0 0 1-1 1H2.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H3.5V12h6.997V7.5z"/></svg>', HF = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm0 12h16v1.5H2zm0-9h5v1.5H2zm0 3h5v1.5H2zm0 3h5v1.5H2z"/><path d="M18.003 7v5.5a1 1 0 0 1-1 1H8.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H9.5V12h6.997V7.5z"/></svg>', qF = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M2.5 17v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zM1 15.5v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm0-2v1h-1v-1h1zm-19 0v1H0v-1h1zM14.5 2v1h-1V2h1zm2 0v1h-1V2h1zm2 0v1h-1V2h1zm-8 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm8 0v1h-1V2h1zm-10 0v1h-1V2h1z"/><path d="M18.095 2H1.905C.853 2 0 2.895 0 4v12c0 1.105.853 2 1.905 2h16.19C19.147 18 20 17.105 20 16V4c0-1.105-.853-2-1.905-2zm0 1.5c.263 0 .476.224.476.5v12c0 .276-.213.5-.476.5H1.905a.489.489 0 0 1-.476-.5V4c0-.276.213-.5.476-.5h16.19z"/></svg>', KF = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M2.5 17v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zM1 15.5v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm0-2v1h-1v-1h1zm-19 0v1H0v-1h1zM14.5 2v1h-1V2h1zm2 0v1h-1V2h1zm2 0v1h-1V2h1zm-8 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm8 0v1h-1V2h1zm-10 0v1h-1V2h1z"/><path d="M13 6H2a2 2 0 0 0-2 2v8a2 2 0 0 0 2 2h11a2 2 0 0 0 2-2V8a2 2 0 0 0-2-2zm0 1.5a.5.5 0 0 1 .5.5v8a.5.5 0 0 1-.5.5H2a.5.5 0 0 1-.5-.5V8a.5.5 0 0 1 .5-.5h11z"/></svg>', GF = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M2.5 17v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zM1 15.5v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm0-2v1h-1v-1h1zm-19 0v1H0v-1h1zM14.5 2v1h-1V2h1zm2 0v1h-1V2h1zm2 0v1h-1V2h1zm-8 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm8 0v1h-1V2h1zm-10 0v1h-1V2h1z"/><path d="M7 10H2a2 2 0 0 0-2 2v4a2 2 0 0 0 2 2h5a2 2 0 0 0 2-2v-4a2 2 0 0 0-2-2zm0 1.5a.5.5 0 0 1 .5.5v4a.5.5 0 0 1-.5.5H2a.5.5 0 0 1-.5-.5v-4a.5.5 0 0 1 .5-.5h5z"/></svg>', YF = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M2.5 17v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zM1 15.5v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm0-2v1h-1v-1h1zm-19 0v1H0v-1h1zM14.5 2v1h-1V2h1zm2 0v1h-1V2h1zm2 0v1h-1V2h1zm-8 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm8 0v1h-1V2h1zm-10 0v1h-1V2h1z"/><path d="M10 8H2a2 2 0 0 0-2 2v6a2 2 0 0 0 2 2h8a2 2 0 0 0 2-2v-6a2 2 0 0 0-2-2zm0 1.5a.5.5 0 0 1 .5.5v6a.5.5 0 0 1-.5.5H2a.5.5 0 0 1-.5-.5v-6a.5.5 0 0 1 .5-.5h8z"/></svg>', JF = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m7.3 17.37-.061.088a1.518 1.518 0 0 1-.934.535l-4.178.663-.806-4.153a1.495 1.495 0 0 1 .187-1.058l.056-.086L8.77 2.639c.958-1.351 2.803-1.076 4.296-.03 1.497 1.047 2.387 2.693 1.433 4.055L7.3 17.37zM9.14 4.728l-5.545 8.346 3.277 2.294 5.544-8.346L9.14 4.728zM6.07 16.512l-3.276-2.295.53 2.73 2.746-.435zM9.994 3.506 13.271 5.8c.316-.452-.16-1.333-1.065-1.966-.905-.634-1.895-.78-2.212-.328zM8 18.5 9.375 17H19v1.5H8z"/></svg>', XF = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M6.999 2H15a1 1 0 0 1 0 2h-1.004v13a1 1 0 1 1-2 0V4H8.999v13a1 1 0 1 1-2 0v-7A4 4 0 0 1 3 6a4 4 0 0 1 3.999-4z"/></svg>', ZF = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M3 10.423a6.5 6.5 0 0 1 6.056-6.408l.038.67C6.448 5.423 5.354 7.663 5.22 10H9c.552 0 .5.432.5.986v4.511c0 .554-.448.503-1 .503h-5c-.552 0-.5-.449-.5-1.003v-4.574zm8 0a6.5 6.5 0 0 1 6.056-6.408l.038.67c-2.646.739-3.74 2.979-3.873 5.315H17c.552 0 .5.432.5.986v4.511c0 .554-.448.503-1 .503h-5c-.552 0-.5-.449-.5-1.003v-4.574z"/></svg>', QF = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><circle cx="9.5" cy="4.5" r="1.5"/><circle cx="9.5" cy="10.5" r="1.5"/><circle cx="9.5" cy="16.5" r="1.5"/></svg>', e9 = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M10.187 17H5.773c-.637 0-1.092-.138-1.364-.415-.273-.277-.409-.718-.409-1.323V4.738c0-.617.14-1.062.419-1.332.279-.27.73-.406 1.354-.406h4.68c.69 0 1.288.041 1.793.124.506.083.96.242 1.36.478.341.197.644.447.906.75a3.262 3.262 0 0 1 .808 2.162c0 1.401-.722 2.426-2.167 3.075C15.05 10.175 16 11.315 16 13.01a3.756 3.756 0 0 1-2.296 3.504 6.1 6.1 0 0 1-1.517.377c-.571.073-1.238.11-2 .11zm-.217-6.217H7v4.087h3.069c1.977 0 2.965-.69 2.965-2.072 0-.707-.256-1.22-.768-1.537-.512-.319-1.277-.478-2.296-.478zM7 5.13v3.619h2.606c.729 0 1.292-.067 1.69-.2a1.6 1.6 0 0 0 .91-.765c.165-.267.247-.566.247-.897 0-.707-.26-1.176-.778-1.409-.519-.232-1.31-.348-2.375-.348H7z"/></svg>', t9 = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M10.5 5.5H7v5h3.5a2.5 2.5 0 1 0 0-5zM5 3h6.5v.025a5 5 0 0 1 0 9.95V13H7v4a1 1 0 0 1-1 1H5a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1z"/></svg>', n9 = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M10 2a1 1 0 0 0-1 1v6H3a1 1 0 1 0 0 2h6v6a1 1 0 1 0 2 0v-6h6a1 1 0 1 0 0-2h-6V3a1 1 0 0 0-1-1Z"/></svg>', i9 = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><g clip-path="url(#a)"><path d="M9.816 11.5 7.038 4.785 4.261 11.5h5.555Zm.62 1.5H3.641l-1.666 4.028H.312l5.789-14h1.875l5.789 14h-1.663L10.436 13Z"/><path clip-rule="evenodd" d="m12.09 17-.534-1.292.848-1.971.545 1.319L12.113 17h-.023Zm1.142-5.187.545 1.319L15.5 9.13l1.858 4.316h-3.45l.398.965h3.467L18.887 17H20l-3.873-9h-1.254l-1.641 3.813Z"/></g><defs><clipPath id="a"><path d="M0 0h20v20H0z"/></clipPath></defs></svg>', r9 = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><g clip-path="url(#a)"><path clip-rule="evenodd" d="M19 4.5 14 0H3v12.673l.868-1.041c.185-.222.4-.402.632-.54V1.5h8v5h5v7.626a2.24 2.24 0 0 1 1.5.822V4.5ZM14 5V2l3.3 3H14Zm-3.692 12.5c.062.105.133.206.213.303L11.52 19H8v-.876a2.243 2.243 0 0 0 1.82-.624h.488Zm7.518-.657a.75.75 0 0 0-1.152-.96L15.5 17.29V12H14v5.29l-1.174-1.408a.75.75 0 0 0-1.152.96l2.346 2.816a.95.95 0 0 0 1.46 0l2.346-2.815Zm-15.056-.38a.75.75 0 0 1-.096-1.056l2.346-2.815a.95.95 0 0 1 1.46 0l2.346 2.815a.75.75 0 1 1-1.152.96L6.5 14.96V20H5v-5.04l-1.174 1.408a.75.75 0 0 1-1.056.096Z"/></g><defs><clipPath id="a"><path d="M0 0h20v20H0z"/></clipPath></defs></svg>';
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const Mt = {
  bold: e9,
  cancel: TF,
  caption: xF,
  check: kF,
  cog: AF,
  eraser: PF,
  image: RF,
  lowVision: IF,
  importExport: r9,
  paragraph: t9,
  plus: n9,
  text: i9,
  alignBottom: OF,
  alignMiddle: MF,
  alignTop: NF,
  alignLeft: DF,
  alignCenter: BF,
  alignRight: VF,
  alignJustify: LF,
  objectLeft: UF,
  objectCenter: $F,
  objectRight: HF,
  objectFullWidth: WF,
  objectInline: jF,
  objectBlockLeft: FF,
  objectBlockRight: zF,
  objectSizeFull: qF,
  objectSizeLarge: KF,
  objectSizeSmall: GF,
  objectSizeMedium: YF,
  pencil: JF,
  pilcrow: XF,
  quote: ZF,
  threeVerticalDots: QF
};
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function vp({ emitter: i, activator: e, callback: t, contextElements: n }) {
  i.listenTo(document, "mousedown", (r, s) => {
    if (!e())
      return;
    const o = typeof s.composedPath == "function" ? s.composedPath() : [], l = typeof n == "function" ? n() : n;
    for (const u of l)
      if (u.contains(s.target) || o.includes(u))
        return;
    t();
  });
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function EC(i) {
  class e extends i {
    disableCssTransitions() {
      this._isCssTransitionsDisabled = !0;
    }
    enableCssTransitions() {
      this._isCssTransitionsDisabled = !1;
    }
    constructor(...n) {
      super(...n), this.set("_isCssTransitionsDisabled", !1), this.initializeCssTransitionDisablerMixin();
    }
    initializeCssTransitionDisablerMixin() {
      this.extendTemplate({
        attributes: {
          class: [
            this.bindTemplate.if("_isCssTransitionsDisabled", "ck-transitions-disabled")
          ]
        }
      });
    }
  }
  return e;
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function CC({ view: i }) {
  i.listenTo(i.element, "submit", (e, t) => {
    t.preventDefault(), i.fire("submit");
  }, { useCapture: !0 });
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function s9({ keystrokeHandler: i, focusTracker: e, gridItems: t, numberOfColumns: n, uiLanguageDirection: r }) {
  const s = typeof n == "number" ? () => n : n;
  i.set("arrowright", o((h, f) => r === "rtl" ? u(h, f.length) : l(h, f.length))), i.set("arrowleft", o((h, f) => r === "rtl" ? l(h, f.length) : u(h, f.length))), i.set("arrowup", o((h, f) => {
    let m = h - s();
    return m < 0 && (m = h + s() * Math.floor(f.length / s()), m > f.length - 1 && (m -= s())), m;
  })), i.set("arrowdown", o((h, f) => {
    let m = h + s();
    return m > f.length - 1 && (m = h % s()), m;
  }));
  function o(h) {
    return (f) => {
      const m = t.find((k) => k.element === e.focusedElement), v = t.getIndex(m), C = h(v, t);
      t.get(C).focus(), f.stopPropagation(), f.preventDefault();
    };
  }
  function l(h, f) {
    return h === f - 1 ? 0 : h + 1;
  }
  function u(h, f) {
    return h === 0 ? f - 1 : h - 1;
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class cs extends Br {
  /**
   * Creates a new instance of the {@link module:ui/viewcollection~ViewCollection}.
   *
   * @param initialItems The initial items of the collection.
   */
  constructor(e = []) {
    super(e, {
      // An #id Number attribute should be legal and not break the `ViewCollection` instance.
      // https://github.com/ckeditor/ckeditor5-ui/issues/93
      idProperty: "viewUid"
    }), this.on("add", (t, n, r) => {
      this._renderViewIntoCollectionParent(n, r);
    }), this.on("remove", (t, n) => {
      n.element && this._parentElement && n.element.remove();
    }), this._parentElement = null;
  }
  /**
   * Destroys the view collection along with child views.
   * See the view {@link module:ui/view~View#destroy} method.
   */
  destroy() {
    this.map((e) => e.destroy());
  }
  /**
   * Sets the parent HTML element of this collection. When parent is set, {@link #add adding} and
   * {@link #remove removing} views in the collection synchronizes their
   * {@link module:ui/view~View#element elements} in the parent element.
   *
   * @param element A new parent element.
   */
  setParent(e) {
    this._parentElement = e;
    for (const t of this)
      this._renderViewIntoCollectionParent(t);
  }
  /**
   * Delegates selected events coming from within views in the collection to any
   * {@link module:utils/emittermixin~Emitter}.
   *
   * For the following views and collection:
   *
   * ```ts
   * const viewA = new View();
   * const viewB = new View();
   * const viewC = new View();
   *
   * const views = parentView.createCollection();
   *
   * views.delegate( 'eventX' ).to( viewB );
   * views.delegate( 'eventX', 'eventY' ).to( viewC );
   *
   * views.add( viewA );
   * ```
   *
   * the `eventX` is delegated (fired by) `viewB` and `viewC` along with `customData`:
   *
   * ```ts
   * viewA.fire( 'eventX', customData );
   * ```
   *
   * and `eventY` is delegated (fired by) `viewC` along with `customData`:
   *
   * ```ts
   * viewA.fire( 'eventY', customData );
   * ```
   *
   * See {@link module:utils/emittermixin~Emitter#delegate}.
   *
   * @param events {@link module:ui/view~View} event names to be delegated to another
   * {@link module:utils/emittermixin~Emitter}.
   * @returns Object with `to` property, a function which accepts the destination
   * of {@link module:utils/emittermixin~Emitter#delegate delegated} events.
   */
  delegate(...e) {
    if (!e.length || !o9(e))
      throw new B("ui-viewcollection-delegate-wrong-events", this);
    return {
      to: (t) => {
        for (const n of this)
          for (const r of e)
            n.delegate(r).to(t);
        this.on("add", (n, r) => {
          for (const s of e)
            r.delegate(s).to(t);
        }), this.on("remove", (n, r) => {
          for (const s of e)
            r.stopDelegating(s, t);
        });
      }
    };
  }
  /**
   * This method {@link module:ui/view~View#render renders} a new view added to the collection.
   *
   * If the {@link #_parentElement parent element} of the collection is set, this method also adds
   * the view's {@link module:ui/view~View#element} as a child of the parent in DOM at a specified index.
   *
   * **Note**: If index is not specified, the view's element is pushed as the last child
   * of the parent element.
   *
   * @param view A new view added to the collection.
   * @param index An index the view holds in the collection. When not specified,
   * the view is added at the end.
   */
  _renderViewIntoCollectionParent(e, t) {
    e.isRendered || e.render(), e.element && this._parentElement && this._parentElement.insertBefore(e.element, this._parentElement.children[t]);
  }
  /**
   * Removes a child view from the collection. If the {@link #setParent parent element} of the
   * collection has been set, the {@link module:ui/view~View#element element} of the view is also removed
   * in DOM, reflecting the order of the collection.
   *
   * See the {@link #add} method.
   *
   * @param subject The view to remove, its id or index in the collection.
   * @returns The removed view.
   */
  remove(e) {
    return super.remove(e);
  }
}
function o9(i) {
  return i.every((e) => typeof e == "string");
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class Xe extends as(Nt()) {
  /**
   * Creates an instance of the {@link module:ui/view~View} class.
   *
   * Also see {@link #render}.
   *
   * @param locale The localization services instance.
   */
  constructor(e) {
    super(), this.element = null, this.isRendered = !1, this.locale = e, this.t = e && e.t, this._viewCollections = new Br(), this._unboundChildren = this.createCollection(), this._viewCollections.on("add", (t, n) => {
      n.locale = e, n.t = e && e.t;
    }), this.decorate("render");
  }
  /**
   * Shorthand for {@link module:ui/template~Template.bind}, a binding
   * {@link module:ui/template~BindChain interface} pre–configured for the view instance.
   *
   * It provides {@link module:ui/template~BindChain#to `to()`} and
   * {@link module:ui/template~BindChain#if `if()`} methods that initialize bindings with
   * observable attributes and attach DOM listeners.
   *
   * ```ts
   * class SampleView extends View {
   * 	constructor( locale ) {
   * 		super( locale );
   *
   * 		const bind = this.bindTemplate;
   *
   * 		// These {@link module:utils/observablemixin~Observable observable} attributes will control
   * 		// the state of the view in DOM.
   * 		this.set( {
   * 			elementClass: 'foo',
   * 		 	isEnabled: true
   * 		 } );
   *
   * 		this.setTemplate( {
   * 			tag: 'p',
   *
   * 			attributes: {
   * 				// The class HTML attribute will follow elementClass
   * 				// and isEnabled view attributes.
   * 				class: [
   * 					bind.to( 'elementClass' )
   * 					bind.if( 'isEnabled', 'present-when-enabled' )
   * 				]
   * 			},
   *
   * 			on: {
   * 				// The view will fire the "clicked" event upon clicking <p> in DOM.
   * 				click: bind.to( 'clicked' )
   * 			}
   * 		} );
   * 	}
   * }
   * ```
   */
  get bindTemplate() {
    return this._bindTemplate ? this._bindTemplate : this._bindTemplate = Li.bind(this, this);
  }
  /**
   * Creates a new collection of views, which can be used as
   * {@link module:ui/template~Template#children} of this view.
   *
   * ```ts
   * class SampleView extends View {
   * 	constructor( locale ) {
   * 		super( locale );
   *
   * 		const child = new ChildView( locale );
   * 		this.items = this.createCollection( [ child ] );
   *
   * 		this.setTemplate( {
   * 			tag: 'p',
   *
   * 			// `items` collection will render here.
   * 			children: this.items
   * 		} );
   * 	}
   * }
   *
   * const view = new SampleView( locale );
   * view.render();
   *
   * // It will append <p><child#element></p> to the <body>.
   * document.body.appendChild( view.element );
   * ```
   *
   * @param views Initial views of the collection.
   * @returns A new collection of view instances.
   */
  createCollection(e) {
    const t = new cs(e);
    return this._viewCollections.add(t), t;
  }
  /**
   * Registers a new child view under the view instance. Once registered, a child
   * view is managed by its parent, including {@link #render rendering}
   * and {@link #destroy destruction}.
   *
   * To revert this, use {@link #deregisterChild}.
   *
   * ```ts
   * class SampleView extends View {
   * 	constructor( locale ) {
   * 		super( locale );
   *
   * 		this.childA = new SomeChildView( locale );
   * 		this.childB = new SomeChildView( locale );
   *
   * 		this.setTemplate( { tag: 'p' } );
   *
   * 		// Register the children.
   * 		this.registerChild( [ this.childA, this.childB ] );
   * 	}
   *
   * 	render() {
   * 		super.render();
   *
   * 		this.element.appendChild( this.childA.element );
   * 		this.element.appendChild( this.childB.element );
   * 	}
   * }
   *
   * const view = new SampleView( locale );
   *
   * view.render();
   *
   * // Will append <p><childA#element><b></b><childB#element></p>.
   * document.body.appendChild( view.element );
   * ```
   *
   * **Note**: There's no need to add child views if they're already referenced in the
   * {@link #template}:
   *
   * ```ts
   * class SampleView extends View {
   * 	constructor( locale ) {
   * 		super( locale );
   *
   * 		this.childA = new SomeChildView( locale );
   * 		this.childB = new SomeChildView( locale );
   *
   * 		this.setTemplate( {
   * 			tag: 'p',
   *
   * 			// These children will be added automatically. There's no
   * 			// need to call {@link #registerChild} for any of them.
   * 			children: [ this.childA, this.childB ]
   * 		} );
   * 	}
   *
   * 	// ...
   * }
   * ```
   *
   * @param children Children views to be registered.
   */
  registerChild(e) {
    di(e) || (e = [e]);
    for (const t of e)
      this._unboundChildren.add(t);
  }
  /**
   * The opposite of {@link #registerChild}. Removes a child view from this view instance.
   * Once removed, the child is no longer managed by its parent, e.g. it can safely
   * become a child of another parent view.
   *
   * @see #registerChild
   * @param children Child views to be removed.
   */
  deregisterChild(e) {
    di(e) || (e = [e]);
    for (const t of e)
      this._unboundChildren.remove(t);
  }
  /**
   * Sets the {@link #template} of the view with with given definition.
   *
   * A shorthand for:
   *
   * ```ts
   * view.setTemplate( definition );
   * ```
   *
   * @param definition Definition of view's template.
   */
  setTemplate(e) {
    this.template = new Li(e);
  }
  /**
   * {@link module:ui/template~Template.extend Extends} the {@link #template} of the view with
   * with given definition.
   *
   * A shorthand for:
   *
   * ```ts
   * Template.extend( view.template, definition );
   * ```
   *
   * **Note**: Is requires the {@link #template} to be already set. See {@link #setTemplate}.
   *
   * @param definition Definition which extends the {@link #template}.
   */
  extendTemplate(e) {
    Li.extend(this.template, e);
  }
  /**
   * Recursively renders the view.
   *
   * Once the view is rendered:
   * * the {@link #element} becomes an HTML element out of {@link #template},
   * * the {@link #isRendered} flag is set `true`.
   *
   * **Note**: The children of the view:
   * * defined directly in the {@link #template}
   * * residing in collections created by the {@link #createCollection} method,
   * * and added by {@link #registerChild}
   * are also rendered in the process.
   *
   * In general, `render()` method is the right place to keep the code which refers to the
   * {@link #element} and should be executed at the very beginning of the view's life cycle.
   *
   * It is possible to {@link module:ui/template~Template.extend} the {@link #template} before
   * the view is rendered. To allow an early customization of the view (e.g. by its parent),
   * such references should be done in `render()`.
   *
   * ```ts
   * class SampleView extends View {
   * 	constructor() {
   * 		this.setTemplate( {
   * 			// ...
   * 		} );
   * 	},
   *
   * 	render() {
   * 		// View#element becomes available.
   * 		super.render();
   *
   * 		// The "scroll" listener depends on #element.
   * 		this.listenTo( window, 'scroll', () => {
   * 			// A reference to #element would render the #template and make it non-extendable.
   * 			if ( window.scrollY > 0 ) {
   * 				this.element.scrollLeft = 100;
   * 			} else {
   * 				this.element.scrollLeft = 0;
   * 			}
   * 		} );
   * 	}
   * }
   *
   * const view = new SampleView();
   *
   * // Let's customize the view before it gets rendered.
   * view.extendTemplate( {
   * 	attributes: {
   * 		class: [
   * 			'additional-class'
   * 		]
   * 	}
   * } );
   *
   * // Late rendering allows customization of the view.
   * view.render();
   * ```
   */
  render() {
    if (this.isRendered)
      throw new B("ui-view-render-already-rendered", this);
    this.template && (this.element = this.template.render(), this.registerChild(this.template.getViews())), this.isRendered = !0;
  }
  /**
   * Recursively destroys the view instance and child views added by {@link #registerChild} and
   * residing in collections created by the {@link #createCollection}.
   *
   * Destruction disables all event listeners:
   * * created on the view, e.g. `view.on( 'event', () => {} )`,
   * * defined in the {@link #template} for DOM events.
   */
  destroy() {
    this.stopListening(), this._viewCollections.map((e) => e.destroy()), this.template && this.template._revertData && this.template.revert(this.element);
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const a9 = "http://www.w3.org/1999/xhtml";
class Li extends kt() {
  /**
   * Creates an instance of the {@link ~Template} class.
   *
   * @param def The definition of the template.
   */
  constructor(e) {
    super(), Object.assign(this, kb(xb(e))), this._isRendered = !1, this._revertData = null;
  }
  /**
   * Renders a DOM Node (an HTML element or text) out of the template.
   *
   * ```ts
   * const domNode = new Template( { ... } ).render();
   * ```
   *
   * See: {@link #apply}.
   */
  render() {
    const e = this._renderNode({
      intoFragment: !0
    });
    return this._isRendered = !0, e;
  }
  /**
   * Applies the template to an existing DOM Node, either HTML element or text.
   *
   * **Note:** No new DOM nodes will be created. Applying extends:
   *
   * {@link module:ui/template~TemplateDefinition attributes},
   * {@link module:ui/template~TemplateDefinition event listeners}, and
   * `textContent` of {@link module:ui/template~TemplateDefinition children} only.
   *
   * **Note:** Existing `class` and `style` attributes are extended when a template
   * is applied to an HTML element, while other attributes and `textContent` are overridden.
   *
   * **Note:** The process of applying a template can be easily reverted using the
   * {@link module:ui/template~Template#revert} method.
   *
   * ```ts
   * const element = document.createElement( 'div' );
   * const observable = new Model( { divClass: 'my-div' } );
   * const emitter = Object.create( EmitterMixin );
   * const bind = Template.bind( observable, emitter );
   *
   * new Template( {
   * 	attributes: {
   * 		id: 'first-div',
   * 		class: bind.to( 'divClass' )
   * 	},
   * 	on: {
   * 		click: bind( 'elementClicked' ) // Will be fired by the observable.
   * 	},
   * 	children: [
   * 		'Div text.'
   * 	]
   * } ).apply( element );
   *
   * console.log( element.outerHTML ); // -> '<div id="first-div" class="my-div"></div>'
   * ```
   *
   * @see module:ui/template~Template#render
   * @see module:ui/template~Template#revert
   * @param node Root node for the template to apply.
   */
  apply(e) {
    return this._revertData = Ib(), this._renderNode({
      node: e,
      intoFragment: !1,
      isApplying: !0,
      revertData: this._revertData
    }), e;
  }
  /**
   * Reverts a template {@link module:ui/template~Template#apply applied} to a DOM node.
   *
   * @param node The root node for the template to revert. In most of the cases, it is the
   * same node used by {@link module:ui/template~Template#apply}.
   */
  revert(e) {
    if (!this._revertData)
      throw new B("ui-template-revert-not-applied", [this, e]);
    this._revertTemplateFromNode(e, this._revertData);
  }
  /**
   * Returns an iterator which traverses the template in search of {@link module:ui/view~View}
   * instances and returns them one by one.
   *
   * ```ts
   * const viewFoo = new View();
   * const viewBar = new View();
   * const viewBaz = new View();
   * const template = new Template( {
   * 	tag: 'div',
   * 	children: [
   * 		viewFoo,
   * 		{
   * 			tag: 'div',
   * 			children: [
   * 				viewBar
   * 			]
   * 		},
   * 		viewBaz
   * 	]
   * } );
   *
   * // Logs: viewFoo, viewBar, viewBaz
   * for ( const view of template.getViews() ) {
   * 	console.log( view );
   * }
   * ```
   */
  *getViews() {
    function* e(t) {
      if (t.children)
        for (const n of t.children)
          Id(n) ? yield n : wp(n) && (yield* e(n));
    }
    yield* e(this);
  }
  /**
   * An entry point to the interface which binds DOM nodes to
   * {@link module:utils/observablemixin~Observable observables}.
   * There are two types of bindings:
   *
   * * HTML element attributes or text `textContent` synchronized with attributes of an
   * {@link module:utils/observablemixin~Observable}. Learn more about {@link module:ui/template~BindChain#to}
   * and {@link module:ui/template~BindChain#if}.
   *
   * ```ts
   * const bind = Template.bind( observable, emitter );
   *
   * new Template( {
   * 	attributes: {
   * 		// Binds the element "class" attribute to observable#classAttribute.
   * 		class: bind.to( 'classAttribute' )
   * 	}
   * } ).render();
   * ```
   *
   * * DOM events fired on HTML element propagated through
   * {@link module:utils/observablemixin~Observable}. Learn more about {@link module:ui/template~BindChain#to}.
   *
   * ```ts
   * const bind = Template.bind( observable, emitter );
   *
   * new Template( {
   * 	on: {
   * 		// Will be fired by the observable.
   * 		click: bind( 'elementClicked' )
   * 	}
   * } ).render();
   * ```
   *
   * Also see {@link module:ui/view~View#bindTemplate}.
   *
   * @param observable An observable which provides boundable attributes.
   * @param emitter An emitter that listens to observable attribute
   * changes or DOM Events (depending on the kind of the binding). Usually, a {@link module:ui/view~View} instance.
   */
  static bind(e, t) {
    return {
      to(n, r) {
        return new l9({
          eventNameOrFunction: n,
          attribute: n,
          observable: e,
          emitter: t,
          callback: r
        });
      },
      if(n, r, s) {
        return new SC({
          observable: e,
          emitter: t,
          attribute: n,
          valueIfTrue: r,
          callback: s
        });
      }
    };
  }
  /**
   * Extends an existing {@link module:ui/template~Template} instance with some additional content
   * from another {@link module:ui/template~TemplateDefinition}.
   *
   * ```ts
   * const bind = Template.bind( observable, emitter );
   *
   * const template = new Template( {
   * 	tag: 'p',
   * 	attributes: {
   * 		class: 'a',
   * 		data-x: bind.to( 'foo' )
   * 	},
   * 	children: [
   * 		{
   * 			tag: 'span',
   * 			attributes: {
   * 				class: 'b'
   * 			},
   * 			children: [
   * 				'Span'
   * 			]
   * 		}
   * 	]
   *  } );
   *
   * // Instance-level extension.
   * Template.extend( template, {
   * 	attributes: {
   * 		class: 'b',
   * 		data-x: bind.to( 'bar' )
   * 	},
   * 	children: [
   * 		{
   * 			attributes: {
   * 				class: 'c'
   * 			}
   * 		}
   * 	]
   * } );
   *
   * // Child extension.
   * Template.extend( template.children[ 0 ], {
   * 	attributes: {
   * 		class: 'd'
   * 	}
   * } );
   * ```
   *
   * the `outerHTML` of `template.render()` is:
   *
   * ```html
   * <p class="a b" data-x="{ observable.foo } { observable.bar }">
   * 	<span class="b c d">Span</span>
   * </p>
   * ```
   *
   * @param template An existing template instance to be extended.
   * @param def Additional definition to be applied to a template.
   */
  static extend(e, t) {
    if (e._isRendered)
      throw new B("template-extend-render", [this, e]);
    AC(e, kb(xb(t)));
  }
  /**
   * Renders a DOM Node (either an HTML element or text) out of the template.
   *
   * @param data Rendering data.
   */
  _renderNode(e) {
    let t;
    if (e.node ? t = this.tag && this.text : t = this.tag ? this.text : !this.text, t)
      throw new B("ui-template-wrong-syntax", this);
    return this.text ? this._renderText(e) : this._renderElement(e);
  }
  /**
   * Renders an HTML element out of the template.
   *
   * @param data Rendering data.
   */
  _renderElement(e) {
    let t = e.node;
    return t || (t = e.node = document.createElementNS(this.ns || a9, this.tag)), this._renderAttributes(e), this._renderElementChildren(e), this._setUpListeners(e), t;
  }
  /**
   * Renders a text node out of {@link module:ui/template~Template#text}.
   *
   * @param data Rendering data.
   */
  _renderText(e) {
    let t = e.node;
    return t ? e.revertData.text = t.textContent : t = e.node = document.createTextNode(""), Zu(this.text) ? this._bindToObservable({
      schema: this.text,
      updater: u9(t),
      data: e
    }) : t.textContent = this.text.join(""), t;
  }
  /**
   * Renders HTML element attributes out of {@link module:ui/template~Template#attributes}.
   *
   * @param data Rendering data.
   */
  _renderAttributes(e) {
    if (!this.attributes)
      return;
    const t = e.node, n = e.revertData;
    for (const r in this.attributes) {
      const s = t.getAttribute(r), o = this.attributes[r];
      n && (n.attributes[r] = s);
      const l = Pb(o) ? o[0].ns : null;
      if (Zu(o)) {
        const u = Pb(o) ? o[0].value : o;
        n && Rb(r) && u.unshift(s), this._bindToObservable({
          schema: u,
          updater: d9(t, r, l),
          data: e
        });
      } else if (r == "style" && typeof o[0] != "string")
        this._renderStyleAttribute(o[0], e);
      else {
        n && s && Rb(r) && o.unshift(s);
        const u = o.map((h) => h && (h.value || h)).reduce((h, f) => h.concat(f), []).reduce(kC, "");
        Uo(u) || t.setAttributeNS(l, r, u);
      }
    }
  }
  /**
   * Renders the `style` attribute of an HTML element based on
   * {@link module:ui/template~Template#attributes}.
   *
   * A style attribute is an object with static values:
   *
   * ```ts
   * attributes: {
   * 	style: {
   * 		color: 'red'
   * 	}
   * }
   * ```
   *
   * or values bound to {@link module:ui/model~Model} properties:
   *
   * ```ts
   * attributes: {
   * 	style: {
   * 		color: bind.to( ... )
   * 	}
   * }
   * ```
   *
   * Note: The `style` attribute is rendered without setting the namespace. It does not seem to be
   * needed.
   *
   * @param styles Styles located in `attributes.style` of {@link module:ui/template~TemplateDefinition}.
   * @param data Rendering data.
   */
  _renderStyleAttribute(e, t) {
    const n = t.node;
    for (const r in e) {
      const s = e[r];
      Zu(s) ? this._bindToObservable({
        schema: [s],
        updater: h9(n, r),
        data: t
      }) : n.style[r] = s;
    }
  }
  /**
   * Recursively renders HTML element's children from {@link module:ui/template~Template#children}.
   *
   * @param data Rendering data.
   */
  _renderElementChildren(e) {
    const t = e.node, n = e.intoFragment ? document.createDocumentFragment() : t, r = e.isApplying;
    let s = 0;
    for (const o of this.children)
      if (bp(o)) {
        if (!r) {
          o.setParent(t);
          for (const l of o)
            n.appendChild(l.element);
        }
      } else if (Id(o))
        r || (o.isRendered || o.render(), n.appendChild(o.element));
      else if (ns(o))
        n.appendChild(o);
      else if (r) {
        const l = e.revertData, u = Ib();
        l.children.push(u), o._renderNode({
          intoFragment: !1,
          node: n.childNodes[s++],
          isApplying: !0,
          revertData: u
        });
      } else
        n.appendChild(o.render());
    e.intoFragment && t.appendChild(n);
  }
  /**
   * Activates `on` event listeners from the {@link module:ui/template~TemplateDefinition}
   * on an HTML element.
   *
   * @param data Rendering data.
   */
  _setUpListeners(e) {
    if (this.eventListeners)
      for (const t in this.eventListeners) {
        const n = this.eventListeners[t].map((r) => {
          const [s, o] = t.split("@");
          return r.activateDomEventListener(s, o, e);
        });
        e.revertData && e.revertData.bindings.push(n);
      }
  }
  /**
   * For a given {@link module:ui/template~TemplateValueSchema} containing {@link module:ui/template~TemplateBinding}
   * activates the binding and sets its initial value.
   *
   * Note: {@link module:ui/template~TemplateValueSchema} can be for HTML element attributes or
   * text node `textContent`.
   *
   * @param options Binding options.
   * @param options.updater A function which updates the DOM (like attribute or text).
   * @param options.data Rendering data.
   */
  _bindToObservable({ schema: e, updater: t, data: n }) {
    const r = n.revertData;
    TC(e, t, n);
    const s = e.filter((o) => !Uo(o)).filter((o) => o.observable).map((o) => o.activateAttributeListener(e, t, n));
    r && r.bindings.push(s);
  }
  /**
   * Reverts {@link module:ui/template~RenderData#revertData template data} from a node to
   * return it to the original state.
   *
   * @param node A node to be reverted.
   * @param revertData An object that stores information about what changes have been made by
   * {@link #apply} to the node. See {@link module:ui/template~RenderData#revertData} for more information.
   */
  _revertTemplateFromNode(e, t) {
    for (const r of t.bindings)
      for (const s of r)
        s();
    if (t.text) {
      e.textContent = t.text;
      return;
    }
    const n = e;
    for (const r in t.attributes) {
      const s = t.attributes[r];
      s === null ? n.removeAttribute(r) : n.setAttribute(r, s);
    }
    for (let r = 0; r < t.children.length; ++r)
      this._revertTemplateFromNode(n.childNodes[r], t.children[r]);
  }
}
class jl {
  /**
   * Creates an instance of the {@link module:ui/template~TemplateBinding} class.
   *
   * @param def The definition of the binding.
   */
  constructor(e) {
    this.attribute = e.attribute, this.observable = e.observable, this.emitter = e.emitter, this.callback = e.callback;
  }
  /**
   * Returns the value of the binding. It is the value of the {@link module:ui/template~TemplateBinding#attribute} in
   * {@link module:ui/template~TemplateBinding#observable}. The value may be processed by the
   * {@link module:ui/template~TemplateBinding#callback}, if such has been passed to the binding.
   *
   * @param node A native DOM node, passed to the custom {@link module:ui/template~TemplateBinding#callback}.
   * @returns The value of {@link module:ui/template~TemplateBinding#attribute} in
   * {@link module:ui/template~TemplateBinding#observable}.
   */
  getValue(e) {
    const t = this.observable[this.attribute];
    return this.callback ? this.callback(t, e) : t;
  }
  /**
   * Activates the listener which waits for changes of the {@link module:ui/template~TemplateBinding#attribute} in
   * {@link module:ui/template~TemplateBinding#observable}, then updates the DOM with the aggregated
   * value of {@link module:ui/template~TemplateValueSchema}.
   *
   * @param schema A full schema to generate an attribute or text in the DOM.
   * @param updater A DOM updater function used to update the native DOM attribute or text.
   * @param data Rendering data.
   * @returns A function to sever the listener binding.
   */
  activateAttributeListener(e, t, n) {
    const r = () => TC(e, t, n);
    return this.emitter.listenTo(this.observable, `change:${this.attribute}`, r), () => {
      this.emitter.stopListening(this.observable, `change:${this.attribute}`, r);
    };
  }
}
class l9 extends jl {
  constructor(e) {
    super(e), this.eventNameOrFunction = e.eventNameOrFunction;
  }
  /**
   * Activates the listener for the native DOM event, which when fired, is propagated by
   * the {@link module:ui/template~TemplateBinding#emitter}.
   *
   * @param domEvtName The name of the native DOM event.
   * @param domSelector The selector in the DOM to filter delegated events.
   * @param data Rendering data.
   * @returns A function to sever the listener binding.
   */
  activateDomEventListener(e, t, n) {
    const r = (s, o) => {
      (!t || o.target.matches(t)) && (typeof this.eventNameOrFunction == "function" ? this.eventNameOrFunction(o) : this.observable.fire(this.eventNameOrFunction, o));
    };
    return this.emitter.listenTo(n.node, e, r), () => {
      this.emitter.stopListening(n.node, e, r);
    };
  }
}
class SC extends jl {
  constructor(e) {
    super(e), this.valueIfTrue = e.valueIfTrue;
  }
  /**
   * @inheritDoc
   */
  getValue(e) {
    const t = super.getValue(e);
    return Uo(t) ? !1 : this.valueIfTrue || !0;
  }
}
function Zu(i) {
  return i ? (i.value && (i = i.value), Array.isArray(i) ? i.some(Zu) : i instanceof jl) : !1;
}
function c9(i, e) {
  return i.map((t) => t instanceof jl ? t.getValue(e) : t);
}
function TC(i, e, { node: t }) {
  const n = c9(i, t);
  let r;
  i.length == 1 && i[0] instanceof SC ? r = n[0] : r = n.reduce(kC, ""), Uo(r) ? e.remove() : e.set(r);
}
function u9(i) {
  return {
    set(e) {
      i.textContent = e;
    },
    remove() {
      i.textContent = "";
    }
  };
}
function d9(i, e, t) {
  return {
    set(n) {
      i.setAttributeNS(t, e, n);
    },
    remove() {
      i.removeAttributeNS(t, e);
    }
  };
}
function h9(i, e) {
  return {
    set(t) {
      i.style[e] = t;
    },
    remove() {
      i.style[e] = null;
    }
  };
}
function xb(i) {
  return Qg(i, (t) => {
    if (t && (t instanceof jl || wp(t) || Id(t) || bp(t)))
      return t;
  });
}
function kb(i) {
  if (typeof i == "string" ? i = g9(i) : i.text && p9(i), i.on && (i.eventListeners = m9(i.on), delete i.on), !i.text) {
    i.attributes && f9(i.attributes);
    const e = [];
    if (i.children)
      if (bp(i.children))
        e.push(i.children);
      else
        for (const t of i.children)
          wp(t) || Id(t) || ns(t) ? e.push(t) : e.push(new Li(t));
    i.children = e;
  }
  return i;
}
function f9(i) {
  for (const e in i)
    i[e].value && (i[e].value = In(i[e].value)), xC(i, e);
}
function m9(i) {
  for (const e in i)
    xC(i, e);
  return i;
}
function g9(i) {
  return {
    text: [i]
  };
}
function p9(i) {
  i.text = In(i.text);
}
function xC(i, e) {
  i[e] = In(i[e]);
}
function kC(i, e) {
  return Uo(e) ? i : Uo(i) ? e : `${i} ${e}`;
}
function Ab(i, e) {
  for (const t in e)
    i[t] ? i[t].push(...e[t]) : i[t] = e[t];
}
function AC(i, e) {
  if (e.attributes && (i.attributes || (i.attributes = {}), Ab(i.attributes, e.attributes)), e.eventListeners && (i.eventListeners || (i.eventListeners = {}), Ab(i.eventListeners, e.eventListeners)), e.text && i.text.push(...e.text), e.children && e.children.length) {
    if (i.children.length != e.children.length)
      throw new B("ui-template-extend-children-mismatch", i);
    let t = 0;
    for (const n of e.children)
      AC(i.children[t++], n);
  }
}
function Uo(i) {
  return !i && i !== 0;
}
function Id(i) {
  return i instanceof Xe;
}
function wp(i) {
  return i instanceof Li;
}
function bp(i) {
  return i instanceof cs;
}
function Pb(i) {
  return Lt(i[0]) && i[0].ns;
}
function Ib() {
  return {
    children: [],
    bindings: [],
    attributes: {}
  };
}
function Rb(i) {
  return i == "class" || i == "style";
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class _9 extends cs {
  /**
   * Creates a new instance of the {@link module:ui/editorui/bodycollection~BodyCollection}.
   *
   * @param locale The {@link module:core/editor/editor~Editor editor's locale} instance.
   * @param initialItems The initial items of the collection.
   */
  constructor(e, t = []) {
    super(t), this.locale = e;
  }
  /**
   * Attaches the body collection to the DOM body element. You need to execute this method to render the content of
   * the body collection.
   */
  attachToDom() {
    this._bodyCollectionContainer = new Li({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-reset_all",
          "ck-body",
          "ck-rounded-corners"
        ],
        dir: this.locale.uiLanguageDirection
      },
      children: this
    }).render();
    let e = document.querySelector(".ck-body-wrapper");
    e || (e = _B(document, "div", { class: "ck-body-wrapper" }), document.body.appendChild(e)), e.appendChild(this._bodyCollectionContainer);
  }
  /**
   * Detaches the collection from the DOM structure. Use this method when you do not need to use the body collection
   * anymore to clean-up the DOM structure.
   */
  detachFromDom() {
    super.destroy(), this._bodyCollectionContainer && this._bodyCollectionContainer.remove();
    const e = document.querySelector(".ck-body-wrapper");
    e && e.childElementCount == 0 && e.remove();
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class ea extends Xe {
  /**
   * @inheritDoc
   */
  constructor() {
    super();
    const e = this.bindTemplate;
    this.set("content", ""), this.set("viewBox", "0 0 20 20"), this.set("fillColor", ""), this.set("isColorInherited", !0), this.setTemplate({
      tag: "svg",
      ns: "http://www.w3.org/2000/svg",
      attributes: {
        class: [
          "ck",
          "ck-icon",
          // Exclude icon internals from the CSS reset to allow rich (non-monochromatic) icons
          // (https://github.com/ckeditor/ckeditor5/issues/12599).
          "ck-reset_all-excluded",
          // The class to remove the dynamic color inheritance is toggleable
          // (https://github.com/ckeditor/ckeditor5/issues/12599).
          e.if("isColorInherited", "ck-icon_inherit-color")
        ],
        viewBox: e.to("viewBox")
      }
    });
  }
  /**
   * @inheritDoc
   */
  render() {
    super.render(), this._updateXMLContent(), this._colorFillPaths(), this.on("change:content", () => {
      this._updateXMLContent(), this._colorFillPaths();
    }), this.on("change:fillColor", () => {
      this._colorFillPaths();
    });
  }
  /**
   * Updates the {@link #element} with the value of {@link #content}.
   */
  _updateXMLContent() {
    if (this.content) {
      const t = new DOMParser().parseFromString(this.content.trim(), "image/svg+xml").querySelector("svg"), n = t.getAttribute("viewBox");
      n && (this.viewBox = n);
      for (const { name: r, value: s } of Array.from(t.attributes))
        ea.presentationalAttributeNames.includes(r) && this.element.setAttribute(r, s);
      for (; this.element.firstChild; )
        this.element.removeChild(this.element.firstChild);
      for (; t.childNodes.length > 0; )
        this.element.appendChild(t.childNodes[0]);
    }
  }
  /**
   * Fills all child `path.ck-icon__fill` with the `#fillColor`.
   */
  _colorFillPaths() {
    this.fillColor && this.element.querySelectorAll(".ck-icon__fill").forEach((e) => {
      e.style.fill = this.fillColor;
    });
  }
}
ea.presentationalAttributeNames = [
  "alignment-baseline",
  "baseline-shift",
  "clip-path",
  "clip-rule",
  "color",
  "color-interpolation",
  "color-interpolation-filters",
  "color-rendering",
  "cursor",
  "direction",
  "display",
  "dominant-baseline",
  "fill",
  "fill-opacity",
  "fill-rule",
  "filter",
  "flood-color",
  "flood-opacity",
  "font-family",
  "font-size",
  "font-size-adjust",
  "font-stretch",
  "font-style",
  "font-variant",
  "font-weight",
  "image-rendering",
  "letter-spacing",
  "lighting-color",
  "marker-end",
  "marker-mid",
  "marker-start",
  "mask",
  "opacity",
  "overflow",
  "paint-order",
  "pointer-events",
  "shape-rendering",
  "stop-color",
  "stop-opacity",
  "stroke",
  "stroke-dasharray",
  "stroke-dashoffset",
  "stroke-linecap",
  "stroke-linejoin",
  "stroke-miterlimit",
  "stroke-opacity",
  "stroke-width",
  "text-anchor",
  "text-decoration",
  "text-overflow",
  "text-rendering",
  "transform",
  "unicode-bidi",
  "vector-effect",
  "visibility",
  "white-space",
  "word-spacing",
  "writing-mode"
];
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class At extends Xe {
  /**
   * @inheritDoc
   */
  constructor(e) {
    super(e);
    const t = this.bindTemplate, n = Rr();
    this.set("class", void 0), this.set("labelStyle", void 0), this.set("icon", void 0), this.set("isEnabled", !0), this.set("isOn", !1), this.set("isVisible", !0), this.set("isToggleable", !1), this.set("keystroke", void 0), this.set("label", void 0), this.set("tabindex", -1), this.set("tooltip", !1), this.set("tooltipPosition", "s"), this.set("type", "button"), this.set("withText", !1), this.set("withKeystroke", !1), this.children = this.createCollection(), this.labelView = this._createLabelView(n), this.iconView = new ea(), this.iconView.extendTemplate({
      attributes: {
        class: "ck-button__icon"
      }
    }), this.keystrokeView = this._createKeystrokeView(), this.bind("_tooltipString").to(this, "tooltip", this, "label", this, "keystroke", this._getTooltipString.bind(this));
    const r = {
      tag: "button",
      attributes: {
        class: [
          "ck",
          "ck-button",
          t.to("class"),
          t.if("isEnabled", "ck-disabled", (s) => !s),
          t.if("isVisible", "ck-hidden", (s) => !s),
          t.to("isOn", (s) => s ? "ck-on" : "ck-off"),
          t.if("withText", "ck-button_with-text"),
          t.if("withKeystroke", "ck-button_with-keystroke")
        ],
        type: t.to("type", (s) => s || "button"),
        tabindex: t.to("tabindex"),
        "aria-labelledby": `ck-editor__aria-label_${n}`,
        "aria-disabled": t.if("isEnabled", !0, (s) => !s),
        "aria-pressed": t.to("isOn", (s) => this.isToggleable ? String(!!s) : !1),
        "data-cke-tooltip-text": t.to("_tooltipString"),
        "data-cke-tooltip-position": t.to("tooltipPosition")
      },
      children: this.children,
      on: {
        click: t.to((s) => {
          this.isEnabled ? this.fire("execute") : s.preventDefault();
        })
      }
    };
    qe.isSafari && (r.on.mousedown = t.to((s) => {
      this.focus(), s.preventDefault();
    })), this.setTemplate(r);
  }
  /**
   * @inheritDoc
   */
  render() {
    super.render(), this.icon && (this.iconView.bind("content").to(this, "icon"), this.children.add(this.iconView)), this.children.add(this.labelView), this.withKeystroke && this.keystroke && this.children.add(this.keystrokeView);
  }
  /**
   * Focuses the {@link #element} of the button.
   */
  focus() {
    this.element.focus();
  }
  /**
   * Creates a label view instance and binds it with button attributes.
   *
   * @param ariaLabelUid The aria label UID.
   */
  _createLabelView(e) {
    const t = new Xe(), n = this.bindTemplate;
    return t.setTemplate({
      tag: "span",
      attributes: {
        class: [
          "ck",
          "ck-button__label"
        ],
        style: n.to("labelStyle"),
        id: `ck-editor__aria-label_${e}`
      },
      children: [
        {
          text: n.to("label")
        }
      ]
    }), t;
  }
  /**
   * Creates a view that displays a keystroke next to a {@link #labelView label }
   * and binds it with button attributes.
   */
  _createKeystrokeView() {
    const e = new Xe();
    return e.setTemplate({
      tag: "span",
      attributes: {
        class: [
          "ck",
          "ck-button__keystroke"
        ]
      },
      children: [
        {
          text: this.bindTemplate.to("keystroke", (t) => $w(t))
        }
      ]
    }), e;
  }
  /**
   * Gets the text for the tooltip from the combination of
   * {@link #tooltip}, {@link #label} and {@link #keystroke} attributes.
   *
   * @see #tooltip
   * @see #_tooltipString
   * @param tooltip Button tooltip.
   * @param label Button label.
   * @param keystroke Button keystroke.
   */
  _getTooltipString(e, t, n) {
    return e ? typeof e == "string" ? e : (n && (n = $w(n)), e instanceof Function ? e(t, n) : `${t}${n ? ` (${n})` : ""}`) : "";
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class hh extends At {
  /**
   * @inheritDoc
   */
  constructor(e) {
    super(e), this.isToggleable = !0, this.toggleSwitchView = this._createToggleView(), this.extendTemplate({
      attributes: {
        class: "ck-switchbutton"
      }
    });
  }
  /**
   * @inheritDoc
   */
  render() {
    super.render(), this.children.add(this.toggleSwitchView);
  }
  /**
   * Creates a toggle child view.
   */
  _createToggleView() {
    const e = new Xe();
    return e.setTemplate({
      tag: "span",
      attributes: {
        class: [
          "ck",
          "ck-button__toggle"
        ]
      },
      children: [
        {
          tag: "span",
          attributes: {
            class: [
              "ck",
              "ck-button__toggle__inner"
            ]
          }
        }
      ]
    }), e;
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class v9 {
  /**
   * Creates an instance of the factory.
   *
   * @param editor The editor instance.
   */
  constructor(e) {
    this._components = /* @__PURE__ */ new Map(), this.editor = e;
  }
  /**
   * Returns an iterator of registered component names. Names are returned in lower case.
   */
  *names() {
    for (const e of this._components.values())
      yield e.originalName;
  }
  /**
   * Registers a component factory function that will be used by the
   * {@link #create create} method and called with the
   * {@link module:core/editor/editor~Editor#locale editor locale} as an argument,
   * allowing localization of the {@link module:ui/view~View view}.
   *
   * @param name The name of the component.
   * @param callback The callback that returns the component.
   */
  add(e, t) {
    this._components.set(Tm(e), { callback: t, originalName: e });
  }
  /**
   * Creates an instance of a component registered in the factory under a specific name.
   *
   * When called, the {@link module:core/editor/editor~Editor#locale editor locale} is passed to
   * the previously {@link #add added} factory function, allowing localization of the
   * {@link module:ui/view~View view}.
   *
   * @param name The name of the component.
   * @returns The instantiated component view.
   */
  create(e) {
    if (!this.has(e))
      throw new B("componentfactory-item-missing", this, { name: e });
    return this._components.get(Tm(e)).callback(this.editor.locale);
  }
  /**
   * Checks if a component of a given name is registered in the factory.
   *
   * @param name The name of the component.
   */
  has(e) {
    return this._components.has(Tm(e));
  }
}
function Tm(i) {
  return String(i).toLowerCase();
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class Ho extends Xe {
  /**
   * Creates an instance of the dropdown.
   *
   * Also see {@link #render}.
   *
   * @param locale The localization services instance.
   */
  constructor(e, t, n) {
    super(e);
    const r = this.bindTemplate;
    this.buttonView = t, this.panelView = n, this.set("isOpen", !1), this.set("isEnabled", !0), this.set("class", void 0), this.set("id", void 0), this.set("panelPosition", "auto"), this.keystrokes = new cr(), this.focusTracker = new hi(), this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-dropdown",
          r.to("class"),
          r.if("isEnabled", "ck-disabled", (s) => !s)
        ],
        id: r.to("id"),
        "aria-describedby": r.to("ariaDescribedById")
      },
      children: [
        t,
        n
      ]
    }), t.extendTemplate({
      attributes: {
        class: [
          "ck-dropdown__button"
        ],
        "data-cke-tooltip-disabled": r.to("isOpen")
      }
    });
  }
  /**
   * @inheritDoc
   */
  render() {
    super.render(), this.focusTracker.add(this.buttonView.element), this.focusTracker.add(this.panelView.element), this.listenTo(this.buttonView, "open", () => {
      this.isOpen = !this.isOpen;
    }), this.panelView.bind("isVisible").to(this, "isOpen"), this.on("change:isOpen", (t, n, r) => {
      r && (this.panelPosition === "auto" ? this.panelView.position = Ho._getOptimalPosition({
        element: this.panelView.element,
        target: this.buttonView.element,
        fitInViewport: !0,
        positions: this._panelPositions
      }).name : this.panelView.position = this.panelPosition);
    }), this.keystrokes.listenTo(this.element);
    const e = (t, n) => {
      this.isOpen && (this.isOpen = !1, n());
    };
    this.keystrokes.set("arrowdown", (t, n) => {
      this.buttonView.isEnabled && !this.isOpen && (this.isOpen = !0, n());
    }), this.keystrokes.set("arrowright", (t, n) => {
      this.isOpen && n();
    }), this.keystrokes.set("arrowleft", e), this.keystrokes.set("esc", e);
  }
  /**
   * Focuses the {@link #buttonView}.
   */
  focus() {
    this.buttonView.focus();
  }
  /**
   * Returns {@link #panelView panel} positions to be used by the
   * {@link module:utils/dom/position~getOptimalPosition `getOptimalPosition()`}
   * utility considering the direction of the language the UI of the editor is displayed in.
   */
  get _panelPositions() {
    const { south: e, north: t, southEast: n, southWest: r, northEast: s, northWest: o, southMiddleEast: l, southMiddleWest: u, northMiddleEast: h, northMiddleWest: f } = Ho.defaultPanelPositions;
    return this.locale.uiLanguageDirection !== "rtl" ? [
      n,
      r,
      l,
      u,
      e,
      s,
      o,
      h,
      f,
      t
    ] : [
      r,
      n,
      u,
      l,
      e,
      o,
      s,
      f,
      h,
      t
    ];
  }
}
Ho.defaultPanelPositions = {
  south: (i, e) => ({
    top: i.bottom,
    left: i.left - (e.width - i.width) / 2,
    name: "s"
  }),
  southEast: (i) => ({
    top: i.bottom,
    left: i.left,
    name: "se"
  }),
  southWest: (i, e) => ({
    top: i.bottom,
    left: i.left - e.width + i.width,
    name: "sw"
  }),
  southMiddleEast: (i, e) => ({
    top: i.bottom,
    left: i.left - (e.width - i.width) / 4,
    name: "sme"
  }),
  southMiddleWest: (i, e) => ({
    top: i.bottom,
    left: i.left - (e.width - i.width) * 3 / 4,
    name: "smw"
  }),
  north: (i, e) => ({
    top: i.top - e.height,
    left: i.left - (e.width - i.width) / 2,
    name: "n"
  }),
  northEast: (i, e) => ({
    top: i.top - e.height,
    left: i.left,
    name: "ne"
  }),
  northWest: (i, e) => ({
    top: i.top - e.height,
    left: i.left - e.width + i.width,
    name: "nw"
  }),
  northMiddleEast: (i, e) => ({
    top: i.top - e.height,
    left: i.left - (e.width - i.width) / 4,
    name: "nme"
  }),
  northMiddleWest: (i, e) => ({
    top: i.top - e.height,
    left: i.left - (e.width - i.width) * 3 / 4,
    name: "nmw"
  })
};
Ho._getOptimalPosition = yE;
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class w9 extends Xe {
  /**
   * @inheritDoc
   */
  constructor(e) {
    super(e);
    const t = this.bindTemplate;
    this.set("isVisible", !1), this.set("position", "se"), this.children = this.createCollection(), this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-reset",
          "ck-dropdown__panel",
          t.to("position", (n) => `ck-dropdown__panel_${n}`),
          t.if("isVisible", "ck-dropdown__panel-visible")
        ]
      },
      children: this.children,
      on: {
        // Drag and drop in the panel should not break the selection in the editor.
        // https://github.com/ckeditor/ckeditor5-ui/issues/228
        selectstart: t.to((n) => n.preventDefault())
      }
    });
  }
  /**
   * Focuses the first view in the {@link #children} collection.
   *
   * See also {@link module:ui/dropdown/dropdownpanelfocusable~DropdownPanelFocusable}.
   */
  focus() {
    if (this.children.length) {
      const e = this.children.first;
      typeof e.focus == "function" ? e.focus() : Yt("ui-dropdown-panel-focus-child-missing-focus", { childView: this.children.first, dropdownPanel: this });
    }
  }
  /**
   * Focuses the view element or last item in view collection on opening dropdown's panel.
   *
   * See also {@link module:ui/dropdown/dropdownpanelfocusable~DropdownPanelFocusable}.
   */
  focusLast() {
    if (this.children.length) {
      const e = this.children.last;
      typeof e.focusLast == "function" ? e.focusLast() : e.focus();
    }
  }
}
const yp = '<svg viewBox="0 0 10 10" xmlns="http://www.w3.org/2000/svg"><path d="M.941 4.523a.75.75 0 1 1 1.06-1.06l3.006 3.005 3.005-3.005a.75.75 0 1 1 1.06 1.06l-3.549 3.55a.75.75 0 0 1-1.168-.136L.941 4.523z"/></svg>';
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class PC extends At {
  /**
   * @inheritDoc
   */
  constructor(e) {
    super(e), this.arrowView = this._createArrowView(), this.extendTemplate({
      attributes: {
        "aria-haspopup": !0,
        "aria-expanded": this.bindTemplate.to("isOn", (t) => String(t))
      }
    }), this.delegate("execute").to(this, "open");
  }
  /**
   * @inheritDoc
   */
  render() {
    super.render(), this.children.add(this.arrowView);
  }
  /**
   * Creates a {@link module:ui/icon/iconview~IconView} instance as {@link #arrowView}.
   */
  _createArrowView() {
    const e = new ea();
    return e.content = yp, e.extendTemplate({
      attributes: {
        class: "ck-dropdown__arrow"
      }
    }), e;
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class fh extends Xe {
  /**
   * @inheritDoc
   */
  constructor(e) {
    super(e);
    const t = this.bindTemplate;
    this.set("class", void 0), this.set("labelStyle", void 0), this.set("icon", void 0), this.set("isEnabled", !0), this.set("isOn", !1), this.set("isToggleable", !1), this.set("isVisible", !0), this.set("keystroke", void 0), this.set("withKeystroke", !1), this.set("label", void 0), this.set("tabindex", -1), this.set("tooltip", !1), this.set("tooltipPosition", "s"), this.set("type", "button"), this.set("withText", !1), this.children = this.createCollection(), this.actionView = this._createActionView(), this.arrowView = this._createArrowView(), this.keystrokes = new cr(), this.focusTracker = new hi(), this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-splitbutton",
          t.to("class"),
          t.if("isVisible", "ck-hidden", (n) => !n),
          this.arrowView.bindTemplate.if("isOn", "ck-splitbutton_open")
        ]
      },
      children: this.children
    });
  }
  /**
   * @inheritDoc
   */
  render() {
    super.render(), this.children.add(this.actionView), this.children.add(this.arrowView), this.focusTracker.add(this.actionView.element), this.focusTracker.add(this.arrowView.element), this.keystrokes.listenTo(this.element), this.keystrokes.set("arrowright", (e, t) => {
      this.focusTracker.focusedElement === this.actionView.element && (this.arrowView.focus(), t());
    }), this.keystrokes.set("arrowleft", (e, t) => {
      this.focusTracker.focusedElement === this.arrowView.element && (this.actionView.focus(), t());
    });
  }
  /**
   * @inheritDoc
   */
  destroy() {
    super.destroy(), this.focusTracker.destroy(), this.keystrokes.destroy();
  }
  /**
   * Focuses the {@link module:ui/button/buttonview~ButtonView#element} of the action part of split button.
   */
  focus() {
    this.actionView.focus();
  }
  /**
   * Creates a {@link module:ui/button/buttonview~ButtonView} instance as {@link #actionView} and binds it with main split button
   * attributes.
   */
  _createActionView() {
    const e = new At();
    return e.bind("icon", "isEnabled", "isOn", "isToggleable", "keystroke", "label", "tabindex", "tooltip", "tooltipPosition", "type", "withText").to(this), e.extendTemplate({
      attributes: {
        class: "ck-splitbutton__action"
      }
    }), e.delegate("execute").to(this), e;
  }
  /**
   * Creates a {@link module:ui/button/buttonview~ButtonView} instance as {@link #arrowView} and binds it with main split button
   * attributes.
   */
  _createArrowView() {
    const e = new At(), t = e.bindTemplate;
    return e.icon = yp, e.extendTemplate({
      attributes: {
        class: [
          "ck-splitbutton__arrow"
        ],
        "data-cke-tooltip-disabled": t.to("isOn"),
        "aria-haspopup": !0,
        "aria-expanded": t.to("isOn", (n) => String(n))
      }
    }), e.bind("isEnabled").to(this), e.bind("label").to(this), e.bind("tooltip").to(this), e.delegate("execute").to(this, "open"), e;
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class ta {
  /**
   * Creates an instance of the focus cycler utility.
   *
   * @param options Configuration options.
   */
  constructor(e) {
    if (this.focusables = e.focusables, this.focusTracker = e.focusTracker, this.keystrokeHandler = e.keystrokeHandler, this.actions = e.actions, e.actions && e.keystrokeHandler)
      for (const t in e.actions) {
        let n = e.actions[t];
        typeof n == "string" && (n = [n]);
        for (const r of n)
          e.keystrokeHandler.set(r, (s, o) => {
            this[t](), o();
          });
      }
  }
  /**
   * Returns the first focusable view in {@link #focusables}.
   * Returns `null` if there is none.
   *
   * **Note**: Hidden views (e.g. with `display: none`) are ignored.
   */
  get first() {
    return this.focusables.find(xm) || null;
  }
  /**
   * Returns the last focusable view in {@link #focusables}.
   * Returns `null` if there is none.
   *
   * **Note**: Hidden views (e.g. with `display: none`) are ignored.
   */
  get last() {
    return this.focusables.filter(xm).slice(-1)[0] || null;
  }
  /**
   * Returns the next focusable view in {@link #focusables} based on {@link #current}.
   * Returns `null` if there is none.
   *
   * **Note**: Hidden views (e.g. with `display: none`) are ignored.
   */
  get next() {
    return this._getFocusableItem(1);
  }
  /**
   * Returns the previous focusable view in {@link #focusables} based on {@link #current}.
   * Returns `null` if there is none.
   *
   * **Note**: Hidden views (e.g. with `display: none`) are ignored.
   */
  get previous() {
    return this._getFocusableItem(-1);
  }
  /**
   * An index of the view in the {@link #focusables} which is focused according
   * to {@link #focusTracker}. Returns `null` when there is no such view.
   */
  get current() {
    let e = null;
    return this.focusTracker.focusedElement === null ? null : (this.focusables.find((t, n) => {
      const r = t.element === this.focusTracker.focusedElement;
      return r && (e = n), r;
    }), e);
  }
  /**
   * Focuses the {@link #first} item in {@link #focusables}.
   *
   * **Note**: Hidden views (e.g. with `display: none`) are ignored.
   */
  focusFirst() {
    this._focus(this.first);
  }
  /**
   * Focuses the {@link #last} item in {@link #focusables}.
   *
   * **Note**: Hidden views (e.g. with `display: none`) are ignored.
   */
  focusLast() {
    this._focus(this.last);
  }
  /**
   * Focuses the {@link #next} item in {@link #focusables}.
   *
   * **Note**: Hidden views (e.g. with `display: none`) are ignored.
   */
  focusNext() {
    this._focus(this.next);
  }
  /**
   * Focuses the {@link #previous} item in {@link #focusables}.
   *
   * **Note**: Hidden views (e.g. with `display: none`) are ignored.
   */
  focusPrevious() {
    this._focus(this.previous);
  }
  /**
   * Focuses the given view if it exists.
   */
  _focus(e) {
    e && e.focus();
  }
  /**
   * Returns the next or previous focusable view in {@link #focusables} with respect
   * to {@link #current}.
   *
   * @param step Either `1` for checking forward from {@link #current} or `-1` for checking backwards.
   */
  _getFocusableItem(e) {
    const t = this.current, n = this.focusables.length;
    if (!n)
      return null;
    if (t === null)
      return this[e === 1 ? "first" : "last"];
    let r = (t + n + e) % n;
    do {
      const s = this.focusables.get(r);
      if (xm(s))
        return s;
      r = (r + n + e) % n;
    } while (r !== t);
    return null;
  }
}
function xm(i) {
  return !!(i.focus && $s(i.element));
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class IC extends Xe {
  /**
   * @inheritDoc
   */
  constructor(e) {
    super(e), this.setTemplate({
      tag: "span",
      attributes: {
        class: [
          "ck",
          "ck-toolbar__separator"
        ]
      }
    });
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class b9 extends Xe {
  /**
   * @inheritDoc
   */
  constructor(e) {
    super(e), this.setTemplate({
      tag: "span",
      attributes: {
        class: [
          "ck",
          "ck-toolbar__line-break"
        ]
      }
    });
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function y9(i) {
  return i.bindTemplate.to((e) => {
    e.target === i.element && e.preventDefault();
  });
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function mh(i) {
  return Array.isArray(i) ? {
    items: i,
    removeItems: []
  } : i ? Object.assign({
    items: [],
    removeItems: []
  }, i) : {
    items: [],
    removeItems: []
  };
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const { threeVerticalDots: RC } = Mt, E9 = {
  alignLeft: Mt.alignLeft,
  bold: Mt.bold,
  importExport: Mt.importExport,
  paragraph: Mt.paragraph,
  plus: Mt.plus,
  text: Mt.text,
  threeVerticalDots: Mt.threeVerticalDots
};
class na extends Xe {
  /**
   * Creates an instance of the {@link module:ui/toolbar/toolbarview~ToolbarView} class.
   *
   * Also see {@link #render}.
   *
   * @param locale The localization services instance.
   * @param options Configuration options of the toolbar.
   */
  constructor(e, t) {
    super(e);
    const n = this.bindTemplate, r = this.t;
    this.options = t || {}, this.set("ariaLabel", r("Editor toolbar")), this.set("maxWidth", "auto"), this.items = this.createCollection(), this.focusTracker = new hi(), this.keystrokes = new cr(), this.set("class", void 0), this.set("isCompact", !1), this.itemsView = new C9(e), this.children = this.createCollection(), this.children.add(this.itemsView), this.focusables = this.createCollection();
    const s = e.uiLanguageDirection === "rtl";
    this._focusCycler = new ta({
      focusables: this.focusables,
      focusTracker: this.focusTracker,
      keystrokeHandler: this.keystrokes,
      actions: {
        // Navigate toolbar items backwards using the arrow[left,up] keys.
        focusPrevious: [s ? "arrowright" : "arrowleft", "arrowup"],
        // Navigate toolbar items forwards using the arrow[right,down] keys.
        focusNext: [s ? "arrowleft" : "arrowright", "arrowdown"]
      }
    });
    const o = [
      "ck",
      "ck-toolbar",
      n.to("class"),
      n.if("isCompact", "ck-toolbar_compact")
    ];
    this.options.shouldGroupWhenFull && this.options.isFloating && o.push("ck-toolbar_floating"), this.setTemplate({
      tag: "div",
      attributes: {
        class: o,
        role: "toolbar",
        "aria-label": n.to("ariaLabel"),
        style: {
          maxWidth: n.to("maxWidth")
        }
      },
      children: this.children,
      on: {
        // https://github.com/ckeditor/ckeditor5-ui/issues/206
        mousedown: y9(this)
      }
    }), this._behavior = this.options.shouldGroupWhenFull ? new T9(this) : new S9(this);
  }
  /**
   * @inheritDoc
   */
  render() {
    super.render();
    for (const e of this.items)
      this.focusTracker.add(e.element);
    this.items.on("add", (e, t) => {
      this.focusTracker.add(t.element);
    }), this.items.on("remove", (e, t) => {
      this.focusTracker.remove(t.element);
    }), this.keystrokes.listenTo(this.element), this._behavior.render(this);
  }
  /**
   * @inheritDoc
   */
  destroy() {
    return this._behavior.destroy(), this.focusTracker.destroy(), this.keystrokes.destroy(), super.destroy();
  }
  /**
   * Focuses the first focusable in {@link #focusables}.
   */
  focus() {
    this._focusCycler.focusFirst();
  }
  /**
   * Focuses the last focusable in {@link #focusables}.
   */
  focusLast() {
    this._focusCycler.focusLast();
  }
  /**
   * A utility that expands the plain toolbar configuration into
   * {@link module:ui/toolbar/toolbarview~ToolbarView#items} using a given component factory.
   *
   * @param itemsOrConfig The toolbar items or the entire toolbar configuration object.
   * @param factory A factory producing toolbar items.
   * @param removeItems An array of items names to be removed from the configuration. When present, applies
   * to this toolbar and all nested ones as well.
   */
  fillFromConfig(e, t, n) {
    this.items.addMany(this._buildItemsFromConfig(e, t, n));
  }
  /**
   * A utility that expands the plain toolbar configuration into a list of view items using a given component factory.
   *
   * @param itemsOrConfig The toolbar items or the entire toolbar configuration object.
   * @param factory A factory producing toolbar items.
   * @param removeItems An array of items names to be removed from the configuration. When present, applies
   * to this toolbar and all nested ones as well.
   */
  _buildItemsFromConfig(e, t, n) {
    const r = mh(e), s = n || r.removeItems;
    return this._cleanItemsConfiguration(r.items, t, s).map((l) => Lt(l) ? this._createNestedToolbarDropdown(l, t, s) : l === "|" ? new IC() : l === "-" ? new b9() : t.create(l)).filter((l) => !!l);
  }
  /**
   * Cleans up the {@link module:ui/toolbar/toolbarview~ToolbarView#items} of the toolbar by removing unwanted items and
   * duplicated (obsolete) separators or line breaks.
   *
   * @param items The toolbar items configuration.
   * @param factory A factory producing toolbar items.
   * @param removeItems An array of items names to be removed from the configuration.
   * @returns Items after the clean-up.
   */
  _cleanItemsConfiguration(e, t, n) {
    const r = e.filter((s, o, l) => s === "|" ? !0 : n.indexOf(s) !== -1 ? !1 : s === "-" ? this.options.shouldGroupWhenFull ? (Yt("toolbarview-line-break-ignored-when-grouping-items", l), !1) : !0 : !Lt(s) && !t.has(s) ? (Yt("toolbarview-item-unavailable", { item: s }), !1) : !0);
    return this._cleanSeparatorsAndLineBreaks(r);
  }
  /**
   * Remove leading, trailing, and duplicated separators (`-` and `|`).
   *
   * @returns Toolbar items after the separator and line break clean-up.
   */
  _cleanSeparatorsAndLineBreaks(e) {
    const t = (o) => o !== "-" && o !== "|", n = e.length, r = e.findIndex(t);
    if (r === -1)
      return [];
    const s = n - e.slice().reverse().findIndex(t);
    return e.slice(r, s).filter((o, l, u) => t(o) ? !0 : !(l > 0 && u[l - 1] === o));
  }
  /**
   * Creates a user-defined dropdown containing a toolbar with items.
   *
   * @param definition A definition of the nested toolbar dropdown.
   * @param definition.label A label of the dropdown.
   * @param definition.icon An icon of the drop-down. One of 'bold', 'plus', 'text', 'importExport', 'alignLeft',
   * 'paragraph' or an SVG string. When `false` is passed, no icon will be used.
   * @param definition.withText When set `true`, the label of the dropdown will be visible. See
   * {@link module:ui/button/buttonview~ButtonView#withText} to learn more.
   * @param definition.tooltip A tooltip of the dropdown button. See
   * {@link module:ui/button/buttonview~ButtonView#tooltip} to learn more. Defaults to `true`.
   * @param componentFactory Component factory used to create items
   * of the nested toolbar.
   */
  _createNestedToolbarDropdown(e, t, n) {
    let { label: r, icon: s, items: o, tooltip: l = !0, withText: u = !1 } = e;
    if (o = this._cleanItemsConfiguration(o, t, n), !o.length)
      return null;
    const h = this.locale, f = Gs(h);
    return r || Yt("toolbarview-nested-toolbar-dropdown-missing-label", e), f.class = "ck-toolbar__nested-toolbar-dropdown", f.buttonView.set({
      label: r,
      tooltip: l,
      withText: !!u
    }), s !== !1 ? f.buttonView.icon = E9[s] || s || RC : f.buttonView.withText = !0, gh(f, () => f.toolbarView._buildItemsFromConfig(o, t, n)), f;
  }
}
class C9 extends Xe {
  /**
   * @inheritDoc
   */
  constructor(e) {
    super(e), this.children = this.createCollection(), this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-toolbar__items"
        ]
      },
      children: this.children
    });
  }
}
class S9 {
  /**
   * Creates an instance of the {@link module:ui/toolbar/toolbarview~StaticLayout} toolbar
   * behavior.
   *
   * @param view An instance of the toolbar that this behavior is added to.
   */
  constructor(e) {
    const t = e.bindTemplate;
    e.set("isVertical", !1), e.itemsView.children.bindTo(e.items).using((n) => n), e.focusables.bindTo(e.items).using((n) => n), e.extendTemplate({
      attributes: {
        class: [
          // When vertical, the toolbar has an additional CSS class.
          t.if("isVertical", "ck-toolbar_vertical")
        ]
      }
    });
  }
  /**
   * @inheritDoc
   */
  render() {
  }
  /**
   * @inheritDoc
   */
  destroy() {
  }
}
class T9 {
  /**
   * Creates an instance of the {@link module:ui/toolbar/toolbarview~DynamicGrouping} toolbar
   * behavior.
   *
   * @param view An instance of the toolbar that this behavior is added to.
   */
  constructor(e) {
    this.resizeObserver = null, this.cachedPadding = null, this.shouldUpdateGroupingOnNextResize = !1, this.view = e, this.viewChildren = e.children, this.viewFocusables = e.focusables, this.viewItemsView = e.itemsView, this.viewFocusTracker = e.focusTracker, this.viewLocale = e.locale, this.ungroupedItems = e.createCollection(), this.groupedItems = e.createCollection(), this.groupedItemsDropdown = this._createGroupedItemsDropdown(), e.itemsView.children.bindTo(this.ungroupedItems).using((t) => t), this.ungroupedItems.on("change", this._updateFocusCycleableItems.bind(this)), e.children.on("change", this._updateFocusCycleableItems.bind(this)), e.items.on("change", (t, n) => {
      const r = n.index, s = Array.from(n.added);
      for (const o of n.removed)
        r >= this.ungroupedItems.length ? this.groupedItems.remove(o) : this.ungroupedItems.remove(o);
      for (let o = r; o < r + s.length; o++) {
        const l = s[o - r];
        o > this.ungroupedItems.length ? this.groupedItems.add(l, o - this.ungroupedItems.length) : this.ungroupedItems.add(l, o);
      }
      this._updateGrouping();
    }), e.extendTemplate({
      attributes: {
        class: [
          // To group items dynamically, the toolbar needs a dedicated CSS class.
          "ck-toolbar_grouping"
        ]
      }
    });
  }
  /**
   * Enables dynamic items grouping based on the dimensions of the toolbar.
   *
   * @param view An instance of the toolbar that this behavior is added to.
   */
  render(e) {
    this.viewElement = e.element, this._enableGroupingOnResize(), this._enableGroupingOnMaxWidthChange(e);
  }
  /**
   * Cleans up the internals used by this behavior.
   */
  destroy() {
    this.groupedItemsDropdown.destroy(), this.resizeObserver.destroy();
  }
  /**
   * When called, it will check if any of the {@link #ungroupedItems} do not fit into a single row of the toolbar,
   * and it will move them to the {@link #groupedItems} when it happens.
   *
   * At the same time, it will also check if there is enough space in the toolbar for the first of the
   * {@link #groupedItems} to be returned back to {@link #ungroupedItems} and still fit into a single row
   * without the toolbar wrapping.
   */
  _updateGrouping() {
    if (!this.viewElement.ownerDocument.body.contains(this.viewElement))
      return;
    if (!$s(this.viewElement)) {
      this.shouldUpdateGroupingOnNextResize = !0;
      return;
    }
    const e = this.groupedItems.length;
    let t;
    for (; this._areItemsOverflowing; )
      this._groupLastItem(), t = !0;
    if (!t && this.groupedItems.length) {
      for (; this.groupedItems.length && !this._areItemsOverflowing; )
        this._ungroupFirstItem();
      this._areItemsOverflowing && this._groupLastItem();
    }
    this.groupedItems.length !== e && this.view.fire("groupedItemsUpdate");
  }
  /**
   * Returns `true` when {@link module:ui/toolbar/toolbarview~ToolbarView#element} children visually overflow,
   * for instance if the toolbar is narrower than its members. Returns `false` otherwise.
   */
  get _areItemsOverflowing() {
    if (!this.ungroupedItems.length)
      return !1;
    const e = this.viewElement, t = this.viewLocale.uiLanguageDirection, n = new pt(e.lastChild), r = new pt(e);
    if (!this.cachedPadding) {
      const s = Ke.window.getComputedStyle(e), o = t === "ltr" ? "paddingRight" : "paddingLeft";
      this.cachedPadding = Number.parseInt(s[o]);
    }
    return t === "ltr" ? n.right > r.right - this.cachedPadding : n.left < r.left + this.cachedPadding;
  }
  /**
   * Enables the functionality that prevents {@link #ungroupedItems} from overflowing (wrapping to the next row)
   * upon resize when there is little space available. Instead, the toolbar items are moved to the
   * {@link #groupedItems} collection and displayed in a dropdown at the end of the row (which has its own nested toolbar).
   *
   * When called, the toolbar will automatically analyze the location of its {@link #ungroupedItems} and "group"
   * them in the dropdown if necessary. It will also observe the browser window for size changes in
   * the future and respond to them by grouping more items or reverting already grouped back, depending
   * on the visual space available.
   */
  _enableGroupingOnResize() {
    let e;
    this.resizeObserver = new xt(this.viewElement, (t) => {
      (!e || e !== t.contentRect.width || this.shouldUpdateGroupingOnNextResize) && (this.shouldUpdateGroupingOnNextResize = !1, this._updateGrouping(), e = t.contentRect.width);
    }), this._updateGrouping();
  }
  /**
   * Enables the grouping functionality, just like {@link #_enableGroupingOnResize} but the difference is that
   * it listens to the changes of {@link module:ui/toolbar/toolbarview~ToolbarView#maxWidth} instead.
   */
  _enableGroupingOnMaxWidthChange(e) {
    e.on("change:maxWidth", () => {
      this._updateGrouping();
    });
  }
  /**
   * When called, it will remove the last item from {@link #ungroupedItems} and move it back
   * to the {@link #groupedItems} collection.
   *
   * The opposite of {@link #_ungroupFirstItem}.
   */
  _groupLastItem() {
    this.groupedItems.length || (this.viewChildren.add(new IC()), this.viewChildren.add(this.groupedItemsDropdown), this.viewFocusTracker.add(this.groupedItemsDropdown.element)), this.groupedItems.add(this.ungroupedItems.remove(this.ungroupedItems.last), 0);
  }
  /**
   * Moves the very first item belonging to {@link #groupedItems} back
   * to the {@link #ungroupedItems} collection.
   *
   * The opposite of {@link #_groupLastItem}.
   */
  _ungroupFirstItem() {
    this.ungroupedItems.add(this.groupedItems.remove(this.groupedItems.first)), this.groupedItems.length || (this.viewChildren.remove(this.groupedItemsDropdown), this.viewChildren.remove(this.viewChildren.last), this.viewFocusTracker.remove(this.groupedItemsDropdown.element));
  }
  /**
   * Creates the {@link #groupedItemsDropdown} that hosts the members of the {@link #groupedItems}
   * collection when there is not enough space in the toolbar to display all items in a single row.
   */
  _createGroupedItemsDropdown() {
    const e = this.viewLocale, t = e.t, n = Gs(e);
    return n.class = "ck-toolbar__grouped-dropdown", n.panelPosition = e.uiLanguageDirection === "ltr" ? "sw" : "se", gh(n, this.groupedItems), n.buttonView.set({
      label: t("Show more items"),
      tooltip: !0,
      tooltipPosition: e.uiLanguageDirection === "rtl" ? "se" : "sw",
      icon: RC
    }), n;
  }
  /**
   * Updates the {@link module:ui/toolbar/toolbarview~ToolbarView#focusables focus–cycleable items}
   * collection so it represents the up–to–date state of the UI from the perspective of the user.
   *
   * For instance, the {@link #groupedItemsDropdown} can show up and hide but when it is visible,
   * it must be subject to focus cycling in the toolbar.
   *
   * See the {@link module:ui/toolbar/toolbarview~ToolbarView#focusables collection} documentation
   * to learn more about the purpose of this method.
   */
  _updateFocusCycleableItems() {
    this.viewFocusables.clear(), this.ungroupedItems.map((e) => {
      this.viewFocusables.add(e);
    }), this.groupedItems.length && this.viewFocusables.add(this.groupedItemsDropdown);
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class x9 extends Xe {
  /**
   * @inheritDoc
   */
  constructor(e) {
    super(e);
    const t = this.bindTemplate;
    this.items = this.createCollection(), this.focusTracker = new hi(), this.keystrokes = new cr(), this._focusCycler = new ta({
      focusables: this.items,
      focusTracker: this.focusTracker,
      keystrokeHandler: this.keystrokes,
      actions: {
        // Navigate list items backwards using the arrowup key.
        focusPrevious: "arrowup",
        // Navigate toolbar items forwards using the arrowdown key.
        focusNext: "arrowdown"
      }
    }), this.set("ariaLabel", void 0), this.setTemplate({
      tag: "ul",
      attributes: {
        class: [
          "ck",
          "ck-reset",
          "ck-list"
        ],
        "aria-label": t.to("ariaLabel")
      },
      children: this.items
    });
  }
  /**
   * @inheritDoc
   */
  render() {
    super.render();
    for (const e of this.items)
      this.focusTracker.add(e.element);
    this.items.on("add", (e, t) => {
      this.focusTracker.add(t.element);
    }), this.items.on("remove", (e, t) => {
      this.focusTracker.remove(t.element);
    }), this.keystrokes.listenTo(this.element);
  }
  /**
   * @inheritDoc
   */
  destroy() {
    super.destroy(), this.focusTracker.destroy(), this.keystrokes.destroy();
  }
  /**
   * Focuses the first focusable in {@link #items}.
   */
  focus() {
    this._focusCycler.focusFirst();
  }
  /**
   * Focuses the last focusable in {@link #items}.
   */
  focusLast() {
    this._focusCycler.focusLast();
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class OC extends Xe {
  /**
   * @inheritDoc
   */
  constructor(e) {
    super(e);
    const t = this.bindTemplate;
    this.set("isVisible", !0), this.children = this.createCollection(), this.setTemplate({
      tag: "li",
      attributes: {
        class: [
          "ck",
          "ck-list__item",
          t.if("isVisible", "ck-hidden", (n) => !n)
        ]
      },
      children: this.children
    });
  }
  /**
   * Focuses the list item.
   */
  focus() {
    this.children.first.focus();
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class k9 extends Xe {
  /**
   * @inheritDoc
   */
  constructor(e) {
    super(e), this.setTemplate({
      tag: "li",
      attributes: {
        class: [
          "ck",
          "ck-list__separator"
        ]
      }
    });
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function Gs(i, e = PC) {
  const t = new e(i), n = new w9(i), r = new Ho(i, t, n);
  return t.bind("isEnabled").to(r), t instanceof fh ? t.arrowView.bind("isOn").to(r, "isOpen") : t.bind("isOn").to(r, "isOpen"), A9(r), r;
}
function gh(i, e, t = {}) {
  i.extendTemplate({
    attributes: {
      class: ["ck-toolbar-dropdown"]
    }
  }), i.isOpen ? Ob(i, e, t) : i.once("change:isOpen", () => Ob(i, e, t), { priority: "highest" }), t.enableActiveItemFocusOnDropdownOpen && Ep(i, () => i.toolbarView.items.find((n) => n.isOn));
}
function Ob(i, e, t) {
  const n = i.locale, r = n.t, s = i.toolbarView = new na(n), o = typeof e == "function" ? e() : e;
  s.ariaLabel = t.ariaLabel || r("Dropdown toolbar"), t.maxWidth && (s.maxWidth = t.maxWidth), t.class && (s.class = t.class), t.isCompact && (s.isCompact = t.isCompact), t.isVertical && (s.isVertical = !0), o instanceof cs ? s.items.bindTo(o).using((l) => l) : s.items.addMany(o), i.panelView.children.add(s), s.items.delegate("execute").to(i);
}
function MC(i, e, t = {}) {
  i.isOpen ? Mb(i, e, t) : i.once("change:isOpen", () => Mb(i, e, t), { priority: "highest" }), Ep(i, () => i.listView.items.find((n) => n instanceof OC ? n.children.first.isOn : !1));
}
function Mb(i, e, t) {
  const n = i.locale, r = i.listView = new x9(n), s = typeof e == "function" ? e() : e;
  r.ariaLabel = t.ariaLabel, r.items.bindTo(s).using((o) => {
    if (o.type === "separator")
      return new k9(n);
    if (o.type === "button" || o.type === "switchbutton") {
      const l = new OC(n);
      let u;
      return o.type === "button" ? u = new At(n) : u = new hh(n), u.bind(...Object.keys(o.model)).to(o.model), u.delegate("execute").to(l), l.children.add(u), l;
    }
    return null;
  }), i.panelView.children.add(r), r.items.delegate("execute").to(i);
}
function Ep(i, e) {
  i.on("change:isOpen", () => {
    if (!i.isOpen)
      return;
    const t = e();
    t && (typeof t.focus == "function" ? t.focus() : Yt("ui-dropdown-focus-child-on-open-child-missing-focus", { view: t }));
  }, { priority: Os.low - 10 });
}
function A9(i) {
  P9(i), I9(i), R9(i), O9(i), M9(i), N9(i);
}
function P9(i) {
  i.on("render", () => {
    vp({
      emitter: i,
      activator: () => i.isOpen,
      callback: () => {
        i.isOpen = !1;
      },
      contextElements: [i.element]
    });
  });
}
function I9(i) {
  i.on("execute", (e) => {
    e.source instanceof hh || (i.isOpen = !1);
  });
}
function R9(i) {
  i.focusTracker.on("change:isFocused", (e, t, n) => {
    i.isOpen && !n && (i.isOpen = !1);
  });
}
function O9(i) {
  i.keystrokes.set("arrowdown", (e, t) => {
    i.isOpen && (i.panelView.focus(), t());
  }), i.keystrokes.set("arrowup", (e, t) => {
    i.isOpen && (i.panelView.focusLast(), t());
  });
}
function M9(i) {
  i.on("change:isOpen", (e, t, n) => {
    if (n)
      return;
    const r = i.panelView.element;
    r && r.contains(Ke.document.activeElement) && i.buttonView.focus();
  });
}
function N9(i) {
  i.on("change:isOpen", (e, t, n) => {
    n && i.panelView.focus();
  }, { priority: "low" });
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const Nb = $l("px"), Db = Ke.document.body;
class gn extends Xe {
  /**
   * @inheritDoc
   */
  constructor(e) {
    super(e);
    const t = this.bindTemplate;
    this.set("top", 0), this.set("left", 0), this.set("position", "arrow_nw"), this.set("isVisible", !1), this.set("withArrow", !0), this.set("class", void 0), this._pinWhenIsVisibleCallback = null, this.content = this.createCollection(), this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-balloon-panel",
          t.to("position", (n) => `ck-balloon-panel_${n}`),
          t.if("isVisible", "ck-balloon-panel_visible"),
          t.if("withArrow", "ck-balloon-panel_with-arrow"),
          t.to("class")
        ],
        style: {
          top: t.to("top", Nb),
          left: t.to("left", Nb)
        }
      },
      children: this.content
    });
  }
  /**
   * Shows the panel.
   *
   * See {@link #isVisible}.
   */
  show() {
    this.isVisible = !0;
  }
  /**
   * Hides the panel.
   *
   * See {@link #isVisible}.
   */
  hide() {
    this.isVisible = !1;
  }
  /**
   * Attaches the panel to a specified {@link module:utils/dom/position~Options#target} with a
   * smart positioning heuristics that chooses from available positions to make sure the panel
   * is visible to the user i.e. within the limits of the viewport.
   *
   * This method accepts configuration {@link module:utils/dom/position~Options options}
   * to set the `target`, optional `limiter` and `positions` the balloon should choose from.
   *
   * ```ts
   * const panel = new BalloonPanelView( locale );
   * const positions = BalloonPanelView.defaultPositions;
   *
   * panel.render();
   *
   * // Attach the panel to an element with the "target" id DOM.
   * panel.attachTo( {
   * 	target: document.querySelector( '#target' ),
   * 	positions: [
   * 		positions.northArrowSouth,
   * 		positions.southArrowNorth
   * 	]
   * } );
   * ```
   *
   * **Note**: Attaching the panel will also automatically {@link #show} it.
   *
   * **Note**: An attached panel will not follow its target when the window is scrolled or resized.
   * See the {@link #pin} method for a more permanent positioning strategy.
   *
   * @param options Positioning options compatible with {@link module:utils/dom/position~getOptimalPosition}.
   * Default `positions` array is {@link module:ui/panel/balloon/balloonpanelview~BalloonPanelView.defaultPositions}.
   */
  attachTo(e) {
    this.show();
    const t = gn.defaultPositions, n = Object.assign({}, {
      element: this.element,
      positions: [
        t.southArrowNorth,
        t.southArrowNorthMiddleWest,
        t.southArrowNorthMiddleEast,
        t.southArrowNorthWest,
        t.southArrowNorthEast,
        t.northArrowSouth,
        t.northArrowSouthMiddleWest,
        t.northArrowSouthMiddleEast,
        t.northArrowSouthWest,
        t.northArrowSouthEast,
        t.viewportStickyNorth
      ],
      limiter: Db,
      fitInViewport: !0
    }, e), r = gn._getOptimalPosition(n), s = parseInt(r.left), o = parseInt(r.top), l = r.name, u = r.config || {}, { withArrow: h = !0 } = u;
    this.top = o, this.left = s, this.position = l, this.withArrow = h;
  }
  /**
   * Works the same way as the {@link #attachTo} method except that the position of the panel is
   * continuously updated when:
   *
   * * any ancestor of the {@link module:utils/dom/position~Options#target}
   * or {@link module:utils/dom/position~Options#limiter} is scrolled,
   * * the browser window gets resized or scrolled.
   *
   * Thanks to that, the panel always sticks to the {@link module:utils/dom/position~Options#target}
   * and is immune to the changing environment.
   *
   * ```ts
   * const panel = new BalloonPanelView( locale );
   * const positions = BalloonPanelView.defaultPositions;
   *
   * panel.render();
   *
   * // Pin the panel to an element with the "target" id DOM.
   * panel.pin( {
   * 	target: document.querySelector( '#target' ),
   * 	positions: [
   * 		positions.northArrowSouth,
   * 		positions.southArrowNorth
   * 	]
   * } );
   * ```
   *
   * To leave the pinned state, use the {@link #unpin} method.
   *
   * **Note**: Pinning the panel will also automatically {@link #show} it.
   *
   * @param options Positioning options compatible with {@link module:utils/dom/position~getOptimalPosition}.
   * Default `positions` array is {@link module:ui/panel/balloon/balloonpanelview~BalloonPanelView.defaultPositions}.
   */
  pin(e) {
    this.unpin(), this._pinWhenIsVisibleCallback = () => {
      this.isVisible ? this._startPinning(e) : this._stopPinning();
    }, this._startPinning(e), this.listenTo(this, "change:isVisible", this._pinWhenIsVisibleCallback);
  }
  /**
   * Stops pinning the panel, as set up by {@link #pin}.
   */
  unpin() {
    this._pinWhenIsVisibleCallback && (this._stopPinning(), this.stopListening(this, "change:isVisible", this._pinWhenIsVisibleCallback), this._pinWhenIsVisibleCallback = null, this.hide());
  }
  /**
   * Starts managing the pinned state of the panel. See {@link #pin}.
   *
   * @param options Positioning options compatible with {@link module:utils/dom/position~getOptimalPosition}.
   */
  _startPinning(e) {
    this.attachTo(e);
    const t = vg(e.target), n = e.limiter ? vg(e.limiter) : Db;
    this.listenTo(Ke.document, "scroll", (r, s) => {
      const o = s.target, l = t && o.contains(t), u = n && o.contains(n);
      (l || u || !t || !n) && this.attachTo(e);
    }, { useCapture: !0 }), this.listenTo(Ke.window, "resize", () => {
      this.attachTo(e);
    });
  }
  /**
   * Stops managing the pinned state of the panel. See {@link #pin}.
   */
  _stopPinning() {
    this.stopListening(Ke.document, "scroll"), this.stopListening(Ke.window, "resize");
  }
}
gn.arrowSideOffset = 25;
gn.arrowHeightOffset = 10;
gn.stickyVerticalOffset = 20;
gn._getOptimalPosition = yE;
gn.defaultPositions = Cp();
function vg(i) {
  return Dr(i) ? i : oh(i) ? i.commonAncestorContainer : typeof i == "function" ? vg(i()) : null;
}
function Cp(i = {}) {
  const { sideOffset: e = gn.arrowSideOffset, heightOffset: t = gn.arrowHeightOffset, stickyVerticalOffset: n = gn.stickyVerticalOffset, config: r } = i;
  return {
    // ------- North west
    northWestArrowSouthWest: (l, u) => ({
      top: s(l, u),
      left: l.left - e,
      name: "arrow_sw",
      ...r && { config: r }
    }),
    northWestArrowSouthMiddleWest: (l, u) => ({
      top: s(l, u),
      left: l.left - u.width * 0.25 - e,
      name: "arrow_smw",
      ...r && { config: r }
    }),
    northWestArrowSouth: (l, u) => ({
      top: s(l, u),
      left: l.left - u.width / 2,
      name: "arrow_s",
      ...r && { config: r }
    }),
    northWestArrowSouthMiddleEast: (l, u) => ({
      top: s(l, u),
      left: l.left - u.width * 0.75 + e,
      name: "arrow_sme",
      ...r && { config: r }
    }),
    northWestArrowSouthEast: (l, u) => ({
      top: s(l, u),
      left: l.left - u.width + e,
      name: "arrow_se",
      ...r && { config: r }
    }),
    // ------- North
    northArrowSouthWest: (l, u) => ({
      top: s(l, u),
      left: l.left + l.width / 2 - e,
      name: "arrow_sw",
      ...r && { config: r }
    }),
    northArrowSouthMiddleWest: (l, u) => ({
      top: s(l, u),
      left: l.left + l.width / 2 - u.width * 0.25 - e,
      name: "arrow_smw",
      ...r && { config: r }
    }),
    northArrowSouth: (l, u) => ({
      top: s(l, u),
      left: l.left + l.width / 2 - u.width / 2,
      name: "arrow_s",
      ...r && { config: r }
    }),
    northArrowSouthMiddleEast: (l, u) => ({
      top: s(l, u),
      left: l.left + l.width / 2 - u.width * 0.75 + e,
      name: "arrow_sme",
      ...r && { config: r }
    }),
    northArrowSouthEast: (l, u) => ({
      top: s(l, u),
      left: l.left + l.width / 2 - u.width + e,
      name: "arrow_se",
      ...r && { config: r }
    }),
    // ------- North east
    northEastArrowSouthWest: (l, u) => ({
      top: s(l, u),
      left: l.right - e,
      name: "arrow_sw",
      ...r && { config: r }
    }),
    northEastArrowSouthMiddleWest: (l, u) => ({
      top: s(l, u),
      left: l.right - u.width * 0.25 - e,
      name: "arrow_smw",
      ...r && { config: r }
    }),
    northEastArrowSouth: (l, u) => ({
      top: s(l, u),
      left: l.right - u.width / 2,
      name: "arrow_s",
      ...r && { config: r }
    }),
    northEastArrowSouthMiddleEast: (l, u) => ({
      top: s(l, u),
      left: l.right - u.width * 0.75 + e,
      name: "arrow_sme",
      ...r && { config: r }
    }),
    northEastArrowSouthEast: (l, u) => ({
      top: s(l, u),
      left: l.right - u.width + e,
      name: "arrow_se",
      ...r && { config: r }
    }),
    // ------- South west
    southWestArrowNorthWest: (l) => ({
      top: o(l),
      left: l.left - e,
      name: "arrow_nw",
      ...r && { config: r }
    }),
    southWestArrowNorthMiddleWest: (l, u) => ({
      top: o(l),
      left: l.left - u.width * 0.25 - e,
      name: "arrow_nmw",
      ...r && { config: r }
    }),
    southWestArrowNorth: (l, u) => ({
      top: o(l),
      left: l.left - u.width / 2,
      name: "arrow_n",
      ...r && { config: r }
    }),
    southWestArrowNorthMiddleEast: (l, u) => ({
      top: o(l),
      left: l.left - u.width * 0.75 + e,
      name: "arrow_nme",
      ...r && { config: r }
    }),
    southWestArrowNorthEast: (l, u) => ({
      top: o(l),
      left: l.left - u.width + e,
      name: "arrow_ne",
      ...r && { config: r }
    }),
    // ------- South
    southArrowNorthWest: (l) => ({
      top: o(l),
      left: l.left + l.width / 2 - e,
      name: "arrow_nw",
      ...r && { config: r }
    }),
    southArrowNorthMiddleWest: (l, u) => ({
      top: o(l),
      left: l.left + l.width / 2 - u.width * 0.25 - e,
      name: "arrow_nmw",
      ...r && { config: r }
    }),
    southArrowNorth: (l, u) => ({
      top: o(l),
      left: l.left + l.width / 2 - u.width / 2,
      name: "arrow_n",
      ...r && { config: r }
    }),
    southArrowNorthMiddleEast: (l, u) => ({
      top: o(l),
      left: l.left + l.width / 2 - u.width * 0.75 + e,
      name: "arrow_nme",
      ...r && { config: r }
    }),
    southArrowNorthEast: (l, u) => ({
      top: o(l),
      left: l.left + l.width / 2 - u.width + e,
      name: "arrow_ne",
      ...r && { config: r }
    }),
    // ------- South east
    southEastArrowNorthWest: (l) => ({
      top: o(l),
      left: l.right - e,
      name: "arrow_nw",
      ...r && { config: r }
    }),
    southEastArrowNorthMiddleWest: (l, u) => ({
      top: o(l),
      left: l.right - u.width * 0.25 - e,
      name: "arrow_nmw",
      ...r && { config: r }
    }),
    southEastArrowNorth: (l, u) => ({
      top: o(l),
      left: l.right - u.width / 2,
      name: "arrow_n",
      ...r && { config: r }
    }),
    southEastArrowNorthMiddleEast: (l, u) => ({
      top: o(l),
      left: l.right - u.width * 0.75 + e,
      name: "arrow_nme",
      ...r && { config: r }
    }),
    southEastArrowNorthEast: (l, u) => ({
      top: o(l),
      left: l.right - u.width + e,
      name: "arrow_ne",
      ...r && { config: r }
    }),
    // ------- West
    westArrowEast: (l, u) => ({
      top: l.top + l.height / 2 - u.height / 2,
      left: l.left - u.width - t,
      name: "arrow_e",
      ...r && { config: r }
    }),
    // ------- East
    eastArrowWest: (l, u) => ({
      top: l.top + l.height / 2 - u.height / 2,
      left: l.right + t,
      name: "arrow_w",
      ...r && { config: r }
    }),
    // ------- Sticky
    viewportStickyNorth: (l, u, h) => l.getIntersection(h) ? {
      top: h.top + n,
      left: l.left + l.width / 2 - u.width / 2,
      name: "arrowless",
      config: {
        withArrow: !1,
        ...r
      }
    } : null
  };
  function s(l, u) {
    return l.top - u.height - t;
  }
  function o(l) {
    return l.bottom + t;
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const Bb = "ck-tooltip";
class mn extends as() {
  /**
   * Creates an instance of the tooltip manager.
   */
  constructor(e) {
    if (super(), this._currentElementWithTooltip = null, this._currentTooltipPosition = null, this._resizeObserver = null, mn._editors.add(e), mn._instance)
      return mn._instance;
    mn._instance = this, this.tooltipTextView = new Xe(e.locale), this.tooltipTextView.set("text", ""), this.tooltipTextView.setTemplate({
      tag: "span",
      attributes: {
        class: [
          "ck",
          "ck-tooltip__text"
        ]
      },
      children: [
        {
          text: this.tooltipTextView.bindTemplate.to("text")
        }
      ]
    }), this.balloonPanelView = new gn(e.locale), this.balloonPanelView.class = Bb, this.balloonPanelView.content.add(this.tooltipTextView), this._pinTooltipDebounced = $o(this._pinTooltip, 600), this.listenTo(Ke.document, "mouseenter", this._onEnterOrFocus.bind(this), { useCapture: !0 }), this.listenTo(Ke.document, "mouseleave", this._onLeaveOrBlur.bind(this), { useCapture: !0 }), this.listenTo(Ke.document, "focus", this._onEnterOrFocus.bind(this), { useCapture: !0 }), this.listenTo(Ke.document, "blur", this._onLeaveOrBlur.bind(this), { useCapture: !0 }), this.listenTo(Ke.document, "scroll", this._onScroll.bind(this), { useCapture: !0 }), this._watchdogExcluded = !0;
  }
  /**
   * Destroys the tooltip manager.
   *
   * **Note**: The manager singleton cannot be destroyed until all editors that use it are destroyed.
   *
   * @param editor The editor the manager was created for.
   */
  destroy(e) {
    const t = e.ui.view && e.ui.view.body;
    mn._editors.delete(e), this.stopListening(e.ui), t && t.has(this.balloonPanelView) && t.remove(this.balloonPanelView), mn._editors.size || (this._unpinTooltip(), this.balloonPanelView.destroy(), this.stopListening(), mn._instance = null);
  }
  /**
   * Returns {@link #balloonPanelView} {@link module:utils/dom/position~PositioningFunction positioning functions} for a given position
   * name.
   *
   * @param position Name of the position (`s`, `se`, `sw`, `n`, `e`, or `w`).
   * @returns Positioning functions to be used by the {@link #balloonPanelView}.
   */
  static getPositioningFunctions(e) {
    const t = mn.defaultBalloonPositions;
    return {
      // South is most popular. We can use positioning heuristics to avoid clipping by the viewport with the sane fallback.
      s: [
        t.southArrowNorth,
        t.southArrowNorthEast,
        t.southArrowNorthWest
      ],
      n: [t.northArrowSouth],
      e: [t.eastArrowWest],
      w: [t.westArrowEast],
      sw: [t.southArrowNorthEast],
      se: [t.southArrowNorthWest]
    }[e];
  }
  /**
   * Handles displaying tooltips on `mouseenter` and `focus` in DOM.
   *
   * @param evt An object containing information about the fired event.
   * @param domEvent The DOM event.
   */
  _onEnterOrFocus(e, { target: t }) {
    const n = km(t);
    n && n !== this._currentElementWithTooltip && (this._unpinTooltip(), this._pinTooltipDebounced(n, D9(n)));
  }
  /**
   * Handles hiding tooltips on `mouseleave` and `blur` in DOM.
   *
   * @param evt An object containing information about the fired event.
   * @param domEvent The DOM event.
   */
  _onLeaveOrBlur(e, { target: t, relatedTarget: n }) {
    if (e.name === "mouseleave") {
      if (!Dr(t) || this._currentElementWithTooltip && t !== this._currentElementWithTooltip)
        return;
      const r = km(t), s = km(n);
      r && r !== s && this._unpinTooltip();
    } else {
      if (this._currentElementWithTooltip && t !== this._currentElementWithTooltip)
        return;
      this._unpinTooltip();
    }
  }
  /**
   * Handles hiding tooltips on `scroll` in DOM.
   *
   * @param evt An object containing information about the fired event.
   * @param domEvent The DOM event.
   */
  _onScroll(e, { target: t }) {
    this._currentElementWithTooltip && (t.contains(this.balloonPanelView.element) && t.contains(this._currentElementWithTooltip) || this._unpinTooltip());
  }
  /**
   * Pins the tooltip to a specific DOM element.
   *
   * @param options.text Text of the tooltip to display.
   * @param options.position The position of the tooltip.
   * @param options.cssClass Additional CSS class of the balloon with the tooltip.
   */
  _pinTooltip(e, { text: t, position: n, cssClass: r }) {
    const s = Rn(mn._editors.values()).ui.view.body;
    s.has(this.balloonPanelView) || s.add(this.balloonPanelView), this.tooltipTextView.text = t, this.balloonPanelView.pin({
      target: e,
      positions: mn.getPositioningFunctions(n)
    }), this._resizeObserver = new xt(e, () => {
      $s(e) || this._unpinTooltip();
    }), this.balloonPanelView.class = [Bb, r].filter((o) => o).join(" ");
    for (const o of mn._editors)
      this.listenTo(o.ui, "update", this._updateTooltipPosition.bind(this), { priority: "low" });
    this._currentElementWithTooltip = e, this._currentTooltipPosition = n;
  }
  /**
   * Unpins the tooltip and cancels all queued pinning.
   */
  _unpinTooltip() {
    this._pinTooltipDebounced.cancel(), this.balloonPanelView.unpin();
    for (const e of mn._editors)
      this.stopListening(e.ui, "update");
    this._currentElementWithTooltip = null, this._currentTooltipPosition = null, this._resizeObserver && this._resizeObserver.destroy();
  }
  /**
   * Updates the position of the tooltip so it stays in sync with the element it is pinned to.
   *
   * Hides the tooltip when the element is no longer visible in DOM.
   */
  _updateTooltipPosition() {
    if (!$s(this._currentElementWithTooltip)) {
      this._unpinTooltip();
      return;
    }
    this.balloonPanelView.pin({
      target: this._currentElementWithTooltip,
      positions: mn.getPositioningFunctions(this._currentTooltipPosition)
    });
  }
}
mn.defaultBalloonPositions = Cp({
  heightOffset: 5,
  sideOffset: 13
});
mn._editors = /* @__PURE__ */ new Set();
mn._instance = null;
function km(i) {
  return Dr(i) ? i.closest("[data-cke-tooltip-text]:not([data-cke-tooltip-disabled])") : null;
}
function D9(i) {
  return {
    text: i.dataset.ckeTooltipText,
    position: i.dataset.ckeTooltipPosition || "s",
    cssClass: i.dataset.ckeTooltipClass || ""
  };
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class ph extends Nt() {
  /**
   * Creates an instance of the editor UI class.
   *
   * @param editor The editor instance.
   */
  constructor(e) {
    super(), this.isReady = !1, this._editableElementsMap = /* @__PURE__ */ new Map(), this._focusableToolbarDefinitions = [], this.editor = e, this.componentFactory = new v9(e), this.focusTracker = new hi(), this.tooltipManager = new mn(e), this.set("viewportOffset", this._readViewportOffsetFromConfig()), this.once("ready", () => {
      this.isReady = !0;
    }), this.listenTo(e.editing.view.document, "layoutChanged", () => this.update()), this._initFocusTracking();
  }
  /**
   * The main (outermost) DOM element of the editor UI.
   *
   * For example, in {@link module:editor-classic/classiceditor~ClassicEditor} it is a `<div>` which
   * wraps the editable element and the toolbar. In {@link module:editor-inline/inlineeditor~InlineEditor}
   * it is the editable element itself (as there is no other wrapper). However, in
   * {@link module:editor-decoupled/decouplededitor~DecoupledEditor} it is set to `null` because this editor does not
   * come with a single "main" HTML element (its editable element and toolbar are separate).
   *
   * This property can be understood as a shorthand for retrieving the element that a specific editor integration
   * considers to be its main DOM element.
   */
  get element() {
    return null;
  }
  /**
   * Fires the {@link module:ui/editorui/editorui~EditorUI#event:update `update`} event.
   *
   * This method should be called when the editor UI (e.g. positions of its balloons) needs to be updated due to
   * some environmental change which CKEditor 5 is not aware of (e.g. resize of a container in which it is used).
   */
  update() {
    this.fire("update");
  }
  /**
   * Destroys the UI.
   */
  destroy() {
    this.stopListening(), this.focusTracker.destroy(), this.tooltipManager.destroy(this.editor);
    for (const e of this._editableElementsMap.values())
      e.ckeditorInstance = null, this.editor.keystrokes.stopListening(e);
    this._editableElementsMap = /* @__PURE__ */ new Map(), this._focusableToolbarDefinitions = [];
  }
  /**
   * Stores the native DOM editable element used by the editor under a unique name.
   *
   * Also, registers the element in the editor to maintain the accessibility of the UI. When the user is editing text in a focusable
   * editable area, they can use the <kbd>Alt</kbd> + <kbd>F10</kbd> keystroke to navigate over editor toolbars. See {@link #addToolbar}.
   *
   * @param rootName The unique name of the editable element.
   * @param domElement The native DOM editable element.
   */
  setEditableElement(e, t) {
    this._editableElementsMap.set(e, t), t.ckeditorInstance || (t.ckeditorInstance = this.editor), this.focusTracker.add(t);
    const n = () => {
      this.editor.editing.view.getDomRoot(e) || this.editor.keystrokes.listenTo(t);
    };
    this.isReady ? n() : this.once("ready", n);
  }
  /**
   * Removes the editable from the editor UI. Removes all handlers added by {@link #setEditableElement}.
   *
   * @param rootName The name of the editable element to remove.
   */
  removeEditableElement(e) {
    const t = this._editableElementsMap.get(e);
    t && (this._editableElementsMap.delete(e), this.editor.keystrokes.stopListening(t), this.focusTracker.remove(t), t.ckeditorInstance = null);
  }
  /**
   * Returns the editable editor element with the given name or null if editable does not exist.
   *
   * @param rootName The editable name.
   */
  getEditableElement(e = "main") {
    return this._editableElementsMap.get(e);
  }
  /**
   * Returns array of names of all editor editable elements.
   */
  getEditableElementsNames() {
    return this._editableElementsMap.keys();
  }
  /**
   * Adds a toolbar to the editor UI. Used primarily to maintain the accessibility of the UI.
   *
   * Focusable toolbars can be accessed (focused) by users by pressing the <kbd>Alt</kbd> + <kbd>F10</kbd> keystroke.
   * Successive keystroke presses navigate over available toolbars.
   *
   * @param toolbarView A instance of the toolbar to be registered.
   */
  addToolbar(e, t = {}) {
    e.isRendered ? (this.focusTracker.add(e.element), this.editor.keystrokes.listenTo(e.element)) : e.once("render", () => {
      this.focusTracker.add(e.element), this.editor.keystrokes.listenTo(e.element);
    }), this._focusableToolbarDefinitions.push({ toolbarView: e, options: t });
  }
  /**
   * Stores all editable elements used by the editor instance.
   *
   * @deprecated
   */
  get _editableElements() {
    return console.warn("editor-ui-deprecated-editable-elements: The EditorUI#_editableElements property has been deprecated and will be removed in the near future.", { editorUI: this }), this._editableElementsMap;
  }
  /**
   * Returns viewport offsets object:
   *
   * ```js
   * {
   * 	top: Number,
   * 	right: Number,
   * 	bottom: Number,
   * 	left: Number
   * }
   * ```
   *
   * Only top property is currently supported.
   */
  _readViewportOffsetFromConfig() {
    const e = this.editor, t = e.config.get("ui.viewportOffset");
    if (t)
      return t;
    const n = e.config.get("toolbar.viewportTopOffset");
    return n ? (console.warn("editor-ui-deprecated-viewport-offset-config: The `toolbar.vieportTopOffset` configuration option is deprecated. It will be removed from future CKEditor versions. Use `ui.viewportOffset.top` instead."), { top: n }) : { top: 0 };
  }
  /**
   * Starts listening for <kbd>Alt</kbd> + <kbd>F10</kbd> and <kbd>Esc</kbd> keystrokes in the context of focusable
   * {@link #setEditableElement editable elements} and {@link #addToolbar toolbars}
   * to allow users navigate across the UI.
   */
  _initFocusTracking() {
    const e = this.editor, t = e.editing.view;
    let n, r;
    e.keystrokes.set("Alt+F10", (s, o) => {
      const l = this.focusTracker.focusedElement;
      Array.from(this._editableElementsMap.values()).includes(l) && !Array.from(t.domRoots.values()).includes(l) && (n = l);
      const u = this._getCurrentFocusedToolbarDefinition();
      (!u || !r) && (r = this._getFocusableCandidateToolbarDefinitions());
      for (let h = 0; h < r.length; h++) {
        const f = r.shift();
        if (r.push(f), f !== u && this._focusFocusableCandidateToolbar(f)) {
          u && u.options.afterBlur && u.options.afterBlur();
          break;
        }
      }
      o();
    }), e.keystrokes.set("Esc", (s, o) => {
      const l = this._getCurrentFocusedToolbarDefinition();
      l && (n ? (n.focus(), n = null) : e.editing.view.focus(), l.options.afterBlur && l.options.afterBlur(), o());
    });
  }
  /**
   * Returns definitions of toolbars that could potentially be focused, sorted by their importance for the user.
   *
   * Focusable toolbars candidates are either:
   * * already visible,
   * * have `beforeFocus()` set in their {@link module:ui/editorui/editorui~FocusableToolbarDefinition definition} that suggests that
   * they might show up when called. Keep in mind that determining whether a toolbar will show up (and become focusable) is impossible
   * at this stage because it depends on its implementation, that in turn depends on the editing context (selection).
   *
   * **Note**: Contextual toolbars take precedence over regular toolbars.
   */
  _getFocusableCandidateToolbarDefinitions() {
    const e = [];
    for (const t of this._focusableToolbarDefinitions) {
      const { toolbarView: n, options: r } = t;
      ($s(n.element) || r.beforeFocus) && e.push(t);
    }
    return e.sort((t, n) => Vb(t) - Vb(n)), e;
  }
  /**
   * Returns a definition of the toolbar that is currently visible and focused (one of its children has focus).
   *
   * `null` is returned when no toolbar is currently focused.
   */
  _getCurrentFocusedToolbarDefinition() {
    for (const e of this._focusableToolbarDefinitions)
      if (e.toolbarView.element && e.toolbarView.element.contains(this.focusTracker.focusedElement))
        return e;
    return null;
  }
  /**
   * Focuses a focusable toolbar candidate using its definition.
   *
   * @param candidateToolbarDefinition A definition of the toolbar to focus.
   * @returns `true` when the toolbar candidate was focused. `false` otherwise.
   */
  _focusFocusableCandidateToolbar(e) {
    const { toolbarView: t, options: { beforeFocus: n } } = e;
    return n && n(), $s(t.element) ? (t.focus(), !0) : !1;
  }
}
function Vb(i) {
  const { toolbarView: e, options: t } = i;
  let n = 10;
  return $s(e.element) && n--, t.isContextual && n--, n;
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class _h extends Xe {
  /**
   * Creates an instance of the editor UI view class.
   *
   * @param locale The locale instance.
   */
  constructor(e) {
    super(e), this.body = new _9(e);
  }
  /**
   * @inheritDoc
   */
  render() {
    super.render(), this.body.attachToDom();
  }
  /**
   * @inheritDoc
   */
  destroy() {
    return this.body.detachFromDom(), super.destroy();
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class NC extends Xe {
  /**
   * @inheritDoc
   */
  constructor(e) {
    super(e), this.set("text", void 0), this.set("for", void 0), this.id = `ck-editor__label_${Rr()}`;
    const t = this.bindTemplate;
    this.setTemplate({
      tag: "label",
      attributes: {
        class: [
          "ck",
          "ck-label"
        ],
        id: this.id,
        for: t.to("for")
      },
      children: [
        {
          text: t.to("text")
        }
      ]
    });
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class B9 extends _h {
  /**
   * Creates an instance of the boxed editor UI view class.
   *
   * @param locale The locale instance..
   */
  constructor(e) {
    super(e), this.top = this.createCollection(), this.main = this.createCollection(), this._voiceLabelView = this._createVoiceLabel(), this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-reset",
          "ck-editor",
          "ck-rounded-corners"
        ],
        role: "application",
        dir: e.uiLanguageDirection,
        lang: e.uiLanguage,
        "aria-labelledby": this._voiceLabelView.id
      },
      children: [
        this._voiceLabelView,
        {
          tag: "div",
          attributes: {
            class: [
              "ck",
              "ck-editor__top",
              "ck-reset_all"
            ],
            role: "presentation"
          },
          children: this.top
        },
        {
          tag: "div",
          attributes: {
            class: [
              "ck",
              "ck-editor__main"
            ],
            role: "presentation"
          },
          children: this.main
        }
      ]
    });
  }
  /**
   * Creates a voice label view instance.
   */
  _createVoiceLabel() {
    const e = this.t, t = new NC();
    return t.text = e("Rich Text Editor"), t.extendTemplate({
      attributes: {
        class: "ck-voice-label"
      }
    }), t;
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class V9 extends Xe {
  /**
   * Creates an instance of EditableUIView class.
   *
   * @param locale The locale instance.
   * @param editingView The editing view instance the editable is related to.
   * @param editableElement The editable element. If not specified, this view
   * should create it. Otherwise, the existing element should be used.
   */
  constructor(e, t, n) {
    super(e), this.name = null, this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-content",
          "ck-editor__editable",
          "ck-rounded-corners"
        ],
        lang: e.contentLanguage,
        dir: e.contentLanguageDirection
      }
    }), this.set("isFocused", !1), this._editableElement = n, this._hasExternalElement = !!this._editableElement, this._editingView = t;
  }
  /**
   * Renders the view by either applying the {@link #template} to the existing
   * {@link module:ui/editableui/editableuiview~EditableUIView#_editableElement} or assigning {@link #element}
   * as {@link module:ui/editableui/editableuiview~EditableUIView#_editableElement}.
   */
  render() {
    super.render(), this._hasExternalElement ? this.template.apply(this.element = this._editableElement) : this._editableElement = this.element, this.on("change:isFocused", () => this._updateIsFocusedClasses()), this._updateIsFocusedClasses();
  }
  /**
   * @inheritDoc
   */
  destroy() {
    this._hasExternalElement && this.template.revert(this._editableElement), super.destroy();
  }
  /**
   * Whether an external {@link #_editableElement} was passed into the constructor, which also means
   * the view will not render its {@link #template}.
   */
  get hasExternalElement() {
    return this._hasExternalElement;
  }
  /**
   * Updates the `ck-focused` and `ck-blurred` CSS classes on the {@link #element} according to
   * the {@link #isFocused} property value using the {@link #_editingView editing view} API.
   */
  _updateIsFocusedClasses() {
    const e = this._editingView;
    e.isRenderingInProgress ? n(this) : t(this);
    function t(r) {
      e.change((s) => {
        const o = e.document.getRoot(r.name);
        s.addClass(r.isFocused ? "ck-focused" : "ck-blurred", o), s.removeClass(r.isFocused ? "ck-blurred" : "ck-focused", o);
      });
    }
    function n(r) {
      e.once("change:isRenderingInProgress", (s, o, l) => {
        l ? n(r) : t(r);
      });
    }
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class vh extends V9 {
  /**
   * Creates an instance of the InlineEditableUIView class.
   *
   * @param locale The locale instance.
   * @param editingView The editing view instance the editable is related to.
   * @param editableElement The editable element. If not specified, the
   * {@link module:ui/editableui/editableuiview~EditableUIView}
   * will create it. Otherwise, the existing element will be used.
   * @param options Additional configuration of the view.
   * @param options.label A function that gets called with the instance of this view as an argument
   * and should return a string that represents the label of the editable for assistive technologies. If not provided,
   * a default label generator is used.
   */
  constructor(e, t, n, r = {}) {
    super(e, t, n);
    const s = e.t;
    this.extendTemplate({
      attributes: {
        role: "textbox",
        class: "ck-editor__editable_inline"
      }
    }), this._generateLabel = r.label || (() => s("Editor editing area: %0", this.name));
  }
  /**
   * @inheritDoc
   */
  render() {
    super.render();
    const e = this._editingView;
    e.change((t) => {
      const n = e.document.getRoot(this.name);
      t.setAttribute("aria-label", this._generateLabel(this), n);
    });
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class DC extends Xe {
  /**
   * @inheritDoc
   */
  constructor(e) {
    super(e), this.set("value", void 0), this.set("id", void 0), this.set("placeholder", void 0), this.set("isReadOnly", !1), this.set("hasError", !1), this.set("ariaDescribedById", void 0), this.focusTracker = new hi(), this.bind("isFocused").to(this.focusTracker), this.set("isEmpty", !0), this.set("inputMode", "text");
    const t = this.bindTemplate;
    this.setTemplate({
      tag: "input",
      attributes: {
        class: [
          "ck",
          "ck-input",
          t.if("isFocused", "ck-input_focused"),
          t.if("isEmpty", "ck-input-text_empty"),
          t.if("hasError", "ck-error")
        ],
        id: t.to("id"),
        placeholder: t.to("placeholder"),
        readonly: t.to("isReadOnly"),
        inputmode: t.to("inputMode"),
        "aria-invalid": t.if("hasError", !0),
        "aria-describedby": t.to("ariaDescribedById")
      },
      on: {
        input: t.to((...n) => {
          this.fire("input", ...n), this._updateIsEmpty();
        }),
        change: t.to(this._updateIsEmpty.bind(this))
      }
    });
  }
  /**
   * @inheritDoc
   */
  render() {
    super.render(), this.focusTracker.add(this.element), this._setDomElementValue(this.value), this._updateIsEmpty(), this.on("change:value", (e, t, n) => {
      this._setDomElementValue(n), this._updateIsEmpty();
    });
  }
  /**
   * @inheritDoc
   */
  destroy() {
    super.destroy(), this.focusTracker.destroy();
  }
  /**
   * Moves the focus to the input and selects the value.
   */
  select() {
    this.element.select();
  }
  /**
   * Focuses the input.
   */
  focus() {
    this.element.focus();
  }
  /**
   * Updates the {@link #isEmpty} property value on demand.
   */
  _updateIsEmpty() {
    this.isEmpty = L9(this.element);
  }
  /**
   * Sets the `value` property of the {@link #element DOM element} on demand.
   */
  _setDomElementValue(e) {
    this.element.value = !e && e !== 0 ? "" : e;
  }
}
function L9(i) {
  return !i.value;
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class F9 extends DC {
  /**
   * @inheritDoc
   */
  constructor(e) {
    super(e), this.extendTemplate({
      attributes: {
        type: "text",
        class: [
          "ck-input-text"
        ]
      }
    });
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class $9 extends DC {
  /**
   * Creates an instance of the input number view.
   *
   * @param locale The {@link module:core/editor/editor~Editor#locale} instance.
   * @param options The options of the input.
   * @param options.min The value of the `min` DOM attribute (the lowest accepted value).
   * @param options.max The value of the `max` DOM attribute (the highest accepted value).
   * @param options.step The value of the `step` DOM attribute.
   */
  constructor(e, { min: t, max: n, step: r } = {}) {
    super(e);
    const s = this.bindTemplate;
    this.set("min", t), this.set("max", n), this.set("step", r), this.extendTemplate({
      attributes: {
        type: "number",
        class: [
          "ck-input-number"
        ],
        min: s.to("min"),
        max: s.to("max"),
        step: s.to("step")
      }
    });
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class Sp extends Xe {
  /**
   * Creates an instance of the labeled field view class using a provided creator function
   * that provides the view to be labeled.
   *
   * @param locale The locale instance.
   * @param viewCreator A function that returns a {@link module:ui/view~View}
   * that will be labeled. The following arguments are passed to the creator function:
   *
   * * an instance of the `LabeledFieldView` to allow binding observable properties,
   * * an UID string that connects the {@link #labelView label} and the labeled field view in DOM,
   * * an UID string that connects the {@link #statusView status} and the labeled field view in DOM.
   */
  constructor(e, t) {
    super(e);
    const n = `ck-labeled-field-view-${Rr()}`, r = `ck-labeled-field-view-status-${Rr()}`;
    this.fieldView = t(this, n, r), this.set("label", void 0), this.set("isEnabled", !0), this.set("isEmpty", !0), this.set("isFocused", !1), this.set("errorText", null), this.set("infoText", null), this.set("class", void 0), this.set("placeholder", void 0), this.labelView = this._createLabelView(n), this.statusView = this._createStatusView(r), this.fieldWrapperChildren = this.createCollection([this.fieldView, this.labelView]), this.bind("_statusText").to(this, "errorText", this, "infoText", (o, l) => o || l);
    const s = this.bindTemplate;
    this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-labeled-field-view",
          s.to("class"),
          s.if("isEnabled", "ck-disabled", (o) => !o),
          s.if("isEmpty", "ck-labeled-field-view_empty"),
          s.if("isFocused", "ck-labeled-field-view_focused"),
          s.if("placeholder", "ck-labeled-field-view_placeholder"),
          s.if("errorText", "ck-error")
        ]
      },
      children: [
        {
          tag: "div",
          attributes: {
            class: [
              "ck",
              "ck-labeled-field-view__input-wrapper"
            ]
          },
          children: this.fieldWrapperChildren
        },
        this.statusView
      ]
    });
  }
  /**
   * Creates label view class instance and bind with view.
   *
   * @param id Unique id to set as labelView#for attribute.
   */
  _createLabelView(e) {
    const t = new NC(this.locale);
    return t.for = e, t.bind("text").to(this, "label"), t;
  }
  /**
   * Creates the status view instance. It displays {@link #errorText} and {@link #infoText}
   * next to the {@link #fieldView}. See {@link #_statusText}.
   *
   * @param statusUid Unique id of the status, shared with the {@link #fieldView view's}
   * `aria-describedby` attribute.
   */
  _createStatusView(e) {
    const t = new Xe(this.locale), n = this.bindTemplate;
    return t.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-labeled-field-view__status",
          n.if("errorText", "ck-labeled-field-view__status_error"),
          n.if("_statusText", "ck-hidden", (r) => !r)
        ],
        id: e,
        role: n.if("errorText", "alert")
      },
      children: [
        {
          text: n.to("_statusText")
        }
      ]
    }), t;
  }
  /**
   * Focuses the {@link #fieldView}.
   */
  focus() {
    this.fieldView.focus();
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function BC(i, e, t) {
  const n = new F9(i.locale);
  return n.set({
    id: e,
    ariaDescribedById: t
  }), n.bind("isReadOnly").to(i, "isEnabled", (r) => !r), n.bind("hasError").to(i, "errorText", (r) => !!r), n.on("input", () => {
    i.errorText = null;
  }), i.bind("isEmpty", "isFocused", "placeholder").to(n), n;
}
function z9(i, e, t) {
  const n = new $9(i.locale);
  return n.set({
    id: e,
    ariaDescribedById: t,
    inputMode: "numeric"
  }), n.bind("isReadOnly").to(i, "isEnabled", (r) => !r), n.bind("hasError").to(i, "errorText", (r) => !!r), n.on("input", () => {
    i.errorText = null;
  }), i.bind("isEmpty", "isFocused", "placeholder").to(n), n;
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class VC extends Nt() {
  /**
   * Creates a new Model instance.
   *
   * @param attributes The model state attributes to be defined during the instance creation.
   * @param properties The (out of state) properties to be appended to the instance during creation.
   */
  constructor(e, t) {
    super(), t && Ly(this, t), e && this.set(e);
  }
}
const W9 = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M11.463 5.187a.888.888 0 1 1 1.254 1.255L9.16 10l3.557 3.557a.888.888 0 1 1-1.254 1.255L7.26 10.61a.888.888 0 0 1 .16-1.382l4.043-4.042z"/></svg>', j9 = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M8.537 14.813a.888.888 0 1 1-1.254-1.255L10.84 10 7.283 6.442a.888.888 0 1 1 1.254-1.255L12.74 9.39a.888.888 0 0 1-.16 1.382l-4.043 4.042z"/></svg>';
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const Hu = $l("px");
class qo extends fe {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "ContextualBalloon";
  }
  /**
   * @inheritDoc
   */
  constructor(e) {
    super(e), this._viewToStack = /* @__PURE__ */ new Map(), this._idToStack = /* @__PURE__ */ new Map(), this._view = null, this._rotatorView = null, this._fakePanelsView = null, this.positionLimiter = () => {
      const t = this.editor.editing.view, r = t.document.selection.editableElement;
      return r ? t.domConverter.mapViewToDom(r.root) : null;
    }, this.set("visibleView", null), this.set("_numberOfStacks", 0), this.set("_singleViewMode", !1);
  }
  /**
   * @inheritDoc
   */
  destroy() {
    super.destroy(), this._view && this._view.destroy(), this._rotatorView && this._rotatorView.destroy(), this._fakePanelsView && this._fakePanelsView.destroy();
  }
  /**
   * The common balloon panel view.
   */
  get view() {
    return this._view || this._createPanelView(), this._view;
  }
  /**
   * Returns `true` when the given view is in one of the stacks. Otherwise returns `false`.
   */
  hasView(e) {
    return Array.from(this._viewToStack.keys()).includes(e);
  }
  /**
   * Adds a new view to the stack and makes it visible if the current stack is visible
   * or it is the first view in the balloon.
   *
   * @param data The configuration of the view.
   * @param data.stackId The ID of the stack that the view is added to. Defaults to `'main'`.
   * @param data.view The content of the balloon.
   * @param data.position Positioning options.
   * @param data.balloonClassName An additional CSS class added to the {@link #view balloon} when visible.
   * @param data.withArrow Whether the {@link #view balloon} should be rendered with an arrow. Defaults to `true`.
   * @param data.singleViewMode Whether the view should be the only visible view even if other stacks were added. Defaults to `false`.
   */
  add(e) {
    if (this._view || this._createPanelView(), this.hasView(e.view))
      throw new B("contextualballoon-add-view-exist", [this, e]);
    const t = e.stackId || "main";
    if (!this._idToStack.has(t)) {
      this._idToStack.set(t, /* @__PURE__ */ new Map([[e.view, e]])), this._viewToStack.set(e.view, this._idToStack.get(t)), this._numberOfStacks = this._idToStack.size, (!this._visibleStack || e.singleViewMode) && this.showStack(t);
      return;
    }
    const n = this._idToStack.get(t);
    e.singleViewMode && this.showStack(t), n.set(e.view, e), this._viewToStack.set(e.view, n), n === this._visibleStack && this._showView(e);
  }
  /**
   * Removes the given view from the stack. If the removed view was visible,
   * the view preceding it in the stack will become visible instead.
   * When there is no view in the stack, the next stack will be displayed.
   * When there are no more stacks, the balloon will hide.
   *
   * @param view A view to be removed from the balloon.
   */
  remove(e) {
    if (!this.hasView(e))
      throw new B("contextualballoon-remove-view-not-exist", [this, e]);
    const t = this._viewToStack.get(e);
    this._singleViewMode && this.visibleView === e && (this._singleViewMode = !1), this.visibleView === e && (t.size === 1 ? this._idToStack.size > 1 ? this._showNextStack() : (this.view.hide(), this.visibleView = null, this._rotatorView.hideView()) : this._showView(Array.from(t.values())[t.size - 2])), t.size === 1 ? (this._idToStack.delete(this._getStackId(t)), this._numberOfStacks = this._idToStack.size) : t.delete(e), this._viewToStack.delete(e);
  }
  /**
   * Updates the position of the balloon using the position data of the first visible view in the stack.
   * When new position data is given, the position data of the currently visible view will be updated.
   *
   * @param position Position options.
   */
  updatePosition(e) {
    e && (this._visibleStack.get(this.visibleView).position = e), this.view.pin(this._getBalloonPosition()), this._fakePanelsView.updatePosition();
  }
  /**
   * Shows the last view from the stack of a given ID.
   */
  showStack(e) {
    this.visibleStack = e;
    const t = this._idToStack.get(e);
    if (!t)
      throw new B("contextualballoon-showstack-stack-not-exist", this);
    this._visibleStack !== t && this._showView(Array.from(t.values()).pop());
  }
  /**
   * Initializes view instances.
   */
  _createPanelView() {
    this._view = new gn(this.editor.locale), this.editor.ui.view.body.add(this._view), this.editor.ui.focusTracker.add(this._view.element), this._rotatorView = this._createRotatorView(), this._fakePanelsView = this._createFakePanelsView();
  }
  /**
   * Returns the stack of the currently visible view.
   */
  get _visibleStack() {
    return this._viewToStack.get(this.visibleView);
  }
  /**
   * Returns the ID of the given stack.
   */
  _getStackId(e) {
    return Array.from(this._idToStack.entries()).find((n) => n[1] === e)[0];
  }
  /**
   * Shows the last view from the next stack.
   */
  _showNextStack() {
    const e = Array.from(this._idToStack.values());
    let t = e.indexOf(this._visibleStack) + 1;
    e[t] || (t = 0), this.showStack(this._getStackId(e[t]));
  }
  /**
   * Shows the last view from the previous stack.
   */
  _showPrevStack() {
    const e = Array.from(this._idToStack.values());
    let t = e.indexOf(this._visibleStack) - 1;
    e[t] || (t = e.length - 1), this.showStack(this._getStackId(e[t]));
  }
  /**
   * Creates a rotator view.
   */
  _createRotatorView() {
    const e = new U9(this.editor.locale), t = this.editor.locale.t;
    return this.view.content.add(e), e.bind("isNavigationVisible").to(this, "_numberOfStacks", this, "_singleViewMode", (n, r) => !r && n > 1), e.on("change:isNavigationVisible", () => this.updatePosition(), { priority: "low" }), e.bind("counter").to(this, "visibleView", this, "_numberOfStacks", (n, r) => {
      if (r < 2)
        return "";
      const s = Array.from(this._idToStack.values()).indexOf(this._visibleStack) + 1;
      return t("%0 of %1", [s, r]);
    }), e.buttonNextView.on("execute", () => {
      e.focusTracker.isFocused && this.editor.editing.view.focus(), this._showNextStack();
    }), e.buttonPrevView.on("execute", () => {
      e.focusTracker.isFocused && this.editor.editing.view.focus(), this._showPrevStack();
    }), e;
  }
  /**
   * Creates a fake panels view.
   */
  _createFakePanelsView() {
    const e = new H9(this.editor.locale, this.view);
    return e.bind("numberOfPanels").to(this, "_numberOfStacks", this, "_singleViewMode", (t, n) => !n && t >= 2 ? Math.min(t - 1, 2) : 0), e.listenTo(this.view, "change:top", () => e.updatePosition()), e.listenTo(this.view, "change:left", () => e.updatePosition()), this.editor.ui.view.body.add(e), e;
  }
  /**
   * Sets the view as the content of the balloon and attaches the balloon using position
   * options of the first view.
   *
   * @param data Configuration.
   * @param data.view The view to show in the balloon.
   * @param data.balloonClassName Additional class name which will be added to the {@link #view balloon}.
   * @param data.withArrow Whether the {@link #view balloon} should be rendered with an arrow.
   */
  _showView({ view: e, balloonClassName: t = "", withArrow: n = !0, singleViewMode: r = !1 }) {
    this.view.class = t, this.view.withArrow = n, this._rotatorView.showView(e), this.visibleView = e, this.view.pin(this._getBalloonPosition()), this._fakePanelsView.updatePosition(), r && (this._singleViewMode = !0);
  }
  /**
   * Returns position options of the last view in the stack.
   * This keeps the balloon in the same position when the view is changed.
   */
  _getBalloonPosition() {
    let e = Array.from(this._visibleStack.values()).pop().position;
    return e && (e.limiter || (e = Object.assign({}, e, {
      limiter: this.positionLimiter
    })), e = Object.assign({}, e, {
      viewportOffsetConfig: this.editor.ui.viewportOffset
    })), e;
  }
}
class U9 extends Xe {
  /**
   * @inheritDoc
   */
  constructor(e) {
    super(e);
    const t = e.t, n = this.bindTemplate;
    this.set("isNavigationVisible", !0), this.focusTracker = new hi(), this.buttonPrevView = this._createButtonView(t("Previous"), W9), this.buttonNextView = this._createButtonView(t("Next"), j9), this.content = this.createCollection(), this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-balloon-rotator"
        ],
        "z-index": "-1"
      },
      children: [
        {
          tag: "div",
          attributes: {
            class: [
              "ck-balloon-rotator__navigation",
              n.to("isNavigationVisible", (r) => r ? "" : "ck-hidden")
            ]
          },
          children: [
            this.buttonPrevView,
            {
              tag: "span",
              attributes: {
                class: [
                  "ck-balloon-rotator__counter"
                ]
              },
              children: [
                {
                  text: n.to("counter")
                }
              ]
            },
            this.buttonNextView
          ]
        },
        {
          tag: "div",
          attributes: {
            class: "ck-balloon-rotator__content"
          },
          children: this.content
        }
      ]
    });
  }
  /**
   * @inheritDoc
   */
  render() {
    super.render(), this.focusTracker.add(this.element);
  }
  /**
   * @inheritDoc
   */
  destroy() {
    super.destroy(), this.focusTracker.destroy();
  }
  /**
   * Shows a given view.
   *
   * @param view The view to show.
   */
  showView(e) {
    this.hideView(), this.content.add(e);
  }
  /**
   * Hides the currently displayed view.
   */
  hideView() {
    this.content.clear();
  }
  /**
   * Creates a navigation button view.
   *
   * @param label The button label.
   * @param icon The button icon.
   */
  _createButtonView(e, t) {
    const n = new At(this.locale);
    return n.set({
      label: e,
      icon: t,
      tooltip: !0
    }), n;
  }
}
class H9 extends Xe {
  /**
   * @inheritDoc
   */
  constructor(e, t) {
    super(e);
    const n = this.bindTemplate;
    this.set("top", 0), this.set("left", 0), this.set("height", 0), this.set("width", 0), this.set("numberOfPanels", 0), this.content = this.createCollection(), this._balloonPanelView = t, this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck-fake-panel",
          n.to("numberOfPanels", (r) => r ? "" : "ck-hidden")
        ],
        style: {
          top: n.to("top", Hu),
          left: n.to("left", Hu),
          width: n.to("width", Hu),
          height: n.to("height", Hu)
        }
      },
      children: this.content
    }), this.on("change:numberOfPanels", (r, s, o, l) => {
      o > l ? this._addPanels(o - l) : this._removePanels(l - o), this.updatePosition();
    });
  }
  _addPanels(e) {
    for (; e--; ) {
      const t = new Xe();
      t.setTemplate({ tag: "div" }), this.content.add(t), this.registerChild(t);
    }
  }
  _removePanels(e) {
    for (; e--; ) {
      const t = this.content.last;
      this.content.remove(t), this.deregisterChild(t), t.destroy();
    }
  }
  /**
   * Updates coordinates of fake panels.
   */
  updatePosition() {
    if (this.numberOfPanels) {
      const { top: e, left: t } = this._balloonPanelView, { width: n, height: r } = new pt(this._balloonPanelView.element);
      Object.assign(this, { top: e, left: t, width: n, height: r });
    }
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const Xa = $l("px");
class q9 extends Xe {
  /**
   * @inheritDoc
   */
  constructor(e) {
    super(e);
    const t = this.bindTemplate;
    this.set("isActive", !1), this.set("isSticky", !1), this.set("limiterElement", null), this.set("limiterBottomOffset", 50), this.set("viewportTopOffset", 0), this.set("_marginLeft", null), this.set("_isStickyToTheLimiter", !1), this.set("_hasViewportTopOffset", !1), this.content = this.createCollection(), this._contentPanelPlaceholder = new Li({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-sticky-panel__placeholder"
        ],
        style: {
          display: t.to("isSticky", (n) => n ? "block" : "none"),
          height: t.to("isSticky", (n) => n ? Xa(this._panelRect.height) : null)
        }
      }
    }).render(), this._contentPanel = new Li({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-sticky-panel__content",
          // Toggle class of the panel when "sticky" state changes in the view.
          t.if("isSticky", "ck-sticky-panel__content_sticky"),
          t.if("_isStickyToTheLimiter", "ck-sticky-panel__content_sticky_bottom-limit")
        ],
        style: {
          width: t.to("isSticky", (n) => n ? Xa(this._contentPanelPlaceholder.getBoundingClientRect().width) : null),
          top: t.to("_hasViewportTopOffset", (n) => n ? Xa(this.viewportTopOffset) : null),
          bottom: t.to("_isStickyToTheLimiter", (n) => n ? Xa(this.limiterBottomOffset) : null),
          marginLeft: t.to("_marginLeft")
        }
      },
      children: this.content
    }).render(), this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-sticky-panel"
        ]
      },
      children: [
        this._contentPanelPlaceholder,
        this._contentPanel
      ]
    });
  }
  /**
   * @inheritDoc
   */
  render() {
    super.render(), this._checkIfShouldBeSticky(), this.listenTo(Ke.window, "scroll", () => {
      this._checkIfShouldBeSticky();
    }), this.listenTo(this, "change:isActive", () => {
      this._checkIfShouldBeSticky();
    });
  }
  /**
   * Analyzes the environment to decide whether the panel should
   * be sticky or not.
   */
  _checkIfShouldBeSticky() {
    const e = this._panelRect = this._contentPanel.getBoundingClientRect();
    let t;
    this.limiterElement ? (t = this._limiterRect = this.limiterElement.getBoundingClientRect(), this.isSticky = this.isActive && // The limiter's top edge must be beyond the upper edge of the visible viewport (+the viewportTopOffset).
    t.top < this.viewportTopOffset && // The model#limiterElement's height mustn't be smaller than the panel's height and model#limiterBottomOffset.
    // There's no point in entering the sticky mode if the model#limiterElement is very, very small, because
    // it would immediately set model#_isStickyToTheLimiter true and, given model#limiterBottomOffset, the panel
    // would be positioned before the model#limiterElement.
    this._panelRect.height + this.limiterBottomOffset < t.height) : this.isSticky = !1, this.isSticky ? (this._isStickyToTheLimiter = t.bottom < e.height + this.limiterBottomOffset + this.viewportTopOffset, this._hasViewportTopOffset = !this._isStickyToTheLimiter && !!this.viewportTopOffset, this._marginLeft = this._isStickyToTheLimiter ? null : Xa(-Ke.window.scrollX)) : (this._isStickyToTheLimiter = !1, this._hasViewportTopOffset = !1, this._marginLeft = null);
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const K9 = $l("px");
class G9 extends fe {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "BalloonToolbar";
  }
  /**
   * @inheritDoc
   */
  static get requires() {
    return [qo];
  }
  /**
   * @inheritDoc
   */
  constructor(e) {
    super(e), this._resizeObserver = null, this._balloonConfig = mh(e.config.get("balloonToolbar")), this.toolbarView = this._createToolbarView(), this.focusTracker = new hi(), e.ui.once("ready", () => {
      this.focusTracker.add(e.ui.getEditableElement()), this.focusTracker.add(this.toolbarView.element);
    }), e.ui.addToolbar(this.toolbarView, {
      beforeFocus: () => this.show(!0),
      afterBlur: () => this.hide(),
      isContextual: !0
    }), this._balloon = e.plugins.get(qo), this._fireSelectionChangeDebounced = $o(() => this.fire("_selectionChangeDebounced"), 200), this.decorate("show");
  }
  /**
   * @inheritDoc
   */
  init() {
    const e = this.editor, t = e.model.document.selection;
    this.listenTo(this.focusTracker, "change:isFocused", (n, r, s) => {
      const o = this._balloon.visibleView === this.toolbarView;
      !s && o ? this.hide() : s && this.show();
    }), this.listenTo(t, "change:range", (n, r) => {
      (r.directChange || t.isCollapsed) && this.hide(), this._fireSelectionChangeDebounced();
    }), this.listenTo(this, "_selectionChangeDebounced", () => {
      this.editor.editing.view.document.isFocused && this.show();
    }), this._balloonConfig.shouldNotGroupWhenFull || this.listenTo(e, "ready", () => {
      const n = e.ui.view.editable.element;
      this._resizeObserver = new xt(n, (r) => {
        this.toolbarView.maxWidth = K9(r.contentRect.width * 0.9);
      });
    }), this.listenTo(this.toolbarView, "groupedItemsUpdate", () => {
      this._updatePosition();
    });
  }
  /**
   * Creates toolbar components based on given configuration.
   * This needs to be done when all plugins are ready.
   */
  afterInit() {
    const e = this.editor.ui.componentFactory;
    this.toolbarView.fillFromConfig(this._balloonConfig, e);
  }
  /**
   * Creates the toolbar view instance.
   */
  _createToolbarView() {
    const e = this.editor.locale.t, t = !this._balloonConfig.shouldNotGroupWhenFull, n = new na(this.editor.locale, {
      shouldGroupWhenFull: t,
      isFloating: !0
    });
    return n.ariaLabel = e("Editor contextual toolbar"), n.render(), n;
  }
  /**
   * Shows the toolbar and attaches it to the selection.
   *
   * Fires {@link #event:show} event which can be stopped to prevent the toolbar from showing up.
   *
   * @param showForCollapsedSelection When set `true`, the toolbar will show despite collapsed selection in the
   * editing view.
   */
  show(e = !1) {
    const t = this.editor, n = t.model.document.selection, r = t.model.schema;
    this._balloon.hasView(this.toolbarView) || n.isCollapsed && !e || Y9(n, r) || Array.from(this.toolbarView.items).every((s) => s.isEnabled !== void 0 && !s.isEnabled) || (this.listenTo(this.editor.ui, "update", () => {
      this._updatePosition();
    }), this._balloon.add({
      view: this.toolbarView,
      position: this._getBalloonPositionData(),
      balloonClassName: "ck-toolbar-container"
    }));
  }
  /**
   * Hides the toolbar.
   */
  hide() {
    this._balloon.hasView(this.toolbarView) && (this.stopListening(this.editor.ui, "update"), this._balloon.remove(this.toolbarView));
  }
  /**
   * Returns positioning options for the {@link #_balloon}. They control the way balloon is attached
   * to the selection.
   */
  _getBalloonPositionData() {
    const t = this.editor.editing.view, n = t.document, r = n.selection, s = n.selection.isBackward;
    return {
      // Because the target for BalloonPanelView is a Rect (not DOMRange), it's geometry will stay fixed
      // as the window scrolls. To let the BalloonPanelView follow such Rect, is must be continuously
      // computed and hence, the target is defined as a function instead of a static value.
      // https://github.com/ckeditor/ckeditor5-ui/issues/195
      target: () => {
        const o = s ? r.getFirstRange() : r.getLastRange(), l = pt.getDomRangeRects(t.domConverter.viewRangeToDom(o));
        return s ? l[0] : (l.length > 1 && l[l.length - 1].width === 0 && l.pop(), l[l.length - 1]);
      },
      positions: this._getBalloonPositions(s)
    };
  }
  /**
   * Updates the position of the {@link #_balloon} to make up for changes:
   *
   * * in the geometry of the selection it is attached to (e.g. the selection moved in the viewport or expanded or shrunk),
   * * or the geometry of the balloon toolbar itself (e.g. the toolbar has grouped or ungrouped some items and it is shorter or longer).
   */
  _updatePosition() {
    this._balloon.updatePosition(this._getBalloonPositionData());
  }
  /**
   * @inheritDoc
   */
  destroy() {
    super.destroy(), this.stopListening(), this._fireSelectionChangeDebounced.cancel(), this.toolbarView.destroy(), this.focusTracker.destroy(), this._resizeObserver && this._resizeObserver.destroy();
  }
  /**
   * Returns toolbar positions for the given direction of the selection.
   */
  _getBalloonPositions(e) {
    const n = qe.isSafari && qe.isiOS ? Cp({
      // 20px when zoomed out. Less then 20px when zoomed in; the "radius" of the native selection handle gets
      // smaller as the user zooms in. No less than the default v-offset, though.
      heightOffset: Math.max(gn.arrowHeightOffset, Math.round(20 / Ke.window.visualViewport.scale))
    }) : gn.defaultPositions;
    return e ? [
      n.northWestArrowSouth,
      n.northWestArrowSouthWest,
      n.northWestArrowSouthEast,
      n.northWestArrowSouthMiddleEast,
      n.northWestArrowSouthMiddleWest,
      n.southWestArrowNorth,
      n.southWestArrowNorthWest,
      n.southWestArrowNorthEast,
      n.southWestArrowNorthMiddleWest,
      n.southWestArrowNorthMiddleEast
    ] : [
      n.southEastArrowNorth,
      n.southEastArrowNorthEast,
      n.southEastArrowNorthWest,
      n.southEastArrowNorthMiddleEast,
      n.southEastArrowNorthMiddleWest,
      n.northEastArrowSouth,
      n.northEastArrowSouthEast,
      n.northEastArrowSouthWest,
      n.northEastArrowSouthMiddleEast,
      n.northEastArrowSouthMiddleWest
    ];
  }
}
function Y9(i, e) {
  return i.rangeCount === 1 ? !1 : [...i.getRanges()].every((t) => {
    const n = t.getContainedElement();
    return n && e.isSelectable(n);
  });
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class LC {
  /**
   * @param {module:watchdog/watchdog~WatchdogConfig} config The watchdog plugin configuration.
   */
  constructor(e) {
    if (this.crashes = [], this.state = "initializing", this._now = Date.now, this.crashes = [], this._crashNumberLimit = typeof e.crashNumberLimit == "number" ? e.crashNumberLimit : 3, this._minimumNonErrorTimePeriod = typeof e.minimumNonErrorTimePeriod == "number" ? e.minimumNonErrorTimePeriod : 5e3, this._boundErrorHandler = (t) => {
      const n = "error" in t ? t.error : t.reason;
      n instanceof Error && this._handleError(n, t);
    }, this._listeners = {}, !this._restart)
      throw new Error("The Watchdog class was split into the abstract `Watchdog` class and the `EditorWatchdog` class. Please, use `EditorWatchdog` if you have used the `Watchdog` class previously.");
  }
  /**
   * Destroys the watchdog and releases the resources.
   */
  destroy() {
    this._stopErrorHandling(), this._listeners = {};
  }
  /**
   * Starts listening to a specific event name by registering a callback that will be executed
   * whenever an event with a given name fires.
   *
   * Note that this method differs from the CKEditor 5's default `EventEmitterMixin` implementation.
   *
   * @param eventName The event name.
   * @param callback A callback which will be added to event listeners.
   */
  on(e, t) {
    this._listeners[e] || (this._listeners[e] = []), this._listeners[e].push(t);
  }
  /**
   * Stops listening to the specified event name by removing the callback from event listeners.
   *
   * Note that this method differs from the CKEditor 5's default `EventEmitterMixin` implementation.
   *
   * @param eventName The event name.
   * @param callback A callback which will be removed from event listeners.
   */
  off(e, t) {
    this._listeners[e] = this._listeners[e].filter((n) => n !== t);
  }
  /**
   * Fires an event with a given event name and arguments.
   *
   * Note that this method differs from the CKEditor 5's default `EventEmitterMixin` implementation.
   */
  _fire(e, ...t) {
    const n = this._listeners[e] || [];
    for (const r of n)
      r.apply(this, [null, ...t]);
  }
  /**
   * Starts error handling by attaching global error handlers.
   */
  _startErrorHandling() {
    window.addEventListener("error", this._boundErrorHandler), window.addEventListener("unhandledrejection", this._boundErrorHandler);
  }
  /**
   * Stops error handling by detaching global error handlers.
   */
  _stopErrorHandling() {
    window.removeEventListener("error", this._boundErrorHandler), window.removeEventListener("unhandledrejection", this._boundErrorHandler);
  }
  /**
   * Checks if an error comes from the watched item and restarts it.
   * It reacts to {@link module:utils/ckeditorerror~CKEditorError `CKEditorError` errors} only.
   *
   * @fires error
   * @param error Error.
   * @param evt An error event.
   */
  _handleError(e, t) {
    if (this._shouldReactToError(e)) {
      this.crashes.push({
        message: e.message,
        stack: e.stack,
        // `evt.filename`, `evt.lineno` and `evt.colno` are available only in ErrorEvent events
        filename: t instanceof ErrorEvent ? t.filename : void 0,
        lineno: t instanceof ErrorEvent ? t.lineno : void 0,
        colno: t instanceof ErrorEvent ? t.colno : void 0,
        date: this._now()
      });
      const n = this._shouldRestart();
      this.state = "crashed", this._fire("stateChange"), this._fire("error", { error: e, causesRestart: n }), n ? this._restart() : (this.state = "crashedPermanently", this._fire("stateChange"));
    }
  }
  /**
   * Checks whether an error should be handled by the watchdog.
   *
   * @param error An error that was caught by the error handling process.
   */
  _shouldReactToError(e) {
    return e.is && e.is("CKEditorError") && e.context !== void 0 && // In some cases the watched item should not be restarted - e.g. during the item initialization.
    // That's why the `null` was introduced as a correct error context which does cause restarting.
    e.context !== null && // Do not react to errors if the watchdog is in states other than `ready`.
    this.state === "ready" && this._isErrorComingFromThisItem(e);
  }
  /**
   * Checks if the watchdog should restart the underlying item.
   */
  _shouldRestart() {
    if (this.crashes.length <= this._crashNumberLimit)
      return !0;
    const e = this.crashes[this.crashes.length - 1].date, t = this.crashes[this.crashes.length - 1 - this._crashNumberLimit].date;
    return (e - t) / this._crashNumberLimit > this._minimumNonErrorTimePeriod;
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function wg(i, e = /* @__PURE__ */ new Set()) {
  const t = [i], n = /* @__PURE__ */ new Set();
  let r = 0;
  for (; t.length > r; ) {
    const s = t[r++];
    if (!(n.has(s) || !J9(s) || e.has(s)))
      if (n.add(s), Symbol.iterator in s)
        try {
          for (const o of s)
            t.push(o);
        } catch {
        }
      else
        for (const o in s)
          o !== "defaultValue" && t.push(s[o]);
  }
  return n;
}
function J9(i) {
  const e = Object.prototype.toString.call(i), t = typeof i;
  return !(t === "number" || t === "boolean" || t === "string" || t === "symbol" || t === "function" || e === "[object Date]" || e === "[object RegExp]" || e === "[object Module]" || i === void 0 || i === null || // This flag is meant to exclude singletons shared across editor instances. So when an error is thrown in one editor,
  // the other editors connected through the reference to the same singleton are not restarted. This is a temporary workaround
  // until a better solution is found.
  // More in https://github.com/ckeditor/ckeditor5/issues/12292.
  i._watchdogExcluded || // Skip native DOM objects, e.g. Window, nodes, events, etc.
  i instanceof EventTarget || i instanceof Event);
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function FC(i, e, t = /* @__PURE__ */ new Set()) {
  if (i === e && X9(i))
    return !0;
  const n = wg(i, t), r = wg(e, t);
  for (const s of n)
    if (r.has(s))
      return !0;
  return !1;
}
function X9(i) {
  return typeof i == "object" && i !== null;
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class Ul extends LC {
  /**
   * @param Editor The editor class.
   * @param watchdogConfig The watchdog plugin configuration.
   */
  constructor(e, t = {}) {
    super(t), this._editor = null, this._throttledSave = tp(this._save.bind(this), typeof t.saveInterval == "number" ? t.saveInterval : 5e3), e && (this._creator = (n, r) => e.create(n, r)), this._destructor = (n) => n.destroy();
  }
  /**
   * The current editor instance.
   */
  get editor() {
    return this._editor;
  }
  /**
   * @internal
   */
  get _item() {
    return this._editor;
  }
  /**
   * Sets the function that is responsible for the editor creation.
   * It expects a function that should return a promise.
   *
   * ```ts
   * watchdog.setCreator( ( element, config ) => ClassicEditor.create( element, config ) );
   * ```
   */
  setCreator(e) {
    this._creator = e;
  }
  /**
   * Sets the function that is responsible for the editor destruction.
   * Overrides the default destruction function, which destroys only the editor instance.
   * It expects a function that should return a promise or `undefined`.
   *
   * ```ts
   * watchdog.setDestructor( editor => {
   * 	// Do something before the editor is destroyed.
   *
   * 	return editor
   * 		.destroy()
   * 		.then( () => {
   * 			// Do something after the editor is destroyed.
   * 		} );
   * } );
   * ```
   */
  setDestructor(e) {
    this._destructor = e;
  }
  /**
   * Restarts the editor instance. This method is called whenever an editor error occurs. It fires the `restart` event and changes
   * the state to `initializing`.
   *
   * @fires restart
   */
  _restart() {
    return Promise.resolve().then(() => (this.state = "initializing", this._fire("stateChange"), this._destroy())).catch((e) => {
      console.error("An error happened during the editor destroying.", e);
    }).then(() => {
      if (typeof this._elementOrData == "string")
        return this.create(this._data, this._config, this._config.context);
      {
        const e = Object.assign({}, this._config, {
          initialData: this._data
        });
        return this.create(this._elementOrData, e, e.context);
      }
    }).then(() => {
      this._fire("restart");
    });
  }
  /**
   * Creates the editor instance and keeps it running, using the defined creator and destructor.
   *
   * @param elementOrData The editor source element or the editor data.
   * @param config The editor configuration.
   * @param context A context for the editor.
   */
  create(e = this._elementOrData, t = this._config, n) {
    return Promise.resolve().then(() => (super._startErrorHandling(), this._elementOrData = e, this._config = this._cloneEditorConfiguration(t) || {}, this._config.context = n, this._creator(e, this._config))).then((r) => {
      this._editor = r, r.model.document.on("change:data", this._throttledSave), this._lastDocumentVersion = r.model.document.version, this._data = this._getData(), this.state = "ready", this._fire("stateChange");
    });
  }
  /**
   * Destroys the watchdog and the current editor instance. It fires the callback
   * registered in {@link #setDestructor `setDestructor()`} and uses it to destroy the editor instance.
   * It also sets the state to `destroyed`.
   */
  destroy() {
    return Promise.resolve().then(() => (this.state = "destroyed", this._fire("stateChange"), super.destroy(), this._destroy()));
  }
  _destroy() {
    return Promise.resolve().then(() => {
      this._stopErrorHandling(), this._throttledSave.flush();
      const e = this._editor;
      return this._editor = null, e.model.document.off("change:data", this._throttledSave), this._destructor(e);
    });
  }
  /**
   * Saves the editor data, so it can be restored after the crash even if the data cannot be fetched at
   * the moment of the crash.
   */
  _save() {
    const e = this._editor.model.document.version;
    try {
      this._data = this._getData(), this._lastDocumentVersion = e;
    } catch (t) {
      console.error(t, "An error happened during restoring editor data. Editor will be restored from the previously saved data.");
    }
  }
  /**
   * @internal
   */
  _setExcludedProperties(e) {
    this._excludedProps = e;
  }
  /**
   * Returns the editor data.
   */
  _getData() {
    const e = {};
    for (const t of this._editor.model.document.getRootNames())
      e[t] = this._editor.data.get({ rootName: t });
    return e;
  }
  /**
   * Traverses the error context and the current editor to find out whether these structures are connected
   * to each other via properties.
   *
   * @internal
   */
  _isErrorComingFromThisItem(e) {
    return FC(this._editor, e.context, this._excludedProps);
  }
  /**
   * Clones the editor configuration.
   */
  _cloneEditorConfiguration(e) {
    return Qg(e, (t, n) => {
      if (Dr(t) || n === "context")
        return t;
    });
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const ml = Symbol("MainQueueId");
class wh extends LC {
  /**
   * The context watchdog class constructor.
   *
   * ```ts
   * const watchdog = new ContextWatchdog( Context );
   *
   * await watchdog.create( contextConfiguration );
   *
   * await watchdog.add( item );
   * ```
   *
   * See the {@glink features/watchdog Watchdog feature guide} to learn more how to use this feature.
   *
   * @param Context The {@link module:core/context~Context} class.
   * @param watchdogConfig The watchdog configuration.
   */
  constructor(e, t = {}) {
    super(t), this._watchdogs = /* @__PURE__ */ new Map(), this._context = null, this._contextProps = /* @__PURE__ */ new Set(), this._actionQueues = new Z9(), this._watchdogConfig = t, this._creator = (n) => e.create(n), this._destructor = (n) => n.destroy(), this._actionQueues.onEmpty(() => {
      this.state === "initializing" && (this.state = "ready", this._fire("stateChange"));
    });
  }
  /**
   * Sets the function that is responsible for the context creation.
   * It expects a function that should return a promise (or `undefined`).
   *
   * ```ts
   * watchdog.setCreator( config => Context.create( config ) );
   * ```
   */
  setCreator(e) {
    this._creator = e;
  }
  /**
   * Sets the function that is responsible for the context destruction.
   * Overrides the default destruction function, which destroys only the context instance.
   * It expects a function that should return a promise (or `undefined`).
   *
   * ```ts
   * watchdog.setDestructor( context => {
   * 	// Do something before the context is destroyed.
   *
   * 	return context
   * 		.destroy()
   * 		.then( () => {
   * 			// Do something after the context is destroyed.
   * 		} );
   * } );
   * ```
   */
  setDestructor(e) {
    this._destructor = e;
  }
  /**
   * The context instance. Keep in mind that this property might be changed when the context watchdog restarts,
   * so do not keep this instance internally. Always operate on the `ContextWatchdog#context` property.
   */
  get context() {
    return this._context;
  }
  /**
   * Initializes the context watchdog. Once it is created, the watchdog takes care about
   * recreating the context and the provided items, and starts the error handling mechanism.
   *
   * ```ts
   * await watchdog.create( {
   * 	plugins: []
   * } );
   * ```
   *
   * @param contextConfig The context configuration. See {@link module:core/context~Context}.
   */
  create(e = {}) {
    return this._actionQueues.enqueue(ml, () => (this._contextConfig = e, this._create()));
  }
  /**
   * Returns an item instance with the given `itemId`.
   *
   * ```ts
   * const editor1 = watchdog.getItem( 'editor1' );
   * ```
   *
   * @param itemId The item ID.
   * @returns The item instance or `undefined` if an item with a given ID has not been found.
   */
  getItem(e) {
    return this._getWatchdog(e)._item;
  }
  /**
   * Gets the state of the given item. See {@link #state} for a list of available states.
   *
   * ```ts
   * const editor1State = watchdog.getItemState( 'editor1' );
   * ```
   *
   * @param itemId Item ID.
   * @returns The state of the item.
   */
  getItemState(e) {
    return this._getWatchdog(e).state;
  }
  /**
   * Adds items to the watchdog. Once created, instances of these items will be available using the {@link #getItem} method.
   *
   * Items can be passed together as an array of objects:
   *
   * ```ts
   * await watchdog.add( [ {
   * 	id: 'editor1',
   * 	type: 'editor',
   * 	sourceElementOrData: document.querySelector( '#editor' ),
   * 	config: {
   * 		plugins: [ Essentials, Paragraph, Bold, Italic ],
   * 		toolbar: [ 'bold', 'italic', 'alignment' ]
   * 	},
   * 	creator: ( element, config ) => ClassicEditor.create( element, config )
   * } ] );
   * ```
   *
   * Or one by one as objects:
   *
   * ```ts
   * await watchdog.add( {
   * 	id: 'editor1',
   * 	type: 'editor',
   * 	sourceElementOrData: document.querySelector( '#editor' ),
   * 	config: {
   * 		plugins: [ Essentials, Paragraph, Bold, Italic ],
   * 		toolbar: [ 'bold', 'italic', 'alignment' ]
   * 	},
   * 	creator: ( element, config ) => ClassicEditor.create( element, config )
   * ] );
   * ```
   *
   * Then an instance can be retrieved using the {@link #getItem} method:
   *
   * ```ts
   * const editor1 = watchdog.getItem( 'editor1' );
   * ```
   *
   * Note that this method can be called multiple times, but for performance reasons it is better
   * to pass all items together.
   *
   * @param itemConfigurationOrItemConfigurations An item configuration object or an array of item configurations.
   */
  add(e) {
    const t = Lb(e);
    return Promise.all(t.map((n) => this._actionQueues.enqueue(n.id, () => {
      if (this.state === "destroyed")
        throw new Error("Cannot add items to destroyed watchdog.");
      if (!this._context)
        throw new Error("Context was not created yet. You should call the `ContextWatchdog#create()` method first.");
      let r;
      if (this._watchdogs.has(n.id))
        throw new Error(`Item with the given id is already added: '${n.id}'.`);
      if (n.type === "editor")
        return r = new Ul(null, this._watchdogConfig), r.setCreator(n.creator), r._setExcludedProperties(this._contextProps), n.destructor && r.setDestructor(n.destructor), this._watchdogs.set(n.id, r), r.on("error", (s, { error: o, causesRestart: l }) => {
          this._fire("itemError", { itemId: n.id, error: o }), l && this._actionQueues.enqueue(n.id, () => new Promise((u) => {
            const h = () => {
              r.off("restart", h), this._fire("itemRestart", { itemId: n.id }), u();
            };
            r.on("restart", h);
          }));
        }), r.create(n.sourceElementOrData, n.config, this._context);
      throw new Error(`Not supported item type: '${n.type}'.`);
    })));
  }
  /**
   * Removes and destroys item(s) with given ID(s).
   *
   * ```ts
   * await watchdog.remove( 'editor1' );
   * ```
   *
   * Or
   *
   * ```ts
   * await watchdog.remove( [ 'editor1', 'editor2' ] );
   * ```
   *
   * @param itemIdOrItemIds Item ID or an array of item IDs.
   */
  remove(e) {
    const t = Lb(e);
    return Promise.all(t.map((n) => this._actionQueues.enqueue(n, () => {
      const r = this._getWatchdog(n);
      return this._watchdogs.delete(n), r.destroy();
    })));
  }
  /**
   * Destroys the context watchdog and all added items.
   * Once the context watchdog is destroyed, new items cannot be added.
   *
   * ```ts
   * await watchdog.destroy();
   * ```
   */
  destroy() {
    return this._actionQueues.enqueue(ml, () => (this.state = "destroyed", this._fire("stateChange"), super.destroy(), this._destroy()));
  }
  /**
   * Restarts the context watchdog.
   */
  _restart() {
    return this._actionQueues.enqueue(ml, () => (this.state = "initializing", this._fire("stateChange"), this._destroy().catch((e) => {
      console.error("An error happened during destroying the context or items.", e);
    }).then(() => this._create()).then(() => this._fire("restart"))));
  }
  /**
   * Initializes the context watchdog.
   */
  _create() {
    return Promise.resolve().then(() => (this._startErrorHandling(), this._creator(this._contextConfig))).then((e) => (this._context = e, this._contextProps = wg(this._context), Promise.all(Array.from(this._watchdogs.values()).map((t) => (t._setExcludedProperties(this._contextProps), t.create(void 0, void 0, this._context))))));
  }
  /**
   * Destroys the context instance and all added items.
   */
  _destroy() {
    return Promise.resolve().then(() => {
      this._stopErrorHandling();
      const e = this._context;
      return this._context = null, this._contextProps = /* @__PURE__ */ new Set(), Promise.all(Array.from(this._watchdogs.values()).map((t) => t.destroy())).then(() => this._destructor(e));
    });
  }
  /**
   * Returns the watchdog for a given item ID.
   *
   * @param itemId Item ID.
   */
  _getWatchdog(e) {
    const t = this._watchdogs.get(e);
    if (!t)
      throw new Error(`Item with the given id was not registered: ${e}.`);
    return t;
  }
  /**
   * Checks whether an error comes from the context instance and not from the item instances.
   *
   * @internal
   */
  _isErrorComingFromThisItem(e) {
    for (const t of this._watchdogs.values())
      if (t._isErrorComingFromThisItem(e))
        return !1;
    return FC(this._context, e.context);
  }
}
class Z9 {
  constructor() {
    this._onEmptyCallbacks = [], this._queues = /* @__PURE__ */ new Map(), this._activeActions = 0;
  }
  /**
   * Used to register callbacks that will be run when the queue becomes empty.
   *
   * @param onEmptyCallback A callback that will be run whenever the queue becomes empty.
   */
  onEmpty(e) {
    this._onEmptyCallbacks.push(e);
  }
  /**
   * It adds asynchronous actions (functions) to the proper queue and runs them one by one.
   *
   * @param queueId The action queue ID.
   * @param action A function that should be enqueued.
   */
  enqueue(e, t) {
    const n = e === ml;
    this._activeActions++, this._queues.get(e) || this._queues.set(e, Promise.resolve());
    const s = (n ? Promise.all(this._queues.values()) : Promise.all([this._queues.get(ml), this._queues.get(e)])).then(t), o = s.catch(() => {
    });
    return this._queues.set(e, o), s.finally(() => {
      this._activeActions--, this._queues.get(e) === o && this._activeActions === 0 && this._onEmptyCallbacks.forEach((l) => l());
    });
  }
}
function Lb(i) {
  return Array.isArray(i) ? i : [i];
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class Q9 extends ph {
  /**
   * Creates an instance of the balloon editor UI class.
   *
   * @param editor The editor instance.
   * @param view The view of the UI.
   */
  constructor(e, t) {
    super(e), this.view = t;
  }
  /**
   * @inheritDoc
   */
  get element() {
    return this.view.editable.element;
  }
  /**
   * Initializes the UI.
   */
  init() {
    const e = this.editor, t = this.view, n = e.editing.view, r = t.editable, s = n.document.getRoot();
    r.name = s.rootName, t.render();
    const o = r.element;
    this.setEditableElement(r.name, o), r.bind("isFocused").to(this.focusTracker), n.attachDomRoot(o), this._initPlaceholder(), this.fire("ready");
  }
  /**
   * @inheritDoc
   */
  destroy() {
    super.destroy();
    const e = this.view;
    this.editor.editing.view.detachDomRoot(e.editable.name), e.destroy();
  }
  /**
   * Enable the placeholder text on the editing root, if any was configured.
   */
  _initPlaceholder() {
    const e = this.editor, t = e.editing.view, n = t.document.getRoot();
    e.sourceElement;
    const r = e.config.get("placeholder");
    if (r) {
      const s = typeof r == "string" ? r : r[n.rootName];
      s && Wl({
        view: t,
        element: n,
        text: s,
        isDirectHost: !1,
        keepOnFocus: !0
      });
    }
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class e$ extends _h {
  /**
   * Creates an instance of the balloon editor UI view.
   *
   * @param locale The {@link module:core/editor/editor~Editor#locale} instance.
   * @param editingView The editing view instance this view is related to.
   * @param editableElement The editable element. If not specified, it will be automatically created by
   * {@link module:ui/editableui/editableuiview~EditableUIView}. Otherwise, the given element will be used.
   */
  constructor(e, t, n) {
    super(e);
    const r = e.t;
    this.editable = new vh(e, t, n, {
      label: (s) => r("Rich Text Editor. Editing area: %0", s.name)
    });
  }
  /**
   * @inheritDoc
   */
  render() {
    super.render(), this.registerChild(this.editable);
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
let bh = class extends Bs(jo(dh)) {
  /**
   * Creates an instance of the balloon editor.
   *
   * **Note:** do not use the constructor to create editor instances. Use the static
   * {@link module:editor-balloon/ballooneditor~BalloonEditor.create `BalloonEditor.create()`} method instead.
   *
   * @param sourceElementOrData The DOM element that will be the source for the created editor
   * (on which the editor will be initialized) or initial data for the editor. For more information see
   * {@link module:editor-balloon/ballooneditor~BalloonEditor.create `BalloonEditor.create()`}.
   * @param config The editor configuration.
   */
  constructor(e, t = {}) {
    if (!Qu(e) && t.initialData !== void 0)
      throw new B("editor-create-initial-data", null);
    super(t), this.config.get("initialData") === void 0 && this.config.set("initialData", t$(e)), Qu(e) && (this.sourceElement = e, _p(this, e));
    const n = this.config.get("plugins");
    n.push(G9), this.config.set("plugins", n), this.config.define("balloonToolbar", this.config.get("toolbar")), this.model.document.createRoot();
    const r = new e$(this.locale, this.editing.view, this.sourceElement);
    this.ui = new Q9(this, r), pp(this);
  }
  /**
   * Destroys the editor instance, releasing all resources used by it.
   *
   * Updates the original editor element with the data if the
   * {@link module:core/editor/editorconfig~EditorConfig#updateSourceElementOnDestroy `updateSourceElementOnDestroy`}
   * configuration option is set to `true`.
   */
  destroy() {
    const e = this.getData();
    return this.ui.destroy(), super.destroy().then(() => {
      this.sourceElement && this.updateSourceElement(e);
    });
  }
  /**
   * Creates a new balloon editor instance.
   *
   * There are three general ways how the editor can be initialized.
   *
   * # Using an existing DOM element (and loading data from it)
   *
   * You can initialize the editor using an existing DOM element:
   *
   * ```ts
   * BalloonEditor
   * 	.create( document.querySelector( '#editor' ) )
   * 	.then( editor => {
   * 		console.log( 'Editor was initialized', editor );
   * 	} )
   * 	.catch( err => {
   * 		console.error( err.stack );
   * 	} );
   * ```
   *
   * The element's content will be used as the editor data and the element will become the editable element.
   *
   * # Creating a detached editor
   *
   * Alternatively, you can initialize the editor by passing the initial data directly as a string.
   * In this case, the editor will render an element that must be inserted into the DOM for the editor to work properly:
   *
   * ```ts
   * BalloonEditor
   * 	.create( '<p>Hello world!</p>' )
   * 	.then( editor => {
   * 		console.log( 'Editor was initialized', editor );
   *
   * 		// Initial data was provided so the editor UI element needs to be added manually to the DOM.
   * 		document.body.appendChild( editor.ui.element );
   * 	} )
   * 	.catch( err => {
   * 		console.error( err.stack );
   * 	} );
   * ```
   *
   * This lets you dynamically append the editor to your web page whenever it is convenient for you. You may use this method if your
   * web page content is generated on the client side and the DOM structure is not ready at the moment when you initialize the editor.
   *
   * # Using an existing DOM element (and data provided in `config.initialData`)
   *
   * You can also mix these two ways by providing a DOM element to be used and passing the initial data through the configuration:
   *
   * ```ts
   * BalloonEditor
   * 	.create( document.querySelector( '#editor' ), {
   * 		initialData: '<h2>Initial data</h2><p>Foo bar.</p>'
   * 	} )
   * 	.then( editor => {
   * 		console.log( 'Editor was initialized', editor );
   * 	} )
   * 	.catch( err => {
   * 		console.error( err.stack );
   * 	} );
   * ```
   *
   * This method can be used to initialize the editor on an existing element with the specified content in case if your integration
   * makes it difficult to set the content of the source element.
   *
   * Note that an error will be thrown if you pass the initial data both as the first parameter and also in the configuration.
   *
   * # Configuring the editor
   *
   * See the {@link module:core/editor/editorconfig~EditorConfig editor configuration documentation} to learn more about
   * customizing plugins, toolbar and more.
   *
   * # Using the editor from source
   *
   * The code samples listed in the previous sections of this documentation assume that you are using an
   * {@glink installation/getting-started/predefined-builds editor build} (for example – `@ckeditor/ckeditor5-build-balloon`).
   *
   * If you want to use the balloon editor from source (`@ckeditor/ckeditor5-editor-balloon/src/ballooneditor`),
   * you need to define the list of
   * {@link module:core/editor/editorconfig~EditorConfig#plugins plugins to be initialized} and
   * {@link module:core/editor/editorconfig~EditorConfig#toolbar toolbar items}. Read more about using the editor from
   * source in the {@glink installation/advanced/alternative-setups/integrating-from-source-webpack dedicated guide}.
   *
   * @param sourceElementOrData The DOM element that will be the source for the created editor
   * or the editor's initial data.
   *
   * If a DOM element is passed, its content will be automatically loaded to the editor upon initialization.
   * The editor data will be set back to the original element once the editor is destroyed only if the
   * {@link module:core/editor/editorconfig~EditorConfig#updateSourceElementOnDestroy updateSourceElementOnDestroy}
   * option is set to `true`.
   *
   * If the initial data is passed, a detached editor will be created. In this case you need to insert it into the DOM manually.
   * It is available under the {@link module:editor-balloon/ballooneditorui~BalloonEditorUI#element `editor.ui.element`} property.
   *
   * @param config The editor configuration.
   * @returns A promise resolved once the editor is ready. The promise resolves with the created editor instance.
   */
  static create(e, t = {}) {
    return new Promise((n) => {
      if (Qu(e) && e.tagName === "TEXTAREA")
        throw new B("editor-wrong-element", null);
      const r = new this(e, t);
      n(r.initPlugins().then(() => r.ui.init()).then(() => r.data.init(r.config.get("initialData"))).then(() => r.fire("ready")).then(() => r));
    });
  }
};
bh.Context = zl;
bh.EditorWatchdog = Ul;
bh.ContextWatchdog = wh;
function t$(i) {
  return Qu(i) ? sh(i) : i;
}
function Qu(i) {
  return Dr(i);
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class Tp extends qs {
  constructor(e) {
    super(e), this.domEventType = [
      "paste",
      "copy",
      "cut",
      "drop",
      "dragover",
      "dragstart",
      "dragend",
      "dragenter",
      "dragleave"
    ];
    const t = this.document;
    this.listenTo(t, "paste", n("clipboardInput"), { priority: "low" }), this.listenTo(t, "drop", n("clipboardInput"), { priority: "low" }), this.listenTo(t, "dragover", n("dragging"), { priority: "low" });
    function n(r) {
      return (s, o) => {
        o.preventDefault();
        const l = o.dropRange ? [o.dropRange] : null, u = new Ir(t, r);
        t.fire(u, {
          dataTransfer: o.dataTransfer,
          method: s.name,
          targetRanges: l,
          target: o.target
        }), u.stop.called && o.stopPropagation();
      };
    }
  }
  onDomEvent(e) {
    const t = "clipboardData" in e ? e.clipboardData : e.dataTransfer, n = e.type == "drop" || e.type == "paste", r = {
      dataTransfer: new HE(t, { cacheFiles: n })
    };
    (e.type == "drop" || e.type == "dragover") && (r.dropRange = n$(this.view, e)), this.fire(e.type, e, r);
  }
}
function n$(i, e) {
  const t = e.target.ownerDocument, n = e.clientX, r = e.clientY;
  let s;
  return t.caretRangeFromPoint && t.caretRangeFromPoint(n, r) ? s = t.caretRangeFromPoint(n, r) : e.rangeParent && (s = t.createRange(), s.setStart(e.rangeParent, e.rangeOffset), s.collapse(!0)), s ? i.domConverter.domRangeToView(s) : null;
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function i$(i) {
  return i = i.replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\r?\n\r?\n/g, "</p><p>").replace(/\r?\n/g, "<br>").replace(/\t/g, "&nbsp;&nbsp;&nbsp;&nbsp;").replace(/^\s/, "&nbsp;").replace(/\s$/, "&nbsp;").replace(/\s\s/g, " &nbsp;"), (i.includes("</p><p>") || i.includes("<br>")) && (i = `<p>${i}</p>`), i;
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function r$(i) {
  return i.replace(/<span(?: class="Apple-converted-space"|)>(\s+)<\/span>/g, (e, t) => t.length == 1 ? " " : t).replace(/<!--[\s\S]*?-->/g, "");
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const Fb = ["figcaption", "li"];
function $C(i) {
  let e = "";
  if (i.is("$text") || i.is("$textProxy"))
    e = i.data;
  else if (i.is("element", "img") && i.hasAttribute("alt"))
    e = i.getAttribute("alt");
  else if (i.is("element", "br"))
    e = `
`;
  else {
    let t = null;
    for (const n of i.getChildren()) {
      const r = $C(n);
      t && (t.is("containerElement") || n.is("containerElement")) && (Fb.includes(t.name) || Fb.includes(n.name) ? e += `
` : e += `

`), e += r, t = n;
    }
  }
  return e;
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class rs extends fe {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "ClipboardPipeline";
  }
  /**
   * @inheritDoc
   */
  init() {
    this.editor.editing.view.addObserver(Tp), this._setupPasteDrop(), this._setupCopyCut();
  }
  /**
   * The clipboard paste pipeline.
   */
  _setupPasteDrop() {
    const e = this.editor, t = e.model, n = e.editing.view, r = n.document;
    this.listenTo(r, "clipboardInput", (s) => {
      e.isReadOnly && s.stop();
    }, { priority: "highest" }), this.listenTo(r, "clipboardInput", (s, o) => {
      const l = o.dataTransfer;
      let u;
      if (o.content)
        u = o.content;
      else {
        let f = "";
        l.getData("text/html") ? f = r$(l.getData("text/html")) : l.getData("text/plain") && (f = i$(l.getData("text/plain"))), u = this.editor.data.htmlProcessor.toView(f);
      }
      const h = new Ir(this, "inputTransformation");
      this.fire(h, {
        content: u,
        dataTransfer: l,
        targetRanges: o.targetRanges,
        method: o.method
      }), h.stop.called && s.stop(), n.scrollToTheSelection();
    }, { priority: "low" }), this.listenTo(this, "inputTransformation", (s, o) => {
      if (o.content.isEmpty)
        return;
      const u = this.editor.data.toModel(o.content, "$clipboardHolder");
      u.childCount != 0 && (s.stop(), t.change(() => {
        this.fire("contentInsertion", {
          content: u,
          method: o.method,
          dataTransfer: o.dataTransfer,
          targetRanges: o.targetRanges
        });
      }));
    }, { priority: "low" }), this.listenTo(this, "contentInsertion", (s, o) => {
      o.resultRange = t.insertContent(o.content);
    }, { priority: "low" });
  }
  /**
   * The clipboard copy/cut pipeline.
   */
  _setupCopyCut() {
    const e = this.editor, t = e.model.document, r = e.editing.view.document, s = (o, l) => {
      const u = l.dataTransfer;
      l.preventDefault();
      const h = e.data.toView(e.model.getSelectedContent(t.selection));
      r.fire("clipboardOutput", {
        dataTransfer: u,
        content: h,
        method: o.name
      });
    };
    this.listenTo(r, "copy", s, { priority: "low" }), this.listenTo(r, "cut", (o, l) => {
      e.isReadOnly ? l.preventDefault() : s(o, l);
    }, { priority: "low" }), this.listenTo(r, "clipboardOutput", (o, l) => {
      l.content.isEmpty || (l.dataTransfer.setData("text/html", this.editor.data.htmlProcessor.toData(l.content)), l.dataTransfer.setData("text/plain", $C(l.content))), l.method == "cut" && e.model.deleteContent(t.selection);
    }, { priority: "low" });
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class zC {
  /**
   * Creates a new instance of the change buffer.
   *
   * @param limit The maximum number of atomic changes which can be contained in one batch.
   */
  constructor(e, t = 20) {
    this._batch = null, this.model = e, this._size = 0, this.limit = t, this._isLocked = !1, this._changeCallback = (n, r) => {
      r.isLocal && r.isUndoable && r !== this._batch && this._reset(!0);
    }, this._selectionChangeCallback = () => {
      this._reset();
    }, this.model.document.on("change", this._changeCallback), this.model.document.selection.on("change:range", this._selectionChangeCallback), this.model.document.selection.on("change:attribute", this._selectionChangeCallback);
  }
  /**
   * The current batch to which a feature should add its operations. Once the {@link #size}
   * is reached or exceeds the {@link #limit}, the batch is set to a new instance and the size is reset.
   */
  get batch() {
    return this._batch || (this._batch = this.model.createBatch({ isTyping: !0 })), this._batch;
  }
  /**
   * The number of atomic changes in the buffer. Once it exceeds the {@link #limit},
   * the {@link #batch batch} is set to a new one.
   */
  get size() {
    return this._size;
  }
  /**
   * The input number of changes into the buffer. Once the {@link #size} is
   * reached or exceeds the {@link #limit}, the batch is set to a new instance and the size is reset.
   *
   * @param changeCount The number of atomic changes to input.
   */
  input(e) {
    this._size += e, this._size >= this.limit && this._reset(!0);
  }
  /**
   * Whether the buffer is locked. A locked buffer cannot be reset unless it gets unlocked.
   */
  get isLocked() {
    return this._isLocked;
  }
  /**
   * Locks the buffer.
   */
  lock() {
    this._isLocked = !0;
  }
  /**
   * Unlocks the buffer.
   */
  unlock() {
    this._isLocked = !1;
  }
  /**
   * Destroys the buffer.
   */
  destroy() {
    this.model.document.off("change", this._changeCallback), this.model.document.selection.off("change:range", this._selectionChangeCallback), this.model.document.selection.off("change:attribute", this._selectionChangeCallback);
  }
  /**
   * Resets the change buffer.
   *
   * @param ignoreLock Whether internal lock {@link #isLocked} should be ignored.
   */
  _reset(e = !1) {
    (!this.isLocked || e) && (this._batch = null, this._size = 0);
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class s$ extends Pt {
  /**
   * Creates an instance of the command.
   *
   * @param undoStepSize The maximum number of atomic changes
   * which can be contained in one batch in the command buffer.
   */
  constructor(e, t) {
    super(e), this._buffer = new zC(e.model, t);
  }
  /**
   * The current change buffer.
   */
  get buffer() {
    return this._buffer;
  }
  /**
   * @inheritDoc
   */
  destroy() {
    super.destroy(), this._buffer.destroy();
  }
  /**
   * Executes the input command. It replaces the content within the given range with the given text.
   * Replacing is a two step process, first the content within the range is removed and then the new text is inserted
   * at the beginning of the range (which after the removal is a collapsed range).
   *
   * @fires execute
   * @param options The command options.
   */
  execute(e = {}) {
    const t = this.editor.model, n = t.document, r = e.text || "", s = r.length;
    let o = n.selection;
    e.selection ? o = e.selection : e.range && (o = t.createSelection(e.range));
    const l = e.resultRange;
    t.enqueueChange(this._buffer.batch, (u) => {
      this._buffer.lock(), t.deleteContent(o), r && t.insertContent(u.createText(r, n.selection.getAttributes()), o), l ? u.setSelection(l) : o.is("documentSelection") || u.setSelection(o), this._buffer.unlock(), this._buffer.input(s);
    });
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const $b = [
  // For collapsed range:
  //	- This one is a regular typing (all browsers, all systems).
  //	- This one is used by Chrome when typing accented letter – 2nd step when the user selects the accent (Mac).
  // For non-collapsed range:
  //	- This one is used by Chrome when typing accented letter – when the selection box first appears (Mac).
  //	- This one is used by Safari when accepting spell check suggestions from the context menu (Mac).
  "insertText",
  // This one is used by Safari when typing accented letter (Mac).
  // This one is used by Safari when accepting spell check suggestions from the autocorrection pop-up (Mac).
  "insertReplacementText"
];
class o$ extends dr {
  /**
   * @inheritDoc
   */
  constructor(e) {
    super(e), qe.isAndroid && $b.push("insertCompositionText");
    const t = e.document;
    t.on("beforeinput", (n, r) => {
      if (!this.isEnabled)
        return;
      const { data: s, targetRanges: o, inputType: l, domEvent: u } = r;
      if (!$b.includes(l))
        return;
      const h = new Ir(t, "insertText");
      t.fire(h, new Wo(e, u, {
        text: s,
        selection: e.createSelection(o)
      })), h.stop.called && n.stop();
    }), t.on("compositionend", (n, { data: r, domEvent: s }) => {
      !this.isEnabled || qe.isAndroid || r && t.fire("insertText", new Wo(e, s, {
        text: r,
        selection: t.selection
      }));
    }, { priority: "lowest" });
  }
  /**
   * @inheritDoc
   */
  observe() {
  }
  /**
   * @inheritDoc
   */
  stopObserving() {
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class WC extends fe {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "Input";
  }
  /**
   * @inheritDoc
   */
  init() {
    const e = this.editor, t = e.model, n = e.editing.view, r = t.document.selection;
    n.addObserver(o$);
    const s = new s$(e, e.config.get("typing.undoStep") || 20);
    e.commands.add("insertText", s), e.commands.add("input", s), this.listenTo(n.document, "insertText", (o, l) => {
      n.document.isComposing || l.preventDefault();
      const { text: u, selection: h, resultRange: f } = l, m = Array.from(h.getRanges()).map((k) => e.editing.mapper.toModelRange(k));
      let v = u;
      if (qe.isAndroid) {
        const k = Array.from(m[0].getItems()).reduce((S, x) => S + (x.is("$textProxy") ? x.data : ""), "");
        k && (k.length <= v.length ? v.startsWith(k) && (v = v.substring(k.length), m[0].start = m[0].start.getShiftedBy(k.length)) : k.startsWith(v) && (m[0].start = m[0].start.getShiftedBy(v.length), v = ""));
      }
      const C = {
        text: v,
        selection: t.createSelection(m)
      };
      f && (C.resultRange = e.editing.mapper.toModelRange(f)), e.execute("insertText", C);
    }), qe.isAndroid ? this.listenTo(n.document, "keydown", (o, l) => {
      r.isCollapsed || l.keyCode != 229 || !n.document.isComposing || zb(t, s);
    }) : this.listenTo(n.document, "compositionstart", () => {
      r.isCollapsed || zb(t, s);
    });
  }
}
function zb(i, e) {
  if (!e.isEnabled)
    return;
  const t = e.buffer;
  t.lock(), i.enqueueChange(t.batch, () => {
    i.deleteContent(i.document.selection);
  }), t.unlock();
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class Wb extends Pt {
  /**
   * Creates an instance of the command.
   *
   * @param direction The directionality of the delete describing in what direction it
   * should consume the content when the selection is collapsed.
   */
  constructor(e, t) {
    super(e), this.direction = t, this._buffer = new zC(e.model, e.config.get("typing.undoStep"));
  }
  /**
   * The current change buffer.
   */
  get buffer() {
    return this._buffer;
  }
  /**
   * Executes the delete command. Depending on whether the selection is collapsed or not, deletes its content
   * or a piece of content in the {@link #direction defined direction}.
   *
   * @fires execute
   * @param options The command options.
   * @param options.unit See {@link module:engine/model/utils/modifyselection~modifySelection}'s options.
   * @param options.sequence A number describing which subsequent delete event it is without the key being released.
   * See the {@link module:engine/view/document~Document#event:delete} event data.
   * @param options.selection Selection to remove. If not set, current model selection will be used.
   */
  execute(e = {}) {
    const t = this.editor.model, n = t.document;
    t.enqueueChange(this._buffer.batch, (r) => {
      this._buffer.lock();
      const s = r.createSelection(e.selection || n.selection), o = e.sequence || 1, l = s.isCollapsed;
      if (s.isCollapsed && t.modifySelection(s, {
        direction: this.direction,
        unit: e.unit,
        treatEmojiAsSingleUnit: !0
      }), this._shouldEntireContentBeReplacedWithParagraph(o)) {
        this._replaceEntireContentWithParagraph(r);
        return;
      }
      if (this._shouldReplaceFirstBlockWithParagraph(s, o)) {
        this.editor.execute("paragraph", { selection: s });
        return;
      }
      if (s.isCollapsed)
        return;
      let u = 0;
      s.getFirstRange().getMinimalFlatRanges().forEach((h) => {
        u += sg(h.getWalker({ singleCharacters: !0, ignoreElementEnd: !0, shallow: !0 }));
      }), t.deleteContent(s, {
        doNotResetEntireContent: l,
        direction: this.direction
      }), this._buffer.input(u), r.setSelection(s), this._buffer.unlock();
    });
  }
  /**
   * If the user keeps <kbd>Backspace</kbd> or <kbd>Delete</kbd> key pressed, the content of the current
   * editable will be cleared. However, this will not yet lead to resetting the remaining block to a paragraph
   * (which happens e.g. when the user does <kbd>Ctrl</kbd> + <kbd>A</kbd>, <kbd>Backspace</kbd>).
   *
   * But, if the user pressed the key in an empty editable for the first time,
   * we want to replace the entire content with a paragraph if:
   *
   * * the current limit element is empty,
   * * the paragraph is allowed in the limit element,
   * * the limit doesn't already have a paragraph inside.
   *
   * See https://github.com/ckeditor/ckeditor5-typing/issues/61.
   *
   * @param sequence A number describing which subsequent delete event it is without the key being released.
   */
  _shouldEntireContentBeReplacedWithParagraph(e) {
    if (e > 1)
      return !1;
    const t = this.editor.model, r = t.document.selection, s = t.schema.getLimitElement(r);
    if (!(r.isCollapsed && r.containsEntireContent(s)) || !t.schema.checkChild(s, "paragraph"))
      return !1;
    const l = s.getChild(0);
    return !(l && l.is("element", "paragraph"));
  }
  /**
   * The entire content is replaced with the paragraph. Selection is moved inside the paragraph.
   *
   * @param writer The model writer.
   */
  _replaceEntireContentWithParagraph(e) {
    const t = this.editor.model, r = t.document.selection, s = t.schema.getLimitElement(r), o = e.createElement("paragraph");
    e.remove(e.createRangeIn(s)), e.insert(o, s), e.setSelection(o, 0);
  }
  /**
   * Checks if the selection is inside an empty element that is the first child of the limit element
   * and should be replaced with a paragraph.
   *
   * @param selection The selection.
   * @param sequence A number describing which subsequent delete event it is without the key being released.
   */
  _shouldReplaceFirstBlockWithParagraph(e, t) {
    const n = this.editor.model;
    if (t > 1 || this.direction != "backward" || !e.isCollapsed)
      return !1;
    const r = e.getFirstPosition(), s = n.schema.getLimitElement(r), o = s.getChild(0);
    return !(r.parent != o || !e.containsEntireContent(o) || !n.schema.checkChild(s, "paragraph") || o.name == "paragraph");
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const a$ = "character", jb = "word", l$ = "codePoint", es = "selection", Oo = "backward", sl = "forward", jC = {
  // --------------------------------------- Backward delete types -----------------------------------------------------
  // This happens in Safari on Mac when some content is selected and Ctrl + K is pressed.
  deleteContent: {
    unit: es,
    // According to the Input Events Level 2 spec, this delete type has no direction
    // but to keep things simple, let's default to backward.
    direction: Oo
  },
  // Chrome and Safari on Mac: Backspace or Ctrl + H
  deleteContentBackward: {
    // This kind of deletions must be done on the code point-level instead of target range provided by the DOM beforeinput event.
    // Take for instance "👨‍👩‍👧‍👧", it equals:
    //
    //	* [ "👨", "ZERO WIDTH JOINER", "👩", "ZERO WIDTH JOINER", "👧", "ZERO WIDTH JOINER", "👧" ]
    //	* or simply "\u{1F468}\u200D\u{1F469}\u200D\u{1F467}\u200D\u{1F467}"
    //
    // The range provided by the browser would cause the entire multi-byte grapheme to disappear while the user
    // intention when deleting backwards ("👨‍👩‍👧‍👧[]", then backspace) is gradual "decomposition" (first to "👨‍👩‍👧‍[]",
    // then to "👨‍👩‍[]", etc.).
    //
    //	* "👨‍👩‍👧‍👧[]" + backward delete (by code point)  -> results in "👨‍👩‍👧[]", removed the last "👧" 👍
    //	* "👨‍👩‍👧‍👧[]" + backward delete (by character)  -> results in "[]", removed the whole grapheme 👎
    //
    // Deleting by code-point is simply a better UX. See "deleteContentForward" to learn more.
    unit: l$,
    direction: Oo
  },
  // On Mac: Option + Backspace.
  // On iOS: Hold the backspace for a while and the whole words will start to disappear.
  deleteWordBackward: {
    unit: jb,
    direction: Oo
  },
  // Safari on Mac: Cmd + Backspace
  deleteHardLineBackward: {
    unit: es,
    direction: Oo
  },
  // Chrome on Mac: Cmd + Backspace.
  deleteSoftLineBackward: {
    unit: es,
    direction: Oo
  },
  // --------------------------------------- Forward delete types -----------------------------------------------------
  // Chrome on Mac: Fn + Backspace or Ctrl + D
  // Safari on Mac: Ctrl + K or Ctrl + D
  deleteContentForward: {
    // Unlike backward delete, this delete must be performed by character instead of by code point, which
    // provides the best UX for working with accented letters.
    // Take, for example "b̂" ("\u0062\u0302", or [ "LATIN SMALL LETTER B", "COMBINING CIRCUMFLEX ACCENT" ]):
    //
    //	* "b̂[]" + backward delete (by code point)  -> results in "b[]", removed the combining mark 👍
    //	* "[]b̂" + forward delete (by code point)   -> results in "[]^", a bare combining mark does that not make sense when alone 👎
    //	* "[]b̂" + forward delete (by character)    -> results in "[]", removed both "b" and the combining mark 👍
    //
    // See: "deleteContentBackward" to learn more.
    unit: a$,
    direction: sl
  },
  // On Mac: Fn + Option + Backspace.
  deleteWordForward: {
    unit: jb,
    direction: sl
  },
  // Chrome on Mac: Ctrl + K (you have to disable the Link plugin first, though, because it uses the same keystroke)
  // This is weird that it does not work in Safari on Mac despite being listed in the official shortcuts listing
  // on Apple's webpage.
  deleteHardLineForward: {
    unit: es,
    direction: sl
  },
  // At this moment there is no known way to trigger this event type but let's keep it for the symmetry with
  // deleteSoftLineBackward.
  deleteSoftLineForward: {
    unit: es,
    direction: sl
  }
};
class c$ extends dr {
  /**
   * @inheritDoc
   */
  constructor(e) {
    super(e);
    const t = e.document;
    let n = 0;
    t.on("keydown", () => {
      n++;
    }), t.on("keyup", () => {
      n = 0;
    }), t.on("beforeinput", (r, s) => {
      if (!this.isEnabled)
        return;
      const { targetRanges: o, domEvent: l, inputType: u } = s, h = jC[u];
      if (!h)
        return;
      const f = {
        direction: h.direction,
        unit: h.unit,
        sequence: n
      };
      f.unit == es && (f.selectionToRemove = e.createSelection(o[0])), u === "deleteContentBackward" && (qe.isAndroid && (f.sequence = 1), d$(o) && (f.unit = es, f.selectionToRemove = e.createSelection(o)));
      const m = new Qo(t, "delete", o[0]);
      t.fire(m, new Wo(e, l, f)), m.stop.called && r.stop();
    }), qe.isBlink && u$(this);
  }
  /**
   * @inheritDoc
   */
  observe() {
  }
  /**
   * @inheritDoc
   */
  stopObserving() {
  }
}
function u$(i) {
  const e = i.view, t = e.document;
  let n = null, r = !1;
  t.on("keydown", (l, { keyCode: u }) => {
    n = u, r = !1;
  }), t.on("keyup", (l, { keyCode: u, domEvent: h }) => {
    const f = t.selection, m = i.isEnabled && u == n && s(u) && !f.isCollapsed && !r;
    if (n = null, m) {
      const v = f.getFirstRange(), C = new Qo(t, "delete", v), k = {
        unit: es,
        direction: o(u),
        selectionToRemove: f
      };
      t.fire(C, new Wo(e, h, k));
    }
  }), t.on("beforeinput", (l, { inputType: u }) => {
    const h = jC[u];
    s(n) && h && h.direction == o(n) && (r = !0);
  }, { priority: "high" }), t.on("beforeinput", (l, { inputType: u, data: h }) => {
    n == tt.delete && u == "insertText" && h == "" && l.stop();
  }, { priority: "high" });
  function s(l) {
    return l == tt.backspace || l == tt.delete;
  }
  function o(l) {
    return l == tt.backspace ? Oo : sl;
  }
}
function d$(i) {
  if (i.length != 1 || i[0].isCollapsed)
    return !1;
  const e = i[0].getWalker({
    direction: "backward",
    singleCharacters: !0,
    ignoreElementEnd: !0
  });
  let t = 0;
  for (const { nextPosition: n } of e) {
    if (!n.parent.is("$text"))
      t++;
    else {
      const r = n.parent.data, s = n.offset;
      if (rp(r, s) || sp(r, s) || AE(r, s))
        continue;
      t++;
    }
    if (t > 1)
      return !0;
  }
  return !1;
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class ia extends fe {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "Delete";
  }
  /**
   * @inheritDoc
   */
  init() {
    const e = this.editor, t = e.editing.view, n = t.document, r = e.model.document;
    t.addObserver(c$), this._undoOnBackspace = !1;
    const s = new Wb(e, "forward");
    e.commands.add("deleteForward", s), e.commands.add("forwardDelete", s), e.commands.add("delete", new Wb(e, "backward")), this.listenTo(n, "delete", (o, l) => {
      n.isComposing || l.preventDefault();
      const { direction: u, sequence: h, selectionToRemove: f, unit: m } = l, v = u === "forward" ? "deleteForward" : "delete", C = { sequence: h };
      if (m == "selection") {
        const k = Array.from(f.getRanges()).map((S) => e.editing.mapper.toModelRange(S));
        C.selection = e.model.createSelection(k);
      } else
        C.unit = m;
      e.execute(v, C), t.scrollToTheSelection();
    }, { priority: "low" }), this.editor.plugins.has("UndoEditing") && (this.listenTo(n, "delete", (o, l) => {
      this._undoOnBackspace && l.direction == "backward" && l.sequence == 1 && l.unit == "codePoint" && (this._undoOnBackspace = !1, e.execute("undo"), l.preventDefault(), o.stop());
    }, { context: "$capture" }), this.listenTo(r, "change", () => {
      this._undoOnBackspace = !1;
    }));
  }
  /**
   * If the next user action after calling this method is pressing backspace, it would undo the last change.
   *
   * Requires {@link module:undo/undoediting~UndoEditing} plugin. If not loaded, does nothing.
   */
  requestUndoOnBackspace() {
    this.editor.plugins.has("UndoEditing") && (this._undoOnBackspace = !0);
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class h$ extends fe {
  static get requires() {
    return [WC, ia];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "Typing";
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function UC(i, e) {
  let t = i.start;
  return { text: Array.from(i.getItems()).reduce((r, s) => s.is("$text") || s.is("$textProxy") ? r + s.data : (t = e.createPositionAfter(s), ""), ""), range: e.createRange(t, i.end) };
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class f$ extends Nt() {
  /**
   * Creates a text watcher instance.
   *
   * @param testCallback See {@link module:typing/textwatcher~TextWatcher#testCallback}.
   */
  constructor(e, t) {
    super(), this.model = e, this.testCallback = t, this._hasMatch = !1, this.set("isEnabled", !0), this.on("change:isEnabled", () => {
      this.isEnabled ? this._startListening() : (this.stopListening(e.document.selection), this.stopListening(e.document));
    }), this._startListening();
  }
  /**
   * Flag indicating whether there is a match currently.
   */
  get hasMatch() {
    return this._hasMatch;
  }
  /**
   * Starts listening to the editor for typing and selection events.
   */
  _startListening() {
    const t = this.model.document;
    this.listenTo(t.selection, "change:range", (n, { directChange: r }) => {
      if (r) {
        if (!t.selection.isCollapsed) {
          this.hasMatch && (this.fire("unmatched"), this._hasMatch = !1);
          return;
        }
        this._evaluateTextBeforeSelection("selection");
      }
    }), this.listenTo(t, "change:data", (n, r) => {
      r.isUndo || !r.isLocal || this._evaluateTextBeforeSelection("data", { batch: r });
    });
  }
  /**
   * Checks the editor content for matched text.
   *
   * @fires matched:data
   * @fires matched:selection
   * @fires unmatched
   *
   * @param suffix A suffix used for generating the event name.
   * @param data Data object for event.
   */
  _evaluateTextBeforeSelection(e, t = {}) {
    const n = this.model, s = n.document.selection, o = n.createRange(n.createPositionAt(s.focus.parent, 0), s.focus), { text: l, range: u } = UC(o, n), h = this.testCallback(l);
    if (!h && this.hasMatch && this.fire("unmatched"), this._hasMatch = !!h, h) {
      const f = Object.assign(t, { text: l, range: u });
      typeof h == "object" && Object.assign(f, h), this.fire(`matched:${e}`, f);
    }
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class Ub extends fe {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "TwoStepCaretMovement";
  }
  /**
   * @inheritDoc
   */
  constructor(e) {
    super(e), this.attributes = /* @__PURE__ */ new Set(), this._overrideUid = null;
  }
  /**
   * @inheritDoc
   */
  init() {
    const e = this.editor, t = e.model, n = e.editing.view, r = e.locale, s = t.document.selection;
    this.listenTo(n.document, "arrowKey", (o, l) => {
      if (!s.isCollapsed || l.shiftKey || l.altKey || l.ctrlKey)
        return;
      const u = l.keyCode == tt.arrowright, h = l.keyCode == tt.arrowleft;
      if (!u && !h)
        return;
      const f = r.contentLanguageDirection;
      let m = !1;
      f === "ltr" && u || f === "rtl" && h ? m = this._handleForwardMovement(l) : m = this._handleBackwardMovement(l), m === !0 && o.stop();
    }, { context: "$text", priority: "highest" }), this._isNextGravityRestorationSkipped = !1, this.listenTo(s, "change:range", (o, l) => {
      if (this._isNextGravityRestorationSkipped) {
        this._isNextGravityRestorationSkipped = !1;
        return;
      }
      this._isGravityOverridden && (!l.directChange && ed(s.getFirstPosition(), this.attributes) || this._restoreGravity());
    });
  }
  /**
   * Registers a given attribute for the two-step caret movement.
   *
   * @param attribute Name of the attribute to handle.
   */
  registerAttribute(e) {
    this.attributes.add(e);
  }
  /**
   * Updates the document selection and the view according to the two–step caret movement state
   * when moving **forwards**. Executed upon `keypress` in the {@link module:engine/view/view~View}.
   *
   * @param data Data of the key press.
   * @returns `true` when the handler prevented caret movement.
   */
  _handleForwardMovement(e) {
    const t = this.attributes, r = this.editor.model.document.selection, s = r.getFirstPosition();
    return this._isGravityOverridden || s.isAtStart && Am(r, t) ? !1 : ed(s, t) ? (qu(e), this._overrideGravity(), !0) : !1;
  }
  /**
   * Updates the document selection and the view according to the two–step caret movement state
   * when moving **backwards**. Executed upon `keypress` in the {@link module:engine/view/view~View}.
   *
   * @param data Data of the key press.
   * @returns `true` when the handler prevented caret movement
   */
  _handleBackwardMovement(e) {
    const t = this.attributes, n = this.editor.model, r = n.document.selection, s = r.getFirstPosition();
    return this._isGravityOverridden ? (qu(e), this._restoreGravity(), Pm(n, t, s), !0) : s.isAtStart ? Am(r, t) ? (qu(e), Pm(n, t, s), !0) : !1 : m$(s, t) ? s.isAtEnd && !Am(r, t) && ed(s, t) ? (qu(e), Pm(n, t, s), !0) : (this._isNextGravityRestorationSkipped = !0, this._overrideGravity(), !1) : !1;
  }
  /**
   * `true` when the gravity is overridden for the plugin.
   */
  get _isGravityOverridden() {
    return !!this._overrideUid;
  }
  /**
   * Overrides the gravity using the {@link module:engine/model/writer~Writer model writer}
   * and stores the information about this fact in the {@link #_overrideUid}.
   *
   * A shorthand for {@link module:engine/model/writer~Writer#overrideSelectionGravity}.
   */
  _overrideGravity() {
    this._overrideUid = this.editor.model.change((e) => e.overrideSelectionGravity());
  }
  /**
   * Restores the gravity using the {@link module:engine/model/writer~Writer model writer}.
   *
   * A shorthand for {@link module:engine/model/writer~Writer#restoreSelectionGravity}.
   */
  _restoreGravity() {
    this.editor.model.change((e) => {
      e.restoreSelectionGravity(this._overrideUid), this._overrideUid = null;
    });
  }
}
function Am(i, e) {
  for (const t of e)
    if (i.hasAttribute(t))
      return !0;
  return !1;
}
function Pm(i, e, t) {
  const n = t.nodeBefore;
  i.change((r) => {
    n ? r.setSelectionAttribute(n.getAttributes()) : r.removeSelectionAttribute(e);
  });
}
function qu(i) {
  i.preventDefault();
}
function m$(i, e) {
  const t = i.getShiftedBy(-1);
  return ed(t, e);
}
function ed(i, e) {
  const { nodeBefore: t, nodeAfter: n } = i;
  for (const r of e) {
    const s = t ? t.getAttribute(r) : void 0;
    if ((n ? n.getAttribute(r) : void 0) !== s)
      return !0;
  }
  return !1;
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function Ko(i, e, t, n) {
  return n.createRange(Hb(i, e, t, !0, n), Hb(i, e, t, !1, n));
}
function Hb(i, e, t, n, r) {
  let s = i.textNode || (n ? i.nodeBefore : i.nodeAfter), o = null;
  for (; s && s.getAttribute(e) == t; )
    o = s, s = n ? s.previousSibling : s.nextSibling;
  return o ? r.createPositionAt(o, n ? "before" : "after") : i;
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function g$(i, e, t, n) {
  const r = i.editing.view, s = /* @__PURE__ */ new Set();
  r.document.registerPostFixer((o) => {
    const l = i.model.document.selection;
    let u = !1;
    if (l.hasAttribute(e)) {
      const h = Ko(l.getFirstPosition(), e, l.getAttribute(e), i.model), f = i.editing.mapper.toViewRange(h);
      for (const m of f.getItems())
        m.is("element", t) && !m.hasClass(n) && (o.addClass(n, m), s.add(m), u = !0);
    }
    return u;
  }), i.conversion.for("editingDowncast").add((o) => {
    o.on("insert", l, { priority: "highest" }), o.on("remove", l, { priority: "highest" }), o.on("attribute", l, { priority: "highest" }), o.on("selection", l, { priority: "highest" });
    function l() {
      r.change((u) => {
        for (const h of s.values())
          u.removeClass(n, h), s.delete(h);
      });
    }
  });
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function* HC(i, e) {
  for (const t of e)
    t && i.getAttributeProperties(t[0]).copyOnEnter && (yield t);
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class p$ extends Pt {
  /**
   * @inheritDoc
   */
  execute() {
    this.editor.model.change((e) => {
      this.enterBlock(e), this.fire("afterExecute", { writer: e });
    });
  }
  /**
   * Splits a block where the document selection is placed, in the way how the <kbd>Enter</kbd> key is expected to work:
   *
   * ```
   * <p>Foo[]bar</p>   ->   <p>Foo</p><p>[]bar</p>
   * <p>Foobar[]</p>   ->   <p>Foobar</p><p>[]</p>
   * <p>Fo[ob]ar</p>   ->   <p>Fo</p><p>[]ar</p>
   * ```
   *
   * In some cases, the split will not happen:
   *
   * ```
   * // The selection parent is a limit element:
   * <figcaption>A[bc]d</figcaption>   ->   <figcaption>A[]d</figcaption>
   *
   * // The selection spans over multiple elements:
   * <h>x[x</h><p>y]y<p>   ->   <h>x</h><p>[]y</p>
   * ```
   *
   * @param writer Writer to use when performing the enter action.
   * @returns Boolean indicating if the block was split.
   */
  enterBlock(e) {
    const t = this.editor.model, n = t.document.selection, r = t.schema, s = n.isCollapsed, o = n.getFirstRange(), l = o.start.parent, u = o.end.parent;
    if (r.isLimit(l) || r.isLimit(u))
      return !s && l == u && t.deleteContent(n), !1;
    if (s) {
      const h = HC(e.model.schema, n.getAttributes());
      return qb(e, o.start), e.setSelectionAttribute(h), !0;
    } else {
      const h = !(o.start.isAtStart && o.end.isAtEnd), f = l == u;
      if (t.deleteContent(n, { leaveUnmerged: h }), h) {
        if (f)
          return qb(e, n.focus), !0;
        e.setSelection(u, 0);
      }
    }
    return !1;
  }
}
function qb(i, e) {
  i.split(e), i.setSelection(e.parent.nextSibling, 0);
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const _$ = {
  insertParagraph: { isSoft: !1 },
  insertLineBreak: { isSoft: !0 }
};
class qC extends dr {
  /**
   * @inheritDoc
   */
  constructor(e) {
    super(e);
    const t = this.document;
    let n = !1;
    t.on("keydown", (r, s) => {
      n = s.shiftKey;
    }), t.on("beforeinput", (r, s) => {
      if (!this.isEnabled)
        return;
      let o = s.inputType;
      qe.isSafari && n && o == "insertParagraph" && (o = "insertLineBreak");
      const l = s.domEvent, u = _$[o];
      if (!u)
        return;
      const h = new Qo(t, "enter", s.targetRanges[0]);
      t.fire(h, new Wo(e, l, {
        isSoft: u.isSoft
      })), h.stop.called && r.stop();
    });
  }
  /**
   * @inheritDoc
   */
  observe() {
  }
  /**
   * @inheritDoc
   */
  stopObserving() {
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class xp extends fe {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "Enter";
  }
  init() {
    const e = this.editor, t = e.editing.view, n = t.document;
    t.addObserver(qC), e.commands.add("enter", new p$(e)), this.listenTo(n, "enter", (r, s) => {
      n.isComposing || s.preventDefault(), !s.isSoft && (e.execute("enter"), t.scrollToTheSelection());
    }, { priority: "low" });
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class v$ extends Pt {
  /**
   * @inheritDoc
   */
  execute() {
    const e = this.editor.model, t = e.document;
    e.change((n) => {
      b$(e, n, t.selection), this.fire("afterExecute", { writer: n });
    });
  }
  /**
   * @inheritDoc
   */
  refresh() {
    const e = this.editor.model, t = e.document;
    this.isEnabled = w$(e.schema, t.selection);
  }
}
function w$(i, e) {
  if (e.rangeCount > 1)
    return !1;
  const t = e.anchor;
  if (!t || !i.checkChild(t, "softBreak"))
    return !1;
  const n = e.getFirstRange(), r = n.start.parent, s = n.end.parent;
  return !((bg(r, i) || bg(s, i)) && r !== s);
}
function b$(i, e, t) {
  const n = t.isCollapsed, r = t.getFirstRange(), s = r.start.parent, o = r.end.parent, l = s == o;
  if (n) {
    const u = HC(i.schema, t.getAttributes());
    Kb(i, e, r.end), e.removeSelectionAttribute(t.getAttributeKeys()), e.setSelectionAttribute(u);
  } else {
    const u = !(r.start.isAtStart && r.end.isAtEnd);
    i.deleteContent(t, { leaveUnmerged: u }), l ? Kb(i, e, t.focus) : u && e.setSelection(o, 0);
  }
}
function Kb(i, e, t) {
  const n = e.createElement("softBreak");
  i.insertContent(n, t), e.setSelection(n, "after");
}
function bg(i, e) {
  return i.is("rootElement") ? !1 : e.isLimit(i) || bg(i.parent, e);
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class KC extends fe {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "ShiftEnter";
  }
  init() {
    const e = this.editor, t = e.model.schema, n = e.conversion, r = e.editing.view, s = r.document;
    t.register("softBreak", {
      allowWhere: "$text",
      isInline: !0
    }), n.for("upcast").elementToElement({
      model: "softBreak",
      view: "br"
    }), n.for("downcast").elementToElement({
      model: "softBreak",
      view: (o, { writer: l }) => l.createEmptyElement("br")
    }), r.addObserver(qC), e.commands.add("shiftEnter", new v$(e)), this.listenTo(s, "enter", (o, l) => {
      s.isComposing || l.preventDefault(), l.isSoft && (e.execute("shiftEnter"), r.scrollToTheSelection());
    }, { priority: "low" });
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class y$ extends kt() {
  constructor() {
    super(...arguments), this._stack = [];
  }
  /**
   * Adds highlight descriptor to the stack.
   *
   * @fires change:top
   */
  add(e, t) {
    const n = this._stack, r = n[0];
    this._insertDescriptor(e);
    const s = n[0];
    r !== s && !Im(r, s) && this.fire("change:top", {
      oldDescriptor: r,
      newDescriptor: s,
      writer: t
    });
  }
  /**
   * Removes highlight descriptor from the stack.
   *
   * @fires change:top
   * @param id Id of the descriptor to remove.
   */
  remove(e, t) {
    const n = this._stack, r = n[0];
    this._removeDescriptor(e);
    const s = n[0];
    r !== s && !Im(r, s) && this.fire("change:top", {
      oldDescriptor: r,
      newDescriptor: s,
      writer: t
    });
  }
  /**
   * Inserts a given descriptor in correct place in the stack. It also takes care about updating information
   * when descriptor with same id is already present.
   */
  _insertDescriptor(e) {
    const t = this._stack, n = t.findIndex((s) => s.id === e.id);
    if (Im(e, t[n]))
      return;
    n > -1 && t.splice(n, 1);
    let r = 0;
    for (; t[r] && E$(t[r], e); )
      r++;
    t.splice(r, 0, e);
  }
  /**
   * Removes descriptor with given id from the stack.
   *
   * @param id Descriptor's id.
   */
  _removeDescriptor(e) {
    const t = this._stack, n = t.findIndex((r) => r.id === e);
    n > -1 && t.splice(n, 1);
  }
}
function Im(i, e) {
  return i && e && i.priority == e.priority && Rd(i.classes) == Rd(e.classes);
}
function E$(i, e) {
  return i.priority > e.priority ? !0 : i.priority < e.priority ? !1 : Rd(i.classes) > Rd(e.classes);
}
function Rd(i) {
  return Array.isArray(i) ? i.sort().join(",") : i;
}
const C$ = '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M4 0v1H1v3H0V.5A.5.5 0 0 1 .5 0H4zm8 0h3.5a.5.5 0 0 1 .5.5V4h-1V1h-3V0zM4 16H.5a.5.5 0 0 1-.5-.5V12h1v3h3v1zm8 0v-1h3v-3h1v3.5a.5.5 0 0 1-.5.5H12z"/><path fill-opacity=".256" d="M1 1h14v14H1z"/><g class="ck-icon__selected-indicator"><path d="M7 0h2v1H7V0zM0 7h1v2H0V7zm15 0h1v2h-1V7zm-8 8h2v1H7v-1z"/><path fill-opacity=".254" d="M1 1h14v14H1z"/></g></svg>';
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const S$ = "ck-widget", Gb = "ck-widget_selected";
function Gt(i) {
  return i.is("element") ? !!i.getCustomProperty("widget") : !1;
}
function T$(i, e, t = {}) {
  if (!i.is("containerElement"))
    throw new B("widget-to-widget-wrong-element-type", null, { element: i });
  return e.setAttribute("contenteditable", "false", i), e.addClass(S$, i), e.setCustomProperty("widget", !0, i), i.getFillerOffset = O$, e.setCustomProperty("widgetLabel", [], i), t.label && A$(i, t.label), t.hasSelectionHandle && M$(i, e), GC(i, e), i;
}
function x$(i, e, t) {
  if (e.classes && t.addClass(In(e.classes), i), e.attributes)
    for (const n in e.attributes)
      t.setAttribute(n, e.attributes[n], i);
}
function k$(i, e, t) {
  if (e.classes && t.removeClass(In(e.classes), i), e.attributes)
    for (const n in e.attributes)
      t.removeAttribute(n, i);
}
function GC(i, e, t = x$, n = k$) {
  const r = new y$();
  r.on("change:top", (l, u) => {
    u.oldDescriptor && n(i, u.oldDescriptor, u.writer), u.newDescriptor && t(i, u.newDescriptor, u.writer);
  });
  const s = (l, u, h) => r.add(u, h), o = (l, u, h) => r.remove(u, h);
  e.setCustomProperty("addHighlight", s, i), e.setCustomProperty("removeHighlight", o, i);
}
function A$(i, e) {
  i.getCustomProperty("widgetLabel").push(e);
}
function P$(i) {
  return i.getCustomProperty("widgetLabel").reduce((t, n) => typeof n == "function" ? t ? t + ". " + n() : n() : t ? t + ". " + n : n, "");
}
function I$(i, e, t = {}) {
  return e.addClass(["ck-editor__editable", "ck-editor__nested-editable"], i), e.setAttribute("role", "textbox", i), t.label && e.setAttribute("aria-label", t.label, i), e.setAttribute("contenteditable", i.isReadOnly ? "false" : "true", i), i.on("change:isReadOnly", (n, r, s) => {
    e.setAttribute("contenteditable", s ? "false" : "true", i);
  }), i.on("change:isFocused", (n, r, s) => {
    s ? e.addClass("ck-editor__nested-editable_focused", i) : e.removeClass("ck-editor__nested-editable_focused", i);
  }), GC(i, e), i;
}
function R$(i, e) {
  const t = i.getSelectedElement();
  if (t) {
    const n = Qr(i);
    if (n)
      return e.createRange(e.createPositionAt(t, n));
  }
  return yC(i, e);
}
function O$() {
  return null;
}
function M$(i, e) {
  const t = e.createUIElement("div", { class: "ck ck-widget__selection-handle" }, function(n) {
    const r = this.toDomElement(n), s = new ea();
    return s.set("content", C$), s.render(), r.appendChild(s.element), r;
  });
  e.insert(e.createPositionAt(i, 0), t), e.addClass(["ck-widget_with-selection-handle"], i);
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const xr = "widget-type-around";
function xs(i, e, t) {
  return !!i && Gt(i) && !t.isInline(e);
}
function N$(i) {
  return i.closest(".ck-widget__type-around__button");
}
function D$(i) {
  return i.classList.contains("ck-widget__type-around__button_before") ? "before" : "after";
}
function B$(i, e) {
  const t = i.closest(".ck-widget");
  return e.mapDomToView(t);
}
function Qr(i) {
  return i.getAttribute(xr);
}
const V$ = '<svg viewBox="0 0 10 8" xmlns="http://www.w3.org/2000/svg"><path d="M9.055.263v3.972h-6.77M1 4.216l2-2.038m-2 2 2 2.038"/></svg>';
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const YC = ["before", "after"], L$ = new DOMParser().parseFromString(V$, "image/svg+xml").firstChild, Yb = "ck-widget__type-around_disabled";
class F$ extends fe {
  constructor() {
    super(...arguments), this._currentFakeCaretModelElement = null;
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "WidgetTypeAround";
  }
  /**
   * @inheritDoc
   */
  static get requires() {
    return [xp, ia];
  }
  /**
   * @inheritDoc
   */
  init() {
    const e = this.editor, t = e.editing.view;
    this.on("change:isEnabled", (n, r, s) => {
      t.change((o) => {
        for (const l of t.document.roots)
          s ? o.removeClass(Yb, l) : o.addClass(Yb, l);
      }), s || e.model.change((o) => {
        o.removeSelectionAttribute(xr);
      });
    }), this._enableTypeAroundUIInjection(), this._enableInsertingParagraphsOnButtonClick(), this._enableInsertingParagraphsOnEnterKeypress(), this._enableInsertingParagraphsOnTypingKeystroke(), this._enableTypeAroundFakeCaretActivationUsingKeyboardArrows(), this._enableDeleteIntegration(), this._enableInsertContentIntegration(), this._enableInsertObjectIntegration(), this._enableDeleteContentIntegration();
  }
  /**
   * @inheritDoc
   */
  destroy() {
    super.destroy(), this._currentFakeCaretModelElement = null;
  }
  /**
   * Inserts a new paragraph next to a widget element with the selection anchored in it.
   *
   * **Note**: This method is heavily user-oriented and will both focus the editing view and scroll
   * the viewport to the selection in the inserted paragraph.
   *
   * @param widgetModelElement The model widget element next to which a paragraph is inserted.
   * @param position The position where the paragraph is inserted. Either `'before'` or `'after'` the widget.
   */
  _insertParagraph(e, t) {
    const n = this.editor, r = n.editing.view, s = n.model.schema.getAttributesWithProperty(e, "copyOnReplace", !0);
    n.execute("insertParagraph", {
      position: n.model.createPositionAt(e, t),
      attributes: s
    }), r.focus(), r.scrollToTheSelection();
  }
  /**
   * A wrapper for the {@link module:utils/emittermixin~Emitter#listenTo} method that executes the callbacks only
   * when the plugin {@link #isEnabled is enabled}.
   *
   * @param emitter The object that fires the event.
   * @param event The name of the event.
   * @param callback The function to be called on event.
   * @param options Additional options.
   * @param options.priority The priority of this event callback. The higher the priority value the sooner
   * the callback will be fired. Events having the same priority are called in the order they were added.
   */
  _listenToIfEnabled(e, t, n, r) {
    this.listenTo(e, t, (...s) => {
      this.isEnabled && n(...s);
    }, r);
  }
  /**
   * Similar to {@link #_insertParagraph}, this method inserts a paragraph except that it
   * does not expect a position. Instead, it performs the insertion next to a selected widget
   * according to the `widget-type-around` model selection attribute value (fake caret position).
   *
   * Because this method requires the `widget-type-around` attribute to be set,
   * the insertion can only happen when the widget's fake caret is active (e.g. activated
   * using the keyboard).
   *
   * @returns Returns `true` when the paragraph was inserted (the attribute was present) and `false` otherwise.
   */
  _insertParagraphAccordingToFakeCaretPosition() {
    const n = this.editor.model.document.selection, r = Qr(n);
    if (!r)
      return !1;
    const s = n.getSelectedElement();
    return this._insertParagraph(s, r), !0;
  }
  /**
   * Creates a listener in the editing conversion pipeline that injects the widget type around
   * UI into every single widget instance created in the editor.
   *
   * The UI is delivered as a {@link module:engine/view/uielement~UIElement}
   * wrapper which renders DOM buttons that users can use to insert paragraphs.
   */
  _enableTypeAroundUIInjection() {
    const e = this.editor, t = e.model.schema, n = e.locale.t, r = {
      before: n("Insert paragraph before block"),
      after: n("Insert paragraph after block")
    };
    e.editing.downcastDispatcher.on("insert", (s, o, l) => {
      const u = l.mapper.toViewElement(o.item);
      u && xs(u, o.item, t) && ($$(l.writer, r, u), u.getCustomProperty("widgetLabel").push(() => this.isEnabled ? n("Press Enter to type after or press Shift + Enter to type before the widget") : ""));
    }, { priority: "low" });
  }
  /**
   * Brings support for the fake caret that appears when either:
   *
   * * the selection moves to a widget from a position next to it using arrow keys,
   * * the arrow key is pressed when the widget is already selected.
   *
   * The fake caret lets the user know that they can start typing or just press
   * <kbd>Enter</kbd> to insert a paragraph at the position next to a widget as suggested by the fake caret.
   *
   * The fake caret disappears when the user changes the selection or the editor
   * gets blurred.
   *
   * The whole idea is as follows:
   *
   * 1. A user does one of the 2 scenarios described at the beginning.
   * 2. The "keydown" listener is executed and the decision is made whether to show or hide the fake caret.
   * 3. If it should show up, the `widget-type-around` model selection attribute is set indicating
   *    on which side of the widget it should appear.
   * 4. The selection dispatcher reacts to the selection attribute and sets CSS classes responsible for the
   *    fake caret on the view widget.
   * 5. If the fake caret should disappear, the selection attribute is removed and the dispatcher
   *    does the CSS class clean-up in the view.
   * 6. Additionally, `change:range` and `FocusTracker#isFocused` listeners also remove the selection
   *    attribute (the former also removes widget CSS classes).
   */
  _enableTypeAroundFakeCaretActivationUsingKeyboardArrows() {
    const e = this.editor, t = e.model, n = t.document.selection, r = t.schema, s = e.editing.view;
    this._listenToIfEnabled(s.document, "arrowKey", (l, u) => {
      this._handleArrowKeyPress(l, u);
    }, { context: [Gt, "$text"], priority: "high" }), this._listenToIfEnabled(n, "change:range", (l, u) => {
      u.directChange && e.model.change((h) => {
        h.removeSelectionAttribute(xr);
      });
    }), this._listenToIfEnabled(t.document, "change:data", () => {
      const l = n.getSelectedElement();
      if (l) {
        const u = e.editing.mapper.toViewElement(l);
        if (xs(u, l, r))
          return;
      }
      e.model.change((u) => {
        u.removeSelectionAttribute(xr);
      });
    }), this._listenToIfEnabled(e.editing.downcastDispatcher, "selection", (l, u, h) => {
      const f = h.writer;
      if (this._currentFakeCaretModelElement) {
        const k = h.mapper.toViewElement(this._currentFakeCaretModelElement);
        k && (f.removeClass(YC.map(o), k), this._currentFakeCaretModelElement = null);
      }
      const m = u.selection.getSelectedElement();
      if (!m)
        return;
      const v = h.mapper.toViewElement(m);
      if (!xs(v, m, r))
        return;
      const C = Qr(u.selection);
      C && (f.addClass(o(C), v), this._currentFakeCaretModelElement = m);
    }), this._listenToIfEnabled(e.ui.focusTracker, "change:isFocused", (l, u, h) => {
      h || e.model.change((f) => {
        f.removeSelectionAttribute(xr);
      });
    });
    function o(l) {
      return `ck-widget_type-around_show-fake-caret_${l}`;
    }
  }
  /**
   * A listener executed on each "keydown" in the view document, a part of
   * {@link #_enableTypeAroundFakeCaretActivationUsingKeyboardArrows}.
   *
   * It decides whether the arrow keypress should activate the fake caret or not (also whether it should
   * be deactivated).
   *
   * The fake caret activation is done by setting the `widget-type-around` model selection attribute
   * in this listener, and stopping and preventing the event that would normally be handled by the widget
   * plugin that is responsible for the regular keyboard navigation near/across all widgets (that
   * includes inline widgets, which are ignored by the widget type around plugin).
   */
  _handleArrowKeyPress(e, t) {
    const n = this.editor, r = n.model, s = r.document.selection, o = r.schema, l = n.editing.view, u = t.keyCode, h = MB(u, n.locale.contentLanguageDirection), f = l.document.selection.getSelectedElement(), m = n.editing.mapper.toModelElement(f);
    let v;
    xs(f, m, o) ? v = this._handleArrowKeyPressOnSelectedWidget(h) : s.isCollapsed ? v = this._handleArrowKeyPressWhenSelectionNextToAWidget(h) : t.shiftKey || (v = this._handleArrowKeyPressWhenNonCollapsedSelection(h)), v && (t.preventDefault(), e.stop());
  }
  /**
   * Handles the keyboard navigation on "keydown" when a widget is currently selected and activates or deactivates
   * the fake caret for that widget, depending on the current value of the `widget-type-around` model
   * selection attribute and the direction of the pressed arrow key.
   *
   * @param isForward `true` when the pressed arrow key was responsible for the forward model selection movement
   * as in {@link module:utils/keyboard~isForwardArrowKeyCode}.
   * @returns Returns `true` when the keypress was handled and no other keydown listener of the editor should
   * process the event any further. Returns `false` otherwise.
   */
  _handleArrowKeyPressOnSelectedWidget(e) {
    const n = this.editor.model, r = n.document.selection, s = Qr(r);
    return n.change((o) => {
      if (s) {
        if (!(s === (e ? "after" : "before")))
          return o.removeSelectionAttribute(xr), !0;
      } else
        return o.setSelectionAttribute(xr, e ? "after" : "before"), !0;
      return !1;
    });
  }
  /**
   * Handles the keyboard navigation on "keydown" when **no** widget is selected but the selection is **directly** next
   * to one and upon the fake caret should become active for this widget upon arrow keypress
   * (AKA entering/selecting the widget).
   *
   * **Note**: This code mirrors the implementation from the widget plugin but also adds the selection attribute.
   * Unfortunately, there is no safe way to let the widget plugin do the selection part first and then just set the
   * selection attribute here in the widget type around plugin. This is why this code must duplicate some from the widget plugin.
   *
   * @param isForward `true` when the pressed arrow key was responsible for the forward model selection movement
   * as in {@link module:utils/keyboard~isForwardArrowKeyCode}.
   * @returns Returns `true` when the keypress was handled and no other keydown listener of the editor should
   * process the event any further. Returns `false` otherwise.
   */
  _handleArrowKeyPressWhenSelectionNextToAWidget(e) {
    const t = this.editor, n = t.model, r = n.schema, s = t.plugins.get("Widget"), o = s._getObjectElementNextToSelection(e), l = t.editing.mapper.toViewElement(o);
    return xs(l, o, r) ? (n.change((u) => {
      s._setSelectionOverElement(o), u.setSelectionAttribute(xr, e ? "before" : "after");
    }), !0) : !1;
  }
  /**
   * Handles the keyboard navigation on "keydown" when a widget is currently selected (together with some other content)
   * and the widget is the first or last element in the selection. It activates or deactivates the fake caret for that widget.
   *
   * @param isForward `true` when the pressed arrow key was responsible for the forward model selection movement
   * as in {@link module:utils/keyboard~isForwardArrowKeyCode}.
   * @returns Returns `true` when the keypress was handled and no other keydown listener of the editor should
   * process the event any further. Returns `false` otherwise.
   */
  _handleArrowKeyPressWhenNonCollapsedSelection(e) {
    const t = this.editor, n = t.model, r = n.schema, s = t.editing.mapper, o = n.document.selection, l = e ? o.getLastPosition().nodeBefore : o.getFirstPosition().nodeAfter, u = s.toViewElement(l);
    return xs(u, l, r) ? (n.change((h) => {
      h.setSelection(l, "on"), h.setSelectionAttribute(xr, e ? "after" : "before");
    }), !0) : !1;
  }
  /**
   * Registers a `mousedown` listener for the view document which intercepts events
   * coming from the widget type around UI, which happens when a user clicks one of the buttons
   * that insert a paragraph next to a widget.
   */
  _enableInsertingParagraphsOnButtonClick() {
    const e = this.editor, t = e.editing.view;
    this._listenToIfEnabled(t.document, "mousedown", (n, r) => {
      const s = N$(r.domTarget);
      if (!s)
        return;
      const o = D$(s), l = B$(s, t.domConverter), u = e.editing.mapper.toModelElement(l);
      this._insertParagraph(u, o), r.preventDefault(), n.stop();
    });
  }
  /**
   * Creates the <kbd>Enter</kbd> key listener on the view document that allows the user to insert a paragraph
   * near the widget when either:
   *
   * * The fake caret was first activated using the arrow keys,
   * * The entire widget is selected in the model.
   *
   * In the first case, the new paragraph is inserted according to the `widget-type-around` selection
   * attribute (see {@link #_handleArrowKeyPress}).
   *
   * In the second case, the new paragraph is inserted based on whether a soft (<kbd>Shift</kbd>+<kbd>Enter</kbd>) keystroke
   * was pressed or not.
   */
  _enableInsertingParagraphsOnEnterKeypress() {
    const e = this.editor, t = e.model.document.selection, n = e.editing.view;
    this._listenToIfEnabled(n.document, "enter", (r, s) => {
      if (r.eventPhase != "atTarget")
        return;
      const o = t.getSelectedElement(), l = e.editing.mapper.toViewElement(o), u = e.model.schema;
      let h;
      this._insertParagraphAccordingToFakeCaretPosition() ? h = !0 : xs(l, o, u) && (this._insertParagraph(o, s.isSoft ? "before" : "after"), h = !0), h && (s.preventDefault(), r.stop());
    }, { context: Gt });
  }
  /**
   * Similar to the {@link #_enableInsertingParagraphsOnEnterKeypress}, it allows the user
   * to insert a paragraph next to a widget when the fake caret was activated using arrow
   * keys but it responds to typing instead of <kbd>Enter</kbd>.
   *
   * Listener enabled by this method will insert a new paragraph according to the `widget-type-around`
   * model selection attribute as the user simply starts typing, which creates the impression that the fake caret
   * behaves like a real one rendered by the browser (AKA your text appears where the caret was).
   *
   * **Note**: At the moment this listener creates 2 undo steps: one for the `insertParagraph` command
   * and another one for actual typing. It is not a disaster but this may need to be fixed
   * sooner or later.
   */
  _enableInsertingParagraphsOnTypingKeystroke() {
    const t = this.editor.editing.view.document;
    this._listenToIfEnabled(t, "insertText", (n, r) => {
      this._insertParagraphAccordingToFakeCaretPosition() && (r.selection = t.selection);
    }, { priority: "high" }), qe.isAndroid ? this._listenToIfEnabled(t, "keydown", (n, r) => {
      r.keyCode == 229 && this._insertParagraphAccordingToFakeCaretPosition();
    }) : this._listenToIfEnabled(t, "compositionstart", () => {
      this._insertParagraphAccordingToFakeCaretPosition();
    }, { priority: "high" });
  }
  /**
   * It creates a "delete" event listener on the view document to handle cases when the <kbd>Delete</kbd> or <kbd>Backspace</kbd>
   * is pressed and the fake caret is currently active.
   *
   * The fake caret should create an illusion of a real browser caret so that when it appears before or after
   * a widget, pressing <kbd>Delete</kbd> or <kbd>Backspace</kbd> should remove a widget or delete the content
   * before or after a widget (depending on the content surrounding the widget).
   */
  _enableDeleteIntegration() {
    const e = this.editor, t = e.editing.view, n = e.model, r = n.schema;
    this._listenToIfEnabled(t.document, "delete", (s, o) => {
      if (s.eventPhase != "atTarget")
        return;
      const l = Qr(n.document.selection);
      if (!l)
        return;
      const u = o.direction, h = n.document.selection.getSelectedElement(), f = l === "before", m = u == "forward";
      if (f === m)
        e.execute("delete", {
          selection: n.createSelection(h, "on")
        });
      else {
        const C = r.getNearestSelectionRange(n.createPositionAt(h, l), u);
        if (C)
          if (!C.isCollapsed)
            n.change((k) => {
              k.setSelection(C), e.execute(m ? "deleteForward" : "delete");
            });
          else {
            const k = n.createSelection(C.start);
            if (n.modifySelection(k, { direction: u }), !k.focus.isEqual(C.start))
              n.change((S) => {
                S.setSelection(C), e.execute(m ? "deleteForward" : "delete");
              });
            else {
              const S = j$(r, C.start.parent);
              n.deleteContent(n.createSelection(S, "on"), {
                doNotAutoparagraph: !0
              });
            }
          }
      }
      o.preventDefault(), s.stop();
    }, { context: Gt });
  }
  /**
   * Attaches the {@link module:engine/model/model~Model#event:insertContent} event listener that, for instance, allows the user to paste
   * content near a widget when the fake caret is first activated using the arrow keys.
   *
   * The content is inserted according to the `widget-type-around` selection attribute (see {@link #_handleArrowKeyPress}).
   */
  _enableInsertContentIntegration() {
    const e = this.editor, t = this.editor.model, n = t.document.selection;
    this._listenToIfEnabled(e.model, "insertContent", (r, [s, o]) => {
      if (o && !o.is("documentSelection"))
        return;
      const l = Qr(n);
      if (l)
        return r.stop(), t.change((u) => {
          const h = n.getSelectedElement(), f = t.createPositionAt(h, l), m = u.createSelection(f), v = t.insertContent(s, m);
          return u.setSelection(m), v;
        });
    }, { priority: "high" });
  }
  /**
   * Attaches the {@link module:engine/model/model~Model#event:insertObject} event listener that modifies the
   * `options.findOptimalPosition`parameter to position of fake caret in relation to selected element
   * to reflect user's intent of desired insertion position.
   *
   * The object is inserted according to the `widget-type-around` selection attribute (see {@link #_handleArrowKeyPress}).
   */
  _enableInsertObjectIntegration() {
    const e = this.editor, n = this.editor.model.document.selection;
    this._listenToIfEnabled(e.model, "insertObject", (r, s) => {
      const [, o, l = {}] = s;
      if (o && !o.is("documentSelection"))
        return;
      const u = Qr(n);
      u && (l.findOptimalPosition = u, s[3] = l);
    }, { priority: "high" });
  }
  /**
   * Attaches the {@link module:engine/model/model~Model#event:deleteContent} event listener to block the event when the fake
   * caret is active.
   *
   * This is required for cases that trigger {@link module:engine/model/model~Model#deleteContent `model.deleteContent()`}
   * before calling {@link module:engine/model/model~Model#insertContent `model.insertContent()`} like, for instance,
   * plain text pasting.
   */
  _enableDeleteContentIntegration() {
    const e = this.editor, n = this.editor.model.document.selection;
    this._listenToIfEnabled(e.model, "deleteContent", (r, [s]) => {
      if (s && !s.is("documentSelection"))
        return;
      Qr(n) && r.stop();
    }, { priority: "high" });
  }
}
function $$(i, e, t) {
  const n = i.createUIElement("div", {
    class: "ck ck-reset_all ck-widget__type-around"
  }, function(r) {
    const s = this.toDomElement(r);
    return z$(s, e), W$(s), s;
  });
  i.insert(i.createPositionAt(t, "end"), n);
}
function z$(i, e) {
  for (const t of YC) {
    const n = new Li({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-widget__type-around__button",
          `ck-widget__type-around__button_${t}`
        ],
        title: e[t],
        "aria-hidden": "true"
      },
      children: [
        i.ownerDocument.importNode(L$, !0)
      ]
    });
    i.appendChild(n.render());
  }
}
function W$(i) {
  const e = new Li({
    tag: "div",
    attributes: {
      class: [
        "ck",
        "ck-widget__type-around__fake-caret"
      ]
    }
  });
  i.appendChild(e.render());
}
function j$(i, e) {
  let t = e;
  for (const n of e.getAncestors({ parentFirst: !0 })) {
    if (n.childCount > 1 || i.isLimit(n))
      break;
    t = n;
  }
  return t;
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function U$(i) {
  const e = i.model;
  return (t, n) => {
    const r = n.keyCode == tt.arrowup, s = n.keyCode == tt.arrowdown, o = n.shiftKey, l = e.document.selection;
    if (!r && !s)
      return;
    const u = s;
    if (o && K$(l, u))
      return;
    const h = H$(i, l, u);
    if (h) {
      if (h.isCollapsed) {
        if (l.isCollapsed)
          return;
        if (o)
          return;
      }
      (h.isCollapsed || q$(i, h, u)) && (e.change((f) => {
        const m = u ? h.end : h.start;
        if (o) {
          const v = e.createSelection(l.anchor);
          v.setFocus(m), f.setSelection(v);
        } else
          f.setSelection(m);
      }), t.stop(), n.preventDefault(), n.stopPropagation());
    }
  };
}
function H$(i, e, t) {
  const n = i.model;
  if (t) {
    const r = e.isCollapsed ? e.focus : e.getLastPosition(), s = Jb(n, r, "forward");
    if (!s)
      return null;
    const o = n.createRange(r, s), l = Xb(n.schema, o, "backward");
    return l ? n.createRange(r, l) : null;
  } else {
    const r = e.isCollapsed ? e.focus : e.getFirstPosition(), s = Jb(n, r, "backward");
    if (!s)
      return null;
    const o = n.createRange(s, r), l = Xb(n.schema, o, "forward");
    return l ? n.createRange(l, r) : null;
  }
}
function Jb(i, e, t) {
  const n = i.schema, r = i.createRangeIn(e.root), s = t == "forward" ? "elementStart" : "elementEnd";
  for (const { previousPosition: o, item: l, type: u } of r.getWalker({ startPosition: e, direction: t })) {
    if (n.isLimit(l) && !n.isInline(l))
      return o;
    if (u == s && n.isBlock(l))
      return null;
  }
  return null;
}
function Xb(i, e, t) {
  const n = t == "backward" ? e.end : e.start;
  if (i.checkChild(n, "$text"))
    return n;
  for (const { nextPosition: r } of e.getWalker({ direction: t }))
    if (i.checkChild(r, "$text"))
      return r;
  return null;
}
function q$(i, e, t) {
  const n = i.model, r = i.view.domConverter;
  if (t) {
    const h = n.createSelection(e.start);
    n.modifySelection(h), !h.focus.isAtEnd && !e.start.isEqual(h.focus) && (e = n.createRange(h.focus, e.end));
  }
  const s = i.mapper.toViewRange(e), o = r.viewRangeToDom(s), l = pt.getDomRangeRects(o);
  let u;
  for (const h of l) {
    if (u === void 0) {
      u = Math.round(h.bottom);
      continue;
    }
    if (Math.round(h.top) >= u)
      return !1;
    u = Math.max(u, Math.round(h.bottom));
  }
  return !0;
}
function K$(i, e) {
  return !i.isCollapsed && i.isBackward == e;
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class kp extends fe {
  constructor() {
    super(...arguments), this._previouslySelected = /* @__PURE__ */ new Set();
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "Widget";
  }
  /**
   * @inheritDoc
   */
  static get requires() {
    return [F$, ia];
  }
  /**
   * @inheritDoc
   */
  init() {
    const e = this.editor, t = e.editing.view, n = t.document;
    this.editor.editing.downcastDispatcher.on("selection", (r, s, o) => {
      const l = o.writer, u = s.selection;
      if (u.isCollapsed)
        return;
      const h = u.getSelectedElement();
      if (!h)
        return;
      const f = e.editing.mapper.toViewElement(h);
      Gt(f) && o.consumable.consume(u, "selection") && l.setSelection(l.createRangeOn(f), {
        fake: !0,
        label: P$(f)
      });
    }), this.editor.editing.downcastDispatcher.on("selection", (r, s, o) => {
      this._clearPreviouslySelectedWidgets(o.writer);
      const l = o.writer, u = l.document.selection;
      let h = null;
      for (const f of u.getRanges())
        for (const m of f) {
          const v = m.item;
          Gt(v) && !Y$(v, h) && (l.addClass(Gb, v), this._previouslySelected.add(v), h = v);
        }
    }, { priority: "low" }), t.addObserver(uh), this.listenTo(n, "mousedown", (...r) => this._onMousedown(...r)), this.listenTo(n, "arrowKey", (...r) => {
      this._handleSelectionChangeOnArrowKeyPress(...r);
    }, { context: [Gt, "$text"] }), this.listenTo(n, "arrowKey", (...r) => {
      this._preventDefaultOnArrowKeyPress(...r);
    }, { context: "$root" }), this.listenTo(n, "arrowKey", U$(this.editor.editing), { context: "$text" }), this.listenTo(n, "delete", (r, s) => {
      this._handleDelete(s.direction == "forward") && (s.preventDefault(), r.stop());
    }, { context: "$root" });
  }
  /**
   * Handles {@link module:engine/view/document~Document#event:mousedown mousedown} events on widget elements.
   */
  _onMousedown(e, t) {
    const n = this.editor, r = n.editing.view, s = r.document;
    let o = t.target;
    if (G$(o)) {
      if ((qe.isSafari || qe.isGecko) && t.domEvent.detail >= 3) {
        const u = n.editing.mapper, h = o.is("attributeElement") ? o.findAncestor((m) => !m.is("attributeElement")) : o, f = u.toModelElement(h);
        t.preventDefault(), this.editor.model.change((m) => {
          m.setSelection(f, "in");
        });
      }
      return;
    }
    if (!Gt(o) && (o = o.findAncestor(Gt), !o))
      return;
    qe.isAndroid && t.preventDefault(), s.isFocused || r.focus();
    const l = n.editing.mapper.toModelElement(o);
    this._setSelectionOverElement(l);
  }
  /**
   * Handles {@link module:engine/view/document~Document#event:keydown keydown} events and changes
   * the model selection when:
   *
   * * arrow key is pressed when the widget is selected,
   * * the selection is next to a widget and the widget should become selected upon the arrow key press.
   *
   * See {@link #_preventDefaultOnArrowKeyPress}.
   */
  _handleSelectionChangeOnArrowKeyPress(e, t) {
    const n = t.keyCode, r = this.editor.model, s = r.schema, o = r.document.selection, l = o.getSelectedElement(), u = kE(n, this.editor.locale.contentLanguageDirection), h = u == "down" || u == "right", f = u == "up" || u == "down";
    if (l && s.isObject(l)) {
      const v = h ? o.getLastPosition() : o.getFirstPosition(), C = s.getNearestSelectionRange(v, h ? "forward" : "backward");
      C && (r.change((k) => {
        k.setSelection(C);
      }), t.preventDefault(), e.stop());
      return;
    }
    if (!o.isCollapsed && !t.shiftKey) {
      const v = o.getFirstPosition(), C = o.getLastPosition(), k = v.nodeAfter, S = C.nodeBefore;
      (k && s.isObject(k) || S && s.isObject(S)) && (r.change((x) => {
        x.setSelection(h ? C : v);
      }), t.preventDefault(), e.stop());
      return;
    }
    if (!o.isCollapsed)
      return;
    const m = this._getObjectElementNextToSelection(h);
    if (m && s.isObject(m)) {
      if (s.isInline(m) && f)
        return;
      this._setSelectionOverElement(m), t.preventDefault(), e.stop();
    }
  }
  /**
   * Handles {@link module:engine/view/document~Document#event:keydown keydown} events and prevents
   * the default browser behavior to make sure the fake selection is not being moved from a fake selection
   * container.
   *
   * See {@link #_handleSelectionChangeOnArrowKeyPress}.
   */
  _preventDefaultOnArrowKeyPress(e, t) {
    const n = this.editor.model, r = n.schema, s = n.document.selection.getSelectedElement();
    s && r.isObject(s) && (t.preventDefault(), e.stop());
  }
  /**
   * Handles delete keys: backspace and delete.
   *
   * @param isForward Set to true if delete was performed in forward direction.
   * @returns Returns `true` if keys were handled correctly.
   */
  _handleDelete(e) {
    if (this.editor.isReadOnly)
      return;
    const n = this.editor.model.document.selection;
    if (!n.isCollapsed)
      return;
    const r = this._getObjectElementNextToSelection(e);
    if (r)
      return this.editor.model.change((s) => {
        let o = n.anchor.parent;
        for (; o.isEmpty; ) {
          const l = o;
          o = l.parent, s.remove(l);
        }
        this._setSelectionOverElement(r);
      }), !0;
  }
  /**
   * Sets {@link module:engine/model/selection~Selection document's selection} over given element.
   *
   * @internal
   */
  _setSelectionOverElement(e) {
    this.editor.model.change((t) => {
      t.setSelection(t.createRangeOn(e));
    });
  }
  /**
   * Checks if {@link module:engine/model/element~Element element} placed next to the current
   * {@link module:engine/model/selection~Selection model selection} exists and is marked in
   * {@link module:engine/model/schema~Schema schema} as `object`.
   *
   * @internal
   * @param forward Direction of checking.
   */
  _getObjectElementNextToSelection(e) {
    const t = this.editor.model, n = t.schema, r = t.document.selection, s = t.createSelection(r);
    if (t.modifySelection(s, { direction: e ? "forward" : "backward" }), s.isEqual(r))
      return null;
    const o = e ? s.focus.nodeBefore : s.focus.nodeAfter;
    return o && n.isObject(o) ? o : null;
  }
  /**
   * Removes CSS class from previously selected widgets.
   */
  _clearPreviouslySelectedWidgets(e) {
    for (const t of this._previouslySelected)
      e.removeClass(Gb, t);
    this._previouslySelected.clear();
  }
}
function G$(i) {
  let e = i;
  for (; e; ) {
    if (e.is("editableElement") && !e.is("rootElement"))
      return !0;
    if (Gt(e))
      return !1;
    e = e.parent;
  }
  return !1;
}
function Y$(i, e) {
  return e ? Array.from(i.getAncestors()).includes(e) : !1;
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class Zb extends fe {
  constructor() {
    super(...arguments), this._toolbarDefinitions = /* @__PURE__ */ new Map();
  }
  /**
   * @inheritDoc
   */
  static get requires() {
    return [qo];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "WidgetToolbarRepository";
  }
  /**
   * @inheritDoc
   */
  init() {
    const e = this.editor;
    if (e.plugins.has("BalloonToolbar")) {
      const t = e.plugins.get("BalloonToolbar");
      this.listenTo(t, "show", (n) => {
        J$(e.editing.view.document.selection) && n.stop();
      }, { priority: "high" });
    }
    this._balloon = this.editor.plugins.get("ContextualBalloon"), this.on("change:isEnabled", () => {
      this._updateToolbarsVisibility();
    }), this.listenTo(e.ui, "update", () => {
      this._updateToolbarsVisibility();
    }), this.listenTo(e.ui.focusTracker, "change:isFocused", () => {
      this._updateToolbarsVisibility();
    }, { priority: "low" });
  }
  destroy() {
    super.destroy();
    for (const e of this._toolbarDefinitions.values())
      e.view.destroy();
  }
  /**
   * Registers toolbar in the WidgetToolbarRepository. It renders it in the `ContextualBalloon` based on the value of the invoked
   * `getRelatedElement` function. Toolbar items are gathered from `items` array.
   * The balloon's CSS class is by default `ck-toolbar-container` and may be override with the `balloonClassName` option.
   *
   * Note: This method should be called in the {@link module:core/plugin~PluginInterface#afterInit `Plugin#afterInit()`}
   * callback (or later) to make sure that the given toolbar items were already registered by other plugins.
   *
   * @param toolbarId An id for the toolbar. Used to
   * @param options.ariaLabel Label used by assistive technologies to describe this toolbar element.
   * @param options.items Array of toolbar items.
   * @param options.getRelatedElement Callback which returns an element the toolbar should be attached to.
   * @param options.balloonClassName CSS class for the widget balloon.
   */
  register(e, { ariaLabel: t, items: n, getRelatedElement: r, balloonClassName: s = "ck-toolbar-container" }) {
    if (!n.length) {
      Yt("widget-toolbar-no-items", { toolbarId: e });
      return;
    }
    const o = this.editor, l = o.t, u = new na(o.locale);
    if (u.ariaLabel = t || l("Widget toolbar"), this._toolbarDefinitions.has(e))
      throw new B("widget-toolbar-duplicated", this, { toolbarId: e });
    const h = {
      view: u,
      getRelatedElement: r,
      balloonClassName: s,
      itemsConfig: n,
      initialized: !1
    };
    o.ui.addToolbar(u, {
      isContextual: !0,
      beforeFocus: () => {
        const f = r(o.editing.view.document.selection);
        f && this._showToolbar(h, f);
      },
      afterBlur: () => {
        this._hideToolbar(h);
      }
    }), this._toolbarDefinitions.set(e, h);
  }
  /**
   * Iterates over stored toolbars and makes them visible or hidden.
   */
  _updateToolbarsVisibility() {
    let e = 0, t = null, n = null;
    for (const r of this._toolbarDefinitions.values()) {
      const s = r.getRelatedElement(this.editor.editing.view.document.selection);
      if (!this.isEnabled || !s)
        this._isToolbarInBalloon(r) && this._hideToolbar(r);
      else if (!this.editor.ui.focusTracker.isFocused)
        this._isToolbarVisible(r) && this._hideToolbar(r);
      else {
        const o = s.getAncestors().length;
        o > e && (e = o, t = s, n = r);
      }
    }
    n && this._showToolbar(n, t);
  }
  /**
   * Hides the given toolbar.
   */
  _hideToolbar(e) {
    this._balloon.remove(e.view), this.stopListening(this._balloon, "change:visibleView");
  }
  /**
   * Shows up the toolbar if the toolbar is not visible.
   * Otherwise, repositions the toolbar's balloon when toolbar's view is the most top view in balloon stack.
   *
   * It might happen here that the toolbar's view is under another view. Then do nothing as the other toolbar view
   * should be still visible after the {@link module:ui/editorui/editorui~EditorUI#event:update}.
   */
  _showToolbar(e, t) {
    this._isToolbarVisible(e) ? Qb(this.editor, t) : this._isToolbarInBalloon(e) || (e.initialized || (e.initialized = !0, e.view.fillFromConfig(e.itemsConfig, this.editor.ui.componentFactory)), this._balloon.add({
      view: e.view,
      position: JC(this.editor, t),
      balloonClassName: e.balloonClassName
    }), this.listenTo(this._balloon, "change:visibleView", () => {
      for (const n of this._toolbarDefinitions.values())
        if (this._isToolbarVisible(n)) {
          const r = n.getRelatedElement(this.editor.editing.view.document.selection);
          Qb(this.editor, r);
        }
    }));
  }
  _isToolbarVisible(e) {
    return this._balloon.visibleView === e.view;
  }
  _isToolbarInBalloon(e) {
    return this._balloon.hasView(e.view);
  }
}
function Qb(i, e) {
  const t = i.plugins.get("ContextualBalloon"), n = JC(i, e);
  t.updatePosition(n);
}
function JC(i, e) {
  const t = i.editing.view, n = gn.defaultPositions;
  return {
    target: t.domConverter.mapViewToDom(e),
    positions: [
      n.northArrowSouth,
      n.northArrowSouthWest,
      n.northArrowSouthEast,
      n.southArrowNorth,
      n.southArrowNorthWest,
      n.southArrowNorthEast,
      n.viewportStickyNorth
    ]
  };
}
function J$(i) {
  const e = i.getSelectedElement();
  return !!(e && Gt(e));
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class X$ extends Nt() {
  /**
   * @param options Resizer options.
   */
  constructor(e) {
    super(), this.set("activeHandlePosition", null), this.set("proposedWidthPercents", null), this.set("proposedWidth", null), this.set("proposedHeight", null), this.set("proposedHandleHostWidth", null), this.set("proposedHandleHostHeight", null), this._options = e, this._referenceCoordinates = null;
  }
  /**
   * The original width (pixels) of the resized object when the resize process was started.
   */
  get originalWidth() {
    return this._originalWidth;
  }
  /**
   * The original height (pixels) of the resized object when the resize process was started.
   */
  get originalHeight() {
    return this._originalHeight;
  }
  /**
   * The original width (percents) of the resized object when the resize process was started.
   */
  get originalWidthPercents() {
    return this._originalWidthPercents;
  }
  /**
   * A width to height ratio of the resized image.
   */
  get aspectRatio() {
    return this._aspectRatio;
  }
  /**
   *
   * @param domResizeHandle The handle used to calculate the reference point.
   */
  begin(e, t, n) {
    const r = new pt(t);
    this.activeHandlePosition = tz(e), this._referenceCoordinates = Q$(t, nz(this.activeHandlePosition)), this._originalWidth = r.width, this._originalHeight = r.height, this._aspectRatio = r.width / r.height;
    const s = n.style.width;
    s && s.match(/^\d+(\.\d*)?%$/) ? this._originalWidthPercents = parseFloat(s) : this._originalWidthPercents = Z$(n, r);
  }
  update(e) {
    this.proposedWidth = e.width, this.proposedHeight = e.height, this.proposedWidthPercents = e.widthPercents, this.proposedHandleHostWidth = e.handleHostWidth, this.proposedHandleHostHeight = e.handleHostHeight;
  }
}
function Z$(i, e) {
  const t = i.parentElement;
  let n = parseFloat(t.ownerDocument.defaultView.getComputedStyle(t).width);
  const r = 5;
  let s = 0, o = t;
  for (; isNaN(n); ) {
    if (o = o.parentElement, ++s > r)
      return 0;
    n = parseFloat(t.ownerDocument.defaultView.getComputedStyle(o).width);
  }
  return e.width / n * 100;
}
function Q$(i, e) {
  const t = new pt(i), n = e.split("-"), r = {
    x: n[1] == "right" ? t.right : t.left,
    y: n[0] == "bottom" ? t.bottom : t.top
  };
  return r.x += i.ownerDocument.defaultView.scrollX, r.y += i.ownerDocument.defaultView.scrollY, r;
}
function ez(i) {
  return `ck-widget__resizer__handle-${i}`;
}
function tz(i) {
  const e = ["top-left", "top-right", "bottom-right", "bottom-left"];
  for (const t of e)
    if (i.classList.contains(ez(t)))
      return t;
}
function nz(i) {
  const e = i.split("-"), t = {
    top: "bottom",
    bottom: "top",
    left: "right",
    right: "left"
  };
  return `${t[e[0]]}-${t[e[1]]}`;
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class iz extends Xe {
  constructor() {
    super();
    const e = this.bindTemplate;
    this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-size-view",
          e.to("_viewPosition", (t) => t ? `ck-orientation-${t}` : "")
        ],
        style: {
          display: e.if("_isVisible", "none", (t) => !t)
        }
      },
      children: [{
        text: e.to("_label")
      }]
    });
  }
  /**
   * A method used for binding the `SizeView` instance properties to the `ResizeState` instance observable properties.
   *
   * @internal
   * @param options An object defining the resizer options, used for setting the proper size label.
   * @param resizeState The `ResizeState` class instance, used for keeping the `SizeView` state up to date.
   */
  _bindToState(e, t) {
    this.bind("_isVisible").to(t, "proposedWidth", t, "proposedHeight", (n, r) => n !== null && r !== null), this.bind("_label").to(t, "proposedHandleHostWidth", t, "proposedHandleHostHeight", t, "proposedWidthPercents", (n, r, s) => e.unit === "px" ? `${n}×${r}` : `${s}%`), this.bind("_viewPosition").to(
      t,
      "activeHandlePosition",
      t,
      "proposedHandleHostWidth",
      t,
      "proposedHandleHostHeight",
      // If the widget is too small to contain the size label, display the label above.
      (n, r, s) => r < 50 || s < 50 ? "above-center" : n
    );
  }
  /**
   * A method used for cleaning up. It removes the bindings and hides the view.
   *
   * @internal
   */
  _dismiss() {
    this.unbind(), this._isVisible = !1;
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class e0 extends Nt() {
  /**
   * @param options Resizer options.
   */
  constructor(e) {
    super(), this._viewResizerWrapper = null, this._options = e, this.set("isEnabled", !0), this.set("isSelected", !1), this.bind("isVisible").to(this, "isEnabled", this, "isSelected", (t, n) => t && n), this.decorate("begin"), this.decorate("cancel"), this.decorate("commit"), this.decorate("updateSize"), this.on("commit", (t) => {
      !this.state.proposedWidth && !this.state.proposedWidthPercents && (this._cleanup(), t.stop());
    }, { priority: "high" });
  }
  /**
   * Stores the state of the resizable host geometry, such as the original width, the currently proposed height, etc.
   *
   * Note that a new state is created for each resize transaction.
   */
  get state() {
    return this._state;
  }
  /**
   * Makes resizer visible in the UI.
   */
  show() {
    this._options.editor.editing.view.change((t) => {
      t.removeClass("ck-hidden", this._viewResizerWrapper);
    });
  }
  /**
   * Hides resizer in the UI.
   */
  hide() {
    this._options.editor.editing.view.change((t) => {
      t.addClass("ck-hidden", this._viewResizerWrapper);
    });
  }
  /**
   * Attaches the resizer to the DOM.
   */
  attach() {
    const e = this, t = this._options.viewElement;
    this._options.editor.editing.view.change((r) => {
      const s = r.createUIElement("div", {
        class: "ck ck-reset_all ck-widget__resizer"
      }, function(o) {
        const l = this.toDomElement(o);
        return e._appendHandles(l), e._appendSizeUI(l), l;
      });
      r.insert(r.createPositionAt(t, "end"), s), r.addClass("ck-widget_with-resizer", t), this._viewResizerWrapper = s, this.isVisible || this.hide();
    }), this.on("change:isVisible", () => {
      this.isVisible ? (this.show(), this.redraw()) : this.hide();
    });
  }
  /**
   * Starts the resizing process.
   *
   * Creates a new {@link #state} for the current process.
   *
   * @fires begin
   * @param domResizeHandle Clicked handle.
   */
  begin(e) {
    this._state = new X$(this._options), this._sizeView._bindToState(this._options, this.state), this._initialViewWidth = this._options.viewElement.getStyle("width"), this.state.begin(e, this._getHandleHost(), this._getResizeHost());
  }
  /**
   * Updates the proposed size based on `domEventData`.
   *
   * @fires updateSize
   */
  updateSize(e) {
    const t = this._proposeNewSize(e);
    this._options.editor.editing.view.change((h) => {
      const f = this._options.unit || "%", m = (f === "%" ? t.widthPercents : t.width) + f;
      h.setStyle("width", m, this._options.viewElement);
    });
    const r = this._getHandleHost(), s = new pt(r), o = Math.round(s.width), l = Math.round(s.height), u = new pt(r);
    t.width = Math.round(u.width), t.height = Math.round(u.height), this.redraw(s), this.state.update({
      ...t,
      handleHostWidth: o,
      handleHostHeight: l
    });
  }
  /**
   * Applies the geometry proposed with the resizer.
   *
   * @fires commit
   */
  commit() {
    const e = this._options.unit || "%", t = (e === "%" ? this.state.proposedWidthPercents : this.state.proposedWidth) + e;
    this._options.editor.editing.view.change(() => {
      this._cleanup(), this._options.onCommit(t);
    });
  }
  /**
   * Cancels and rejects the proposed resize dimensions, hiding the UI.
   *
   * @fires cancel
   */
  cancel() {
    this._cleanup();
  }
  /**
   * Destroys the resizer.
   */
  destroy() {
    this.cancel();
  }
  /**
   * Redraws the resizer.
   *
   * @param handleHostRect Handle host rectangle might be given to improve performance.
   */
  redraw(e) {
    const t = this._domResizerWrapper;
    if (!oz(t))
      return;
    const n = t.parentElement, r = this._getHandleHost(), s = this._viewResizerWrapper, o = [
      s.getStyle("width"),
      s.getStyle("height"),
      s.getStyle("left"),
      s.getStyle("top")
    ];
    let l;
    if (n.isSameNode(r)) {
      const u = e || new pt(r);
      l = [
        u.width + "px",
        u.height + "px",
        void 0,
        void 0
      ];
    } else
      l = [
        r.offsetWidth + "px",
        r.offsetHeight + "px",
        r.offsetLeft + "px",
        r.offsetTop + "px"
      ];
    Pn(o, l) !== "same" && this._options.editor.editing.view.change((u) => {
      u.setStyle({
        width: l[0],
        height: l[1],
        left: l[2],
        top: l[3]
      }, s);
    });
  }
  containsHandle(e) {
    return this._domResizerWrapper.contains(e);
  }
  static isResizeHandle(e) {
    return e.classList.contains("ck-widget__resizer__handle");
  }
  /**
   * Cleans up the context state.
   */
  _cleanup() {
    this._sizeView._dismiss(), this._options.editor.editing.view.change((t) => {
      t.setStyle("width", this._initialViewWidth, this._options.viewElement);
    });
  }
  /**
   * Calculates the proposed size as the resize handles are dragged.
   *
   * @param domEventData Event data that caused the size update request. It should be used to calculate the proposed size.
   */
  _proposeNewSize(e) {
    const t = this.state, n = sz(e), r = this._options.isCentered ? this._options.isCentered(this) : !0, s = {
      x: t._referenceCoordinates.x - (n.x + t.originalWidth),
      y: n.y - t.originalHeight - t._referenceCoordinates.y
    };
    r && t.activeHandlePosition.endsWith("-right") && (s.x = n.x - (t._referenceCoordinates.x + t.originalWidth)), r && (s.x *= 2);
    let o = Math.abs(t.originalWidth + s.x), l = Math.abs(t.originalHeight + s.y);
    return (o / t.aspectRatio > l ? "width" : "height") == "width" ? l = o / t.aspectRatio : o = l * t.aspectRatio, {
      width: Math.round(o),
      height: Math.round(l),
      widthPercents: Math.min(Math.round(t.originalWidthPercents / t.originalWidth * o * 100) / 100, 100)
    };
  }
  /**
   * Obtains the resize host.
   *
   * Resize host is an object that receives dimensions which are the result of resizing.
   */
  _getResizeHost() {
    const e = this._domResizerWrapper.parentElement;
    return this._options.getResizeHost(e);
  }
  /**
   * Obtains the handle host.
   *
   * Handle host is an object that the handles are aligned to.
   *
   * Handle host will not always be an entire widget itself. Take an image as an example. The image widget
   * contains an image and a caption. Only the image should be surrounded with handles.
   */
  _getHandleHost() {
    const e = this._domResizerWrapper.parentElement;
    return this._options.getHandleHost(e);
  }
  /**
   * DOM container of the entire resize UI.
   *
   * Note that this property will have a value only after the element bound with the resizer is rendered
   * (otherwise `null`).
   */
  get _domResizerWrapper() {
    return this._options.editor.editing.view.domConverter.mapViewToDom(this._viewResizerWrapper);
  }
  /**
   * Renders the resize handles in the DOM.
   *
   * @param domElement The resizer wrapper.
   */
  _appendHandles(e) {
    const t = ["top-left", "top-right", "bottom-right", "bottom-left"];
    for (const n of t)
      e.appendChild(new Li({
        tag: "div",
        attributes: {
          class: `ck-widget__resizer__handle ${rz(n)}`
        }
      }).render());
  }
  /**
   * Sets up the {@link #_sizeView} property and adds it to the passed `domElement`.
   */
  _appendSizeUI(e) {
    this._sizeView = new iz(), this._sizeView.render(), e.appendChild(this._sizeView.element);
  }
}
function rz(i) {
  return `ck-widget__resizer__handle-${i}`;
}
function sz(i) {
  return {
    x: i.pageX,
    y: i.pageY
  };
}
function oz(i) {
  return i && i.ownerDocument && i.ownerDocument.contains(i);
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class Rm extends fe {
  constructor() {
    super(...arguments), this._resizers = /* @__PURE__ */ new Map();
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "WidgetResize";
  }
  /**
   * @inheritDoc
   */
  init() {
    const e = this.editor.editing, t = Ke.window.document;
    this.set("selectedResizer", null), this.set("_activeResizer", null), e.view.addObserver(uh), this._observer = new (as())(), this.listenTo(e.view.document, "mousedown", this._mouseDownListener.bind(this), { priority: "high" }), this._observer.listenTo(t, "mousemove", this._mouseMoveListener.bind(this)), this._observer.listenTo(t, "mouseup", this._mouseUpListener.bind(this)), this._redrawSelectedResizerThrottled = tp(() => this.redrawSelectedResizer(), 200), this.editor.ui.on("update", this._redrawSelectedResizerThrottled), this.editor.model.document.on("change", () => {
      for (const [r, s] of this._resizers)
        r.isAttached() || (this._resizers.delete(r), s.destroy());
    }, { priority: "lowest" }), this._observer.listenTo(Ke.window, "resize", this._redrawSelectedResizerThrottled);
    const n = this.editor.editing.view.document.selection;
    n.on("change", () => {
      const r = n.getSelectedElement(), s = this.getResizerByViewElement(r) || null;
      s ? this.select(s) : this.deselect();
    });
  }
  /**
   * Redraws the selected resizer if there is any selected resizer and if it is visible.
   */
  redrawSelectedResizer() {
    this.selectedResizer && this.selectedResizer.isVisible && this.selectedResizer.redraw();
  }
  /**
   * @inheritDoc
   */
  destroy() {
    super.destroy(), this._observer.stopListening();
    for (const e of this._resizers.values())
      e.destroy();
    this._redrawSelectedResizerThrottled.cancel();
  }
  /**
   * Marks resizer as selected.
   */
  select(e) {
    this.deselect(), this.selectedResizer = e, this.selectedResizer.isSelected = !0;
  }
  /**
   * Deselects currently set resizer.
   */
  deselect() {
    this.selectedResizer && (this.selectedResizer.isSelected = !1), this.selectedResizer = null;
  }
  /**
   * @param options Resizer options.
   */
  attachTo(e) {
    const t = new e0(e), n = this.editor.plugins;
    if (t.attach(), n.has("WidgetToolbarRepository")) {
      const o = n.get("WidgetToolbarRepository");
      t.on("begin", () => {
        o.forceDisabled("resize");
      }, { priority: "lowest" }), t.on("cancel", () => {
        o.clearForceDisabled("resize");
      }, { priority: "highest" }), t.on("commit", () => {
        o.clearForceDisabled("resize");
      }, { priority: "highest" });
    }
    this._resizers.set(e.viewElement, t);
    const s = this.editor.editing.view.document.selection.getSelectedElement();
    return this.getResizerByViewElement(s) == t && this.select(t), t;
  }
  /**
   * Returns a resizer created for a given view element (widget element).
   *
   * @param viewElement View element associated with the resizer.
   */
  getResizerByViewElement(e) {
    return this._resizers.get(e);
  }
  /**
   * Returns a resizer that contains a given resize handle.
   */
  _getResizerByHandle(e) {
    for (const t of this._resizers.values())
      if (t.containsHandle(e))
        return t;
  }
  /**
   * @param domEventData Native DOM event.
   */
  _mouseDownListener(e, t) {
    const n = t.domTarget;
    e0.isResizeHandle(n) && (this._activeResizer = this._getResizerByHandle(n) || null, this._activeResizer && (this._activeResizer.begin(n), e.stop(), t.preventDefault()));
  }
  /**
   * @param domEventData Native DOM event.
   */
  _mouseMoveListener(e, t) {
    this._activeResizer && this._activeResizer.updateSize(t);
  }
  _mouseUpListener() {
    this._activeResizer && (this._activeResizer.commit(), this._activeResizer = null);
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class az extends fe {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "DragDrop";
  }
  /**
   * @inheritDoc
   */
  static get requires() {
    return [rs, kp];
  }
  /**
   * @inheritDoc
   */
  init() {
    const e = this.editor, t = e.editing.view;
    this._draggedRange = null, this._draggingUid = "", this._draggableElement = null, this._updateDropMarkerThrottled = tp((n) => this._updateDropMarker(n), 40), this._removeDropMarkerDelayed = i0(() => this._removeDropMarker(), 40), this._clearDraggableAttributesDelayed = i0(() => this._clearDraggableAttributes(), 40), t.addObserver(Tp), t.addObserver(uh), this._setupDragging(), this._setupContentInsertionIntegration(), this._setupClipboardInputIntegration(), this._setupDropMarker(), this._setupDraggableAttributeHandling(), this.listenTo(e, "change:isReadOnly", (n, r, s) => {
      s ? this.forceDisabled("readOnlyMode") : this.clearForceDisabled("readOnlyMode");
    }), this.on("change:isEnabled", (n, r, s) => {
      s || this._finalizeDragging(!1);
    }), qe.isAndroid && this.forceDisabled("noAndroidSupport");
  }
  /**
   * @inheritDoc
   */
  destroy() {
    return this._draggedRange && (this._draggedRange.detach(), this._draggedRange = null), this._updateDropMarkerThrottled.cancel(), this._removeDropMarkerDelayed.cancel(), this._clearDraggableAttributesDelayed.cancel(), super.destroy();
  }
  /**
   * Drag and drop events handling.
   */
  _setupDragging() {
    const e = this.editor, t = e.model, n = t.document, r = e.editing.view, s = r.document;
    this.listenTo(s, "dragstart", (o, l) => {
      const u = n.selection;
      if (l.target && l.target.is("editableElement")) {
        l.preventDefault();
        return;
      }
      const h = l.target ? r0(l.target) : null;
      if (h) {
        const v = e.editing.mapper.toModelElement(h);
        this._draggedRange = ur.fromRange(t.createRangeOn(v)), e.plugins.has("WidgetToolbarRepository") && e.plugins.get("WidgetToolbarRepository").forceDisabled("dragDrop");
      } else if (!s.selection.isCollapsed) {
        const v = s.selection.getSelectedElement();
        (!v || !Gt(v)) && (this._draggedRange = ur.fromRange(u.getFirstRange()));
      }
      if (!this._draggedRange) {
        l.preventDefault();
        return;
      }
      this._draggingUid = Rr(), l.dataTransfer.effectAllowed = this.isEnabled ? "copyMove" : "copy", l.dataTransfer.setData("application/ckeditor5-dragging-uid", this._draggingUid);
      const f = t.createSelection(this._draggedRange.toRange()), m = e.data.toView(t.getSelectedContent(f));
      s.fire("clipboardOutput", {
        dataTransfer: l.dataTransfer,
        content: m,
        method: "dragstart"
      }), this.isEnabled || (this._draggedRange.detach(), this._draggedRange = null, this._draggingUid = "");
    }, { priority: "low" }), this.listenTo(s, "dragend", (o, l) => {
      this._finalizeDragging(!l.dataTransfer.isCanceled && l.dataTransfer.dropEffect == "move");
    }, { priority: "low" }), this.listenTo(s, "dragenter", () => {
      this.isEnabled && r.focus();
    }), this.listenTo(s, "dragleave", () => {
      this._removeDropMarkerDelayed();
    }), this.listenTo(s, "dragging", (o, l) => {
      if (!this.isEnabled) {
        l.dataTransfer.dropEffect = "none";
        return;
      }
      this._removeDropMarkerDelayed.cancel();
      const u = t0(e, l.targetRanges, l.target);
      this._draggedRange || (l.dataTransfer.dropEffect = "copy"), qe.isGecko || (l.dataTransfer.effectAllowed == "copy" ? l.dataTransfer.dropEffect = "copy" : ["all", "copyMove"].includes(l.dataTransfer.effectAllowed) && (l.dataTransfer.dropEffect = "move"));
      /* istanbul ignore else -- @preserve */
      u && this._updateDropMarkerThrottled(u);
    }, { priority: "low" });
  }
  /**
   * Integration with the `clipboardInput` event.
   */
  _setupClipboardInputIntegration() {
    const e = this.editor, n = e.editing.view.document;
    this.listenTo(n, "clipboardInput", (r, s) => {
      if (s.method != "drop")
        return;
      const o = t0(e, s.targetRanges, s.target);
      this._removeDropMarker();
      /* istanbul ignore if -- @preserve */
      if (!o) {
        this._finalizeDragging(!1), r.stop();
        return;
      }
      if (this._draggedRange && this._draggingUid != s.dataTransfer.getData("application/ckeditor5-dragging-uid") && (this._draggedRange.detach(), this._draggedRange = null, this._draggingUid = ""), n0(s.dataTransfer) == "move" && this._draggedRange && this._draggedRange.containsRange(o, !0)) {
        this._finalizeDragging(!1), r.stop();
        return;
      }
      s.targetRanges = [e.editing.mapper.toViewRange(o)];
    }, { priority: "high" });
  }
  /**
   * Integration with the `contentInsertion` event of the clipboard pipeline.
   */
  _setupContentInsertionIntegration() {
    const e = this.editor.plugins.get(rs);
    e.on("contentInsertion", (t, n) => {
      if (!this.isEnabled || n.method !== "drop")
        return;
      const r = n.targetRanges.map((s) => this.editor.editing.mapper.toModelRange(s));
      this.editor.model.change((s) => s.setSelection(r));
    }, { priority: "high" }), e.on("contentInsertion", (t, n) => {
      if (!this.isEnabled || n.method !== "drop")
        return;
      const r = n0(n.dataTransfer) == "move", s = !n.resultRange || !n.resultRange.isCollapsed;
      this._finalizeDragging(s && r);
    }, { priority: "lowest" });
  }
  /**
   * Adds listeners that add the `draggable` attribute to the elements while the mouse button is down so the dragging could start.
   */
  _setupDraggableAttributeHandling() {
    const e = this.editor, t = e.editing.view, n = t.document;
    this.listenTo(n, "mousedown", (r, s) => {
      if (qe.isAndroid || !s)
        return;
      this._clearDraggableAttributesDelayed.cancel();
      let o = r0(s.target);
      if (qe.isBlink && !e.isReadOnly && !o && !n.selection.isCollapsed) {
        const l = n.selection.getSelectedElement();
        (!l || !Gt(l)) && (o = n.selection.editableElement);
      }
      o && (t.change((l) => {
        l.setAttribute("draggable", "true", o);
      }), this._draggableElement = e.editing.mapper.toModelElement(o));
    }), this.listenTo(n, "mouseup", () => {
      qe.isAndroid || this._clearDraggableAttributesDelayed();
    });
  }
  /**
   * Removes the `draggable` attribute from the element that was used for dragging.
   */
  _clearDraggableAttributes() {
    const e = this.editor.editing;
    e.view.change((t) => {
      this._draggableElement && this._draggableElement.root.rootName != "$graveyard" && t.removeAttribute("draggable", e.mapper.toViewElement(this._draggableElement)), this._draggableElement = null;
    });
  }
  /**
   * Creates downcast conversion for the drop target marker.
   */
  _setupDropMarker() {
    const e = this.editor;
    e.conversion.for("editingDowncast").markerToHighlight({
      model: "drop-target",
      view: {
        classes: ["ck-clipboard-drop-target-range"]
      }
    }), e.conversion.for("editingDowncast").markerToElement({
      model: "drop-target",
      view: (t, { writer: n }) => {
        if (e.model.schema.checkChild(t.markerRange.start, "$text"))
          return n.createUIElement("span", { class: "ck ck-clipboard-drop-target-position" }, function(s) {
            const o = this.toDomElement(s);
            return o.append("⁠", s.createElement("span"), "⁠"), o;
          });
      }
    });
  }
  /**
   * Updates the drop target marker to the provided range.
   *
   * @param targetRange The range to set the marker to.
   */
  _updateDropMarker(e) {
    const t = this.editor, n = t.model.markers;
    t.model.change((r) => {
      n.has("drop-target") ? n.get("drop-target").getRange().isEqual(e) || r.updateMarker("drop-target", { range: e }) : r.addMarker("drop-target", {
        range: e,
        usingOperation: !1,
        affectsData: !1
      });
    });
  }
  /**
   * Removes the drop target marker.
   */
  _removeDropMarker() {
    const e = this.editor.model;
    this._removeDropMarkerDelayed.cancel(), this._updateDropMarkerThrottled.cancel(), e.markers.has("drop-target") && e.change((t) => {
      t.removeMarker("drop-target");
    });
  }
  /**
   * Deletes the dragged content from its original range and clears the dragging state.
   *
   * @param moved Whether the move succeeded.
   */
  _finalizeDragging(e) {
    const t = this.editor, n = t.model;
    this._removeDropMarker(), this._clearDraggableAttributes(), t.plugins.has("WidgetToolbarRepository") && t.plugins.get("WidgetToolbarRepository").clearForceDisabled("dragDrop"), this._draggingUid = "", this._draggedRange && (e && this.isEnabled && n.deleteContent(n.createSelection(this._draggedRange), { doNotAutoparagraph: !0 }), this._draggedRange.detach(), this._draggedRange = null);
  }
}
function t0(i, e, t) {
  const n = i.model, r = i.editing.mapper;
  let s = null;
  const o = e ? e[0].start : null;
  if (t.is("uiElement") && (t = t.parent), s = lz(i, t), s)
    return s;
  const l = hz(i, t), u = o ? r.toModelPosition(o) : null;
  return u ? (s = uz(i, u, l), s || (s = n.schema.getNearestSelectionRange(u, qe.isGecko ? "forward" : "backward"), s) ? s : dz(i, u.parent)) : cz(i, l);
}
function lz(i, e) {
  const t = i.model, n = i.editing.mapper;
  if (Gt(e))
    return t.createRangeOn(n.toModelElement(e));
  if (!e.is("editableElement")) {
    const r = e.findAncestor((s) => Gt(s) || s.is("editableElement"));
    if (Gt(r))
      return t.createRangeOn(n.toModelElement(r));
  }
  return null;
}
function cz(i, e) {
  const t = i.model, n = t.schema, r = t.createPositionAt(e, 0);
  return n.getNearestSelectionRange(r, "forward");
}
function uz(i, e, t) {
  const n = i.model;
  if (!n.schema.checkChild(t, "$block"))
    return null;
  const r = n.createPositionAt(t, 0), s = e.path.slice(0, r.path.length), l = n.createPositionFromPath(e.root, s).nodeAfter;
  return l && n.schema.isObject(l) ? n.createRangeOn(l) : null;
}
function dz(i, e) {
  const t = i.model;
  let n = e;
  for (; n; ) {
    if (t.schema.isObject(n))
      return t.createRangeOn(n);
    n = n.parent;
  }
  /* istanbul ignore next -- @preserve */
  return null;
}
function hz(i, e) {
  const t = i.editing.mapper, n = i.editing.view, r = t.toModelElement(e);
  if (r)
    return r;
  const s = n.createPositionBefore(e), o = t.findMappedViewAncestor(s);
  return t.toModelElement(o);
}
function n0(i) {
  return qe.isGecko ? i.dropEffect : ["all", "copyMove"].includes(i.effectAllowed) ? "move" : "copy";
}
function i0(i, e) {
  let t;
  function n(...r) {
    n.cancel(), t = setTimeout(() => i(...r), e);
  }
  return n.cancel = () => {
    clearTimeout(t);
  }, n;
}
function r0(i) {
  if (i.is("editableElement"))
    return null;
  if (i.hasClass("ck-widget__selection-handle"))
    return i.findAncestor(Gt);
  if (Gt(i))
    return i;
  const e = i.findAncestor((t) => Gt(t) || t.is("editableElement"));
  return Gt(e) ? e : null;
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class fz extends fe {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "PastePlainText";
  }
  /**
   * @inheritDoc
   */
  static get requires() {
    return [rs];
  }
  /**
   * @inheritDoc
   */
  init() {
    const e = this.editor, t = e.model, n = e.editing.view, r = n.document, s = t.document.selection;
    let o = !1;
    n.addObserver(Tp), this.listenTo(r, "keydown", (l, u) => {
      o = u.shiftKey;
    }), e.plugins.get(rs).on("contentInsertion", (l, u) => {
      !o && !mz(u.content, t.schema) || t.change((h) => {
        const f = Array.from(s.getAttributes()).filter(([v]) => t.schema.getAttributeProperties(v).isFormatting);
        s.isCollapsed || t.deleteContent(s, { doNotAutoparagraph: !0 }), f.push(...s.getAttributes());
        const m = h.createRangeIn(u.content);
        for (const v of m.getItems())
          v.is("$textProxy") && h.setAttributes(f, v);
      });
    });
  }
}
function mz(i, e) {
  if (i.childCount > 1)
    return !1;
  const t = i.getChild(0);
  return e.isObject(t) ? !1 : Array.from(t.getAttributeKeys()).length == 0;
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class XC extends fe {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "Clipboard";
  }
  /**
   * @inheritDoc
   */
  static get requires() {
    return [rs, az, fz];
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class gz extends Pt {
  /**
   * @inheritDoc
   */
  constructor(e) {
    super(e), this.affectsData = !1;
  }
  /**
   * @inheritDoc
   */
  execute() {
    const e = this.editor.model, t = e.document.selection;
    let n = e.schema.getLimitElement(t);
    if (t.containsEntireContent(n) || !s0(e.schema, n))
      do
        if (n = n.parent, !n)
          return;
      while (!s0(e.schema, n));
    e.change((r) => {
      r.setSelection(n, "in");
    });
  }
}
function s0(i, e) {
  return i.isLimit(e) && (i.checkChild(e, "$text") || i.checkChild(e, "paragraph"));
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const pz = ip("Ctrl+A");
class _z extends fe {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "SelectAllEditing";
  }
  /**
   * @inheritDoc
   */
  init() {
    const e = this.editor, n = e.editing.view.document;
    e.commands.add("selectAll", new gz(e)), this.listenTo(n, "keydown", (r, s) => {
      zo(s) === pz && (e.execute("selectAll"), s.preventDefault());
    });
  }
}
const vz = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M.75 15.5a.75.75 0 0 1 .75.75V18l.008.09A.5.5 0 0 0 2 18.5h1.75a.75.75 0 1 1 0 1.5H1.5l-.144-.007a1.5 1.5 0 0 1-1.35-1.349L0 18.5v-2.25a.75.75 0 0 1 .75-.75zm18.5 0a.75.75 0 0 1 .75.75v2.25l-.007.144a1.5 1.5 0 0 1-1.349 1.35L18.5 20h-2.25a.75.75 0 1 1 0-1.5H18a.5.5 0 0 0 .492-.41L18.5 18v-1.75a.75.75 0 0 1 .75-.75zm-10.45 3c.11 0 .2.09.2.2v1.1a.2.2 0 0 1-.2.2H7.2a.2.2 0 0 1-.2-.2v-1.1c0-.11.09-.2.2-.2h1.6zm4 0c.11 0 .2.09.2.2v1.1a.2.2 0 0 1-.2.2h-1.6a.2.2 0 0 1-.2-.2v-1.1c0-.11.09-.2.2-.2h1.6zm.45-5.5a.75.75 0 1 1 0 1.5h-8.5a.75.75 0 1 1 0-1.5h8.5zM1.3 11c.11 0 .2.09.2.2v1.6a.2.2 0 0 1-.2.2H.2a.2.2 0 0 1-.2-.2v-1.6c0-.11.09-.2.2-.2h1.1zm18.5 0c.11 0 .2.09.2.2v1.6a.2.2 0 0 1-.2.2h-1.1a.2.2 0 0 1-.2-.2v-1.6c0-.11.09-.2.2-.2h1.1zm-4.55-2a.75.75 0 1 1 0 1.5H4.75a.75.75 0 1 1 0-1.5h10.5zM1.3 7c.11 0 .2.09.2.2v1.6a.2.2 0 0 1-.2.2H.2a.2.2 0 0 1-.2-.2V7.2c0-.11.09-.2.2-.2h1.1zm18.5 0c.11 0 .2.09.2.2v1.6a.2.2 0 0 1-.2.2h-1.1a.2.2 0 0 1-.2-.2V7.2c0-.11.09-.2.2-.2h1.1zm-4.55-2a.75.75 0 1 1 0 1.5h-2.5a.75.75 0 1 1 0-1.5h2.5zm-5 0a.75.75 0 1 1 0 1.5h-5.5a.75.75 0 0 1 0-1.5h5.5zm-6.5-5a.75.75 0 0 1 0 1.5H2a.5.5 0 0 0-.492.41L1.5 2v1.75a.75.75 0 0 1-1.5 0V1.5l.007-.144A1.5 1.5 0 0 1 1.356.006L1.5 0h2.25zM18.5 0l.144.007a1.5 1.5 0 0 1 1.35 1.349L20 1.5v2.25a.75.75 0 1 1-1.5 0V2l-.008-.09A.5.5 0 0 0 18 1.5h-1.75a.75.75 0 1 1 0-1.5h2.25zM8.8 0c.11 0 .2.09.2.2v1.1a.2.2 0 0 1-.2.2H7.2a.2.2 0 0 1-.2-.2V.2c0-.11.09-.2.2-.2h1.6zm4 0c.11 0 .2.09.2.2v1.1a.2.2 0 0 1-.2.2h-1.6a.2.2 0 0 1-.2-.2V.2c0-.11.09-.2.2-.2h1.6z"/></svg>';
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class wz extends fe {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "SelectAllUI";
  }
  /**
   * @inheritDoc
   */
  init() {
    const e = this.editor;
    e.ui.componentFactory.add("selectAll", (t) => {
      const n = e.commands.get("selectAll"), r = new At(t), s = t.t;
      return r.set({
        label: s("Select all"),
        icon: vz,
        keystroke: "Ctrl+A",
        tooltip: !0
      }), r.bind("isEnabled").to(n, "isEnabled"), this.listenTo(r, "execute", () => {
        e.execute("selectAll"), e.editing.view.focus();
      }), r;
    });
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class bz extends fe {
  /**
   * @inheritDoc
   */
  static get requires() {
    return [_z, wz];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "SelectAll";
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class ZC extends Pt {
  /**
   * @inheritDoc
   */
  constructor(e) {
    super(e), this._stack = [], this._createdBatches = /* @__PURE__ */ new WeakSet(), this.refresh(), this.listenTo(e.data, "set", (t, n) => {
      n[1] = { ...n[1] };
      const r = n[1];
      r.batchType || (r.batchType = { isUndoable: !1 });
    }, { priority: "high" }), this.listenTo(e.data, "set", (t, n) => {
      n[1].batchType.isUndoable || this.clearStack();
    });
  }
  /**
   * @inheritDoc
   */
  refresh() {
    this.isEnabled = this._stack.length > 0;
  }
  /**
   * Returns all batches created by this command.
   */
  get createdBatches() {
    return this._createdBatches;
  }
  /**
   * Stores a batch in the command, together with the selection state of the {@link module:engine/model/document~Document document}
   * created by the editor which this command is registered to.
   *
   * @param batch The batch to add.
   */
  addBatch(e) {
    const t = this.editor.model.document.selection, n = {
      ranges: t.hasOwnRange ? Array.from(t.getRanges()) : [],
      isBackward: t.isBackward
    };
    this._stack.push({ batch: e, selection: n }), this.refresh();
  }
  /**
   * Removes all items from the stack.
   */
  clearStack() {
    this._stack = [], this.refresh();
  }
  /**
   * Restores the {@link module:engine/model/document~Document#selection document selection} state after a batch was undone.
   *
   * @param ranges Ranges to be restored.
   * @param isBackward A flag describing whether the restored range was selected forward or backward.
   * @param operations Operations which has been applied since selection has been stored.
   */
  _restoreSelection(e, t, n) {
    const r = this.editor.model, s = r.document, o = [], l = e.map((h) => h.getTransformedByOperations(n)), u = l.flat();
    for (const h of l) {
      const f = h.filter((m) => m.root != s.graveyard).filter((m) => !Ez(m, u));
      f.length && (yz(f), o.push(f[0]));
    }
    o.length && r.change((h) => {
      h.setSelection(o, { backward: t });
    });
  }
  /**
   * Undoes a batch by reversing that batch, transforming reversed batch and finally applying it.
   * This is a helper method for {@link #execute}.
   *
   * @param batchToUndo The batch to be undone.
   * @param undoingBatch The batch that will contain undoing changes.
   */
  _undo(e, t) {
    const n = this.editor.model, r = n.document;
    this._createdBatches.add(t);
    const s = e.operations.slice().filter((o) => o.isDocumentOperation);
    s.reverse();
    for (const o of s) {
      const l = o.baseVersion + 1, u = Array.from(r.history.getOperations(l)), f = B8([o.getReversed()], u, {
        useRelations: !0,
        document: this.editor.model.document,
        padWithNoOps: !1,
        forceWeakRemove: !0
      }).operationsA;
      for (const m of f)
        t.addOperation(m), n.applyOperation(m), r.history.setOperationAsUndone(o, m);
    }
  }
}
function yz(i) {
  i.sort((e, t) => e.start.isBefore(t.start) ? -1 : 1);
  for (let e = 1; e < i.length; e++) {
    const n = i[e - 1].getJoined(i[e], !0);
    n && (e--, i.splice(e, 2, n));
  }
}
function Ez(i, e) {
  return e.some((t) => t !== i && t.containsRange(i, !0));
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class Cz extends ZC {
  /**
   * Executes the command. This method reverts a {@link module:engine/model/batch~Batch batch} added to the command's stack, transforms
   * and applies the reverted version on the {@link module:engine/model/document~Document document} and removes the batch from the stack.
   * Then, it restores the {@link module:engine/model/document~Document#selection document selection}.
   *
   * @fires execute
   * @fires revert
   * @param batch A batch that should be undone. If not set, the last added batch will be undone.
   */
  execute(e = null) {
    const t = e ? this._stack.findIndex((s) => s.batch == e) : this._stack.length - 1, n = this._stack.splice(t, 1)[0], r = this.editor.model.createBatch({ isUndo: !0 });
    this.editor.model.enqueueChange(r, () => {
      this._undo(n.batch, r);
      const s = this.editor.model.document.history.getOperations(n.batch.baseVersion);
      this._restoreSelection(n.selection.ranges, n.selection.isBackward, s), this.fire("revert", n.batch, r);
    }), this.refresh();
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class Sz extends ZC {
  /**
   * Executes the command. This method reverts the last {@link module:engine/model/batch~Batch batch} added to
   * the command's stack, applies the reverted and transformed version on the
   * {@link module:engine/model/document~Document document} and removes the batch from the stack.
   * Then, it restores the {@link module:engine/model/document~Document#selection document selection}.
   *
   * @fires execute
   */
  execute() {
    const e = this._stack.pop(), t = this.editor.model.createBatch({ isUndo: !0 });
    this.editor.model.enqueueChange(t, () => {
      const r = e.batch.operations[e.batch.operations.length - 1].baseVersion + 1, s = this.editor.model.document.history.getOperations(r);
      this._restoreSelection(e.selection.ranges, e.selection.isBackward, s), this._undo(e.batch, t);
    }), this.refresh();
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class Tz extends fe {
  constructor() {
    super(...arguments), this._batchRegistry = /* @__PURE__ */ new WeakSet();
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "UndoEditing";
  }
  /**
   * @inheritDoc
   */
  init() {
    const e = this.editor;
    this._undoCommand = new Cz(e), this._redoCommand = new Sz(e), e.commands.add("undo", this._undoCommand), e.commands.add("redo", this._redoCommand), this.listenTo(e.model, "applyOperation", (t, n) => {
      const r = n[0];
      if (!r.isDocumentOperation)
        return;
      const s = r.batch, o = this._redoCommand.createdBatches.has(s), l = this._undoCommand.createdBatches.has(s);
      this._batchRegistry.has(s) || (this._batchRegistry.add(s), s.isUndoable && (o ? this._undoCommand.addBatch(s) : l || (this._undoCommand.addBatch(s), this._redoCommand.clearStack())));
    }, { priority: "highest" }), this.listenTo(this._undoCommand, "revert", (t, n, r) => {
      this._redoCommand.addBatch(r);
    }), e.keystrokes.set("CTRL+Z", "undo"), e.keystrokes.set("CTRL+Y", "redo"), e.keystrokes.set("CTRL+SHIFT+Z", "redo");
  }
}
const o0 = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m5.042 9.367 2.189 1.837a.75.75 0 0 1-.965 1.149l-3.788-3.18a.747.747 0 0 1-.21-.284.75.75 0 0 1 .17-.945L6.23 4.762a.75.75 0 1 1 .964 1.15L4.863 7.866h8.917A.75.75 0 0 1 14 7.9a4 4 0 1 1-1.477 7.718l.344-1.489a2.5 2.5 0 1 0 1.094-4.73l.008-.032H5.042z"/></svg>', a0 = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m14.958 9.367-2.189 1.837a.75.75 0 0 0 .965 1.149l3.788-3.18a.747.747 0 0 0 .21-.284.75.75 0 0 0-.17-.945L13.77 4.762a.75.75 0 1 0-.964 1.15l2.331 1.955H6.22A.75.75 0 0 0 6 7.9a4 4 0 1 0 1.477 7.718l-.344-1.489A2.5 2.5 0 1 1 6.039 9.4l-.008-.032h8.927z"/></svg>';
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class xz extends fe {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "UndoUI";
  }
  /**
   * @inheritDoc
   */
  init() {
    const e = this.editor, t = e.locale, n = e.t, r = t.uiLanguageDirection == "ltr" ? o0 : a0, s = t.uiLanguageDirection == "ltr" ? a0 : o0;
    this._addButton("undo", n("Undo"), "CTRL+Z", r), this._addButton("redo", n("Redo"), "CTRL+Y", s);
  }
  /**
   * Creates a button for the specified command.
   *
   * @param name Command name.
   * @param label Button label.
   * @param keystroke Command keystroke.
   * @param Icon Source of the icon.
   */
  _addButton(e, t, n, r) {
    const s = this.editor;
    s.ui.componentFactory.add(e, (o) => {
      const l = s.commands.get(e), u = new At(o);
      return u.set({
        label: t,
        icon: r,
        keystroke: n,
        tooltip: !0
      }), u.bind("isEnabled").to(l, "isEnabled"), this.listenTo(u, "execute", () => {
        s.execute(e), s.editing.view.focus();
      }), u;
    });
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class QC extends fe {
  /**
   * @inheritDoc
   */
  static get requires() {
    return [Tz, xz];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "Undo";
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class kz extends fe {
  /**
   * @inheritDoc
   */
  static get requires() {
    return [XC, xp, bz, KC, h$, QC];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "Essentials";
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const Ap = ["left", "right", "center", "justify"];
function eS(i) {
  return Ap.includes(i);
}
function tS(i, e) {
  return e.contentLanguageDirection == "rtl" ? i === "right" : i === "left";
}
function nS(i) {
  const e = i.map((n) => {
    let r;
    return typeof n == "string" ? r = { name: n } : r = n, r;
  }).filter((n) => {
    const r = Ap.includes(n.name);
    return r || Yt("alignment-config-name-not-recognized", { option: n }), r;
  }), t = e.filter((n) => !!n.className).length;
  if (t && t < e.length)
    throw new B("alignment-config-classnames-are-missing", { configuredOptions: i });
  return e.forEach((n, r, s) => {
    const o = s.slice(r + 1);
    if (o.some((u) => u.name == n.name))
      throw new B("alignment-config-name-already-defined", { option: n, configuredOptions: i });
    if (n.className && o.some((h) => h.className == n.className))
      throw new B("alignment-config-classname-already-defined", { option: n, configuredOptions: i });
  }), e;
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const Pp = "alignment";
class Az extends Pt {
  /**
   * @inheritDoc
   */
  refresh() {
    const t = this.editor.locale, n = Rn(this.editor.model.document.selection.getSelectedBlocks());
    this.isEnabled = !!n && this._canBeAligned(n), this.isEnabled && n.hasAttribute("alignment") ? this.value = n.getAttribute("alignment") : this.value = t.contentLanguageDirection === "rtl" ? "right" : "left";
  }
  /**
   * Executes the command. Applies the alignment `value` to the selected blocks.
   * If no `value` is passed, the `value` is the default one or it is equal to the currently selected block's alignment attribute,
   * the command will remove the attribute from the selected blocks.
   *
   * @param options Options for the executed command.
   * @param options.value The value to apply.
   * @fires execute
   */
  execute(e = {}) {
    const t = this.editor, n = t.locale, r = t.model, s = r.document, o = e.value;
    r.change((l) => {
      const u = Array.from(s.selection.getSelectedBlocks()).filter((m) => this._canBeAligned(m)), h = u[0].getAttribute("alignment");
      tS(o, n) || h === o || !o ? Pz(u, l) : Iz(u, l, o);
    });
  }
  /**
   * Checks whether a block can have alignment set.
   *
   * @param block The block to be checked.
   */
  _canBeAligned(e) {
    return this.editor.model.schema.checkAttribute(e, Pp);
  }
}
function Pz(i, e) {
  for (const t of i)
    e.removeAttribute(Pp, t);
}
function Iz(i, e, t) {
  for (const n of i)
    e.setAttribute(Pp, t, n);
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class Rz extends fe {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "AlignmentEditing";
  }
  /**
   * @inheritDoc
   */
  constructor(e) {
    super(e), e.config.define("alignment", {
      options: Ap.map((t) => ({ name: t }))
    });
  }
  /**
   * @inheritDoc
   */
  init() {
    const e = this.editor, t = e.locale, n = e.model.schema, s = nS(e.config.get("alignment.options")).filter((h) => eS(h.name) && !tS(h.name, t)), o = s.some((h) => !!h.className);
    n.extend("$block", { allowAttributes: "alignment" }), e.model.schema.setAttributeProperties("alignment", { isFormatting: !0 }), o ? e.conversion.attributeToAttribute(Dz(s)) : e.conversion.for("downcast").attributeToAttribute(Oz(s));
    const l = Mz(s);
    for (const h of l)
      e.conversion.for("upcast").attributeToAttribute(h);
    const u = Nz(s);
    for (const h of u)
      e.conversion.for("upcast").attributeToAttribute(h);
    e.commands.add("alignment", new Az(e));
  }
}
function Oz(i) {
  const e = {};
  for (const { name: n } of i)
    e[n] = {
      key: "style",
      value: {
        "text-align": n
      }
    };
  return {
    model: {
      key: "alignment",
      values: i.map((n) => n.name)
    },
    view: e
  };
}
function Mz(i) {
  const e = [];
  for (const { name: t } of i)
    e.push({
      view: {
        key: "style",
        value: {
          "text-align": t
        }
      },
      model: {
        key: "alignment",
        value: t
      }
    });
  return e;
}
function Nz(i) {
  const e = [];
  for (const { name: t } of i)
    e.push({
      view: {
        key: "align",
        value: t
      },
      model: {
        key: "alignment",
        value: t
      }
    });
  return e;
}
function Dz(i) {
  const e = {};
  for (const n of i)
    e[n.name] = {
      key: "class",
      value: n.className
    };
  return {
    model: {
      key: "alignment",
      values: i.map((n) => n.name)
    },
    view: e
  };
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const Ku = /* @__PURE__ */ new Map([
  ["left", Mt.alignLeft],
  ["right", Mt.alignRight],
  ["center", Mt.alignCenter],
  ["justify", Mt.alignJustify]
]);
class Bz extends fe {
  /**
   * Returns the localized option titles provided by the plugin.
   *
   * The following localized titles corresponding with
   * {@link module:alignment/alignmentconfig~AlignmentConfig#options} are available:
   *
   * * `'left'`,
   * * `'right'`,
   * * `'center'`,
   * * `'justify'`.
   *
   * @readonly
   */
  get localizedOptionTitles() {
    const e = this.editor.t;
    return {
      left: e("Align left"),
      right: e("Align right"),
      center: e("Align center"),
      justify: e("Justify")
    };
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "AlignmentUI";
  }
  /**
   * @inheritDoc
   */
  init() {
    const e = this.editor, t = e.ui.componentFactory, n = e.t, r = nS(e.config.get("alignment.options"));
    r.map((s) => s.name).filter(eS).forEach((s) => this._addButton(s)), t.add("alignment", (s) => {
      const o = Gs(s);
      gh(o, () => r.map((h) => t.create(`alignment:${h.name}`)), {
        enableActiveItemFocusOnDropdownOpen: !0,
        isVertical: !0,
        ariaLabel: n("Text alignment toolbar")
      }), o.buttonView.set({
        label: n("Text alignment"),
        tooltip: !0
      }), o.extendTemplate({
        attributes: {
          class: "ck-alignment-dropdown"
        }
      });
      const l = s.contentLanguageDirection === "rtl" ? Ku.get("right") : Ku.get("left"), u = e.commands.get("alignment");
      return o.buttonView.bind("icon").to(u, "value", (h) => Ku.get(h) || l), o.bind("isEnabled").to(u, "isEnabled"), this.listenTo(o, "execute", () => {
        e.editing.view.focus();
      }), o;
    });
  }
  /**
   * Helper method for initializing the button and linking it with an appropriate command.
   *
   * @param option The name of the alignment option for which the button is added.
   */
  _addButton(e) {
    const t = this.editor;
    t.ui.componentFactory.add(`alignment:${e}`, (n) => {
      const r = t.commands.get("alignment"), s = new At(n);
      return s.set({
        label: this.localizedOptionTitles[e],
        icon: Ku.get(e),
        tooltip: !0,
        isToggleable: !0
      }), s.bind("isEnabled").to(r), s.bind("isOn").to(r, "value", (o) => o === e), this.listenTo(s, "execute", () => {
        t.execute("alignment", { value: e }), t.editing.view.focus();
      }), s;
    });
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class Vz extends fe {
  /**
   * @inheritDoc
   */
  static get requires() {
    return [Rz, Bz];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "Alignment";
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function Ip(i) {
  const e = i.t, t = i.config.get("codeBlock.languages");
  for (const n of t)
    n.label === "Plain text" && (n.label = e("Plain text")), n.class === void 0 && (n.class = `language-${n.language}`);
  return t;
}
function yg(i, e, t) {
  const n = {};
  for (const r of i)
    if (e === "class") {
      const s = r[e].split(" ").shift();
      n[s] = r[t];
    } else
      n[r[e]] = r[t];
  return n;
}
function Rp(i) {
  return i.data.match(/^(\s*)/)[0];
}
function Lz(i, e) {
  const t = i.createDocumentFragment(), n = e.split(`
`), r = n.reduce((s, o, l) => (s.push(o), l < n.length - 1 && s.push(i.createElement("br")), s), []);
  return i.appendChild(r, t), t;
}
function Eg(i) {
  const e = i.document.selection, t = [];
  if (e.isCollapsed)
    return [e.anchor];
  const n = e.getFirstRange().getWalker({
    ignoreElementEnd: !0,
    direction: "backward"
  });
  for (const { item: r } of n) {
    if (!r.is("$textProxy"))
      continue;
    const { parent: s, startOffset: o } = r.textNode;
    if (!s.is("element", "codeBlock"))
      continue;
    const l = Rp(r.textNode), u = i.createPositionAt(s, o + l.length);
    t.push(u);
  }
  return t;
}
function iS(i) {
  const e = Rn(i.getSelectedBlocks());
  return !!e && e.is("element", "codeBlock");
}
function l0(i, e) {
  return e.is("rootElement") || i.isLimit(e) ? !1 : i.checkChild(e.parent, "codeBlock");
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class Fz extends Pt {
  /**
   * @inheritDoc
   */
  constructor(e) {
    super(e), this._lastLanguage = null;
  }
  /**
   * @inheritDoc
   */
  refresh() {
    this.value = this._getValue(), this.isEnabled = this._checkEnabled();
  }
  /**
   * Executes the command. When the command {@link #value is on}, all topmost code blocks within
   * the selection will be removed. If it is off, all selected blocks will be flattened and
   * wrapped by a code block.
   *
   * @fires execute
   * @param options Command options.
   * @param options.language The code block language.
   * @param options.forceValue If set, it will force the command behavior. If `true`, the command will apply a code block,
   * otherwise the command will remove the code block. If not set, the command will act basing on its current value.
   * @param options.usePreviousLanguageChoice If set on `true` and the `options.language` is not specified, the command
   * will apply the previous language (if the command was already executed) when inserting the `codeBlock` element.
   */
  execute(e = {}) {
    const t = this.editor, n = t.model, r = n.document.selection, o = Ip(t)[0], l = Array.from(r.getSelectedBlocks()), u = e.forceValue == null ? !this.value : e.forceValue, h = $z(e, this._lastLanguage, o.language);
    n.change((f) => {
      u ? this._applyCodeBlock(f, l, h) : this._removeCodeBlock(f, l);
    });
  }
  /**
   * Checks the command's {@link #value}.
   *
   * @returns The current value.
   */
  _getValue() {
    const e = this.editor.model.document.selection, t = Rn(e.getSelectedBlocks());
    return !!(t && t.is("element", "codeBlock")) ? t.getAttribute("language") : !1;
  }
  /**
   * Checks whether the command can be enabled in the current context.
   *
   * @returns Whether the command should be enabled.
   */
  _checkEnabled() {
    if (this.value)
      return !0;
    const e = this.editor.model.document.selection, t = this.editor.model.schema, n = Rn(e.getSelectedBlocks());
    return n ? l0(t, n) : !1;
  }
  _applyCodeBlock(e, t, n) {
    this._lastLanguage = n;
    const r = this.editor.model.schema, s = t.filter((o) => l0(r, o));
    for (const o of s)
      e.rename(o, "codeBlock"), e.setAttribute("language", n, o), r.removeDisallowedAttributes([o], e), Array.from(o.getChildren()).filter((l) => !r.checkChild(o, l)).forEach((l) => e.remove(l));
    s.reverse().forEach((o, l) => {
      const u = s[l + 1];
      o.previousSibling === u && (e.appendElement("softBreak", u), e.merge(e.createPositionBefore(o)));
    });
  }
  _removeCodeBlock(e, t) {
    const n = t.filter((r) => r.is("element", "codeBlock"));
    for (const r of n) {
      const s = e.createRangeOn(r);
      for (const o of Array.from(s.getItems()).reverse())
        if (o.is("element", "softBreak") && o.parent.is("element", "codeBlock")) {
          const { position: l } = e.split(e.createPositionBefore(o)), u = l.nodeAfter;
          e.rename(u, "paragraph"), e.removeAttribute("language", u), e.remove(o);
        }
      e.rename(r, "paragraph"), e.removeAttribute("language", r);
    }
  }
}
function $z(i, e, t) {
  return i.language ? i.language : i.usePreviousLanguageChoice && e ? e : t;
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class zz extends Pt {
  constructor(e) {
    super(e), this._indentSequence = e.config.get("codeBlock.indentSequence");
  }
  /**
   * @inheritDoc
   */
  refresh() {
    this.isEnabled = this._checkEnabled();
  }
  /**
   * Executes the command. When the command {@link #isEnabled is enabled}, the indentation of the
   * code lines in the selection will be increased.
   *
   * @fires execute
   */
  execute() {
    const t = this.editor.model;
    t.change((n) => {
      const r = Eg(t);
      for (const s of r) {
        const o = n.createText(this._indentSequence);
        t.insertContent(o, s);
      }
    });
  }
  /**
   * Checks whether the command can be enabled in the current context.
   */
  _checkEnabled() {
    return this._indentSequence ? iS(this.editor.model.document.selection) : !1;
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class Wz extends Pt {
  constructor(e) {
    super(e), this._indentSequence = e.config.get("codeBlock.indentSequence");
  }
  /**
   * @inheritDoc
   */
  refresh() {
    this.isEnabled = this._checkEnabled();
  }
  /**
   * Executes the command. When the command {@link #isEnabled is enabled}, the indentation of the
   * code lines in the selection will be decreased.
   *
   * @fires execute
   */
  execute() {
    const t = this.editor.model;
    t.change(() => {
      const n = Eg(t);
      for (const r of n) {
        const s = c0(t, r, this._indentSequence);
        s && t.deleteContent(t.createSelection(s));
      }
    });
  }
  /**
   * Checks whether the command can be enabled in the current context.
   *
   * @private
   * @returns {Boolean} Whether the command should be enabled.
   */
  _checkEnabled() {
    if (!this._indentSequence)
      return !1;
    const e = this.editor.model;
    return iS(e.document.selection) ? Eg(e).some((t) => c0(e, t, this._indentSequence)) : !1;
  }
}
function c0(i, e, t) {
  const n = jz(e);
  if (!n)
    return null;
  const r = Rp(n), s = r.lastIndexOf(t);
  if (s + t.length !== r.length || s === -1)
    return null;
  const { parent: o, startOffset: l } = n;
  return i.createRange(i.createPositionAt(o, l + s), i.createPositionAt(o, l + s + t.length));
}
function jz(i) {
  let e = i.parent.getChild(i.index);
  return (!e || e.is("element", "softBreak")) && (e = i.nodeBefore), !e || e.is("element", "softBreak") ? null : e;
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function u0(i, e, t = !1) {
  const n = yg(e, "language", "class"), r = yg(e, "language", "label");
  return (s, o, l) => {
    const { writer: u, mapper: h, consumable: f } = l;
    if (!f.consume(o.item, "insert"))
      return;
    const m = o.item.getAttribute("language"), v = h.toViewPosition(i.createPositionBefore(o.item)), C = {};
    t && (C["data-language"] = r[m], C.spellcheck = "false");
    const k = n[m] ? {
      class: n[m]
    } : void 0, S = u.createContainerElement("code", k), x = u.createContainerElement("pre", C, S);
    u.insert(v, x), h.bindElements(o.item, S);
  };
}
function Uz(i) {
  return (e, t, n) => {
    if (t.item.parent.name !== "codeBlock")
      return;
    const { writer: r, mapper: s, consumable: o } = n;
    if (!o.consume(t.item, "insert"))
      return;
    const l = s.toViewPosition(i.createPositionBefore(t.item));
    r.insert(l, r.createText(`
`));
  };
}
function Hz(i, e) {
  const t = yg(e, "class", "language"), n = e[0].language;
  return (r, s, o) => {
    const l = s.viewItem, u = l.parent;
    if (!u || !u.is("element", "pre") || s.modelCursor.findAncestor("codeBlock"))
      return;
    const { consumable: h, writer: f } = o;
    if (!h.test(l, { name: !0 }))
      return;
    const m = f.createElement("codeBlock"), v = [...l.getClassNames()];
    v.length || v.push("");
    for (const C of v) {
      const k = t[C];
      if (k) {
        f.setAttribute("language", k, m);
        break;
      }
    }
    m.hasAttribute("language") || f.setAttribute("language", n, m), o.convertChildren(l, m), o.safeInsert(m, s.modelCursor) && (h.consume(l, { name: !0 }), o.updateConversionResult(m, s));
  };
}
function qz() {
  return (i, e, { consumable: t, writer: n }) => {
    let r = e.modelCursor;
    if (!t.test(e.viewItem) || !r.findAncestor("codeBlock"))
      return;
    t.consume(e.viewItem);
    const o = e.viewItem.data.split(`
`).map((u) => n.createText(u)), l = o[o.length - 1];
    for (const u of o)
      if (n.insert(u, r), r = r.getShiftedBy(u.offsetSize), u !== l) {
        const h = n.createElement("softBreak");
        n.insert(h, r), r = n.createPositionAfter(h);
      }
    e.modelRange = n.createRange(e.modelCursor, r), e.modelCursor = r;
  };
}
function Kz() {
  return (i, e, { consumable: t }) => {
    const n = e.viewItem;
    if (n.findAncestor("pre"))
      return;
    const r = Array.from(n.getChildren()), s = r.find((o) => o.is("element", "code"));
    if (s)
      for (const o of r)
        o === s || !o.is("$text") || t.consume(o, { name: !0 });
  };
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const rS = "paragraph";
class Gz extends fe {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "CodeBlockEditing";
  }
  /**
   * @inheritDoc
   */
  static get requires() {
    return [KC];
  }
  /**
   * @inheritDoc
   */
  constructor(e) {
    super(e), e.config.define("codeBlock", {
      languages: [
        { language: "plaintext", label: "Plain text" },
        { language: "c", label: "C" },
        { language: "cs", label: "C#" },
        { language: "cpp", label: "C++" },
        { language: "css", label: "CSS" },
        { language: "diff", label: "Diff" },
        { language: "html", label: "HTML" },
        { language: "java", label: "Java" },
        { language: "javascript", label: "JavaScript" },
        { language: "php", label: "PHP" },
        { language: "python", label: "Python" },
        { language: "ruby", label: "Ruby" },
        { language: "typescript", label: "TypeScript" },
        { language: "xml", label: "XML" }
      ],
      // A single tab.
      indentSequence: "	"
    });
  }
  /**
   * @inheritDoc
   */
  init() {
    const e = this.editor, t = e.model.schema, n = e.model, r = e.editing.view, s = e.plugins.has("DocumentListEditing"), o = Ip(e);
    e.commands.add("codeBlock", new Fz(e)), e.commands.add("indentCodeBlock", new zz(e)), e.commands.add("outdentCodeBlock", new Wz(e)), this.listenTo(r.document, "tab", (l, u) => {
      const h = u.shiftKey ? "outdentCodeBlock" : "indentCodeBlock";
      e.commands.get(h).isEnabled && (e.execute(h), u.stopPropagation(), u.preventDefault(), l.stop());
    }, { context: "pre" }), t.register("codeBlock", {
      allowWhere: "$block",
      allowChildren: "$text",
      isBlock: !0,
      allowAttributes: ["language"]
    }), t.addAttributeCheck((l, u) => {
      const h = l.endsWith("codeBlock") && u.startsWith("list") && u !== "list";
      if (s && h)
        return !0;
      if (l.endsWith("codeBlock $text"))
        return !1;
    }), e.model.schema.addChildCheck((l, u) => {
      if (l.endsWith("codeBlock") && u.isObject)
        return !1;
    }), e.editing.downcastDispatcher.on("insert:codeBlock", u0(n, o, !0)), e.data.downcastDispatcher.on("insert:codeBlock", u0(n, o)), e.data.downcastDispatcher.on("insert:softBreak", Uz(n), { priority: "high" }), e.data.upcastDispatcher.on("element:code", Hz(r, o)), e.data.upcastDispatcher.on("text", qz()), e.data.upcastDispatcher.on("element:pre", Kz(), { priority: "high" }), this.listenTo(e.editing.view.document, "clipboardInput", (l, u) => {
      let h = n.createRange(n.document.selection.anchor);
      if (u.targetRanges && (h = e.editing.mapper.toModelRange(u.targetRanges[0])), !h.start.parent.is("element", "codeBlock"))
        return;
      const f = u.dataTransfer.getData("text/plain"), m = new gp(e.editing.view.document);
      u.content = Lz(m, f);
    }), this.listenTo(n, "getSelectedContent", (l, [u]) => {
      const h = u.anchor;
      u.isCollapsed || !h.parent.is("element", "codeBlock") || !h.hasSameParentAs(u.focus) || n.change((f) => {
        const m = l.return;
        if (h.parent.is("element") && (m.childCount > 1 || u.containsEntireContent(h.parent))) {
          const C = f.createElement("codeBlock", h.parent.getAttributes());
          f.append(m, C);
          const k = f.createDocumentFragment();
          f.append(C, k), l.return = k;
          return;
        }
        const v = m.getChild(0);
        t.checkAttribute(v, "code") && f.setAttribute("code", !0, v);
      });
    });
  }
  /**
   * @inheritDoc
   */
  afterInit() {
    const e = this.editor, t = e.commands, n = t.get("indent"), r = t.get("outdent");
    n && n.registerChildCommand(t.get("indentCodeBlock"), { priority: "highest" }), r && r.registerChildCommand(t.get("outdentCodeBlock")), this.listenTo(e.editing.view.document, "enter", (s, o) => {
      e.model.document.selection.getLastPosition().parent.is("element", "codeBlock") && (!Jz(e, o.isSoft) && !Xz(e, o.isSoft) && Yz(e), o.preventDefault(), s.stop());
    }, { context: "pre" });
  }
}
function Yz(i) {
  const t = i.model.document, n = t.selection.getLastPosition(), r = n.nodeBefore || n.textNode;
  let s;
  r && r.is("$text") && (s = Rp(r)), i.model.change((o) => {
    i.execute("shiftEnter"), s && o.insertText(s, t.selection.anchor);
  });
}
function Jz(i, e) {
  const n = i.model.document, r = i.editing.view, s = n.selection.getLastPosition(), o = s.nodeAfter;
  return e || !n.selection.isCollapsed || !s.isAtStart || !As(o) ? !1 : (i.model.change((l) => {
    i.execute("enter");
    const u = n.selection.anchor.parent.previousSibling;
    l.rename(u, rS), l.setSelection(u, "in"), i.model.schema.removeDisallowedAttributes([u], l), l.remove(o);
  }), r.scrollToTheSelection(), !0);
}
function Xz(i, e) {
  const t = i.model, n = t.document, r = i.editing.view, s = n.selection.getLastPosition(), o = s.nodeBefore;
  let l;
  if (e || !n.selection.isCollapsed || !s.isAtEnd || !o || !o.previousSibling)
    return !1;
  if (As(o) && As(o.previousSibling))
    l = t.createRange(t.createPositionBefore(o.previousSibling), t.createPositionAfter(o));
  else if (Om(o) && As(o.previousSibling) && As(o.previousSibling.previousSibling))
    l = t.createRange(t.createPositionBefore(o.previousSibling.previousSibling), t.createPositionAfter(o));
  else if (Om(o) && As(o.previousSibling) && Om(o.previousSibling.previousSibling) && o.previousSibling.previousSibling && As(o.previousSibling.previousSibling.previousSibling))
    l = t.createRange(t.createPositionBefore(o.previousSibling.previousSibling.previousSibling), t.createPositionAfter(o));
  else
    return !1;
  return i.model.change((u) => {
    u.remove(l), i.execute("enter");
    const h = n.selection.anchor.parent;
    u.rename(h, rS), i.model.schema.removeDisallowedAttributes([h], u);
  }), r.scrollToTheSelection(), !0;
}
function Om(i) {
  return i && i.is("$text") && !i.data.match(/\S/);
}
function As(i) {
  return i && i.is("element", "softBreak");
}
const Zz = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M12.87 12.61a.75.75 0 0 1-.089.976l-.085.07-3.154 2.254 3.412 2.414a.75.75 0 0 1 .237.95l-.057.095a.75.75 0 0 1-.95.237l-.096-.058-4.272-3.022-.003-1.223 4.01-2.867a.75.75 0 0 1 1.047.174zm2.795-.231.095.057 4.011 2.867-.003 1.223-4.272 3.022-.095.058a.75.75 0 0 1-.88-.151l-.07-.086-.058-.095a.75.75 0 0 1 .15-.88l.087-.07 3.412-2.414-3.154-2.253-.085-.071a.75.75 0 0 1 .862-1.207zM16 0a2 2 0 0 1 2 2v9.354l-.663-.492-.837-.001V2a.5.5 0 0 0-.5-.5H2a.5.5 0 0 0-.5.5v15a.5.5 0 0 0 .5.5h3.118L7.156 19H2a2 2 0 0 1-2-2V2a2 2 0 0 1 2-2h14zM5.009 15l.003 1H3v-1h2.009zm2.188-2-1.471 1H5v-1h2.197zM10 11v.095L8.668 12H7v-1h3zm4-2v1H7V9h7zm0-2v1H7V7h7zm-4-2v1H5V5h5zM6 3v1H3V3h3z"/></svg>';
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class Qz extends fe {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "CodeBlockUI";
  }
  /**
   * @inheritDoc
   */
  init() {
    const e = this.editor, t = e.t, n = e.ui.componentFactory, r = Ip(e);
    n.add("codeBlock", (s) => {
      const o = e.commands.get("codeBlock"), l = Gs(s, fh), u = l.buttonView;
      return u.set({
        label: t("Insert code block"),
        tooltip: !0,
        icon: Zz,
        isToggleable: !0
      }), u.bind("isOn").to(o, "value", (h) => !!h), u.on("execute", () => {
        e.execute("codeBlock", {
          usePreviousLanguageChoice: !0
        }), e.editing.view.focus();
      }), l.on("execute", (h) => {
        e.execute("codeBlock", {
          language: h.source._codeBlockLanguage,
          forceValue: !0
        }), e.editing.view.focus();
      }), l.class = "ck-code-block-dropdown", l.bind("isEnabled").to(o), MC(l, () => this._getLanguageListItemDefinitions(r)), l;
    });
  }
  /**
   * A helper returning a collection of the `codeBlock` dropdown items representing languages
   * available for the user to choose from.
   */
  _getLanguageListItemDefinitions(e) {
    const n = this.editor.commands.get("codeBlock"), r = new Br();
    for (const s of e) {
      const o = {
        type: "button",
        model: new VC({
          _codeBlockLanguage: s.language,
          label: s.label,
          withText: !0
        })
      };
      o.model.bind("isOn").to(n, "value", (l) => l === o.model._codeBlockLanguage), r.add(o);
    }
    return r;
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class eW extends fe {
  /**
   * @inheritDoc
   */
  static get requires() {
    return [Gz, Qz];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "CodeBlock";
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class ra extends Pt {
  /**
   * @param attributeKey Attribute that will be set by the command.
   */
  constructor(e, t) {
    super(e), this.attributeKey = t;
  }
  /**
   * Updates the command's {@link #value} and {@link #isEnabled} based on the current selection.
   */
  refresh() {
    const e = this.editor.model, t = e.document;
    this.value = this._getValueFromFirstAllowedNode(), this.isEnabled = e.schema.checkAttributeInSelection(t.selection, this.attributeKey);
  }
  /**
   * Executes the command &mdash; applies the attribute to the selection or removes it from the selection.
   *
   * If the command is active (`value == true`), it will remove attributes. Otherwise, it will set attributes.
   *
   * The execution result differs, depending on the {@link module:engine/model/document~Document#selection}:
   *
   * * If the selection is on a range, the command applies the attribute to all nodes in that range
   * (if they are allowed to have this attribute by the {@link module:engine/model/schema~Schema schema}).
   * * If the selection is collapsed in a non-empty node, the command applies the attribute to the
   * {@link module:engine/model/document~Document#selection} itself (note that typed characters copy attributes from the selection).
   * * If the selection is collapsed in an empty node, the command applies the attribute to the parent node of the selection (note
   * that the selection inherits all attributes from a node if it is in an empty node).
   *
   * @fires execute
   * @param options Command options.
   * @param options.forceValue If set, it will force the command behavior. If `true`,
   * the command will apply the attribute, otherwise the command will remove the attribute.
   * If not set, the command will look for its current value to decide what it should do.
   */
  execute(e = {}) {
    const t = this.editor.model, r = t.document.selection, s = e.forceValue === void 0 ? !this.value : e.forceValue;
    t.change((o) => {
      if (r.isCollapsed)
        s ? o.setSelectionAttribute(this.attributeKey, !0) : o.removeSelectionAttribute(this.attributeKey);
      else {
        const l = t.schema.getValidRanges(r.getRanges(), this.attributeKey);
        for (const u of l)
          s ? o.setAttribute(this.attributeKey, s, u) : o.removeAttribute(this.attributeKey, u);
      }
    });
  }
  /**
   * Checks the attribute value of the first node in the selection that allows the attribute.
   * For the collapsed selection returns the selection attribute.
   *
   * @returns The attribute value.
   */
  _getValueFromFirstAllowedNode() {
    const e = this.editor.model, t = e.schema, n = e.document.selection;
    if (n.isCollapsed)
      return n.hasAttribute(this.attributeKey);
    for (const r of n.getRanges())
      for (const s of r.getItems())
        if (t.checkAttribute(s, this.attributeKey))
          return s.hasAttribute(this.attributeKey);
    return !1;
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const Ao = "bold";
class tW extends fe {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "BoldEditing";
  }
  /**
   * @inheritDoc
   */
  init() {
    const e = this.editor;
    e.model.schema.extend("$text", { allowAttributes: Ao }), e.model.schema.setAttributeProperties(Ao, {
      isFormatting: !0,
      copyOnEnter: !0
    }), e.conversion.attributeToElement({
      model: Ao,
      view: "strong",
      upcastAlso: [
        "b",
        (t) => {
          const n = t.getStyle("font-weight");
          return n && (n == "bold" || Number(n) >= 600) ? {
            name: !0,
            styles: ["font-weight"]
          } : null;
        }
      ]
    }), e.commands.add(Ao, new ra(e, Ao)), e.keystrokes.set("CTRL+B", Ao);
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const Mm = "bold";
class nW extends fe {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "BoldUI";
  }
  /**
   * @inheritDoc
   */
  init() {
    const e = this.editor, t = e.t;
    e.ui.componentFactory.add(Mm, (n) => {
      const r = e.commands.get(Mm), s = new At(n);
      return s.set({
        label: t("Bold"),
        icon: Mt.bold,
        keystroke: "CTRL+B",
        tooltip: !0,
        isToggleable: !0
      }), s.bind("isOn", "isEnabled").to(r, "value", "isEnabled"), this.listenTo(s, "execute", () => {
        e.execute(Mm), e.editing.view.focus();
      }), s;
    });
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class iW extends fe {
  /**
   * @inheritDoc
   */
  static get requires() {
    return [tW, nW];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "Bold";
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const Po = "italic";
class rW extends fe {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "ItalicEditing";
  }
  /**
   * @inheritDoc
   */
  init() {
    const e = this.editor;
    e.model.schema.extend("$text", { allowAttributes: Po }), e.model.schema.setAttributeProperties(Po, {
      isFormatting: !0,
      copyOnEnter: !0
    }), e.conversion.attributeToElement({
      model: Po,
      view: "i",
      upcastAlso: [
        "em",
        {
          styles: {
            "font-style": "italic"
          }
        }
      ]
    }), e.commands.add(Po, new ra(e, Po)), e.keystrokes.set("CTRL+I", Po);
  }
}
const sW = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m9.586 14.633.021.004c-.036.335.095.655.393.962.082.083.173.15.274.201h1.474a.6.6 0 1 1 0 1.2H5.304a.6.6 0 0 1 0-1.2h1.15c.474-.07.809-.182 1.005-.334.157-.122.291-.32.404-.597l2.416-9.55a1.053 1.053 0 0 0-.281-.823 1.12 1.12 0 0 0-.442-.296H8.15a.6.6 0 0 1 0-1.2h6.443a.6.6 0 1 1 0 1.2h-1.195c-.376.056-.65.155-.823.296-.215.175-.423.439-.623.79l-2.366 9.347z"/></svg>';
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const Nm = "italic";
class oW extends fe {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "ItalicUI";
  }
  /**
   * @inheritDoc
   */
  init() {
    const e = this.editor, t = e.t;
    e.ui.componentFactory.add(Nm, (n) => {
      const r = e.commands.get(Nm), s = new At(n);
      return s.set({
        label: t("Italic"),
        icon: sW,
        keystroke: "CTRL+I",
        tooltip: !0,
        isToggleable: !0
      }), s.bind("isOn", "isEnabled").to(r, "value", "isEnabled"), this.listenTo(s, "execute", () => {
        e.execute(Nm), e.editing.view.focus();
      }), s;
    });
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class aW extends fe {
  /**
   * @inheritDoc
   */
  static get requires() {
    return [rW, oW];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "Italic";
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const Za = "strikethrough";
class lW extends fe {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "StrikethroughEditing";
  }
  /**
   * @inheritDoc
   */
  init() {
    const e = this.editor;
    e.model.schema.extend("$text", { allowAttributes: Za }), e.model.schema.setAttributeProperties(Za, {
      isFormatting: !0,
      copyOnEnter: !0
    }), e.conversion.attributeToElement({
      model: Za,
      view: "s",
      upcastAlso: [
        "del",
        "strike",
        {
          styles: {
            "text-decoration": "line-through"
          }
        }
      ]
    }), e.commands.add(Za, new ra(e, Za)), e.keystrokes.set("CTRL+SHIFT+X", "strikethrough");
  }
}
const cW = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M7 16.4c-.8-.4-1.5-.9-2.2-1.5a.6.6 0 0 1-.2-.5l.3-.6h1c1 1.2 2.1 1.7 3.7 1.7 1 0 1.8-.3 2.3-.6.6-.4.6-1.2.6-1.3.2-1.2-.9-2.1-.9-2.1h2.1c.3.7.4 1.2.4 1.7v.8l-.6 1.2c-.6.8-1.1 1-1.6 1.2a6 6 0 0 1-2.4.6c-1 0-1.8-.3-2.5-.6zM6.8 9 6 8.3c-.4-.5-.5-.8-.5-1.6 0-.7.1-1.3.5-1.8.4-.6 1-1 1.6-1.3a6.3 6.3 0 0 1 4.7 0 4 4 0 0 1 1.7 1l.3.7c0 .1.2.4-.2.7-.4.2-.9.1-1 0a3 3 0 0 0-1.2-1c-.4-.2-1-.3-2-.4-.7 0-1.4.2-2 .6-.8.6-1 .8-1 1.5 0 .8.5 1 1.2 1.5.6.4 1.1.7 1.9 1H6.8z"/><path d="M3 10.5V9h14v1.5z"/></svg>';
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const Dm = "strikethrough";
class uW extends fe {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "StrikethroughUI";
  }
  /**
   * @inheritDoc
   */
  init() {
    const e = this.editor, t = e.t;
    e.ui.componentFactory.add(Dm, (n) => {
      const r = e.commands.get(Dm), s = new At(n);
      return s.set({
        label: t("Strikethrough"),
        icon: cW,
        keystroke: "CTRL+SHIFT+X",
        tooltip: !0,
        isToggleable: !0
      }), s.bind("isOn", "isEnabled").to(r, "value", "isEnabled"), this.listenTo(s, "execute", () => {
        e.execute(Dm), e.editing.view.focus();
      }), s;
    });
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class dW extends fe {
  /**
   * @inheritDoc
   */
  static get requires() {
    return [lW, uW];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "Strikethrough";
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const Qa = "underline";
class hW extends fe {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "UnderlineEditing";
  }
  /**
   * @inheritDoc
   */
  init() {
    const e = this.editor;
    e.model.schema.extend("$text", { allowAttributes: Qa }), e.model.schema.setAttributeProperties(Qa, {
      isFormatting: !0,
      copyOnEnter: !0
    }), e.conversion.attributeToElement({
      model: Qa,
      view: "u",
      upcastAlso: {
        styles: {
          "text-decoration": "underline"
        }
      }
    }), e.commands.add(Qa, new ra(e, Qa)), e.keystrokes.set("CTRL+U", "underline");
  }
}
const fW = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M3 18v-1.5h14V18zm2.2-8V3.6c0-.4.4-.6.8-.6.3 0 .7.2.7.6v6.2c0 2 1.3 2.8 3.2 2.8 1.9 0 3.4-.9 3.4-2.9V3.6c0-.3.4-.5.8-.5.3 0 .7.2.7.5V10c0 2.7-2.2 4-4.9 4-2.6 0-4.7-1.2-4.7-4z"/></svg>';
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const Bm = "underline";
class mW extends fe {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "UnderlineUI";
  }
  /**
   * @inheritDoc
   */
  init() {
    const e = this.editor, t = e.t;
    e.ui.componentFactory.add(Bm, (n) => {
      const r = e.commands.get(Bm), s = new At(n);
      return s.set({
        label: t("Underline"),
        icon: fW,
        keystroke: "CTRL+U",
        tooltip: !0,
        isToggleable: !0
      }), s.bind("isOn", "isEnabled").to(r, "value", "isEnabled"), this.listenTo(s, "execute", () => {
        e.execute(Bm), e.editing.view.focus();
      }), s;
    });
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class gW extends fe {
  /**
   * @inheritDoc
   */
  static get requires() {
    return [hW, mW];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "Underline";
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class pW extends Pt {
  /**
   * @inheritDoc
   */
  refresh() {
    const n = this.editor.plugins.get("ImageUtils").getClosestSelectedImageElement(this.editor.model.document.selection);
    this.isEnabled = !!n, this.isEnabled && n.hasAttribute("alt") ? this.value = n.getAttribute("alt") : this.value = !1;
  }
  /**
   * Executes the command.
   *
   * @fires execute
   * @param options
   * @param options.newValue The new value of the `alt` attribute to set.
   */
  execute(e) {
    const t = this.editor, n = t.plugins.get("ImageUtils"), r = t.model, s = n.getClosestSelectedImageElement(r.document.selection);
    r.change((o) => {
      o.setAttribute("alt", e.newValue, s);
    });
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function _W(i) {
  return i.createContainerElement("span", { class: "image-inline" }, i.createEmptyElement("img"));
}
function d0(i) {
  return i.createContainerElement("figure", { class: "image" }, [
    i.createEmptyElement("img"),
    i.createSlot("children")
  ]);
}
function sS(i, e) {
  const t = i.plugins.get("ImageUtils"), n = i.plugins.has("ImageInlineEditing") && i.plugins.has("ImageBlockEditing");
  return (s) => t.isInlineImageView(s) ? n && (s.getStyle("display") == "block" || s.findAncestor(t.isBlockImageView) ? "imageBlock" : "imageInline") !== e ? null : r(s) : null;
  function r(s) {
    const o = {
      name: !0
    };
    return s.hasAttribute("src") && (o.attributes = ["src"]), o;
  }
}
function Op(i, e) {
  const t = Rn(e.getSelectedBlocks());
  return !t || i.isObject(t) || t.isEmpty && t.name != "listItem" ? "imageBlock" : "imageInline";
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class Wi extends fe {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "ImageUtils";
  }
  /**
   * Checks if the provided model element is an `image` or `imageInline`.
   */
  isImage(e) {
    return this.isInlineImage(e) || this.isBlockImage(e);
  }
  /**
   * Checks if the provided view element represents an inline image.
   *
   * Also, see {@link module:image/imageutils~ImageUtils#isImageWidget}.
   */
  isInlineImageView(e) {
    return !!e && e.is("element", "img");
  }
  /**
   * Checks if the provided view element represents a block image.
   *
   * Also, see {@link module:image/imageutils~ImageUtils#isImageWidget}.
   */
  isBlockImageView(e) {
    return !!e && e.is("element", "figure") && e.hasClass("image");
  }
  /**
   * Handles inserting single file. This method unifies image insertion using {@link module:widget/utils~findOptimalInsertionRange}
   * method.
   *
   * ```ts
   * const imageUtils = editor.plugins.get( 'ImageUtils' );
   *
   * imageUtils.insertImage( { src: 'path/to/image.jpg' } );
   * ```
   *
   * @param attributes Attributes of the inserted image.
   * This method filters out the attributes which are disallowed by the {@link module:engine/model/schema~Schema}.
   * @param selectable Place to insert the image. If not specified,
   * the {@link module:widget/utils~findOptimalInsertionRange} logic will be applied for the block images
   * and `model.document.selection` for the inline images.
   *
   * **Note**: If `selectable` is passed, this helper will not be able to set selection attributes (such as `linkHref`)
   * and apply them to the new image. In this case, make sure all selection attributes are passed in `attributes`.
   *
   * @param imageType Image type of inserted image. If not specified,
   * it will be determined automatically depending of editor config or place of the insertion.
   * @return The inserted model image element.
   */
  insertImage(e = {}, t = null, n = null) {
    const r = this.editor, s = r.model, o = s.document.selection;
    n = oS(r, t || o, n), e = {
      ...Object.fromEntries(o.getAttributes()),
      ...e
    };
    for (const l in e)
      s.schema.checkAttribute(n, l) || delete e[l];
    return s.change((l) => {
      const u = l.createElement(n, e);
      return s.insertObject(u, t, null, {
        setSelection: "on",
        // If we want to insert a block image (for whatever reason) then we don't want to split text blocks.
        // This applies only when we don't have the selectable specified (i.e., we insert multiple block images at once).
        findOptimalPosition: !t && n != "imageInline" ? "auto" : void 0
      }), u.parent ? u : null;
    });
  }
  /**
   * Returns an image widget editing view element if one is selected or is among the selection's ancestors.
   */
  getClosestSelectedImageWidget(e) {
    const t = e.getFirstPosition();
    if (!t)
      return null;
    const n = e.getSelectedElement();
    if (n && this.isImageWidget(n))
      return n;
    let r = t.parent;
    for (; r; ) {
      if (r.is("element") && this.isImageWidget(r))
        return r;
      r = r.parent;
    }
    return null;
  }
  /**
   * Returns a image model element if one is selected or is among the selection's ancestors.
   */
  getClosestSelectedImageElement(e) {
    const t = e.getSelectedElement();
    return this.isImage(t) ? t : e.getFirstPosition().findAncestor("imageBlock");
  }
  /**
   * Checks if image can be inserted at current model selection.
   *
   * @internal
   */
  isImageAllowed() {
    const t = this.editor.model.document.selection;
    return vW(this.editor, t) && wW(t);
  }
  /**
   * Converts a given {@link module:engine/view/element~Element} to an image widget:
   * * Adds a {@link module:engine/view/element~Element#_setCustomProperty custom property} allowing to recognize the image widget
   * element.
   * * Calls the {@link module:widget/utils~toWidget} function with the proper element's label creator.
   *
   * @param writer An instance of the view writer.
   * @param label The element's label. It will be concatenated with the image `alt` attribute if one is present.
   */
  toImageWidget(e, t, n) {
    return t.setCustomProperty("image", !0, e), T$(e, t, { label: () => {
      const o = this.findViewImgElement(e).getAttribute("alt");
      return o ? `${o} ${n}` : n;
    } });
  }
  /**
   * Checks if a given view element is an image widget.
   */
  isImageWidget(e) {
    return !!e.getCustomProperty("image") && Gt(e);
  }
  /**
   * Checks if the provided model element is an `image`.
   */
  isBlockImage(e) {
    return !!e && e.is("element", "imageBlock");
  }
  /**
   * Checks if the provided model element is an `imageInline`.
   */
  isInlineImage(e) {
    return !!e && e.is("element", "imageInline");
  }
  /**
   * Get the view `<img>` from another view element, e.g. a widget (`<figure class="image">`), a link (`<a>`).
   *
   * The `<img>` can be located deep in other elements, so this helper performs a deep tree search.
   */
  findViewImgElement(e) {
    if (this.isInlineImageView(e))
      return e;
    const t = this.editor.editing.view;
    for (const { item: n } of t.createRangeIn(e))
      if (this.isInlineImageView(n))
        return n;
  }
}
function vW(i, e) {
  if (oS(i, e, null) == "imageBlock") {
    const n = bW(e, i.model);
    if (i.model.schema.checkChild(n, "imageBlock"))
      return !0;
  } else if (i.model.schema.checkChild(e.focus, "imageInline"))
    return !0;
  return !1;
}
function wW(i) {
  return [...i.focus.getAncestors()].every((e) => !e.is("element", "imageBlock"));
}
function bW(i, e) {
  const n = R$(i, e).start.parent;
  return n.isEmpty && !n.is("element", "$root") ? n.parent : n;
}
function oS(i, e, t) {
  const n = i.model.schema, r = i.config.get("image.insert.type");
  return i.plugins.has("ImageBlockEditing") ? i.plugins.has("ImageInlineEditing") ? t || (r === "inline" ? "imageInline" : r === "block" ? "imageBlock" : e.is("selection") ? Op(n, e) : n.checkChild(e, "imageInline") ? "imageInline" : "imageBlock") : "imageBlock" : "imageInline";
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class yW extends fe {
  /**
   * @inheritDoc
   */
  static get requires() {
    return [Wi];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "ImageTextAlternativeEditing";
  }
  /**
   * @inheritDoc
   */
  init() {
    this.editor.commands.add("imageTextAlternative", new pW(this.editor));
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class EW extends Xe {
  /**
   * @inheritDoc
   */
  constructor(e) {
    super(e);
    const t = this.locale.t;
    this.focusTracker = new hi(), this.keystrokes = new cr(), this.labeledInput = this._createLabeledInputView(), this.saveButtonView = this._createButton(t("Save"), Mt.check, "ck-button-save"), this.saveButtonView.type = "submit", this.cancelButtonView = this._createButton(t("Cancel"), Mt.cancel, "ck-button-cancel", "cancel"), this._focusables = new cs(), this._focusCycler = new ta({
      focusables: this._focusables,
      focusTracker: this.focusTracker,
      keystrokeHandler: this.keystrokes,
      actions: {
        // Navigate form fields backwards using the Shift + Tab keystroke.
        focusPrevious: "shift + tab",
        // Navigate form fields forwards using the Tab key.
        focusNext: "tab"
      }
    }), this.setTemplate({
      tag: "form",
      attributes: {
        class: [
          "ck",
          "ck-text-alternative-form",
          "ck-responsive-form"
        ],
        // https://github.com/ckeditor/ckeditor5-image/issues/40
        tabindex: "-1"
      },
      children: [
        this.labeledInput,
        this.saveButtonView,
        this.cancelButtonView
      ]
    });
  }
  /**
   * @inheritDoc
   */
  render() {
    super.render(), this.keystrokes.listenTo(this.element), CC({ view: this }), [this.labeledInput, this.saveButtonView, this.cancelButtonView].forEach((e) => {
      this._focusables.add(e), this.focusTracker.add(e.element);
    });
  }
  /**
   * @inheritDoc
   */
  destroy() {
    super.destroy(), this.focusTracker.destroy(), this.keystrokes.destroy();
  }
  /**
   * Creates the button view.
   *
   * @param label The button label
   * @param icon The button's icon.
   * @param className The additional button CSS class name.
   * @param eventName The event name that the ButtonView#execute event will be delegated to.
   * @returns The button view instance.
   */
  _createButton(e, t, n, r) {
    const s = new At(this.locale);
    return s.set({
      label: e,
      icon: t,
      tooltip: !0
    }), s.extendTemplate({
      attributes: {
        class: n
      }
    }), r && s.delegate("execute").to(this, r), s;
  }
  /**
   * Creates an input with a label.
   *
   * @returns Labeled field view instance.
   */
  _createLabeledInputView() {
    const e = this.locale.t, t = new Sp(this.locale, BC);
    return t.label = e("Text alternative"), t;
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function CW(i) {
  const e = i.plugins.get("ContextualBalloon");
  if (i.plugins.get("ImageUtils").getClosestSelectedImageWidget(i.editing.view.document.selection)) {
    const n = aS(i);
    e.updatePosition(n);
  }
}
function aS(i) {
  const e = i.editing.view, t = gn.defaultPositions, n = i.plugins.get("ImageUtils");
  return {
    target: e.domConverter.mapViewToDom(n.getClosestSelectedImageWidget(e.document.selection)),
    positions: [
      t.northArrowSouth,
      t.northArrowSouthWest,
      t.northArrowSouthEast,
      t.southArrowNorth,
      t.southArrowNorthWest,
      t.southArrowNorthEast,
      t.viewportStickyNorth
    ]
  };
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class SW extends fe {
  /**
   * @inheritDoc
   */
  static get requires() {
    return [qo];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "ImageTextAlternativeUI";
  }
  /**
   * @inheritDoc
   */
  init() {
    this._createButton();
  }
  /**
   * @inheritDoc
   */
  destroy() {
    super.destroy(), this._form && this._form.destroy();
  }
  /**
   * Creates a button showing the balloon panel for changing the image text alternative and
   * registers it in the editor {@link module:ui/componentfactory~ComponentFactory ComponentFactory}.
   */
  _createButton() {
    const e = this.editor, t = e.t;
    e.ui.componentFactory.add("imageTextAlternative", (n) => {
      const r = e.commands.get("imageTextAlternative"), s = new At(n);
      return s.set({
        label: t("Change image text alternative"),
        icon: Mt.lowVision,
        tooltip: !0
      }), s.bind("isEnabled").to(r, "isEnabled"), s.bind("isOn").to(r, "value", (o) => !!o), this.listenTo(s, "execute", () => {
        this._showForm();
      }), s;
    });
  }
  /**
   * Creates the {@link module:image/imagetextalternative/ui/textalternativeformview~TextAlternativeFormView}
   * form.
   */
  _createForm() {
    const e = this.editor, n = e.editing.view.document, r = e.plugins.get("ImageUtils");
    this._balloon = this.editor.plugins.get("ContextualBalloon"), this._form = new (EC(EW))(e.locale), this._form.render(), this.listenTo(this._form, "submit", () => {
      e.execute("imageTextAlternative", {
        newValue: this._form.labeledInput.fieldView.element.value
      }), this._hideForm(!0);
    }), this.listenTo(this._form, "cancel", () => {
      this._hideForm(!0);
    }), this._form.keystrokes.set("Esc", (s, o) => {
      this._hideForm(!0), o();
    }), this.listenTo(e.ui, "update", () => {
      r.getClosestSelectedImageWidget(n.selection) ? this._isVisible && CW(e) : this._hideForm(!0);
    }), vp({
      emitter: this._form,
      activator: () => this._isVisible,
      contextElements: () => [this._balloon.view.element],
      callback: () => this._hideForm()
    });
  }
  /**
   * Shows the {@link #_form} in the {@link #_balloon}.
   */
  _showForm() {
    if (this._isVisible)
      return;
    this._form || this._createForm();
    const e = this.editor, t = e.commands.get("imageTextAlternative"), n = this._form.labeledInput;
    this._form.disableCssTransitions(), this._isInBalloon || this._balloon.add({
      view: this._form,
      position: aS(e)
    }), n.fieldView.value = n.fieldView.element.value = t.value || "", this._form.labeledInput.fieldView.select(), this._form.enableCssTransitions();
  }
  /**
   * Removes the {@link #_form} from the {@link #_balloon}.
   *
   * @param focusEditable Controls whether the editing view is focused afterwards.
   */
  _hideForm(e = !1) {
    this._isInBalloon && (this._form.focusTracker.isFocused && this._form.saveButtonView.focus(), this._balloon.remove(this._form), e && this.editor.editing.view.focus());
  }
  /**
   * Returns `true` when the {@link #_form} is the visible view in the {@link #_balloon}.
   */
  get _isVisible() {
    return !!this._balloon && this._balloon.visibleView === this._form;
  }
  /**
   * Returns `true` when the {@link #_form} is in the {@link #_balloon}.
   */
  get _isInBalloon() {
    return !!this._balloon && this._balloon.hasView(this._form);
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class lS extends fe {
  /**
   * @inheritDoc
   */
  static get requires() {
    return [yW, SW];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "ImageTextAlternative";
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function TW(i) {
  const e = (t, n, r) => {
    if (!r.consumable.test(n.viewItem, { name: !0, classes: "image" }))
      return;
    const s = i.findViewImgElement(n.viewItem);
    if (!s || !r.consumable.test(s, { name: !0 }))
      return;
    r.consumable.consume(n.viewItem, { name: !0, classes: "image" });
    const o = r.convertItem(s, n.modelCursor), l = Rn(o.modelRange.getItems());
    if (!l) {
      r.consumable.revert(n.viewItem, { name: !0, classes: "image" });
      return;
    }
    r.convertChildren(n.viewItem, l), r.updateConversionResult(l, n);
  };
  return (t) => {
    t.on("element:figure", e);
  };
}
function cS(i, e) {
  const t = (n, r, s) => {
    if (!s.consumable.consume(r.item, n.name))
      return;
    const o = s.writer, l = s.mapper.toViewElement(r.item), u = i.findViewImgElement(l);
    if (r.attributeNewValue === null) {
      const h = r.attributeOldValue;
      h && h.data && (o.removeAttribute("srcset", u), o.removeAttribute("sizes", u), h.width && o.removeAttribute("width", u));
    } else {
      const h = r.attributeNewValue;
      h && h.data && (o.setAttribute("srcset", h.data, u), o.setAttribute("sizes", "100vw", u), h.width && o.setAttribute("width", h.width, u));
    }
  };
  return (n) => {
    n.on(`attribute:srcset:${e}`, t);
  };
}
function Od(i, e, t) {
  const n = (r, s, o) => {
    if (!o.consumable.consume(s.item, r.name))
      return;
    const l = o.writer, u = o.mapper.toViewElement(s.item), h = i.findViewImgElement(u);
    l.setAttribute(s.attributeKey, s.attributeNewValue || "", h);
  };
  return (r) => {
    r.on(`attribute:${t}:${e}`, n);
  };
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class uS extends dr {
  /**
   * @inheritDoc
   */
  observe(e) {
    this.listenTo(e, "load", (t, n) => {
      const r = n.target;
      this.checkShouldIgnoreEventFromTarget(r) || r.tagName == "IMG" && this._fireEvents(n);
    }, { useCapture: !0 });
  }
  /**
   * @inheritDoc
   */
  stopObserving(e) {
    this.stopListening(e);
  }
  /**
   * Fires {@link module:engine/view/document~Document#event:layoutChanged} and
   * {@link module:engine/view/document~Document#event:imageLoaded}
   * if observer {@link #isEnabled is enabled}.
   *
   * @param domEvent The DOM event.
   */
  _fireEvents(e) {
    this.isEnabled && (this.document.fire("layoutChanged"), this.document.fire("imageLoaded", e));
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class xW extends Pt {
  /**
   * @inheritDoc
   */
  constructor(e) {
    super(e);
    const t = e.config.get("image.insert.type");
    e.plugins.has("ImageBlockEditing") || t === "block" && Yt("image-block-plugin-required"), e.plugins.has("ImageInlineEditing") || t === "inline" && Yt("image-inline-plugin-required");
  }
  /**
   * @inheritDoc
   */
  refresh() {
    const e = this.editor.plugins.get("ImageUtils");
    this.isEnabled = e.isImageAllowed();
  }
  /**
   * Executes the command.
   *
   * @fires execute
   * @param options Options for the executed command.
   * @param options.source The image source or an array of image sources to insert.
   * See the documentation of the command to learn more about accepted formats.
   */
  execute(e) {
    const t = In(e.source), n = this.editor.model.document.selection, r = this.editor.plugins.get("ImageUtils"), s = Object.fromEntries(n.getAttributes());
    t.forEach((o, l) => {
      const u = n.getSelectedElement();
      if (typeof o == "string" && (o = { src: o }), l && u && r.isImage(u)) {
        const h = this.editor.model.createPositionAfter(u);
        r.insertImage({ ...o, ...s }, h);
      } else
        r.insertImage({ ...o, ...s });
    });
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class kW extends Pt {
  /**
   * @inheritDoc
   */
  refresh() {
    const t = this.editor.plugins.get("ImageUtils"), n = this.editor.model.document.selection.getSelectedElement();
    this.isEnabled = t.isImage(n), this.value = this.isEnabled ? n.getAttribute("src") : null;
  }
  /**
   * Executes the command.
   *
   * @fires execute
   * @param options Options for the executed command.
   * @param options.source The image source to replace.
   */
  execute(e) {
    const t = this.editor.model.document.selection.getSelectedElement();
    this.editor.model.change((n) => {
      n.setAttribute("src", e.source, t), n.removeAttribute("srcset", t), n.removeAttribute("sizes", t);
    });
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class dS extends fe {
  /**
   * @inheritDoc
   */
  static get requires() {
    return [Wi];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "ImageEditing";
  }
  /**
   * @inheritDoc
   */
  init() {
    const e = this.editor, t = e.conversion;
    e.editing.view.addObserver(uS), t.for("upcast").attributeToAttribute({
      view: {
        name: "img",
        key: "alt"
      },
      model: "alt"
    }).attributeToAttribute({
      view: {
        name: "img",
        key: "srcset"
      },
      model: {
        key: "srcset",
        value: (s) => {
          const o = {
            data: s.getAttribute("srcset")
          };
          return s.hasAttribute("width") && (o.width = s.getAttribute("width")), o;
        }
      }
    });
    const n = new xW(e), r = new kW(e);
    e.commands.add("insertImage", n), e.commands.add("replaceImageSource", r), e.commands.add("imageInsert", n);
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class hS extends Pt {
  /**
   * @inheritDoc
   *
   * @param modelElementName Model element name the command converts to.
   */
  constructor(e, t) {
    super(e), this._modelElementName = t;
  }
  /**
   * @inheritDoc
   */
  refresh() {
    const t = this.editor.plugins.get("ImageUtils"), n = t.getClosestSelectedImageElement(this.editor.model.document.selection);
    this._modelElementName === "imageBlock" ? this.isEnabled = t.isInlineImage(n) : this.isEnabled = t.isBlockImage(n);
  }
  /**
   * Executes the command and changes the type of a selected image.
   *
   * @fires execute
   * @returns An object containing references to old and new model image elements
   * (for before and after the change) so external integrations can hook into the decorated
   * `execute` event and handle this change. `null` if the type change failed.
   */
  execute() {
    const e = this.editor, t = this.editor.model, n = e.plugins.get("ImageUtils"), r = n.getClosestSelectedImageElement(t.document.selection), s = Object.fromEntries(r.getAttributes());
    return !s.src && !s.uploadId ? null : t.change((o) => {
      const l = Array.from(t.markers).filter((f) => f.getRange().containsItem(r)), u = n.insertImage(s, t.createSelection(r, "on"), this._modelElementName);
      if (!u)
        return null;
      const h = o.createRangeOn(u);
      for (const f of l) {
        const m = f.getRange(), v = m.root.rootName != "$graveyard" ? m.getJoined(h, !0) : h;
        o.updateMarker(f, { range: v });
      }
      return {
        oldElement: r,
        newElement: u
      };
    });
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class fS extends fe {
  /**
   * @inheritDoc
   */
  static get requires() {
    return [dS, Wi, rs];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "ImageBlockEditing";
  }
  /**
   * @inheritDoc
   */
  init() {
    const e = this.editor;
    e.model.schema.register("imageBlock", {
      inheritAllFrom: "$blockObject",
      allowAttributes: ["alt", "src", "srcset"]
    }), this._setupConversion(), e.plugins.has("ImageInlineEditing") && (e.commands.add("imageTypeBlock", new hS(this.editor, "imageBlock")), this._setupClipboardIntegration());
  }
  /**
   * Configures conversion pipelines to support upcasting and downcasting
   * block images (block image widgets) and their attributes.
   */
  _setupConversion() {
    const e = this.editor, t = e.t, n = e.conversion, r = e.plugins.get("ImageUtils");
    n.for("dataDowncast").elementToStructure({
      model: "imageBlock",
      view: (s, { writer: o }) => d0(o)
    }), n.for("editingDowncast").elementToStructure({
      model: "imageBlock",
      view: (s, { writer: o }) => r.toImageWidget(d0(o), o, t("image widget"))
    }), n.for("downcast").add(Od(r, "imageBlock", "src")).add(Od(r, "imageBlock", "alt")).add(cS(r, "imageBlock")), n.for("upcast").elementToElement({
      view: sS(e, "imageBlock"),
      model: (s, { writer: o }) => o.createElement("imageBlock", s.hasAttribute("src") ? { src: s.getAttribute("src") } : void 0)
    }).add(TW(r));
  }
  /**
   * Integrates the plugin with the clipboard pipeline.
   *
   * Idea is that the feature should recognize the user's intent when an **inline** image is
   * pasted or dropped. If such an image is pasted/dropped:
   *
   * * into an empty block (e.g. an empty paragraph),
   * * on another object (e.g. some block widget).
   *
   * it gets converted into a block image on the fly. We assume this is the user's intent
   * if they decided to put their image there.
   *
   * See the `ImageInlineEditing` for the similar integration that works in the opposite direction.
   */
  _setupClipboardIntegration() {
    const e = this.editor, t = e.model, n = e.editing.view, r = e.plugins.get("ImageUtils"), s = e.plugins.get("ClipboardPipeline");
    this.listenTo(s, "inputTransformation", (o, l) => {
      const u = Array.from(l.content.getChildren());
      let h;
      if (!u.every(r.isInlineImageView))
        return;
      l.targetRanges ? h = e.editing.mapper.toModelRange(l.targetRanges[0]) : h = t.document.selection.getFirstRange();
      const f = t.createSelection(h);
      if (Op(t.schema, f) === "imageBlock") {
        const m = new gp(n.document), v = u.map((C) => m.createElement("figure", { class: "image" }, C));
        l.content = m.createDocumentFragment(v);
      }
    });
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class AW extends fe {
  /**
   * @inheritDoc
   */
  static get requires() {
    return [fS, kp, lS];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "ImageBlock";
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class PW extends fe {
  /**
   * @inheritDoc
   */
  static get requires() {
    return [dS, Wi, rs];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "ImageInlineEditing";
  }
  /**
   * @inheritDoc
   */
  init() {
    const e = this.editor, t = e.model.schema;
    t.register("imageInline", {
      inheritAllFrom: "$inlineObject",
      allowAttributes: ["alt", "src", "srcset"]
    }), t.addChildCheck((n, r) => {
      if (n.endsWith("caption") && r.name === "imageInline")
        return !1;
    }), this._setupConversion(), e.plugins.has("ImageBlockEditing") && (e.commands.add("imageTypeInline", new hS(this.editor, "imageInline")), this._setupClipboardIntegration());
  }
  /**
   * Configures conversion pipelines to support upcasting and downcasting
   * inline images (inline image widgets) and their attributes.
   */
  _setupConversion() {
    const e = this.editor, t = e.t, n = e.conversion, r = e.plugins.get("ImageUtils");
    n.for("dataDowncast").elementToElement({
      model: "imageInline",
      view: (s, { writer: o }) => o.createEmptyElement("img")
    }), n.for("editingDowncast").elementToStructure({
      model: "imageInline",
      view: (s, { writer: o }) => r.toImageWidget(_W(o), o, t("image widget"))
    }), n.for("downcast").add(Od(r, "imageInline", "src")).add(Od(r, "imageInline", "alt")).add(cS(r, "imageInline")), n.for("upcast").elementToElement({
      view: sS(e, "imageInline"),
      model: (s, { writer: o }) => o.createElement("imageInline", s.hasAttribute("src") ? { src: s.getAttribute("src") } : void 0)
    });
  }
  /**
   * Integrates the plugin with the clipboard pipeline.
   *
   * Idea is that the feature should recognize the user's intent when an **block** image is
   * pasted or dropped. If such an image is pasted/dropped into a non-empty block
   * (e.g. a paragraph with some text) it gets converted into an inline image on the fly.
   *
   * We assume this is the user's intent if they decided to put their image there.
   *
   * **Note**: If a block image has a caption, it will not be converted to an inline image
   * to avoid the confusion. Captions are added on purpose and they should never be lost
   * in the clipboard pipeline.
   *
   * See the `ImageBlockEditing` for the similar integration that works in the opposite direction.
   */
  _setupClipboardIntegration() {
    const e = this.editor, t = e.model, n = e.editing.view, r = e.plugins.get("ImageUtils"), s = e.plugins.get("ClipboardPipeline");
    this.listenTo(s, "inputTransformation", (o, l) => {
      const u = Array.from(l.content.getChildren());
      let h;
      if (!u.every(r.isBlockImageView))
        return;
      l.targetRanges ? h = e.editing.mapper.toModelRange(l.targetRanges[0]) : h = t.document.selection.getFirstRange();
      const f = t.createSelection(h);
      if (Op(t.schema, f) === "imageInline") {
        const m = new gp(n.document), v = u.map((C) => C.childCount === 1 ? (Array.from(C.getAttributes()).forEach((k) => m.setAttribute(...k, r.findViewImgElement(C))), C.getChild(0)) : C);
        l.content = m.createDocumentFragment(v);
      }
    });
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class IW extends fe {
  /**
   * @inheritDoc
   */
  static get requires() {
    return [PW, kp, lS];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "ImageInline";
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class RW extends fe {
  /**
   * @inheritDoc
   */
  static get requires() {
    return [AW, IW];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "Image";
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const OW = new RegExp(String(/^(http(s)?:\/\/)?[\w-]+\.[\w.~:/[\]@!$&'()*+,;=%-]+/.source + /\.(jpg|jpeg|png|gif|ico|webp|JPG|JPEG|PNG|GIF|ICO|WEBP)/.source + /(\?[\w.~:/[\]@!$&'()*+,;=%-]*)?/.source + /(#[\w.~:/[\]@!$&'()*+,;=%-]*)?$/.source));
class MW extends fe {
  /**
   * @inheritDoc
   */
  static get requires() {
    return [XC, Wi, QC, ia];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "AutoImage";
  }
  /**
   * @inheritDoc
   */
  constructor(e) {
    super(e), this._timeoutId = null, this._positionToInsert = null;
  }
  /**
   * @inheritDoc
   */
  init() {
    const e = this.editor, t = e.model.document, n = e.plugins.get("ClipboardPipeline");
    this.listenTo(n, "inputTransformation", () => {
      const r = t.selection.getFirstRange(), s = En.fromPosition(r.start);
      s.stickiness = "toPrevious";
      const o = En.fromPosition(r.end);
      o.stickiness = "toNext", t.once("change:data", () => {
        this._embedImageBetweenPositions(s, o), s.detach(), o.detach();
      }, { priority: "high" });
    }), e.commands.get("undo").on("execute", () => {
      this._timeoutId && (Ke.window.clearTimeout(this._timeoutId), this._positionToInsert.detach(), this._timeoutId = null, this._positionToInsert = null);
    }, { priority: "high" });
  }
  /**
   * Analyzes the part of the document between provided positions in search for a URL representing an image.
   * When the URL is found, it is automatically converted into an image.
   *
   * @param leftPosition Left position of the selection.
   * @param rightPosition Right position of the selection.
   */
  _embedImageBetweenPositions(e, t) {
    const n = this.editor, r = new ur(e, t), s = r.getWalker({ ignoreElementEnd: !0 }), o = Object.fromEntries(n.model.document.selection.getAttributes()), l = this.editor.plugins.get("ImageUtils");
    let u = "";
    for (const h of s)
      h.item.is("$textProxy") && (u += h.item.data);
    if (u = u.trim(), !u.match(OW)) {
      r.detach();
      return;
    }
    this._positionToInsert = En.fromPosition(e), this._timeoutId = setTimeout(() => {
      if (!n.commands.get("insertImage").isEnabled) {
        r.detach();
        return;
      }
      n.model.change((m) => {
        this._timeoutId = null, m.remove(r), r.detach();
        let v;
        this._positionToInsert.root.rootName !== "$graveyard" && (v = this._positionToInsert.toPosition()), l.insertImage({ ...o, src: u }, v), this._positionToInsert.detach(), this._positionToInsert = null;
      }), n.plugins.get("Delete").requestUndoOnBackspace();
    }, 100);
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class NW extends Pt {
  /**
   * @inheritDoc
   */
  refresh() {
    const e = this.editor, t = e.plugins.get("ImageCaptionUtils"), n = e.plugins.get("ImageUtils");
    if (!e.plugins.has(fS)) {
      this.isEnabled = !1, this.value = !1;
      return;
    }
    const r = e.model.document.selection, s = r.getSelectedElement();
    if (!s) {
      const o = t.getCaptionFromModelSelection(r);
      this.isEnabled = !!o, this.value = !!o;
      return;
    }
    this.isEnabled = n.isImage(s), this.isEnabled ? this.value = !!t.getCaptionFromImageModelElement(s) : this.value = !1;
  }
  /**
   * Executes the command.
   *
   * ```ts
   * editor.execute( 'toggleImageCaption' );
   * ```
   *
   * @param options Options for the executed command.
   * @param options.focusCaptionOnShow When true and the caption shows up, the selection will be moved into it straight away.
   * @fires execute
   */
  execute(e = {}) {
    const { focusCaptionOnShow: t } = e;
    this.editor.model.change((n) => {
      this.value ? this._hideImageCaption(n) : this._showImageCaption(n, t);
    });
  }
  /**
   * Shows the caption of the `<imageBlock>` or `<imageInline>`. Also:
   *
   * * it converts `<imageInline>` to `<imageBlock>` to show the caption,
   * * it attempts to restore the caption content from the `ImageCaptionEditing` caption registry,
   * * it moves the selection to the caption right away, it the `focusCaptionOnShow` option was set.
   */
  _showImageCaption(e, t) {
    const r = this.editor.model.document.selection, s = this.editor.plugins.get("ImageCaptionEditing"), o = this.editor.plugins.get("ImageUtils");
    let l = r.getSelectedElement();
    const u = s._getSavedCaption(l);
    o.isInlineImage(l) && (this.editor.execute("imageTypeBlock"), l = r.getSelectedElement());
    const h = u || e.createElement("caption");
    e.append(h, l), t && e.setSelection(h, "in");
  }
  /**
   * Hides the caption of a selected image (or an image caption the selection is anchored to).
   *
   * The content of the caption is stored in the `ImageCaptionEditing` caption registry to make this
   * a reversible action.
   */
  _hideImageCaption(e) {
    const t = this.editor, n = t.model.document.selection, r = t.plugins.get("ImageCaptionEditing"), s = t.plugins.get("ImageCaptionUtils");
    let o = n.getSelectedElement(), l;
    o ? l = s.getCaptionFromImageModelElement(o) : (l = s.getCaptionFromModelSelection(n), o = l.parent), r._saveCaption(o, l), e.setSelection(o, "on"), e.remove(l);
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class mS extends fe {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "ImageCaptionUtils";
  }
  /**
   * @inheritDoc
   */
  static get requires() {
    return [Wi];
  }
  /**
   * Returns the caption model element from a given image element. Returns `null` if no caption is found.
   */
  getCaptionFromImageModelElement(e) {
    for (const t of e.getChildren())
      if (t && t.is("element", "caption"))
        return t;
    return null;
  }
  /**
   * Returns the caption model element for a model selection. Returns `null` if the selection has no caption element ancestor.
   */
  getCaptionFromModelSelection(e) {
    const t = this.editor.plugins.get("ImageUtils"), n = e.getFirstPosition().findAncestor("caption");
    return n && t.isBlockImage(n.parent) ? n : null;
  }
  /**
   * {@link module:engine/view/matcher~Matcher} pattern. Checks if a given element is a `<figcaption>` element that is placed
   * inside the image `<figure>` element.
   * @returns Returns the object accepted by {@link module:engine/view/matcher~Matcher} or `null` if the element
   * cannot be matched.
   */
  matchImageCaptionViewElement(e) {
    const t = this.editor.plugins.get("ImageUtils");
    return e.name == "figcaption" && t.isBlockImageView(e.parent) ? { name: !0 } : null;
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class DW extends fe {
  /**
   * @inheritDoc
   */
  static get requires() {
    return [Wi, mS];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "ImageCaptionEditing";
  }
  /**
   * @inheritDoc
   */
  constructor(e) {
    super(e), this._savedCaptionsMap = /* @__PURE__ */ new WeakMap();
  }
  /**
   * @inheritDoc
   */
  init() {
    const e = this.editor, t = e.model.schema;
    t.isRegistered("caption") ? t.extend("caption", {
      allowIn: "imageBlock"
    }) : t.register("caption", {
      allowIn: "imageBlock",
      allowContentOf: "$block",
      isLimit: !0
    }), e.commands.add("toggleImageCaption", new NW(this.editor)), this._setupConversion(), this._setupImageTypeCommandsIntegration(), this._registerCaptionReconversion();
  }
  /**
   * Configures conversion pipelines to support upcasting and downcasting
   * image captions.
   */
  _setupConversion() {
    const e = this.editor, t = e.editing.view, n = e.plugins.get("ImageUtils"), r = e.plugins.get("ImageCaptionUtils"), s = e.t;
    e.conversion.for("upcast").elementToElement({
      view: (o) => r.matchImageCaptionViewElement(o),
      model: "caption"
    }), e.conversion.for("dataDowncast").elementToElement({
      model: "caption",
      view: (o, { writer: l }) => n.isBlockImage(o.parent) ? l.createContainerElement("figcaption") : null
    }), e.conversion.for("editingDowncast").elementToElement({
      model: "caption",
      view: (o, { writer: l }) => {
        if (!n.isBlockImage(o.parent))
          return null;
        const u = l.createEditableElement("figcaption");
        l.setCustomProperty("imageCaption", !0, u), Wl({
          view: t,
          element: u,
          text: s("Enter image caption"),
          keepOnFocus: !0
        });
        const h = o.parent.getAttribute("alt"), f = h ? s("Caption for image: %0", [h]) : s("Caption for the image");
        return I$(u, l, { label: f });
      }
    });
  }
  /**
   * Integrates with {@link module:image/image/imagetypecommand~ImageTypeCommand image type commands}
   * to make sure the caption is preserved when the type of an image changes so it can be restored
   * in the future if the user decides they want their caption back.
   */
  _setupImageTypeCommandsIntegration() {
    const e = this.editor, t = e.plugins.get("ImageUtils"), n = e.plugins.get("ImageCaptionUtils"), r = e.commands.get("imageTypeInline"), s = e.commands.get("imageTypeBlock"), o = (l) => {
      if (!l.return)
        return;
      const { oldElement: u, newElement: h } = l.return;
      /* istanbul ignore if: paranoid check -- @preserve */
      if (!u)
        return;
      if (t.isBlockImage(u)) {
        const m = n.getCaptionFromImageModelElement(u);
        if (m) {
          this._saveCaption(h, m);
          return;
        }
      }
      const f = this._getSavedCaption(u);
      f && this._saveCaption(h, f);
    };
    r && this.listenTo(r, "execute", o, { priority: "low" }), s && this.listenTo(s, "execute", o, { priority: "low" });
  }
  /**
   * Returns the saved {@link module:engine/model/element~Element#toJSON JSONified} caption
   * of an image model element.
   *
   * See {@link #_saveCaption}.
   *
   * @internal
   * @param imageModelElement The model element the caption should be returned for.
   * @returns The model caption element or `null` if there is none.
   */
  _getSavedCaption(e) {
    const t = this._savedCaptionsMap.get(e);
    return t ? gt.fromJSON(t) : null;
  }
  /**
   * Saves a {@link module:engine/model/element~Element#toJSON JSONified} caption for
   * an image element to allow restoring it in the future.
   *
   * A caption is saved every time it gets hidden and/or the type of an image changes. The
   * user should be able to restore it on demand.
   *
   * **Note**: The caption cannot be stored in the image model element attribute because,
   * for instance, when the model state propagates to collaborators, the attribute would get
   * lost (mainly because it does not convert to anything when the caption is hidden) and
   * the states of collaborators' models would de-synchronize causing numerous issues.
   *
   * See {@link #_getSavedCaption}.
   *
   * @internal
   * @param imageModelElement The model element the caption is saved for.
   * @param caption The caption model element to be saved.
   */
  _saveCaption(e, t) {
    this._savedCaptionsMap.set(e, t.toJSON());
  }
  /**
   * Reconverts image caption when image alt attribute changes.
   * The change of alt attribute is reflected in caption's aria-label attribute.
   */
  _registerCaptionReconversion() {
    const e = this.editor, t = e.model, n = e.plugins.get("ImageUtils"), r = e.plugins.get("ImageCaptionUtils");
    t.document.on("change:data", () => {
      const s = t.document.differ.getChanges();
      for (const o of s) {
        if (o.attributeKey !== "alt")
          continue;
        const l = o.range.start.nodeAfter;
        if (n.isBlockImage(l)) {
          const u = r.getCaptionFromImageModelElement(l);
          if (!u)
            return;
          e.editing.reconvertItem(u);
        }
      }
    });
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class BW extends fe {
  /**
   * @inheritDoc
   */
  static get requires() {
    return [mS];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "ImageCaptionUI";
  }
  /**
   * @inheritDoc
   */
  init() {
    const e = this.editor, t = e.editing.view, n = e.plugins.get("ImageCaptionUtils"), r = e.t;
    e.ui.componentFactory.add("toggleImageCaption", (s) => {
      const o = e.commands.get("toggleImageCaption"), l = new At(s);
      return l.set({
        icon: Mt.caption,
        tooltip: !0,
        isToggleable: !0
      }), l.bind("isOn", "isEnabled").to(o, "value", "isEnabled"), l.bind("label").to(o, "value", (u) => r(u ? "Toggle caption off" : "Toggle caption on")), this.listenTo(l, "execute", () => {
        e.execute("toggleImageCaption", { focusCaptionOnShow: !0 });
        const u = n.getCaptionFromModelSelection(e.model.document.selection);
        if (u) {
          const h = e.editing.mapper.toViewElement(u);
          t.scrollToTheSelection(), t.change((f) => {
            f.addClass("image__caption_highlighted", h);
          });
        }
        e.editing.view.focus();
      }), l;
    });
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class VW extends fe {
  /**
   * @inheritDoc
   */
  static get requires() {
    return [DW, BW];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "ImageCaption";
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class LW extends Pt {
  /**
   * @inheritDoc
   */
  refresh() {
    const e = this.editor, n = e.plugins.get("ImageUtils").getClosestSelectedImageElement(e.model.document.selection);
    this.isEnabled = !!n, !n || !n.hasAttribute("width") ? this.value = null : this.value = {
      width: n.getAttribute("width"),
      height: null
    };
  }
  /**
   * Executes the command.
   *
   * ```ts
   * // Sets the width to 50%:
   * editor.execute( 'resizeImage', { width: '50%' } );
   *
   * // Removes the width attribute:
   * editor.execute( 'resizeImage', { width: null } );
   * ```
   *
   * @param options
   * @param options.width The new width of the image.
   * @fires execute
   */
  execute(e) {
    const t = this.editor, n = t.model, s = t.plugins.get("ImageUtils").getClosestSelectedImageElement(n.document.selection);
    this.value = {
      width: e.width,
      height: null
    }, s && n.change((o) => {
      o.setAttribute("width", e.width, s);
    });
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class gS extends fe {
  /**
   * @inheritDoc
   */
  static get requires() {
    return [Wi];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "ImageResizeEditing";
  }
  /**
   * @inheritDoc
   */
  constructor(e) {
    super(e), e.config.define("image", {
      resizeUnit: "%",
      resizeOptions: [
        {
          name: "resizeImage:original",
          value: null,
          icon: "original"
        },
        {
          name: "resizeImage:25",
          value: "25",
          icon: "small"
        },
        {
          name: "resizeImage:50",
          value: "50",
          icon: "medium"
        },
        {
          name: "resizeImage:75",
          value: "75",
          icon: "large"
        }
      ]
    });
  }
  /**
   * @inheritDoc
   */
  init() {
    const e = this.editor, t = new LW(e);
    this._registerSchema(), this._registerConverters("imageBlock"), this._registerConverters("imageInline"), e.commands.add("resizeImage", t), e.commands.add("imageResize", t);
  }
  _registerSchema() {
    this.editor.plugins.has("ImageBlockEditing") && this.editor.model.schema.extend("imageBlock", { allowAttributes: "width" }), this.editor.plugins.has("ImageInlineEditing") && this.editor.model.schema.extend("imageInline", { allowAttributes: "width" });
  }
  /**
   * Registers image resize converters.
   *
   * @param imageType The type of the image.
   */
  _registerConverters(e) {
    const t = this.editor;
    t.conversion.for("downcast").add((n) => n.on(`attribute:width:${e}`, (r, s, o) => {
      if (!o.consumable.consume(s.item, r.name))
        return;
      const l = o.writer, u = o.mapper.toViewElement(s.item);
      s.attributeNewValue !== null ? (l.setStyle("width", s.attributeNewValue, u), l.addClass("image_resized", u)) : (l.removeStyle("width", u), l.removeClass("image_resized", u));
    })), t.conversion.for("upcast").attributeToAttribute({
      view: {
        name: e === "imageBlock" ? "figure" : "img",
        styles: {
          width: /.+/
        }
      },
      model: {
        key: "width",
        value: (n) => n.getStyle("width")
      }
    });
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const Vm = {
  small: Mt.objectSizeSmall,
  medium: Mt.objectSizeMedium,
  large: Mt.objectSizeLarge,
  original: Mt.objectSizeFull
};
class FW extends fe {
  /**
   * @inheritDoc
   */
  static get requires() {
    return [gS];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "ImageResizeButtons";
  }
  /**
   * @inheritDoc
   */
  constructor(e) {
    super(e), this._resizeUnit = e.config.get("image.resizeUnit");
  }
  /**
   * @inheritDoc
   */
  init() {
    const e = this.editor, t = e.config.get("image.resizeOptions"), n = e.commands.get("resizeImage");
    this.bind("isEnabled").to(n);
    for (const r of t)
      this._registerImageResizeButton(r);
    this._registerImageResizeDropdown(t);
  }
  /**
   * A helper function that creates a standalone button component for the plugin.
   *
   * @param resizeOption A model of the resize option.
   */
  _registerImageResizeButton(e) {
    const t = this.editor, { name: n, value: r, icon: s } = e, o = r ? r + this._resizeUnit : null;
    t.ui.componentFactory.add(n, (l) => {
      const u = new At(l), h = t.commands.get("resizeImage"), f = this._getOptionLabelValue(e, !0);
      if (!Vm[s])
        throw new B("imageresizebuttons-missing-icon", t, e);
      return u.set({
        // Use the `label` property for a verbose description (because of ARIA).
        label: f,
        icon: Vm[s],
        tooltip: f,
        isToggleable: !0
      }), u.bind("isEnabled").to(this), u.bind("isOn").to(h, "value", h0(o)), this.listenTo(u, "execute", () => {
        t.execute("resizeImage", { width: o });
      }), u;
    });
  }
  /**
   * A helper function that creates a dropdown component for the plugin containing all the resize options defined in
   * the editor configuration.
   *
   * @param options An array of configured options.
   */
  _registerImageResizeDropdown(e) {
    const t = this.editor, n = t.t, r = e.find((o) => !o.value), s = (o) => {
      const l = t.commands.get("resizeImage"), u = Gs(o, PC), h = u.buttonView;
      return h.set({
        tooltip: n("Resize image"),
        commandValue: r.value,
        icon: Vm.medium,
        isToggleable: !0,
        label: this._getOptionLabelValue(r),
        withText: !0,
        class: "ck-resize-image-button"
      }), h.bind("label").to(l, "value", (f) => f && f.width ? f.width : this._getOptionLabelValue(r)), u.bind("isEnabled").to(this), MC(u, () => this._getResizeDropdownListItemDefinitions(e, l), {
        ariaLabel: n("Image resize list")
      }), this.listenTo(u, "execute", (f) => {
        t.execute(f.source.commandName, { width: f.source.commandValue }), t.editing.view.focus();
      }), u;
    };
    t.ui.componentFactory.add("resizeImage", s), t.ui.componentFactory.add("imageResize", s);
  }
  /**
   * A helper function for creating an option label value string.
   *
   * @param option A resize option object.
   * @param forTooltip An optional flag for creating a tooltip label.
   * @returns A user-defined label combined from the numeric value and the resize unit or the default label
   * for reset options (`Original`).
   */
  _getOptionLabelValue(e, t = !1) {
    const n = this.editor.t;
    return e.label ? e.label : t ? e.value ? n("Resize image to %0", e.value + this._resizeUnit) : n("Resize image to the original size") : e.value ? e.value + this._resizeUnit : n("Original");
  }
  /**
   * A helper function that parses the resize options and returns list item definitions ready for use in the dropdown.
   *
   * @param options The resize options.
   * @param command The resize image command.
   * @returns Dropdown item definitions.
   */
  _getResizeDropdownListItemDefinitions(e, t) {
    const n = new Br();
    return e.map((r) => {
      const s = r.value ? r.value + this._resizeUnit : null, o = {
        type: "button",
        model: new VC({
          commandName: "resizeImage",
          commandValue: s,
          label: this._getOptionLabelValue(r),
          withText: !0,
          icon: null
        })
      };
      o.model.bind("isOn").to(t, "value", h0(s)), n.add(o);
    }), n;
  }
}
function h0(i) {
  return (e) => {
    const t = e;
    return i === null && t === i ? !0 : t !== null && t.width === i;
  };
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const $W = "figure.image.ck-widget > img,figure.image.ck-widget > picture > img,figure.image.ck-widget > a > img,figure.image.ck-widget > a > picture > img,span.image-inline.ck-widget > img,span.image-inline.ck-widget > picture > img", zW = /(image|image-inline)/, Lm = "image_resized";
class WW extends fe {
  /**
   * @inheritDoc
   */
  static get requires() {
    return [Rm];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "ImageResizeHandles";
  }
  /**
   * @inheritDoc
   */
  init() {
    const e = this.editor.commands.get("resizeImage");
    this.bind("isEnabled").to(e), this._setupResizerCreator();
  }
  /**
   * Attaches the listeners responsible for creating a resizer for each image, except for images inside the HTML embed preview.
   */
  _setupResizerCreator() {
    const e = this.editor, t = e.editing.view;
    t.addObserver(uS), this.listenTo(t.document, "imageLoaded", (n, r) => {
      if (!r.target.matches($W))
        return;
      const s = e.editing.view.domConverter, l = s.domToView(r.target).findAncestor({ classes: zW });
      let u = this.editor.plugins.get(Rm).getResizerByViewElement(l);
      if (u) {
        u.redraw();
        return;
      }
      const h = e.editing.mapper, f = h.toModelElement(l);
      u = e.plugins.get(Rm).attachTo({
        unit: e.config.get("image.resizeUnit"),
        modelElement: f,
        viewElement: l,
        editor: e,
        getHandleHost(m) {
          return m.querySelector("img");
        },
        getResizeHost() {
          return s.mapViewToDom(h.toViewElement(f.parent));
        },
        // TODO consider other positions.
        isCentered() {
          const m = f.getAttribute("imageStyle");
          return !m || m == "block" || m == "alignCenter";
        },
        onCommit(m) {
          t.change((v) => {
            v.removeClass(Lm, l);
          }), e.execute("resizeImage", { width: m });
        }
      }), u.on("updateSize", () => {
        l.hasClass(Lm) || t.change((m) => {
          m.addClass(Lm, l);
        });
      }), u.bind("isEnabled").to(this);
    });
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class jW extends fe {
  /**
   * @inheritDoc
   */
  static get requires() {
    return [gS, WW, FW];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "ImageResize";
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class UW extends Pt {
  /**
   * Creates an instance of the image style command. When executed, the command applies one of
   * {@link module:image/imageconfig~ImageStyleConfig#options style options} to the currently selected image.
   *
   * @param editor The editor instance.
   * @param styles The style options that this command supports.
   */
  constructor(e, t) {
    super(e), this._defaultStyles = {
      imageBlock: !1,
      imageInline: !1
    }, this._styles = new Map(t.map((n) => {
      if (n.isDefault)
        for (const r of n.modelElements)
          this._defaultStyles[r] = n.name;
      return [n.name, n];
    }));
  }
  /**
   * @inheritDoc
   */
  refresh() {
    const n = this.editor.plugins.get("ImageUtils").getClosestSelectedImageElement(this.editor.model.document.selection);
    this.isEnabled = !!n, this.isEnabled ? n.hasAttribute("imageStyle") ? this.value = n.getAttribute("imageStyle") : this.value = this._defaultStyles[n.name] : this.value = !1;
  }
  /**
   * Executes the command and applies the style to the currently selected image:
   *
   * ```ts
   * editor.execute( 'imageStyle', { value: 'side' } );
   * ```
   *
   * **Note**: Executing this command may change the image model element if the desired style requires an image
   * of a different type. Learn more about {@link module:image/imageconfig~ImageStyleOptionDefinition#modelElements model element}
   * configuration for the style option.
   *
   * @param options.value The name of the style (as configured in {@link module:image/imageconfig~ImageStyleConfig#options}).
   * @fires execute
   */
  execute(e = {}) {
    const t = this.editor, n = t.model, r = t.plugins.get("ImageUtils");
    n.change((s) => {
      const o = e.value;
      let l = r.getClosestSelectedImageElement(n.document.selection);
      o && this.shouldConvertImageType(o, l) && (this.editor.execute(r.isBlockImage(l) ? "imageTypeInline" : "imageTypeBlock"), l = r.getClosestSelectedImageElement(n.document.selection)), !o || this._styles.get(o).isDefault ? s.removeAttribute("imageStyle", l) : s.setAttribute("imageStyle", o, l);
    });
  }
  /**
   * Returns `true` if requested style change would trigger the image type change.
   *
   * @param requestedStyle The name of the style (as configured in {@link module:image/imageconfig~ImageStyleConfig#options}).
   * @param imageElement The image model element.
   */
  shouldConvertImageType(e, t) {
    return !this._styles.get(e).modelElements.includes(t.name);
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const { objectFullWidth: HW, objectInline: pS, objectLeft: _S, objectRight: Cg, objectCenter: Sg, objectBlockLeft: vS, objectBlockRight: wS } = Mt, td = {
  // This style represents an image placed in the line of text.
  get inline() {
    return {
      name: "inline",
      title: "In line",
      icon: pS,
      modelElements: ["imageInline"],
      isDefault: !0
    };
  },
  // This style represents an image aligned to the left and wrapped with text.
  get alignLeft() {
    return {
      name: "alignLeft",
      title: "Left aligned image",
      icon: _S,
      modelElements: ["imageBlock", "imageInline"],
      className: "image-style-align-left"
    };
  },
  // This style represents an image aligned to the left.
  get alignBlockLeft() {
    return {
      name: "alignBlockLeft",
      title: "Left aligned image",
      icon: vS,
      modelElements: ["imageBlock"],
      className: "image-style-block-align-left"
    };
  },
  // This style represents a centered image.
  get alignCenter() {
    return {
      name: "alignCenter",
      title: "Centered image",
      icon: Sg,
      modelElements: ["imageBlock"],
      className: "image-style-align-center"
    };
  },
  // This style represents an image aligned to the right and wrapped with text.
  get alignRight() {
    return {
      name: "alignRight",
      title: "Right aligned image",
      icon: Cg,
      modelElements: ["imageBlock", "imageInline"],
      className: "image-style-align-right"
    };
  },
  // This style represents an image aligned to the right.
  get alignBlockRight() {
    return {
      name: "alignBlockRight",
      title: "Right aligned image",
      icon: wS,
      modelElements: ["imageBlock"],
      className: "image-style-block-align-right"
    };
  },
  // This option is equal to the situation when no style is applied.
  get block() {
    return {
      name: "block",
      title: "Centered image",
      icon: Sg,
      modelElements: ["imageBlock"],
      isDefault: !0
    };
  },
  // This represents a side image.
  get side() {
    return {
      name: "side",
      title: "Side image",
      icon: Cg,
      modelElements: ["imageBlock"],
      className: "image-style-side"
    };
  }
}, bS = {
  full: HW,
  left: vS,
  right: wS,
  center: Sg,
  inlineLeft: _S,
  inlineRight: Cg,
  inline: pS
}, yS = [{
  name: "imageStyle:wrapText",
  title: "Wrap text",
  defaultItem: "imageStyle:alignLeft",
  items: ["imageStyle:alignLeft", "imageStyle:alignRight"]
}, {
  name: "imageStyle:breakText",
  title: "Break text",
  defaultItem: "imageStyle:block",
  items: ["imageStyle:alignBlockLeft", "imageStyle:block", "imageStyle:alignBlockRight"]
}];
function qW(i) {
  return (i.configuredStyles.options || []).map((n) => YW(n)).filter((n) => JW(n, i));
}
function KW(i, e) {
  return i && e ? {
    options: [
      "inline",
      "alignLeft",
      "alignRight",
      "alignCenter",
      "alignBlockLeft",
      "alignBlockRight",
      "block",
      "side"
    ]
  } : i ? {
    options: ["block", "side"]
  } : e ? {
    options: ["inline", "alignLeft", "alignRight"]
  } : {};
}
function GW(i) {
  return i.has("ImageBlockEditing") && i.has("ImageInlineEditing") ? [...yS] : [];
}
function YW(i) {
  return typeof i == "string" ? td[i] ? i = { ...td[i] } : i = { name: i } : i = XW(td[i.name], i), typeof i.icon == "string" && (i.icon = bS[i.icon] || i.icon), i;
}
function JW(i, { isBlockPluginLoaded: e, isInlinePluginLoaded: t }) {
  const { modelElements: n, name: r } = i;
  if (!n || !n.length || !r)
    return ES({ style: i }), !1;
  {
    const s = [e ? "imageBlock" : null, t ? "imageInline" : null];
    if (!n.some((o) => s.includes(o)))
      return Yt("image-style-missing-dependency", {
        style: i,
        missingPlugins: n.map((o) => o === "imageBlock" ? "ImageBlockEditing" : "ImageInlineEditing")
      }), !1;
  }
  return !0;
}
function XW(i, e) {
  const t = { ...e };
  for (const n in i)
    Object.prototype.hasOwnProperty.call(e, n) || (t[n] = i[n]);
  return t;
}
function ES(i) {
  Yt("image-style-configuration-definition-invalid", i);
}
const Tg = {
  normalizeStyles: qW,
  getDefaultStylesConfiguration: KW,
  getDefaultDropdownDefinitions: GW,
  warnInvalidStyle: ES,
  DEFAULT_OPTIONS: td,
  DEFAULT_ICONS: bS,
  DEFAULT_DROPDOWN_DEFINITIONS: yS
};
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function ZW(i) {
  return (e, t, n) => {
    if (!n.consumable.consume(t.item, e.name))
      return;
    const r = f0(t.attributeNewValue, i), s = f0(t.attributeOldValue, i), o = n.mapper.toViewElement(t.item), l = n.writer;
    s && l.removeClass(s.className, o), r && l.addClass(r.className, o);
  };
}
function QW(i) {
  const e = {
    imageInline: i.filter((t) => !t.isDefault && t.modelElements.includes("imageInline")),
    imageBlock: i.filter((t) => !t.isDefault && t.modelElements.includes("imageBlock"))
  };
  return (t, n, r) => {
    if (!n.modelRange)
      return;
    const s = n.viewItem, o = Rn(n.modelRange.getItems());
    if (o && r.schema.checkAttribute(o, "imageStyle"))
      for (const l of e[o.name])
        r.consumable.consume(s, { classes: l.className }) && r.writer.setAttribute("imageStyle", l.name, o);
  };
}
function f0(i, e) {
  for (const t of e)
    if (t.name === i)
      return t;
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class CS extends fe {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "ImageStyleEditing";
  }
  /**
   * @inheritDoc
   */
  static get requires() {
    return [Wi];
  }
  /**
   * @inheritDoc
   */
  init() {
    const { normalizeStyles: e, getDefaultStylesConfiguration: t } = Tg, n = this.editor, r = n.plugins.has("ImageBlockEditing"), s = n.plugins.has("ImageInlineEditing");
    n.config.define("image.styles", t(r, s)), this.normalizedStyles = e({
      configuredStyles: n.config.get("image.styles"),
      isBlockPluginLoaded: r,
      isInlinePluginLoaded: s
    }), this._setupConversion(r, s), this._setupPostFixer(), n.commands.add("imageStyle", new UW(n, this.normalizedStyles));
  }
  /**
   * Sets the editor conversion taking the presence of
   * {@link module:image/image/imageinlineediting~ImageInlineEditing `ImageInlineEditing`}
   * and {@link module:image/image/imageblockediting~ImageBlockEditing `ImageBlockEditing`} plugins into consideration.
   */
  _setupConversion(e, t) {
    const n = this.editor, r = n.model.schema, s = ZW(this.normalizedStyles), o = QW(this.normalizedStyles);
    n.editing.downcastDispatcher.on("attribute:imageStyle", s), n.data.downcastDispatcher.on("attribute:imageStyle", s), e && (r.extend("imageBlock", { allowAttributes: "imageStyle" }), n.data.upcastDispatcher.on("element:figure", o, { priority: "low" })), t && (r.extend("imageInline", { allowAttributes: "imageStyle" }), n.data.upcastDispatcher.on("element:img", o, { priority: "low" }));
  }
  /**
   * Registers a post-fixer that will make sure that the style attribute value is correct for a specific image type (block vs inline).
   */
  _setupPostFixer() {
    const e = this.editor, t = e.model.document, n = e.plugins.get(Wi), r = new Map(this.normalizedStyles.map((s) => [s.name, s]));
    t.registerPostFixer((s) => {
      let o = !1;
      for (const l of t.differ.getChanges())
        if (l.type == "insert" || l.type == "attribute" && l.attributeKey == "imageStyle") {
          let u = l.type == "insert" ? l.position.nodeAfter : l.range.start.nodeAfter;
          if (u && u.is("element", "paragraph") && u.childCount > 0 && (u = u.getChild(0)), !n.isImage(u))
            continue;
          const h = u.getAttribute("imageStyle");
          if (!h)
            continue;
          const f = r.get(h);
          (!f || !f.modelElements.includes(u.name)) && (s.removeAttribute("imageStyle", u), o = !0);
        }
      return o;
    });
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class ej extends fe {
  /**
   * @inheritDoc
   */
  static get requires() {
    return [CS];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "ImageStyleUI";
  }
  /**
   * Returns the default localized style titles provided by the plugin.
   *
   * The following localized titles corresponding with
   * {@link module:image/imagestyle/utils#DEFAULT_OPTIONS} are available:
   *
   * * `'Wrap text'`,
   * * `'Break text'`,
   * * `'In line'`,
   * * `'Full size image'`,
   * * `'Side image'`,
   * * `'Left aligned image'`,
   * * `'Centered image'`,
   * * `'Right aligned image'`
   */
  get localizedDefaultStylesTitles() {
    const e = this.editor.t;
    return {
      "Wrap text": e("Wrap text"),
      "Break text": e("Break text"),
      "In line": e("In line"),
      "Full size image": e("Full size image"),
      "Side image": e("Side image"),
      "Left aligned image": e("Left aligned image"),
      "Centered image": e("Centered image"),
      "Right aligned image": e("Right aligned image")
    };
  }
  /**
   * @inheritDoc
   */
  init() {
    const e = this.editor.plugins, t = this.editor.config.get("image.toolbar") || [], n = e.get("ImageStyleEditing"), r = m0(n.normalizedStyles, this.localizedDefaultStylesTitles);
    for (const o of r)
      this._createButton(o);
    const s = m0([
      ...t.filter(Lt),
      ...Tg.getDefaultDropdownDefinitions(e)
    ], this.localizedDefaultStylesTitles);
    for (const o of s)
      this._createDropdown(o, r);
  }
  /**
   * Creates a dropdown and stores it in the editor {@link module:ui/componentfactory~ComponentFactory}.
   */
  _createDropdown(e, t) {
    const n = this.editor.ui.componentFactory;
    n.add(e.name, (r) => {
      let s;
      const { defaultItem: o, items: l, title: u } = e, h = l.filter((C) => t.find(({ name: k }) => g0(k) === C)).map((C) => {
        const k = n.create(C);
        return C === o && (s = k), k;
      });
      l.length !== h.length && Tg.warnInvalidStyle({ dropdown: e });
      const f = Gs(r, fh), m = f.buttonView, v = m.arrowView;
      return gh(f, h, { enableActiveItemFocusOnDropdownOpen: !0 }), m.set({
        label: p0(u, s.label),
        class: null,
        tooltip: !0
      }), v.unbind("label"), v.set({
        label: u
      }), m.bind("icon").toMany(h, "isOn", (...C) => {
        const k = C.findIndex(Ps);
        return k < 0 ? s.icon : h[k].icon;
      }), m.bind("label").toMany(h, "isOn", (...C) => {
        const k = C.findIndex(Ps);
        return p0(u, k < 0 ? s.label : h[k].label);
      }), m.bind("isOn").toMany(h, "isOn", (...C) => C.some(Ps)), m.bind("class").toMany(h, "isOn", (...C) => C.some(Ps) ? "ck-splitbutton_flatten" : void 0), m.on("execute", () => {
        h.some(({ isOn: C }) => C) ? f.isOpen = !f.isOpen : s.fire("execute");
      }), f.bind("isEnabled").toMany(h, "isEnabled", (...C) => C.some(Ps)), this.listenTo(f, "execute", () => {
        this.editor.editing.view.focus();
      }), f;
    });
  }
  /**
   * Creates a button and stores it in the editor {@link module:ui/componentfactory~ComponentFactory}.
   */
  _createButton(e) {
    const t = e.name;
    this.editor.ui.componentFactory.add(g0(t), (n) => {
      const r = this.editor.commands.get("imageStyle"), s = new At(n);
      return s.set({
        label: e.title,
        icon: e.icon,
        tooltip: !0,
        isToggleable: !0
      }), s.bind("isEnabled").to(r, "isEnabled"), s.bind("isOn").to(r, "value", (o) => o === t), s.on("execute", this._executeCommand.bind(this, t)), s;
    });
  }
  _executeCommand(e) {
    this.editor.execute("imageStyle", { value: e }), this.editor.editing.view.focus();
  }
}
function m0(i, e) {
  for (const t of i)
    e[t.title] && (t.title = e[t.title]);
  return i;
}
function g0(i) {
  return `imageStyle:${i}`;
}
function p0(i, e) {
  return (i ? i + ": " : "") + e;
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class tj extends fe {
  /**
   * @inheritDoc
   */
  static get requires() {
    return [CS, ej];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "ImageStyle";
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class nj extends fe {
  /**
   * @inheritDoc
   */
  static get requires() {
    return [Zb, Wi];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "ImageToolbar";
  }
  /**
   * @inheritDoc
   */
  afterInit() {
    const e = this.editor, t = e.t, n = e.plugins.get(Zb), r = e.plugins.get("ImageUtils");
    n.register("image", {
      ariaLabel: t("Image toolbar"),
      items: ij(e.config.get("image.toolbar") || []),
      getRelatedElement: (s) => r.getClosestSelectedImageWidget(s)
    });
  }
}
function ij(i) {
  return i.map((e) => Lt(e) ? e.name : e);
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class rj {
  constructor() {
    this._definitions = /* @__PURE__ */ new Set();
  }
  /**
   * Gives information about the number of decorators stored in the {@link module:link/utils/automaticdecorators~AutomaticDecorators}
   * instance.
   */
  get length() {
    return this._definitions.size;
  }
  /**
   * Adds automatic decorator objects or an array with them to be used during downcasting.
   *
   * @param item A configuration object of automatic rules for decorating links. It might also be an array of such objects.
   */
  add(e) {
    Array.isArray(e) ? e.forEach((t) => this._definitions.add(t)) : this._definitions.add(e);
  }
  /**
   * Provides the conversion helper used in the {@link module:engine/conversion/downcasthelpers~DowncastHelpers#add} method.
   *
   * @returns A dispatcher function used as conversion helper in {@link module:engine/conversion/downcasthelpers~DowncastHelpers#add}.
   */
  getDispatcher() {
    return (e) => {
      e.on("attribute:linkHref", (t, n, r) => {
        if (!r.consumable.test(n.item, "attribute:linkHref") || !(n.item.is("selection") || r.schema.isInline(n.item)))
          return;
        const s = r.writer, o = s.document.selection;
        for (const l of this._definitions) {
          const u = s.createAttributeElement("a", l.attributes, {
            priority: 5
          });
          l.classes && s.addClass(l.classes, u);
          for (const h in l.styles)
            s.setStyle(h, l.styles[h], u);
          s.setCustomProperty("link", !0, u), l.callback(n.attributeNewValue) ? n.item.is("selection") ? s.wrap(o.getFirstRange(), u) : s.wrap(r.mapper.toViewRange(n.range), u) : s.unwrap(r.mapper.toViewRange(n.range), u);
        }
      }, { priority: "high" });
    };
  }
  /**
   * Provides the conversion helper used in the {@link module:engine/conversion/downcasthelpers~DowncastHelpers#add} method
   * when linking images.
   *
   * @returns A dispatcher function used as conversion helper in {@link module:engine/conversion/downcasthelpers~DowncastHelpers#add}.
   */
  getDispatcherForLinkedImage() {
    return (e) => {
      e.on("attribute:linkHref:imageBlock", (t, n, { writer: r, mapper: s }) => {
        const o = s.toViewElement(n.item), l = Array.from(o.getChildren()).find((u) => u.is("element", "a"));
        for (const u of this._definitions) {
          const h = Or(u.attributes);
          if (u.callback(n.attributeNewValue)) {
            for (const [f, m] of h)
              f === "class" ? r.addClass(m, l) : r.setAttribute(f, m, l);
            u.classes && r.addClass(u.classes, l);
            for (const f in u.styles)
              r.setStyle(f, u.styles[f], l);
          } else {
            for (const [f, m] of h)
              f === "class" ? r.removeClass(m, l) : r.removeAttribute(f, l);
            u.classes && r.removeClass(u.classes, l);
            for (const f in u.styles)
              r.removeStyle(f, l);
          }
        }
      });
    };
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const sj = /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205f\u3000]/g, oj = /^(?:(?:https?|ftps?|mailto):|[^a-z]|[a-z+.-]+(?:[^a-z+.:-]|$))/i, aj = /^[\S]+@((?![-_])(?:[-\w\u00a1-\uffff]{0,63}[^-_]\.))+(?:[a-z\u00a1-\uffff]{2,})$/i, lj = /^((\w+:(\/{2,})?)|(\W))/i, Fm = "Ctrl+K";
function cj(i) {
  return i.is("attributeElement") && !!i.getCustomProperty("link");
}
function _0(i, { writer: e }) {
  const t = e.createAttributeElement("a", { href: i }, { priority: 5 });
  return e.setCustomProperty("link", !0, t), t;
}
function SS(i) {
  const e = String(i);
  return uj(e) ? e : "#";
}
function uj(i) {
  return !!i.replace(sj, "").match(oj);
}
function dj(i, e) {
  const t = {
    "Open in a new tab": i("Open in a new tab"),
    Downloadable: i("Downloadable")
  };
  return e.forEach((n) => ("label" in n && t[n.label] && (n.label = t[n.label]), n)), e;
}
function hj(i) {
  const e = [];
  if (i)
    for (const [t, n] of Object.entries(i)) {
      const r = Object.assign({}, n, { id: `link${x7(t)}` });
      e.push(r);
    }
  return e;
}
function xg(i, e) {
  return i ? e.checkAttribute(i.name, "linkHref") : !1;
}
function fj(i) {
  return aj.test(i);
}
function Mp(i, e) {
  const t = fj(i) ? "mailto:" : e, n = !!t && !TS(i);
  return i && n ? t + i : i;
}
function TS(i) {
  return lj.test(i);
}
function v0(i) {
  window.open(i, "_blank", "noopener");
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class mj extends Pt {
  constructor() {
    super(...arguments), this.manualDecorators = new Br(), this.automaticDecorators = new rj();
  }
  /**
   * Synchronizes the state of {@link #manualDecorators} with the currently present elements in the model.
   */
  restoreManualDecoratorStates() {
    for (const e of this.manualDecorators)
      e.value = this._getDecoratorStateFromModel(e.id);
  }
  /**
   * @inheritDoc
   */
  refresh() {
    const e = this.editor.model, t = e.document.selection, n = t.getSelectedElement() || Rn(t.getSelectedBlocks());
    xg(n, e.schema) ? (this.value = n.getAttribute("linkHref"), this.isEnabled = e.schema.checkAttribute(n, "linkHref")) : (this.value = t.getAttribute("linkHref"), this.isEnabled = e.schema.checkAttributeInSelection(t, "linkHref"));
    for (const r of this.manualDecorators)
      r.value = this._getDecoratorStateFromModel(r.id);
  }
  /**
   * Executes the command.
   *
   * When the selection is non-collapsed, the `linkHref` attribute will be applied to nodes inside the selection, but only to
   * those nodes where the `linkHref` attribute is allowed (disallowed nodes will be omitted).
   *
   * When the selection is collapsed and is not inside the text with the `linkHref` attribute, a
   * new {@link module:engine/model/text~Text text node} with the `linkHref` attribute will be inserted in place of the caret, but
   * only if such element is allowed in this place. The `_data` of the inserted text will equal the `href` parameter.
   * The selection will be updated to wrap the just inserted text node.
   *
   * When the selection is collapsed and inside the text with the `linkHref` attribute, the attribute value will be updated.
   *
   * # Decorators and model attribute management
   *
   * There is an optional argument to this command that applies or removes model
   * {@glink framework/architecture/editing-engine#text-attributes text attributes} brought by
   * {@link module:link/utils/manualdecorator~ManualDecorator manual link decorators}.
   *
   * Text attribute names in the model correspond to the entries in the {@link module:link/linkconfig~LinkConfig#decorators
   * configuration}.
   * For every decorator configured, a model text attribute exists with the "link" prefix. For example, a `'linkMyDecorator'` attribute
   * corresponds to `'myDecorator'` in the configuration.
   *
   * To learn more about link decorators, check out the {@link module:link/linkconfig~LinkConfig#decorators `config.link.decorators`}
   * documentation.
   *
   * Here is how to manage decorator attributes with the link command:
   *
   * ```ts
   * const linkCommand = editor.commands.get( 'link' );
   *
   * // Adding a new decorator attribute.
   * linkCommand.execute( 'http://example.com', {
   * 	linkIsExternal: true
   * } );
   *
   * // Removing a decorator attribute from the selection.
   * linkCommand.execute( 'http://example.com', {
   * 	linkIsExternal: false
   * } );
   *
   * // Adding multiple decorator attributes at the same time.
   * linkCommand.execute( 'http://example.com', {
   * 	linkIsExternal: true,
   * 	linkIsDownloadable: true,
   * } );
   *
   * // Removing and adding decorator attributes at the same time.
   * linkCommand.execute( 'http://example.com', {
   * 	linkIsExternal: false,
   * 	linkFoo: true,
   * 	linkIsDownloadable: false,
   * } );
   * ```
   *
   * **Note**: If the decorator attribute name is not specified, its state remains untouched.
   *
   * **Note**: {@link module:link/unlinkcommand~UnlinkCommand#execute `UnlinkCommand#execute()`} removes all
   * decorator attributes.
   *
   * @fires execute
   * @param href Link destination.
   * @param manualDecoratorIds The information about manual decorator attributes to be applied or removed upon execution.
   */
  execute(e, t = {}) {
    const n = this.editor.model, r = n.document.selection, s = [], o = [];
    for (const l in t)
      t[l] ? s.push(l) : o.push(l);
    n.change((l) => {
      if (r.isCollapsed) {
        const u = r.getFirstPosition();
        if (r.hasAttribute("linkHref")) {
          const h = w0(r);
          let f = Ko(u, "linkHref", r.getAttribute("linkHref"), n);
          r.getAttribute("linkHref") === h && (f = this._updateLinkContent(n, l, f, e)), l.setAttribute("linkHref", e, f), s.forEach((m) => {
            l.setAttribute(m, !0, f);
          }), o.forEach((m) => {
            l.removeAttribute(m, f);
          }), l.setSelection(l.createPositionAfter(f.end.nodeBefore));
        } else if (e !== "") {
          const h = Or(r.getAttributes());
          h.set("linkHref", e), s.forEach((m) => {
            h.set(m, !0);
          });
          const { end: f } = n.insertContent(l.createText(e, h), u);
          l.setSelection(f);
        }
        ["linkHref", ...s, ...o].forEach((h) => {
          l.removeSelectionAttribute(h);
        });
      } else {
        const u = n.schema.getValidRanges(r.getRanges(), "linkHref"), h = [];
        for (const m of r.getSelectedBlocks())
          n.schema.checkAttribute(m, "linkHref") && h.push(l.createRangeOn(m));
        const f = h.slice();
        for (const m of u)
          this._isRangeToUpdate(m, h) && f.push(m);
        for (const m of f) {
          let v = m;
          if (f.length === 1) {
            const C = w0(r);
            r.getAttribute("linkHref") === C && (v = this._updateLinkContent(n, l, m, e), l.setSelection(l.createSelection(v)));
          }
          l.setAttribute("linkHref", e, v), s.forEach((C) => {
            l.setAttribute(C, !0, v);
          }), o.forEach((C) => {
            l.removeAttribute(C, v);
          });
        }
      }
    });
  }
  /**
   * Provides information whether a decorator with a given name is present in the currently processed selection.
   *
   * @param decoratorName The name of the manual decorator used in the model
   * @returns The information whether a given decorator is currently present in the selection.
   */
  _getDecoratorStateFromModel(e) {
    const t = this.editor.model, n = t.document.selection, r = n.getSelectedElement();
    return xg(r, t.schema) ? r.getAttribute(e) : n.getAttribute(e);
  }
  /**
   * Checks whether specified `range` is inside an element that accepts the `linkHref` attribute.
   *
   * @param range A range to check.
   * @param allowedRanges An array of ranges created on elements where the attribute is accepted.
   */
  _isRangeToUpdate(e, t) {
    for (const n of t)
      if (n.containsRange(e))
        return !1;
    return !0;
  }
  /**
   * Updates selected link with a new value as its content and as its href attribute.
   *
   * @param model Model is need to insert content.
   * @param writer Writer is need to create text element in model.
   * @param range A range where should be inserted content.
   * @param href A link value which should be in the href attribute and in the content.
   */
  _updateLinkContent(e, t, n, r) {
    const s = t.createText(r, { linkHref: r });
    return e.insertContent(s, n);
  }
}
function w0(i) {
  if (i.isCollapsed) {
    const e = i.getFirstPosition();
    return e.textNode && e.textNode.data;
  } else {
    const e = Array.from(i.getFirstRange().getItems());
    if (e.length > 1)
      return null;
    const t = e[0];
    return t.is("$text") || t.is("$textProxy") ? t.data : null;
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class gj extends Pt {
  /**
   * @inheritDoc
   */
  refresh() {
    const e = this.editor.model, t = e.document.selection, n = t.getSelectedElement();
    xg(n, e.schema) ? this.isEnabled = e.schema.checkAttribute(n, "linkHref") : this.isEnabled = e.schema.checkAttributeInSelection(t, "linkHref");
  }
  /**
   * Executes the command.
   *
   * When the selection is collapsed, it removes the `linkHref` attribute from each node with the same `linkHref` attribute value.
   * When the selection is non-collapsed, it removes the `linkHref` attribute from each node in selected ranges.
   *
   * # Decorators
   *
   * If {@link module:link/linkconfig~LinkConfig#decorators `config.link.decorators`} is specified,
   * all configured decorators are removed together with the `linkHref` attribute.
   *
   * @fires execute
   */
  execute() {
    const e = this.editor, t = this.editor.model, n = t.document.selection, r = e.commands.get("link");
    t.change((s) => {
      const o = n.isCollapsed ? [Ko(n.getFirstPosition(), "linkHref", n.getAttribute("linkHref"), t)] : t.schema.getValidRanges(n.getRanges(), "linkHref");
      for (const l of o)
        if (s.removeAttribute("linkHref", l), r)
          for (const u of r.manualDecorators)
            s.removeAttribute(u.id, l);
    });
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class pj extends Nt() {
  /**
   * Creates a new instance of {@link module:link/utils/manualdecorator~ManualDecorator}.
   *
   * @param config.id The name of the attribute used in the model that represents a given manual decorator.
   * For example: `'linkIsExternal'`.
   * @param config.label The label used in the user interface to toggle the manual decorator.
   * @param config.attributes A set of attributes added to output data when the decorator is active for a specific link.
   * Attributes should keep the format of attributes defined in {@link module:engine/view/elementdefinition~ElementDefinition}.
   * @param [config.defaultValue] Controls whether the decorator is "on" by default.
   */
  constructor({ id: e, label: t, attributes: n, classes: r, styles: s, defaultValue: o }) {
    super(), this.id = e, this.set("value", void 0), this.defaultValue = o, this.label = t, this.attributes = n, this.classes = r, this.styles = s;
  }
  /**
   * Returns {@link module:engine/view/matcher~MatcherPattern} with decorator attributes.
   *
   * @internal
   */
  _createPattern() {
    return {
      attributes: this.attributes,
      classes: this.classes,
      styles: this.styles
    };
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const _j = "ck-link_selected", b0 = "automatic", vj = "manual", wj = /^(https?:)?\/\//;
class bj extends fe {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "LinkEditing";
  }
  /**
   * @inheritDoc
   */
  static get requires() {
    return [Ub, WC, rs];
  }
  /**
   * @inheritDoc
   */
  constructor(e) {
    super(e), e.config.define("link", {
      addTargetToExternalLinks: !1
    });
  }
  /**
   * @inheritDoc
   */
  init() {
    const e = this.editor;
    e.model.schema.extend("$text", { allowAttributes: "linkHref" }), e.conversion.for("dataDowncast").attributeToElement({ model: "linkHref", view: _0 }), e.conversion.for("editingDowncast").attributeToElement({ model: "linkHref", view: (r, s) => _0(SS(r), s) }), e.conversion.for("upcast").elementToAttribute({
      view: {
        name: "a",
        attributes: {
          href: !0
        }
      },
      model: {
        key: "linkHref",
        value: (r) => r.getAttribute("href")
      }
    }), e.commands.add("link", new mj(e)), e.commands.add("unlink", new gj(e));
    const t = dj(e.t, hj(e.config.get("link.decorators")));
    this._enableAutomaticDecorators(t.filter((r) => r.mode === b0)), this._enableManualDecorators(t.filter((r) => r.mode === vj)), e.plugins.get(Ub).registerAttribute("linkHref"), g$(e, "linkHref", "a", _j), this._enableLinkOpen(), this._enableInsertContentSelectionAttributesFixer(), this._enableClickingAfterLink(), this._enableTypingOverLink(), this._handleDeleteContentAfterLink(), this._enableClipboardIntegration();
  }
  /**
   * Processes an array of configured {@link module:link/linkconfig~LinkDecoratorAutomaticDefinition automatic decorators}
   * and registers a {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher downcast dispatcher}
   * for each one of them. Downcast dispatchers are obtained using the
   * {@link module:link/utils/automaticdecorators~AutomaticDecorators#getDispatcher} method.
   *
   * **Note**: This method also activates the automatic external link decorator if enabled with
   * {@link module:link/linkconfig~LinkConfig#addTargetToExternalLinks `config.link.addTargetToExternalLinks`}.
   */
  _enableAutomaticDecorators(e) {
    const t = this.editor, r = t.commands.get("link").automaticDecorators;
    t.config.get("link.addTargetToExternalLinks") && r.add({
      id: "linkIsExternal",
      mode: b0,
      callback: (s) => !!s && wj.test(s),
      attributes: {
        target: "_blank",
        rel: "noopener noreferrer"
      }
    }), r.add(e), r.length && t.conversion.for("downcast").add(r.getDispatcher());
  }
  /**
   * Processes an array of configured {@link module:link/linkconfig~LinkDecoratorManualDefinition manual decorators},
   * transforms them into {@link module:link/utils/manualdecorator~ManualDecorator} instances and stores them in the
   * {@link module:link/linkcommand~LinkCommand#manualDecorators} collection (a model for manual decorators state).
   *
   * Also registers an {@link module:engine/conversion/downcasthelpers~DowncastHelpers#attributeToElement attribute-to-element}
   * converter for each manual decorator and extends the {@link module:engine/model/schema~Schema model's schema}
   * with adequate model attributes.
   */
  _enableManualDecorators(e) {
    if (!e.length)
      return;
    const t = this.editor, r = t.commands.get("link").manualDecorators;
    e.forEach((s) => {
      t.model.schema.extend("$text", { allowAttributes: s.id });
      const o = new pj(s);
      r.add(o), t.conversion.for("downcast").attributeToElement({
        model: o.id,
        view: (l, { writer: u, schema: h }, { item: f }) => {
          if ((f.is("selection") || h.isInline(f)) && l) {
            const m = u.createAttributeElement("a", o.attributes, { priority: 5 });
            o.classes && u.addClass(o.classes, m);
            for (const v in o.styles)
              u.setStyle(v, o.styles[v], m);
            return u.setCustomProperty("link", !0, m), m;
          }
        }
      }), t.conversion.for("upcast").elementToAttribute({
        view: {
          name: "a",
          ...o._createPattern()
        },
        model: {
          key: o.id
        }
      });
    });
  }
  /**
   * Attaches handlers for {@link module:engine/view/document~Document#event:enter} and
   * {@link module:engine/view/document~Document#event:click} to enable link following.
   */
  _enableLinkOpen() {
    const e = this.editor, n = e.editing.view.document;
    this.listenTo(n, "click", (r, s) => {
      if (!(qe.isMac ? s.domEvent.metaKey : s.domEvent.ctrlKey))
        return;
      let l = s.domTarget;
      if (l.tagName.toLowerCase() != "a" && (l = l.closest("a")), !l)
        return;
      const u = l.getAttribute("href");
      u && (r.stop(), s.preventDefault(), v0(u));
    }, { context: "$capture" }), this.listenTo(n, "keydown", (r, s) => {
      const l = e.commands.get("link").value;
      l && s.keyCode === tt.enter && s.altKey && (r.stop(), v0(l));
    });
  }
  /**
   * Starts listening to {@link module:engine/model/model~Model#event:insertContent} and corrects the model
   * selection attributes if the selection is at the end of a link after inserting the content.
   *
   * The purpose of this action is to improve the overall UX because the user is no longer "trapped" by the
   * `linkHref` attribute of the selection and they can type a "clean" (`linkHref`–less) text right away.
   *
   * See https://github.com/ckeditor/ckeditor5/issues/6053.
   */
  _enableInsertContentSelectionAttributesFixer() {
    const t = this.editor.model, n = t.document.selection;
    this.listenTo(t, "insertContent", () => {
      const r = n.anchor.nodeBefore, s = n.anchor.nodeAfter;
      n.hasAttribute("linkHref") && r && r.hasAttribute("linkHref") && (s && s.hasAttribute("linkHref") || t.change((o) => {
        $m(o, zm(t.schema));
      }));
    }, { priority: "low" });
  }
  /**
   * Starts listening to {@link module:engine/view/document~Document#event:mousedown} and
   * {@link module:engine/view/document~Document#event:selectionChange} and puts the selection before/after a link node
   * if clicked at the beginning/ending of the link.
   *
   * The purpose of this action is to allow typing around the link node directly after a click.
   *
   * See https://github.com/ckeditor/ckeditor5/issues/1016.
   */
  _enableClickingAfterLink() {
    const e = this.editor, t = e.model;
    e.editing.view.addObserver(uh);
    let n = !1;
    this.listenTo(e.editing.view.document, "mousedown", () => {
      n = !0;
    }), this.listenTo(e.editing.view.document, "selectionChange", () => {
      if (!n)
        return;
      n = !1;
      const r = t.document.selection;
      if (!r.isCollapsed || !r.hasAttribute("linkHref"))
        return;
      const s = r.getFirstPosition(), o = Ko(s, "linkHref", r.getAttribute("linkHref"), t);
      (s.isTouching(o.start) || s.isTouching(o.end)) && t.change((l) => {
        $m(l, zm(t.schema));
      });
    });
  }
  /**
   * Starts listening to {@link module:engine/model/model~Model#deleteContent} and {@link module:engine/model/model~Model#insertContent}
   * and checks whether typing over the link. If so, attributes of removed text are preserved and applied to the inserted text.
   *
   * The purpose of this action is to allow modifying a text without loosing the `linkHref` attribute (and other).
   *
   * See https://github.com/ckeditor/ckeditor5/issues/4762.
   */
  _enableTypingOverLink() {
    const e = this.editor, t = e.editing.view;
    let n = null, r = !1;
    this.listenTo(t.document, "delete", () => {
      r = !0;
    }, { priority: "high" }), this.listenTo(e.model, "deleteContent", () => {
      const s = e.model.document.selection;
      if (!s.isCollapsed) {
        if (r) {
          r = !1;
          return;
        }
        y0(e) && yj(e.model) && (n = s.getAttributes());
      }
    }, { priority: "high" }), this.listenTo(e.model, "insertContent", (s, [o]) => {
      r = !1, y0(e) && n && (e.model.change((l) => {
        for (const [u, h] of n)
          l.setAttribute(u, h, o);
      }), n = null);
    }, { priority: "high" });
  }
  /**
   * Starts listening to {@link module:engine/model/model~Model#deleteContent} and checks whether
   * removing a content right after the "linkHref" attribute.
   *
   * If so, the selection should not preserve the `linkHref` attribute. However, if
   * the {@link module:typing/twostepcaretmovement~TwoStepCaretMovement} plugin is active and
   * the selection has the "linkHref" attribute due to overriden gravity (at the end), the `linkHref` attribute should stay untouched.
   *
   * The purpose of this action is to allow removing the link text and keep the selection outside the link.
   *
   * See https://github.com/ckeditor/ckeditor5/issues/7521.
   */
  _handleDeleteContentAfterLink() {
    const e = this.editor, t = e.model, n = t.document.selection, r = e.editing.view;
    let s = !1, o = !1;
    this.listenTo(r.document, "delete", (l, u) => {
      o = u.direction === "backward";
    }, { priority: "high" }), this.listenTo(t, "deleteContent", () => {
      s = !1;
      const l = n.getFirstPosition(), u = n.getAttribute("linkHref");
      if (!u)
        return;
      const h = Ko(l, "linkHref", u, t);
      s = h.containsPosition(l) || h.end.isEqual(l);
    }, { priority: "high" }), this.listenTo(t, "deleteContent", () => {
      o && (o = !1, !s && e.model.enqueueChange((l) => {
        $m(l, zm(t.schema));
      }));
    }, { priority: "low" });
  }
  /**
   * Enables URL fixing on pasting.
   */
  _enableClipboardIntegration() {
    const e = this.editor, t = e.model, n = this.editor.config.get("link.defaultProtocol");
    n && this.listenTo(e.plugins.get("ClipboardPipeline"), "contentInsertion", (r, s) => {
      t.change((o) => {
        const l = o.createRangeIn(s.content);
        for (const u of l.getItems())
          if (u.hasAttribute("linkHref")) {
            const h = Mp(u.getAttribute("linkHref"), n);
            o.setAttribute("linkHref", h, u);
          }
      });
    });
  }
}
function $m(i, e) {
  i.removeSelectionAttribute("linkHref");
  for (const t of e)
    i.removeSelectionAttribute(t);
}
function yj(i) {
  const e = i.document.selection, t = e.getFirstPosition(), n = e.getLastPosition(), r = t.nodeAfter;
  if (!r || !r.is("$text") || !r.hasAttribute("linkHref"))
    return !1;
  const s = n.textNode || n.nodeBefore;
  return r === s ? !0 : Ko(t, "linkHref", r.getAttribute("linkHref"), i).containsRange(i.createRange(t, n), !0);
}
function y0(i) {
  return i.model.change((t) => t.batch).isTyping;
}
function zm(i) {
  return i.getDefinition("$text").allowAttributes.filter((t) => t.startsWith("link"));
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class Ej extends Xe {
  /**
   * Creates an instance of the {@link module:link/ui/linkformview~LinkFormView} class.
   *
   * Also see {@link #render}.
   *
   * @param locale The localization services instance.
   * @param linkCommand Reference to {@link module:link/linkcommand~LinkCommand}.
   */
  constructor(e, t) {
    super(e), this.focusTracker = new hi(), this.keystrokes = new cr(), this._focusables = new cs();
    const n = e.t;
    this.urlInputView = this._createUrlInput(), this.saveButtonView = this._createButton(n("Save"), Mt.check, "ck-button-save"), this.saveButtonView.type = "submit", this.cancelButtonView = this._createButton(n("Cancel"), Mt.cancel, "ck-button-cancel", "cancel"), this._manualDecoratorSwitches = this._createManualDecoratorSwitches(t), this.children = this._createFormChildren(t.manualDecorators), this._focusCycler = new ta({
      focusables: this._focusables,
      focusTracker: this.focusTracker,
      keystrokeHandler: this.keystrokes,
      actions: {
        // Navigate form fields backwards using the Shift + Tab keystroke.
        focusPrevious: "shift + tab",
        // Navigate form fields forwards using the Tab key.
        focusNext: "tab"
      }
    });
    const r = ["ck", "ck-link-form", "ck-responsive-form"];
    t.manualDecorators.length && r.push("ck-link-form_layout-vertical", "ck-vertical-form"), this.setTemplate({
      tag: "form",
      attributes: {
        class: r,
        // https://github.com/ckeditor/ckeditor5-link/issues/90
        tabindex: "-1"
      },
      children: this.children
    });
  }
  /**
   * Obtains the state of the {@link module:ui/button/switchbuttonview~SwitchButtonView switch buttons} representing
   * {@link module:link/linkcommand~LinkCommand#manualDecorators manual link decorators}
   * in the {@link module:link/ui/linkformview~LinkFormView}.
   *
   * @returns Key-value pairs, where the key is the name of the decorator and the value is its state.
   */
  getDecoratorSwitchesState() {
    return Array.from(this._manualDecoratorSwitches).reduce((e, t) => (e[t.name] = t.isOn, e), {});
  }
  /**
   * @inheritDoc
   */
  render() {
    super.render(), CC({
      view: this
    }), [
      this.urlInputView,
      ...this._manualDecoratorSwitches,
      this.saveButtonView,
      this.cancelButtonView
    ].forEach((t) => {
      this._focusables.add(t), this.focusTracker.add(t.element);
    }), this.keystrokes.listenTo(this.element);
  }
  /**
   * @inheritDoc
   */
  destroy() {
    super.destroy(), this.focusTracker.destroy(), this.keystrokes.destroy();
  }
  /**
   * Focuses the fist {@link #_focusables} in the form.
   */
  focus() {
    this._focusCycler.focusFirst();
  }
  /**
   * Creates a labeled input view.
   *
   * @returns Labeled field view instance.
   */
  _createUrlInput() {
    const e = this.locale.t, t = new Sp(this.locale, BC);
    return t.label = e("Link URL"), t;
  }
  /**
   * Creates a button view.
   *
   * @param label The button label.
   * @param icon The button icon.
   * @param className The additional button CSS class name.
   * @param eventName An event name that the `ButtonView#execute` event will be delegated to.
   * @returns The button view instance.
   */
  _createButton(e, t, n, r) {
    const s = new At(this.locale);
    return s.set({
      label: e,
      icon: t,
      tooltip: !0
    }), s.extendTemplate({
      attributes: {
        class: n
      }
    }), r && s.delegate("execute").to(this, r), s;
  }
  /**
   * Populates {@link module:ui/viewcollection~ViewCollection} of {@link module:ui/button/switchbuttonview~SwitchButtonView}
   * made based on {@link module:link/linkcommand~LinkCommand#manualDecorators}.
   *
   * @param linkCommand A reference to the link command.
   * @returns ViewCollection of switch buttons.
   */
  _createManualDecoratorSwitches(e) {
    const t = this.createCollection();
    for (const n of e.manualDecorators) {
      const r = new hh(this.locale);
      r.set({
        name: n.id,
        label: n.label,
        withText: !0
      }), r.bind("isOn").toMany([n, e], "value", (s, o) => o === void 0 && s === void 0 ? !!n.defaultValue : !!s), r.on("execute", () => {
        n.set("value", !r.isOn);
      }), t.add(r);
    }
    return t;
  }
  /**
   * Populates the {@link #children} collection of the form.
   *
   * If {@link module:link/linkcommand~LinkCommand#manualDecorators manual decorators} are configured in the editor, it creates an
   * additional `View` wrapping all {@link #_manualDecoratorSwitches} switch buttons corresponding
   * to these decorators.
   *
   * @param manualDecorators A reference to
   * the collection of manual decorators stored in the link command.
   * @returns The children of link form view.
   */
  _createFormChildren(e) {
    const t = this.createCollection();
    if (t.add(this.urlInputView), e.length) {
      const n = new Xe();
      n.setTemplate({
        tag: "ul",
        children: this._manualDecoratorSwitches.map((r) => ({
          tag: "li",
          children: [r],
          attributes: {
            class: [
              "ck",
              "ck-list__item"
            ]
          }
        })),
        attributes: {
          class: [
            "ck",
            "ck-reset",
            "ck-list"
          ]
        }
      }), t.add(n);
    }
    return t.add(this.saveButtonView), t.add(this.cancelButtonView), t;
  }
}
const Cj = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m11.077 15 .991-1.416a.75.75 0 1 1 1.229.86l-1.148 1.64a.748.748 0 0 1-.217.206 5.251 5.251 0 0 1-8.503-5.955.741.741 0 0 1 .12-.274l1.147-1.639a.75.75 0 1 1 1.228.86L4.933 10.7l.006.003a3.75 3.75 0 0 0 6.132 4.294l.006.004zm5.494-5.335a.748.748 0 0 1-.12.274l-1.147 1.639a.75.75 0 1 1-1.228-.86l.86-1.23a3.75 3.75 0 0 0-6.144-4.301l-.86 1.229a.75.75 0 0 1-1.229-.86l1.148-1.64a.748.748 0 0 1 .217-.206 5.251 5.251 0 0 1 8.503 5.955zm-4.563-2.532a.75.75 0 0 1 .184 1.045l-3.155 4.505a.75.75 0 1 1-1.229-.86l3.155-4.506a.75.75 0 0 1 1.045-.184zm4.919 10.562-1.414 1.414a.75.75 0 1 1-1.06-1.06l1.414-1.415-1.415-1.414a.75.75 0 0 1 1.061-1.06l1.414 1.414 1.414-1.415a.75.75 0 0 1 1.061 1.061l-1.414 1.414 1.414 1.415a.75.75 0 0 1-1.06 1.06l-1.415-1.414z"/></svg>';
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class Sj extends Xe {
  /**
   * @inheritDoc
   */
  constructor(e) {
    super(e), this.focusTracker = new hi(), this.keystrokes = new cr(), this._focusables = new cs();
    const t = e.t;
    this.previewButtonView = this._createPreviewButton(), this.unlinkButtonView = this._createButton(t("Unlink"), Cj, "unlink"), this.editButtonView = this._createButton(t("Edit link"), Mt.pencil, "edit"), this.set("href", void 0), this._focusCycler = new ta({
      focusables: this._focusables,
      focusTracker: this.focusTracker,
      keystrokeHandler: this.keystrokes,
      actions: {
        // Navigate fields backwards using the Shift + Tab keystroke.
        focusPrevious: "shift + tab",
        // Navigate fields forwards using the Tab key.
        focusNext: "tab"
      }
    }), this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-link-actions",
          "ck-responsive-form"
        ],
        // https://github.com/ckeditor/ckeditor5-link/issues/90
        tabindex: "-1"
      },
      children: [
        this.previewButtonView,
        this.editButtonView,
        this.unlinkButtonView
      ]
    });
  }
  /**
   * @inheritDoc
   */
  render() {
    super.render(), [
      this.previewButtonView,
      this.editButtonView,
      this.unlinkButtonView
    ].forEach((t) => {
      this._focusables.add(t), this.focusTracker.add(t.element);
    }), this.keystrokes.listenTo(this.element);
  }
  /**
   * @inheritDoc
   */
  destroy() {
    super.destroy(), this.focusTracker.destroy(), this.keystrokes.destroy();
  }
  /**
   * Focuses the fist {@link #_focusables} in the actions.
   */
  focus() {
    this._focusCycler.focusFirst();
  }
  /**
   * Creates a button view.
   *
   * @param label The button label.
   * @param icon The button icon.
   * @param eventName An event name that the `ButtonView#execute` event will be delegated to.
   * @returns The button view instance.
   */
  _createButton(e, t, n) {
    const r = new At(this.locale);
    return r.set({
      label: e,
      icon: t,
      tooltip: !0
    }), r.delegate("execute").to(this, n), r;
  }
  /**
   * Creates a link href preview button.
   *
   * @returns The button view instance.
   */
  _createPreviewButton() {
    const e = new At(this.locale), t = this.bindTemplate, n = this.t;
    return e.set({
      withText: !0,
      tooltip: n("Open link in new tab")
    }), e.extendTemplate({
      attributes: {
        class: [
          "ck",
          "ck-link-actions__preview"
        ],
        href: t.to("href", (r) => r && SS(r)),
        target: "_blank",
        rel: "noopener noreferrer"
      }
    }), e.bind("label").to(this, "href", (r) => r || n("This link has no URL")), e.bind("isEnabled").to(this, "href", (r) => !!r), e.template.tag = "a", e.template.eventListeners = {}, e;
  }
}
const Tj = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m11.077 15 .991-1.416a.75.75 0 1 1 1.229.86l-1.148 1.64a.748.748 0 0 1-.217.206 5.251 5.251 0 0 1-8.503-5.955.741.741 0 0 1 .12-.274l1.147-1.639a.75.75 0 1 1 1.228.86L4.933 10.7l.006.003a3.75 3.75 0 0 0 6.132 4.294l.006.004zm5.494-5.335a.748.748 0 0 1-.12.274l-1.147 1.639a.75.75 0 1 1-1.228-.86l.86-1.23a3.75 3.75 0 0 0-6.144-4.301l-.86 1.229a.75.75 0 0 1-1.229-.86l1.148-1.64a.748.748 0 0 1 .217-.206 5.251 5.251 0 0 1 8.503 5.955zm-4.563-2.532a.75.75 0 0 1 .184 1.045l-3.155 4.505a.75.75 0 1 1-1.229-.86l3.155-4.506a.75.75 0 0 1 1.045-.184z"/></svg>';
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const Qi = "link-ui";
class xj extends fe {
  constructor() {
    super(...arguments), this.actionsView = null, this.formView = null;
  }
  /**
   * @inheritDoc
   */
  static get requires() {
    return [qo];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "LinkUI";
  }
  /**
   * @inheritDoc
   */
  init() {
    const e = this.editor;
    e.editing.view.addObserver(yF), this._balloon = e.plugins.get(qo), this._createToolbarLinkButton(), this._enableBalloonActivators(), e.conversion.for("editingDowncast").markerToHighlight({
      model: Qi,
      view: {
        classes: ["ck-fake-link-selection"]
      }
    }), e.conversion.for("editingDowncast").markerToElement({
      model: Qi,
      view: {
        name: "span",
        classes: ["ck-fake-link-selection", "ck-fake-link-selection_collapsed"]
      }
    });
  }
  /**
   * @inheritDoc
   */
  destroy() {
    super.destroy(), this.formView && this.formView.destroy(), this.actionsView && this.actionsView.destroy();
  }
  /**
   * Creates views.
   */
  _createViews() {
    this.actionsView = this._createActionsView(), this.formView = this._createFormView(), this._enableUserBalloonInteractions();
  }
  /**
   * Creates the {@link module:link/ui/linkactionsview~LinkActionsView} instance.
   */
  _createActionsView() {
    const e = this.editor, t = new Sj(e.locale), n = e.commands.get("link"), r = e.commands.get("unlink");
    return t.bind("href").to(n, "value"), t.editButtonView.bind("isEnabled").to(n), t.unlinkButtonView.bind("isEnabled").to(r), this.listenTo(t, "edit", () => {
      this._addFormView();
    }), this.listenTo(t, "unlink", () => {
      e.execute("unlink"), this._hideUI();
    }), t.keystrokes.set("Esc", (s, o) => {
      this._hideUI(), o();
    }), t.keystrokes.set(Fm, (s, o) => {
      this._addFormView(), o();
    }), t;
  }
  /**
   * Creates the {@link module:link/ui/linkformview~LinkFormView} instance.
   */
  _createFormView() {
    const e = this.editor, t = e.commands.get("link"), n = e.config.get("link.defaultProtocol"), r = new (EC(Ej))(e.locale, t);
    return r.urlInputView.fieldView.bind("value").to(t, "value"), r.urlInputView.bind("isEnabled").to(t, "isEnabled"), r.saveButtonView.bind("isEnabled").to(t), this.listenTo(r, "submit", () => {
      const { value: s } = r.urlInputView.fieldView.element, o = Mp(s, n);
      e.execute("link", o, r.getDecoratorSwitchesState()), this._closeFormView();
    }), this.listenTo(r, "cancel", () => {
      this._closeFormView();
    }), r.keystrokes.set("Esc", (s, o) => {
      this._closeFormView(), o();
    }), r;
  }
  /**
   * Creates a toolbar Link button. Clicking this button will show
   * a {@link #_balloon} attached to the selection.
   */
  _createToolbarLinkButton() {
    const e = this.editor, t = e.commands.get("link"), n = e.t;
    e.ui.componentFactory.add("link", (r) => {
      const s = new At(r);
      return s.isEnabled = !0, s.label = n("Link"), s.icon = Tj, s.keystroke = Fm, s.tooltip = !0, s.isToggleable = !0, s.bind("isEnabled").to(t, "isEnabled"), s.bind("isOn").to(t, "value", (o) => !!o), this.listenTo(s, "execute", () => this._showUI(!0)), s;
    });
  }
  /**
   * Attaches actions that control whether the balloon panel containing the
   * {@link #formView} should be displayed.
   */
  _enableBalloonActivators() {
    const e = this.editor, t = e.editing.view.document;
    this.listenTo(t, "click", () => {
      this._getSelectedLinkElement() && this._showUI();
    }), e.keystrokes.set(Fm, (n, r) => {
      r(), e.commands.get("link").isEnabled && this._showUI(!0);
    });
  }
  /**
   * Attaches actions that control whether the balloon panel containing the
   * {@link #formView} is visible or not.
   */
  _enableUserBalloonInteractions() {
    this.editor.keystrokes.set("Tab", (e, t) => {
      this._areActionsVisible && !this.actionsView.focusTracker.isFocused && (this.actionsView.focus(), t());
    }, {
      // Use the high priority because the link UI navigation is more important
      // than other feature's actions, e.g. list indentation.
      // https://github.com/ckeditor/ckeditor5-link/issues/146
      priority: "high"
    }), this.editor.keystrokes.set("Esc", (e, t) => {
      this._isUIVisible && (this._hideUI(), t());
    }), vp({
      emitter: this.formView,
      activator: () => this._isUIInPanel,
      contextElements: () => [this._balloon.view.element],
      callback: () => this._hideUI()
    });
  }
  /**
   * Adds the {@link #actionsView} to the {@link #_balloon}.
   *
   * @internal
   */
  _addActionsView() {
    this.actionsView || this._createViews(), !this._areActionsInPanel && this._balloon.add({
      view: this.actionsView,
      position: this._getBalloonPositionData()
    });
  }
  /**
   * Adds the {@link #formView} to the {@link #_balloon}.
   */
  _addFormView() {
    if (this.formView || this._createViews(), this._isFormInPanel)
      return;
    const t = this.editor.commands.get("link");
    this.formView.disableCssTransitions(), this._balloon.add({
      view: this.formView,
      position: this._getBalloonPositionData()
    }), this._balloon.visibleView === this.formView && this.formView.urlInputView.fieldView.select(), this.formView.enableCssTransitions(), this.formView.urlInputView.fieldView.element.value = t.value || "";
  }
  /**
   * Closes the form view. Decides whether the balloon should be hidden completely or if the action view should be shown. This is
   * decided upon the link command value (which has a value if the document selection is in the link).
   *
   * Additionally, if any {@link module:link/linkconfig~LinkConfig#decorators} are defined in the editor configuration, the state of
   * switch buttons responsible for manual decorator handling is restored.
   */
  _closeFormView() {
    const e = this.editor.commands.get("link");
    e.restoreManualDecoratorStates(), e.value !== void 0 ? this._removeFormView() : this._hideUI();
  }
  /**
   * Removes the {@link #formView} from the {@link #_balloon}.
   */
  _removeFormView() {
    this._isFormInPanel && (this.formView.saveButtonView.focus(), this._balloon.remove(this.formView), this.editor.editing.view.focus(), this._hideFakeVisualSelection());
  }
  /**
   * Shows the correct UI type. It is either {@link #formView} or {@link #actionsView}.
   *
   * @internal
   */
  _showUI(e = !1) {
    this.formView || this._createViews(), this._getSelectedLinkElement() ? (this._areActionsVisible ? this._addFormView() : this._addActionsView(), e && this._balloon.showStack("main")) : (this._showFakeVisualSelection(), this._addActionsView(), e && this._balloon.showStack("main"), this._addFormView()), this._startUpdatingUI();
  }
  /**
   * Removes the {@link #formView} from the {@link #_balloon}.
   *
   * See {@link #_addFormView}, {@link #_addActionsView}.
   */
  _hideUI() {
    if (!this._isUIInPanel)
      return;
    const e = this.editor;
    this.stopListening(e.ui, "update"), this.stopListening(this._balloon, "change:visibleView"), e.editing.view.focus(), this._removeFormView(), this._balloon.remove(this.actionsView), this._hideFakeVisualSelection();
  }
  /**
   * Makes the UI react to the {@link module:ui/editorui/editorui~EditorUI#event:update} event to
   * reposition itself when the editor UI should be refreshed.
   *
   * See: {@link #_hideUI} to learn when the UI stops reacting to the `update` event.
   */
  _startUpdatingUI() {
    const e = this.editor, t = e.editing.view.document;
    let n = this._getSelectedLinkElement(), r = o();
    const s = () => {
      const l = this._getSelectedLinkElement(), u = o();
      n && !l || !n && u !== r ? this._hideUI() : this._isUIVisible && this._balloon.updatePosition(this._getBalloonPositionData()), n = l, r = u;
    };
    function o() {
      return t.selection.focus.getAncestors().reverse().find((l) => l.is("element"));
    }
    this.listenTo(e.ui, "update", s), this.listenTo(this._balloon, "change:visibleView", s);
  }
  /**
   * Returns `true` when {@link #formView} is in the {@link #_balloon}.
   */
  get _isFormInPanel() {
    return !!this.formView && this._balloon.hasView(this.formView);
  }
  /**
   * Returns `true` when {@link #actionsView} is in the {@link #_balloon}.
   */
  get _areActionsInPanel() {
    return !!this.actionsView && this._balloon.hasView(this.actionsView);
  }
  /**
   * Returns `true` when {@link #actionsView} is in the {@link #_balloon} and it is
   * currently visible.
   */
  get _areActionsVisible() {
    return !!this.actionsView && this._balloon.visibleView === this.actionsView;
  }
  /**
   * Returns `true` when {@link #actionsView} or {@link #formView} is in the {@link #_balloon}.
   */
  get _isUIInPanel() {
    return this._isFormInPanel || this._areActionsInPanel;
  }
  /**
   * Returns `true` when {@link #actionsView} or {@link #formView} is in the {@link #_balloon} and it is
   * currently visible.
   */
  get _isUIVisible() {
    const e = this._balloon.visibleView;
    return !!this.formView && e == this.formView || this._areActionsVisible;
  }
  /**
   * Returns positioning options for the {@link #_balloon}. They control the way the balloon is attached
   * to the target element or selection.
   *
   * If the selection is collapsed and inside a link element, the panel will be attached to the
   * entire link element. Otherwise, it will be attached to the selection.
   */
  _getBalloonPositionData() {
    const e = this.editor.editing.view, t = this.editor.model, n = e.document;
    let r;
    if (t.markers.has(Qi)) {
      const s = Array.from(this.editor.editing.mapper.markerNameToElements(Qi)), o = e.createRange(e.createPositionBefore(s[0]), e.createPositionAfter(s[s.length - 1]));
      r = e.domConverter.viewRangeToDom(o);
    } else
      r = () => {
        const s = this._getSelectedLinkElement();
        return s ? (
          // When selection is inside link element, then attach panel to this element.
          e.domConverter.mapViewToDom(s)
        ) : (
          // Otherwise attach panel to the selection.
          e.domConverter.viewRangeToDom(n.selection.getFirstRange())
        );
      };
    return { target: r };
  }
  /**
   * Returns the link {@link module:engine/view/attributeelement~AttributeElement} under
   * the {@link module:engine/view/document~Document editing view's} selection or `null`
   * if there is none.
   *
   * **Note**: For a non–collapsed selection, the link element is returned when **fully**
   * selected and the **only** element within the selection boundaries, or when
   * a linked widget is selected.
   */
  _getSelectedLinkElement() {
    const e = this.editor.editing.view, t = e.document.selection, n = t.getSelectedElement();
    if (t.isCollapsed || n && Gt(n))
      return Wm(t.getFirstPosition());
    {
      const r = t.getFirstRange().getTrimmed(), s = Wm(r.start), o = Wm(r.end);
      return !s || s != o ? null : e.createRangeIn(s).getTrimmed().isEqual(r) ? s : null;
    }
  }
  /**
   * Displays a fake visual selection when the contextual balloon is displayed.
   *
   * This adds a 'link-ui' marker into the document that is rendered as a highlight on selected text fragment.
   */
  _showFakeVisualSelection() {
    const e = this.editor.model;
    e.change((t) => {
      const n = e.document.selection.getFirstRange();
      if (e.markers.has(Qi))
        t.updateMarker(Qi, { range: n });
      else if (n.start.isAtEnd) {
        const r = n.start.getLastMatchingPosition(({ item: s }) => !e.schema.isContent(s), { boundaries: n });
        t.addMarker(Qi, {
          usingOperation: !1,
          affectsData: !1,
          range: t.createRange(r, n.end)
        });
      } else
        t.addMarker(Qi, {
          usingOperation: !1,
          affectsData: !1,
          range: n
        });
    });
  }
  /**
   * Hides the fake visual selection created in {@link #_showFakeVisualSelection}.
   */
  _hideFakeVisualSelection() {
    const e = this.editor.model;
    e.markers.has(Qi) && e.change((t) => {
      t.removeMarker(Qi);
    });
  }
}
function Wm(i) {
  return i.getAncestors().find((e) => cj(e)) || null;
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const kj = 4, Aj = new RegExp(
  // Group 1: Line start or after a space.
  "(^|\\s)(((?:(?:(?:https?|ftp):)?\\/\\/)(?:\\S+(?::\\S*)?@)?(?:(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(((?!www\\.)|(www\\.))(?![-_])(?:[-_a-z0-9\\u00a1-\\uffff]{1,63}\\.)+(?:[a-z\\u00a1-\\uffff]{2,63})))(?::\\d{2,5})?(?:[/?#]\\S*)?)|((www.|(\\S+@))((?![-_])(?:[-_a-z0-9\\u00a1-\\uffff]{1,63}\\.))+(?:[a-z\\u00a1-\\uffff]{2,63})))$",
  "i"
), Pj = 2;
class Ij extends fe {
  /**
   * @inheritDoc
   */
  static get requires() {
    return [ia];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "AutoLink";
  }
  /**
   * @inheritDoc
   */
  init() {
    const t = this.editor.model.document.selection;
    t.on("change:range", () => {
      this.isEnabled = !t.anchor.parent.is("element", "codeBlock");
    }), this._enableTypingHandling();
  }
  /**
   * @inheritDoc
   */
  afterInit() {
    this._enableEnterHandling(), this._enableShiftEnterHandling();
  }
  /**
   * Enables autolinking on typing.
   */
  _enableTypingHandling() {
    const e = this.editor, t = new f$(e.model, (n) => {
      if (!Rj(n))
        return;
      const r = E0(n.substr(0, n.length - 1));
      if (r)
        return { url: r };
    });
    t.on("matched:data", (n, r) => {
      const { batch: s, range: o, url: l } = r;
      if (!s.isTyping)
        return;
      const u = o.end.getShiftedBy(-1), h = u.getShiftedBy(-l.length), f = e.model.createRange(h, u);
      this._applyAutoLink(l, f);
    }), t.bind("isEnabled").to(this);
  }
  /**
   * Enables autolinking on the <kbd>Enter</kbd> key.
   */
  _enableEnterHandling() {
    const e = this.editor, t = e.model, n = e.commands.get("enter");
    n && n.on("execute", () => {
      const r = t.document.selection.getFirstPosition();
      if (!r.parent.previousSibling)
        return;
      const s = t.createRangeIn(r.parent.previousSibling);
      this._checkAndApplyAutoLinkOnRange(s);
    });
  }
  /**
   * Enables autolinking on the <kbd>Shift</kbd>+<kbd>Enter</kbd> keyboard shortcut.
   */
  _enableShiftEnterHandling() {
    const e = this.editor, t = e.model, n = e.commands.get("shiftEnter");
    n && n.on("execute", () => {
      const r = t.document.selection.getFirstPosition(), s = t.createRange(t.createPositionAt(r.parent, 0), r.getShiftedBy(-1));
      this._checkAndApplyAutoLinkOnRange(s);
    });
  }
  /**
   * Checks if the passed range contains a linkable text.
   */
  _checkAndApplyAutoLinkOnRange(e) {
    const t = this.editor.model, { text: n, range: r } = UC(e, t), s = E0(n);
    if (s) {
      const o = t.createRange(r.end.getShiftedBy(-s.length), r.end);
      this._applyAutoLink(s, o);
    }
  }
  /**
   * Applies a link on a given range if the link should be applied.
   *
   * @param url The URL to link.
   * @param range The text range to apply the link attribute to.
   */
  _applyAutoLink(e, t) {
    const n = this.editor.model, r = this.editor.config.get("link.defaultProtocol"), s = Mp(e, r);
    !this.isEnabled || !Oj(t, n) || !TS(s) || Mj(t) || this._persistAutoLink(s, t);
  }
  /**
   * Enqueues autolink changes in the model.
   *
   * @param url The URL to link.
   * @param range The text range to apply the link attribute to.
   */
  _persistAutoLink(e, t) {
    const n = this.editor.model, r = this.editor.plugins.get("Delete");
    n.enqueueChange((s) => {
      s.setAttribute("linkHref", e, t), n.enqueueChange(() => {
        r.requestUndoOnBackspace();
      });
    });
  }
}
function Rj(i) {
  return i.length > kj && i[i.length - 1] === " " && i[i.length - 2] !== " ";
}
function E0(i) {
  const e = Aj.exec(i);
  return e ? e[Pj] : null;
}
function Oj(i, e) {
  return e.schema.checkAttributeInSelection(e.createSelection(i), "linkHref");
}
function Mj(i) {
  const e = i.start.nodeAfter;
  return !!e && e.hasAttribute("linkHref");
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class Nj extends fe {
  /**
   * @inheritDoc
   */
  static get requires() {
    return [bj, xj, Ij];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "Link";
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class C0 extends Pt {
  /**
   * Creates an instance of the command.
   *
   * @param editor The editor instance.
   * @param type List type that will be handled by this command.
   */
  constructor(e, t) {
    super(e), this.type = t;
  }
  /**
   * @inheritDoc
   */
  refresh() {
    this.value = this._getValue(), this.isEnabled = this._checkEnabled();
  }
  /**
   * Executes the list command.
   *
   * @fires execute
   * @param options Command options.
   * @param options.forceValue If set, it will force the command behavior. If `true`, the command will try to convert the
   * selected items and potentially the neighbor elements to the proper list items. If set to `false`, it will convert selected elements
   * to paragraphs. If not set, the command will toggle selected elements to list items or paragraphs, depending on the selection.
   */
  execute(e = {}) {
    const t = this.editor.model, n = t.document, r = Array.from(n.selection.getSelectedBlocks()).filter((o) => T0(o, t.schema)), s = e.forceValue !== void 0 ? !e.forceValue : this.value;
    t.change((o) => {
      if (s) {
        let l = r[r.length - 1].nextSibling, u = Number.POSITIVE_INFINITY, h = [];
        for (; l && l.name == "listItem" && l.getAttribute("listIndent") !== 0; ) {
          const f = l.getAttribute("listIndent");
          f < u && (u = f);
          const m = f - u;
          h.push({ element: l, listIndent: m }), l = l.nextSibling;
        }
        h = h.reverse();
        for (const f of h)
          o.setAttribute("listIndent", f.listIndent, f.element);
      }
      if (!s) {
        let l = Number.POSITIVE_INFINITY;
        for (const u of r)
          u.is("element", "listItem") && u.getAttribute("listIndent") < l && (l = u.getAttribute("listIndent"));
        l = l === 0 ? 1 : l, S0(r, !0, l), S0(r, !1, l);
      }
      for (const l of r.reverse())
        s && l.name == "listItem" ? o.rename(l, "paragraph") : !s && l.name != "listItem" ? (o.setAttributes({ listType: this.type, listIndent: 0 }, l), o.rename(l, "listItem")) : !s && l.name == "listItem" && l.getAttribute("listType") != this.type && o.setAttribute("listType", this.type, l);
      this.fire("_executeCleanup", r);
    });
  }
  /**
   * Checks the command's {@link #value}.
   *
   * @returns The current value.
   */
  _getValue() {
    const e = Rn(this.editor.model.document.selection.getSelectedBlocks());
    return !!e && e.is("element", "listItem") && e.getAttribute("listType") == this.type;
  }
  /**
   * Checks whether the command can be enabled in the current context.
   *
   * @returns Whether the command should be enabled.
   */
  _checkEnabled() {
    if (this.value)
      return !0;
    const e = this.editor.model.document.selection, t = this.editor.model.schema, n = Rn(e.getSelectedBlocks());
    return n ? T0(n, t) : !1;
  }
}
function S0(i, e, t) {
  const n = e ? i[0] : i[i.length - 1];
  if (n.is("element", "listItem")) {
    let r = n[e ? "previousSibling" : "nextSibling"], s = n.getAttribute("listIndent");
    for (; r && r.is("element", "listItem") && r.getAttribute("listIndent") >= t; )
      s > r.getAttribute("listIndent") && (s = r.getAttribute("listIndent")), r.getAttribute("listIndent") == s && i[e ? "unshift" : "push"](r), r = r[e ? "previousSibling" : "nextSibling"];
  }
}
function T0(i, e) {
  return e.checkChild(i.parent, "listItem") && !e.isObject(i);
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class x0 extends Pt {
  /**
   * Creates an instance of the command.
   *
   * @param editor The editor instance.
   * @param indentDirection The direction of indent. If it is equal to `backward`, the command will outdent a list item.
   */
  constructor(e, t) {
    super(e), this._indentBy = t == "forward" ? 1 : -1;
  }
  /**
   * @inheritDoc
   */
  refresh() {
    this.isEnabled = this._checkEnabled();
  }
  /**
   * Indents or outdents (depending on the {@link #constructor}'s `indentDirection` parameter) selected list items.
   *
   * @fires execute
   */
  execute() {
    const e = this.editor.model, t = e.document;
    let n = Array.from(t.selection.getSelectedBlocks());
    e.change((r) => {
      const s = n[n.length - 1];
      let o = s.nextSibling;
      for (; o && o.name == "listItem" && o.getAttribute("listIndent") > s.getAttribute("listIndent"); )
        n.push(o), o = o.nextSibling;
      this._indentBy < 0 && (n = n.reverse());
      for (const l of n) {
        const u = l.getAttribute("listIndent") + this._indentBy;
        u < 0 ? r.rename(l, "paragraph") : r.setAttribute("listIndent", u, l);
      }
      this.fire("_executeCleanup", n);
    });
  }
  /**
   * Checks whether the command can be enabled in the current context.
   *
   * @returns Whether the command should be enabled.
   */
  _checkEnabled() {
    const e = Rn(this.editor.model.document.selection.getSelectedBlocks());
    if (!e || !e.is("element", "listItem"))
      return !1;
    if (this._indentBy > 0) {
      const t = e.getAttribute("listIndent"), n = e.getAttribute("listType");
      let r = e.previousSibling;
      for (; r && r.is("element", "listItem") && r.getAttribute("listIndent") >= t; ) {
        if (r.getAttribute("listIndent") == t)
          return r.getAttribute("listType") == n;
        r = r.previousSibling;
      }
      return !1;
    }
    return !0;
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function Dj(i) {
  const e = i.createContainerElement("li");
  return e.getFillerOffset = $j, e;
}
function Bj(i, e) {
  const t = e.mapper, n = e.writer, r = i.getAttribute("listType") == "numbered" ? "ol" : "ul", s = Dj(n), o = n.createContainerElement(r, null);
  return n.insert(n.createPositionAt(o, 0), s), t.bindElements(i, s), s;
}
function xS(i, e, t, n) {
  const r = e.parent, s = t.mapper, o = t.writer;
  let l = s.toViewPosition(n.createPositionBefore(i));
  const u = Go(i.previousSibling, {
    sameIndent: !0,
    smallerIndent: !0,
    listIndent: i.getAttribute("listIndent")
  }), h = i.previousSibling;
  if (u && u.getAttribute("listIndent") == i.getAttribute("listIndent")) {
    const f = s.toViewElement(u);
    l = o.breakContainer(o.createPositionAfter(f));
  } else if (h && h.name == "listItem") {
    l = s.toViewPosition(n.createPositionAt(h, "end"));
    const f = s.findMappedViewAncestor(l), m = Vj(f);
    m ? l = o.createPositionBefore(m) : l = o.createPositionAt(f, "end");
  } else
    l = s.toViewPosition(n.createPositionBefore(i));
  if (l = kS(l), o.insert(l, r), h && h.name == "listItem") {
    const f = s.toViewElement(h), v = o.createRange(o.createPositionAt(f, 0), l).getWalker({ ignoreElementEnd: !0 });
    for (const C of v)
      if (C.item.is("element", "li")) {
        const k = o.breakContainer(o.createPositionBefore(C.item)), S = C.item.parent, x = o.createPositionAt(e, "end");
        Ai(o, x.nodeBefore, x.nodeAfter), o.move(o.createRangeOn(S), x), v._position = k;
      }
  } else {
    const f = r.nextSibling;
    if (f && (f.is("element", "ul") || f.is("element", "ol"))) {
      let m = null;
      for (const v of f.getChildren()) {
        const C = s.toModelElement(v);
        if (C && C.getAttribute("listIndent") > i.getAttribute("listIndent"))
          m = v;
        else
          break;
      }
      m && (o.breakContainer(o.createPositionAfter(m)), o.move(o.createRangeOn(m.parent), o.createPositionAt(e, "end")));
    }
  }
  Ai(o, r, r.nextSibling), Ai(o, r.previousSibling, r);
}
function Ai(i, e, t) {
  return !e || !t || e.name != "ul" && e.name != "ol" || e.name != t.name || e.getAttribute("class") !== t.getAttribute("class") ? null : i.mergeContainers(i.createPositionAfter(e));
}
function kS(i) {
  return i.getLastMatchingPosition((e) => e.item.is("uiElement"));
}
function Go(i, e) {
  const t = !!e.sameIndent, n = !!e.smallerIndent, r = e.listIndent;
  let s = i;
  for (; s && s.name == "listItem"; ) {
    const o = s.getAttribute("listIndent");
    if (t && r == o || n && r > o)
      return s;
    e.direction === "forward" ? s = s.nextSibling : s = s.previousSibling;
  }
  return null;
}
function k0(i, e, t, n) {
  i.ui.componentFactory.add(e, (r) => {
    const s = i.commands.get(e), o = new At(r);
    return o.set({
      label: t,
      icon: n,
      tooltip: !0,
      isToggleable: !0
    }), o.bind("isOn", "isEnabled").to(s, "value", "isEnabled"), o.on("execute", () => {
      i.execute(e), i.editing.view.focus();
    }), o;
  });
}
function Vj(i) {
  for (const e of i.getChildren())
    if (e.name == "ul" || e.name == "ol")
      return e;
  return null;
}
function Md(i, e) {
  const t = [], n = i.parent, r = {
    ignoreElementEnd: !1,
    startPosition: i,
    shallow: !0,
    direction: e
  }, s = n.getAttribute("listIndent"), o = [...new ir(r)].filter((l) => l.item.is("element")).map((l) => l.item);
  for (const l of o) {
    if (!l.is("element", "listItem") || l.getAttribute("listIndent") < s)
      break;
    if (!(l.getAttribute("listIndent") > s)) {
      if (l.getAttribute("listType") !== n.getAttribute("listType") || l.getAttribute("listStyle") !== n.getAttribute("listStyle") || l.getAttribute("listReversed") !== n.getAttribute("listReversed") || l.getAttribute("listStart") !== n.getAttribute("listStart"))
        break;
      e === "backward" ? t.unshift(l) : t.push(l);
    }
  }
  return t;
}
function yh(i) {
  let t = [...i.document.selection.getSelectedBlocks()].filter((n) => n.is("element", "listItem")).map((n) => {
    const r = i.change((s) => s.createPositionAt(n, 0));
    return [
      ...Md(r, "backward"),
      ...Md(r, "forward")
    ];
  }).flat();
  return t = [...new Set(t)], t;
}
const Lj = ["disc", "circle", "square"], Fj = [
  "decimal",
  "decimal-leading-zero",
  "lower-roman",
  "upper-roman",
  "lower-latin",
  "upper-latin"
];
function AS(i) {
  return Lj.includes(i) ? "bulleted" : Fj.includes(i) ? "numbered" : null;
}
function $j() {
  const i = !this.isEmpty && (this.getChild(0).name == "ul" || this.getChild(0).name == "ol");
  return this.isEmpty || i ? 0 : RE.call(this);
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class zj extends fe {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "ListUtils";
  }
  /**
   * Checks whether the given list-style-type is supported by numbered or bulleted list.
   */
  getListTypeFromListStyleType(e) {
    return AS(e);
  }
  /**
   * Returns an array with all `listItem` elements in the model selection.
   *
   * It returns all the items even if only a part of the list is selected, including items that belong to nested lists.
   * If no list is selected, it returns an empty array.
   * The order of the elements is not specified.
   */
  getSelectedListItems(e) {
    return yh(e);
  }
  /**
   * Returns an array with all `listItem` elements that represent the same list.
   *
   * It means that values of `listIndent`, `listType`, `listStyle`, `listReversed` and `listStart` for all items are equal.
   *
   * Additionally, if the `position` is inside a list item, that list item will be returned as well.
   *
   * @param position Starting position.
   * @param direction Walking direction.
   */
  getSiblingNodes(e, t) {
    return Md(e, t);
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function A0(i) {
  return (e, t, n) => {
    const r = n.consumable;
    if (!r.test(t.item, "insert") || !r.test(t.item, "attribute:listType") || !r.test(t.item, "attribute:listIndent"))
      return;
    r.consume(t.item, "insert"), r.consume(t.item, "attribute:listType"), r.consume(t.item, "attribute:listIndent");
    const s = t.item, o = Bj(s, n);
    xS(s, o, n, i);
  };
}
function Wj(i) {
  return (e, t, n) => {
    const o = n.mapper.toViewPosition(t.position).getLastMatchingPosition((C) => !C.item.is("element", "li")).nodeAfter, l = n.writer;
    l.breakContainer(l.createPositionBefore(o)), l.breakContainer(l.createPositionAfter(o));
    const u = o.parent, h = u.previousSibling, f = l.createRangeOn(u), m = l.remove(f);
    h && h.nextSibling && Ai(l, h, h.nextSibling);
    const v = n.mapper.toModelElement(o);
    PS(v.getAttribute("listIndent") + 1, t.position, f.start, o, n, i);
    for (const C of l.createRangeIn(m).getItems())
      n.mapper.unbindViewElement(C);
    e.stop();
  };
}
const jj = (i, e, t) => {
  if (!t.consumable.test(e.item, i.name))
    return;
  const n = t.mapper.toViewElement(e.item), r = t.writer;
  r.breakContainer(r.createPositionBefore(n)), r.breakContainer(r.createPositionAfter(n));
  const s = n.parent, o = e.attributeNewValue == "numbered" ? "ol" : "ul";
  r.rename(o, s);
}, Uj = (i, e, t) => {
  t.consumable.consume(e.item, i.name);
  const r = t.mapper.toViewElement(e.item).parent, s = t.writer;
  Ai(s, r, r.nextSibling), Ai(s, r.previousSibling, r);
};
function Hj(i) {
  return (e, t, n) => {
    if (!n.consumable.consume(t.item, "attribute:listIndent"))
      return;
    const r = n.mapper.toViewElement(t.item), s = n.writer;
    s.breakContainer(s.createPositionBefore(r)), s.breakContainer(s.createPositionAfter(r));
    const o = r.parent, l = o.previousSibling, u = s.createRangeOn(o);
    s.remove(u), l && l.nextSibling && Ai(s, l, l.nextSibling), PS(t.attributeOldValue + 1, t.range.start, u.start, r, n, i), xS(t.item, r, n, i);
    for (const h of t.item.getChildren())
      n.consumable.consume(h, "insert");
  };
}
const P0 = (i, e, t) => {
  if (t.consumable.test(e.item, i.name) && e.item.name != "listItem") {
    let n = t.mapper.toViewPosition(e.range.start);
    const r = t.writer, s = [];
    for (; (n.parent.name == "ul" || n.parent.name == "ol") && (n = r.breakContainer(n), n.parent.name == "li"); ) {
      const o = n, l = r.createPositionAt(n.parent, "end");
      if (!o.isEqual(l)) {
        const u = r.remove(r.createRange(o, l));
        s.push(u);
      }
      n = r.createPositionAfter(n.parent);
    }
    if (s.length > 0) {
      for (let o = 0; o < s.length; o++) {
        const l = n.nodeBefore;
        if (n = r.insert(n, s[o]).end, o > 0) {
          const h = Ai(r, l, l.nextSibling);
          h && h.parent == l && n.offset--;
        }
      }
      Ai(r, n.nodeBefore, n.nodeAfter);
    }
  }
}, qj = (i, e, t) => {
  const n = t.mapper.toViewPosition(e.position), r = n.nodeBefore, s = n.nodeAfter;
  Ai(t.writer, r, s);
}, Kj = (i, e, t) => {
  if (t.consumable.consume(e.viewItem, { name: !0 })) {
    const n = t.writer, r = n.createElement("listItem"), s = eU(e.viewItem);
    n.setAttribute("listIndent", s, r);
    const o = e.viewItem.parent && e.viewItem.parent.name == "ol" ? "numbered" : "bulleted";
    if (n.setAttribute("listType", o, r), !t.safeInsert(r, e.modelCursor))
      return;
    const l = Zj(r, e.viewItem.getChildren(), t);
    e.modelRange = n.createRange(e.modelCursor, l), t.updateConversionResult(r, e);
  }
}, I0 = (i, e, t) => {
  if (t.consumable.test(e.viewItem, { name: !0 })) {
    const n = Array.from(e.viewItem.getChildren());
    for (const r of n)
      !(r.is("element", "li") || Yo(r)) && r._remove();
  }
}, Gj = (i, e, t) => {
  if (t.consumable.test(e.viewItem, { name: !0 })) {
    if (e.viewItem.childCount === 0)
      return;
    const n = [...e.viewItem.getChildren()];
    let r = !1;
    for (const s of n)
      r && !Yo(s) && s._remove(), Yo(s) && (r = !0);
  }
};
function R0(i) {
  return (e, t) => {
    if (t.isPhantom)
      return;
    const n = t.modelPosition.nodeBefore;
    if (n && n.is("element", "listItem")) {
      const r = t.mapper.toViewElement(n), s = r.getAncestors().find(Yo), o = i.createPositionAt(r, 0).getWalker();
      for (const l of o)
        if (l.type == "elementStart" && l.item.is("element", "li")) {
          t.viewPosition = l.previousPosition;
          break;
        } else if (l.type == "elementEnd" && l.item == s) {
          t.viewPosition = l.nextPosition;
          break;
        }
    }
  };
}
function Yj(i) {
  return (e, t) => {
    const n = t.viewPosition, r = n.parent, s = t.mapper;
    if (r.name == "ul" || r.name == "ol") {
      if (n.isAtEnd) {
        const o = s.toModelElement(n.nodeBefore), l = s.getModelLength(n.nodeBefore);
        t.modelPosition = i.createPositionBefore(o).getShiftedBy(l);
      } else {
        const o = s.toModelElement(n.nodeAfter);
        t.modelPosition = i.createPositionBefore(o);
      }
      e.stop();
    } else if (r.name == "li" && n.nodeBefore && (n.nodeBefore.name == "ul" || n.nodeBefore.name == "ol")) {
      const o = s.toModelElement(r);
      let l = 1, u = n.nodeBefore;
      for (; u && Yo(u); )
        l += s.getModelLength(u), u = u.previousSibling;
      t.modelPosition = i.createPositionBefore(o).getShiftedBy(l), e.stop();
    }
  };
}
function Jj(i, e) {
  const t = i.document.differ.getChanges(), n = /* @__PURE__ */ new Map();
  let r = !1;
  for (const u of t)
    if (u.type == "insert" && u.name == "listItem")
      s(u.position);
    else if (u.type == "insert" && u.name != "listItem") {
      if (u.name != "$text") {
        const f = u.position.nodeAfter;
        f.hasAttribute("listIndent") && (e.removeAttribute("listIndent", f), r = !0), f.hasAttribute("listType") && (e.removeAttribute("listType", f), r = !0), f.hasAttribute("listStyle") && (e.removeAttribute("listStyle", f), r = !0), f.hasAttribute("listReversed") && (e.removeAttribute("listReversed", f), r = !0), f.hasAttribute("listStart") && (e.removeAttribute("listStart", f), r = !0);
        for (const m of Array.from(i.createRangeIn(f)).filter((v) => v.item.is("element", "listItem")))
          s(m.previousPosition);
      }
      const h = u.position.getShiftedBy(u.length);
      s(h);
    } else
      u.type == "remove" && u.name == "listItem" ? s(u.position) : (u.type == "attribute" && u.attributeKey == "listIndent" || u.type == "attribute" && u.attributeKey == "listType") && s(u.range.start);
  for (const u of n.values())
    o(u), l(u);
  return r;
  function s(u) {
    const h = u.nodeBefore;
    if (!h || !h.is("element", "listItem")) {
      const f = u.nodeAfter;
      f && f.is("element", "listItem") && n.set(f, f);
    } else {
      let f = h;
      if (n.has(f))
        return;
      for (let m = f.previousSibling; m && m.is("element", "listItem"); m = f.previousSibling)
        if (f = m, n.has(f))
          return;
      n.set(h, f);
    }
  }
  function o(u) {
    let h = 0, f = null;
    for (; u && u.is("element", "listItem"); ) {
      const m = u.getAttribute("listIndent");
      if (m > h) {
        let v;
        f === null ? (f = m - h, v = h) : (f > m && (f = m), v = m - f), e.setAttribute("listIndent", v, u), r = !0;
      } else
        f = null, h = u.getAttribute("listIndent") + 1;
      u = u.nextSibling;
    }
  }
  function l(u) {
    let h = [], f = null;
    for (; u && u.is("element", "listItem"); ) {
      const m = u.getAttribute("listIndent");
      if (f && f.getAttribute("listIndent") > m && (h = h.slice(0, m + 1)), m != 0)
        if (h[m]) {
          const v = h[m];
          u.getAttribute("listType") != v && (e.setAttribute("listType", v, u), r = !0);
        } else
          h[m] = u.getAttribute("listType");
      f = u, u = u.nextSibling;
    }
  }
}
const Xj = function(i, [e, t]) {
  const n = this;
  let r = e.is("documentFragment") ? e.getChild(0) : e, s;
  if (t ? s = n.createSelection(t) : s = n.document.selection, r && r.is("element", "listItem")) {
    const o = s.getFirstPosition();
    let l = null;
    if (o.parent.is("element", "listItem") ? l = o.parent : o.nodeBefore && o.nodeBefore.is("element", "listItem") && (l = o.nodeBefore), l) {
      const u = l.getAttribute("listIndent");
      if (u > 0)
        for (; r && r.is("element", "listItem"); )
          r._setAttribute("listIndent", r.getAttribute("listIndent") + u), r = r.nextSibling;
    }
  }
};
function Zj(i, e, t) {
  const { writer: n, schema: r } = t;
  let s = n.createPositionAfter(i);
  for (const o of e)
    if (o.name == "ul" || o.name == "ol")
      s = t.convertItem(o, s).modelCursor;
    else {
      const l = t.convertItem(o, n.createPositionAt(i, "end")), u = l.modelRange.start.nodeAfter;
      u && u.is("element") && !r.checkChild(i, u.name) && (l.modelCursor.parent.is("element", "listItem") ? i = l.modelCursor.parent : i = Qj(l.modelCursor), s = n.createPositionAfter(i));
    }
  return s;
}
function Qj(i) {
  const e = new ir({ startPosition: i });
  let t;
  do
    t = e.next();
  while (!t.value.item.is("element", "listItem"));
  return t.value.item;
}
function PS(i, e, t, n, r, s) {
  const o = Go(e.nodeBefore, {
    sameIndent: !0,
    smallerIndent: !0,
    listIndent: i
  }), l = r.mapper, u = r.writer, h = o ? o.getAttribute("listIndent") : null;
  let f;
  if (!o)
    f = t;
  else if (h == i) {
    const m = l.toViewElement(o).parent;
    f = u.createPositionAfter(m);
  } else {
    const m = s.createPositionAt(o, "end");
    f = l.toViewPosition(m);
  }
  f = kS(f);
  for (const m of [...n.getChildren()])
    Yo(m) && (f = u.move(u.createRangeOn(m), f).end, Ai(u, m, m.nextSibling), Ai(u, m.previousSibling, m));
}
function Yo(i) {
  return i.is("element", "ol") || i.is("element", "ul");
}
function eU(i) {
  let e = 0, t = i.parent;
  for (; t; ) {
    if (t.is("element", "li"))
      e++;
    else {
      const n = t.previousSibling;
      n && n.is("element", "li") && e++;
    }
    t = t.parent;
  }
  return e;
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class IS extends fe {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "ListEditing";
  }
  /**
   * @inheritDoc
   */
  static get requires() {
    return [xp, ia, zj];
  }
  /**
   * @inheritDoc
   */
  init() {
    const e = this.editor;
    e.model.schema.register("listItem", {
      inheritAllFrom: "$block",
      allowAttributes: ["listType", "listIndent"]
    });
    const t = e.data, n = e.editing;
    e.model.document.registerPostFixer((s) => Jj(e.model, s)), n.mapper.registerViewToModelLength("li", kg), t.mapper.registerViewToModelLength("li", kg), n.mapper.on("modelToViewPosition", R0(n.view)), n.mapper.on("viewToModelPosition", Yj(e.model)), t.mapper.on("modelToViewPosition", R0(n.view)), e.conversion.for("editingDowncast").add((s) => {
      s.on("insert", P0, { priority: "high" }), s.on("insert:listItem", A0(e.model)), s.on("attribute:listType:listItem", jj, { priority: "high" }), s.on("attribute:listType:listItem", Uj, { priority: "low" }), s.on("attribute:listIndent:listItem", Hj(e.model)), s.on("remove:listItem", Wj(e.model)), s.on("remove", qj, { priority: "low" });
    }), e.conversion.for("dataDowncast").add((s) => {
      s.on("insert", P0, { priority: "high" }), s.on("insert:listItem", A0(e.model));
    }), e.conversion.for("upcast").add((s) => {
      s.on("element:ul", I0, { priority: "high" }), s.on("element:ol", I0, { priority: "high" }), s.on("element:li", Gj, { priority: "high" }), s.on("element:li", Kj);
    }), e.model.on("insertContent", Xj, { priority: "high" }), e.commands.add("numberedList", new C0(e, "numbered")), e.commands.add("bulletedList", new C0(e, "bulleted")), e.commands.add("indentList", new x0(e, "forward")), e.commands.add("outdentList", new x0(e, "backward"));
    const r = n.view.document;
    this.listenTo(r, "enter", (s, o) => {
      const l = this.editor.model.document, u = l.selection.getLastPosition().parent;
      l.selection.isCollapsed && u.name == "listItem" && u.isEmpty && (this.editor.execute("outdentList"), o.preventDefault(), s.stop());
    }, { context: "li" }), this.listenTo(r, "delete", (s, o) => {
      if (o.direction !== "backward")
        return;
      const l = this.editor.model.document.selection;
      if (!l.isCollapsed)
        return;
      const u = l.getFirstPosition();
      if (!u.isAtStart)
        return;
      const h = u.parent;
      h.name !== "listItem" || h.previousSibling && h.previousSibling.name === "listItem" || (this.editor.execute("outdentList"), o.preventDefault(), s.stop());
    }, { context: "li" }), this.listenTo(e.editing.view.document, "tab", (s, o) => {
      const l = o.shiftKey ? "outdentList" : "indentList";
      this.editor.commands.get(l).isEnabled && (e.execute(l), o.stopPropagation(), o.preventDefault(), s.stop());
    }, { context: "li" });
  }
  /**
   * @inheritDoc
   */
  afterInit() {
    const e = this.editor.commands, t = e.get("indent"), n = e.get("outdent");
    t && t.registerChildCommand(e.get("indentList")), n && n.registerChildCommand(e.get("outdentList"));
  }
}
function kg(i) {
  let e = 1;
  for (const t of i.getChildren())
    if (t.name == "ul" || t.name == "ol")
      for (const n of t.getChildren())
        e += kg(n);
  return e;
}
const RS = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M7 5.75c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zM3.5 3v5H2V3.7H1v-1h2.5V3zM.343 17.857l2.59-3.257H2.92a.6.6 0 1 0-1.04 0H.302a2 2 0 1 1 3.995 0h-.001c-.048.405-.16.734-.333.988-.175.254-.59.692-1.244 1.312H4.3v1h-4l.043-.043zM7 14.75a.75.75 0 0 1 .75-.75h9.5a.75.75 0 1 1 0 1.5h-9.5a.75.75 0 0 1-.75-.75z"/></svg>', OS = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M7 5.75c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zm-6 0C1 4.784 1.777 4 2.75 4c.966 0 1.75.777 1.75 1.75 0 .966-.777 1.75-1.75 1.75C1.784 7.5 1 6.723 1 5.75zm6 9c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zm-6 0c0-.966.777-1.75 1.75-1.75.966 0 1.75.777 1.75 1.75 0 .966-.777 1.75-1.75 1.75-.966 0-1.75-.777-1.75-1.75z"/></svg>';
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class tU extends fe {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "ListUI";
  }
  /**
   * @inheritDoc
   */
  init() {
    const e = this.editor.t;
    k0(this.editor, "numberedList", e("Numbered List"), RS), k0(this.editor, "bulletedList", e("Bulleted List"), OS);
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class nU extends fe {
  /**
   * @inheritDoc
   */
  static get requires() {
    return [IS, tU];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "List";
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class iU extends Pt {
  /**
   * Creates an instance of the command.
   *
   * @param editor The editor instance.
   * @param defaultType The list type that will be used by default if the value was not specified during
   * the command execution.
   */
  constructor(e, t) {
    super(e), this.defaultType = t;
  }
  /**
   * @inheritDoc
   */
  refresh() {
    this.value = this._getValue(), this.isEnabled = this._checkEnabled();
  }
  /**
   * Executes the command.
   *
   * @fires execute
   * @param options.type The type of the list style, e.g. `'disc'` or `'square'`. If `null` is specified, the default
   * style will be applied.
   */
  execute(e = {}) {
    this._tryToConvertItemsToList(e);
    const t = this.editor.model, n = yh(t);
    n.length && t.change((r) => {
      for (const s of n)
        r.setAttribute("listStyle", e.type || this.defaultType, s);
    });
  }
  /**
   * Checks the command's {@link #value}.
   *
   * @returns The current value.
   */
  _getValue() {
    const e = this.editor.model.document.selection.getFirstPosition().parent;
    return e && e.is("element", "listItem") ? e.getAttribute("listStyle") : null;
  }
  /**
   * Checks whether the command can be enabled in the current context.
   *
   * @returns Whether the command should be enabled.
   */
  _checkEnabled() {
    const e = this.editor, t = e.commands.get("numberedList"), n = e.commands.get("bulletedList");
    return t.isEnabled || n.isEnabled;
  }
  /**
   * Checks if the provided list style is valid. Also changes the selection to a list if it's not set yet.
   *
   * @param The type of the list style. If `null` is specified, the function does nothing.
  */
  _tryToConvertItemsToList(e) {
    if (!e.type)
      return;
    const t = AS(e.type);
    if (!t)
      return;
    const n = this.editor, r = `${t}List`;
    n.commands.get(r).value || n.execute(r);
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class rU extends Pt {
  /**
   * @inheritDoc
   */
  refresh() {
    const e = this._getValue();
    this.value = e, this.isEnabled = e != null;
  }
  /**
   * Executes the command.
   *
   * @fires execute
   * @param options.reversed Whether the list should be reversed.
   */
  execute(e = {}) {
    const t = this.editor.model, n = yh(t).filter((r) => r.getAttribute("listType") == "numbered");
    t.change((r) => {
      for (const s of n)
        r.setAttribute("listReversed", !!e.reversed, s);
    });
  }
  /**
   * Checks the command's {@link #value}.
   *
   * @returns The current value.
   */
  _getValue() {
    const e = this.editor.model.document.selection.getFirstPosition().parent;
    return e && e.is("element", "listItem") && e.getAttribute("listType") == "numbered" ? e.getAttribute("listReversed") : null;
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class sU extends Pt {
  /**
   * @inheritDoc
   */
  refresh() {
    const e = this._getValue();
    this.value = e, this.isEnabled = e != null;
  }
  /**
   * Executes the command.
   *
   * @fires execute
   * @param options.startIndex The list start index.
   */
  execute({ startIndex: e = 1 } = {}) {
    const t = this.editor.model, n = yh(t).filter((r) => r.getAttribute("listType") == "numbered");
    t.change((r) => {
      for (const s of n)
        r.setAttribute("listStart", e >= 0 ? e : 1, s);
    });
  }
  /**
   * Checks the command's {@link #value}.
   *
   * @returns The current value.
   */
  _getValue() {
    const e = this.editor.model.document.selection.getFirstPosition().parent;
    return e && e.is("element", "listItem") && e.getAttribute("listType") == "numbered" ? e.getAttribute("listStart") : null;
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const Gu = "default";
class oU extends fe {
  /**
   * @inheritDoc
   */
  static get requires() {
    return [IS];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "ListPropertiesEditing";
  }
  /**
   * @inheritDoc
   */
  constructor(e) {
    super(e), e.config.define("list", {
      properties: {
        styles: !0,
        startIndex: !1,
        reversed: !1
      }
    });
  }
  /**
   * @inheritDoc
   */
  init() {
    const e = this.editor, t = e.model, n = e.config.get("list.properties"), r = aU(n);
    t.schema.extend("listItem", {
      allowAttributes: r.map((s) => s.attributeName)
    });
    for (const s of r)
      s.addCommand(e);
    this.listenTo(e.commands.get("indentList"), "_executeCleanup", uU(e, r)), this.listenTo(e.commands.get("outdentList"), "_executeCleanup", dU(e, r)), this.listenTo(e.commands.get("bulletedList"), "_executeCleanup", O0(e)), this.listenTo(e.commands.get("numberedList"), "_executeCleanup", O0(e)), t.document.registerPostFixer(hU(e, r)), e.conversion.for("upcast").add(lU(r)), e.conversion.for("downcast").add(cU(r)), this._mergeListAttributesWhileMergingLists(r);
  }
  /**
   * @inheritDoc
   */
  afterInit() {
    const e = this.editor;
    e.commands.get("todoList") && e.model.document.registerPostFixer(gU(e));
  }
  /**
   * Starts listening to {@link module:engine/model/model~Model#deleteContent} and checks whether two lists will be merged into a single
   * one after deleting the content.
   *
   * The purpose of this action is to adjust the `listStyle`, `listReversed` and `listStart` values
   * for the list that was merged.
   *
   * Consider the following model's content:
   *
   * ```xml
   * <listItem listIndent="0" listType="bulleted" listStyle="square">UL List item 1</listItem>
   * <listItem listIndent="0" listType="bulleted" listStyle="square">UL List item 2</listItem>
   * <paragraph>[A paragraph.]</paragraph>
   * <listItem listIndent="0" listType="bulleted" listStyle="circle">UL List item 1</listItem>
   * <listItem listIndent="0" listType="bulleted" listStyle="circle">UL List item 2</listItem>
   * ```
   *
   * After removing the paragraph element, the second list will be merged into the first one.
   * We want to inherit the `listStyle` attribute for the second list from the first one.
   *
   * ```xml
   * <listItem listIndent="0" listType="bulleted" listStyle="square">UL List item 1</listItem>
   * <listItem listIndent="0" listType="bulleted" listStyle="square">UL List item 2</listItem>
   * <listItem listIndent="0" listType="bulleted" listStyle="square">UL List item 1</listItem>
   * <listItem listIndent="0" listType="bulleted" listStyle="square">UL List item 2</listItem>
   * ```
   *
   * See https://github.com/ckeditor/ckeditor5/issues/7879.
   *
   * @param attributeStrategies Strategies for the enabled attributes.
   */
  _mergeListAttributesWhileMergingLists(e) {
    const n = this.editor.model;
    let r;
    this.listenTo(n, "deleteContent", (s, [o]) => {
      const l = o.getFirstPosition(), u = o.getLastPosition();
      if (l.parent === u.parent || !l.parent.is("element", "listItem"))
        return;
      const h = u.parent.nextSibling;
      if (!h || !h.is("element", "listItem"))
        return;
      const f = Go(l.parent, {
        sameIndent: !0,
        listIndent: h.getAttribute("listIndent")
      });
      f && f.getAttribute("listType") === h.getAttribute("listType") && (r = f);
    }, { priority: "high" }), this.listenTo(n, "deleteContent", () => {
      r && (n.change((s) => {
        const o = Go(r.nextSibling, {
          sameIndent: !0,
          listIndent: r.getAttribute("listIndent"),
          direction: "forward"
        });
        if (!o) {
          r = null;
          return;
        }
        const l = [
          o,
          ...Md(s.createPositionAt(o, 0), "forward")
        ];
        for (const u of l)
          for (const h of e)
            if (h.appliesToListItem(u)) {
              const f = h.attributeName, m = r.getAttribute(f);
              s.setAttribute(f, m, u);
            }
      }), r = null);
    }, { priority: "low" });
  }
}
function aU(i) {
  const e = [];
  return i.styles && e.push({
    attributeName: "listStyle",
    defaultValue: Gu,
    addCommand(t) {
      t.commands.add("listStyle", new iU(t, Gu));
    },
    appliesToListItem() {
      return !0;
    },
    setAttributeOnDowncast(t, n, r) {
      n && n !== Gu ? t.setStyle("list-style-type", n, r) : t.removeStyle("list-style-type", r);
    },
    getAttributeOnUpcast(t) {
      return t.getStyle("list-style-type") || Gu;
    }
  }), i.reversed && e.push({
    attributeName: "listReversed",
    defaultValue: !1,
    addCommand(t) {
      t.commands.add("listReversed", new rU(t));
    },
    appliesToListItem(t) {
      return t.getAttribute("listType") == "numbered";
    },
    setAttributeOnDowncast(t, n, r) {
      n ? t.setAttribute("reversed", "reversed", r) : t.removeAttribute("reversed", r);
    },
    getAttributeOnUpcast(t) {
      return t.hasAttribute("reversed");
    }
  }), i.startIndex && e.push({
    attributeName: "listStart",
    defaultValue: 1,
    addCommand(t) {
      t.commands.add("listStart", new sU(t));
    },
    appliesToListItem(t) {
      return t.getAttribute("listType") == "numbered";
    },
    setAttributeOnDowncast(t, n, r) {
      n == 0 || n > 1 ? t.setAttribute("start", n, r) : t.removeAttribute("start", r);
    },
    getAttributeOnUpcast(t) {
      const n = t.getAttribute("start");
      return n >= 0 ? n : 1;
    }
  }), e;
}
function lU(i) {
  return (e) => {
    e.on("element:li", (t, n, r) => {
      if (!n.modelRange)
        return;
      const s = n.viewItem.parent, o = n.modelRange.start.nodeAfter || n.modelRange.end.nodeBefore;
      for (const l of i)
        if (l.appliesToListItem(o)) {
          const u = l.getAttributeOnUpcast(s);
          r.writer.setAttribute(l.attributeName, u, o);
        }
    }, { priority: "low" });
  };
}
function cU(i) {
  return (t) => {
    for (const n of i)
      t.on(`attribute:${n.attributeName}:listItem`, (r, s, o) => {
        const l = o.writer, u = s.item, h = Go(u.previousSibling, {
          sameIndent: !0,
          listIndent: u.getAttribute("listIndent"),
          direction: "backward"
        }), f = o.mapper.toViewElement(u);
        e(u, h) || l.breakContainer(l.createPositionBefore(f)), n.setAttributeOnDowncast(l, s.attributeNewValue, f.parent);
      }, { priority: "low" });
  };
  function e(t, n) {
    return n && t.getAttribute("listType") === n.getAttribute("listType") && t.getAttribute("listIndent") === n.getAttribute("listIndent") && t.getAttribute("listStyle") === n.getAttribute("listStyle") && t.getAttribute("listReversed") === n.getAttribute("listReversed") && t.getAttribute("listStart") === n.getAttribute("listStart");
  }
}
function uU(i, e) {
  return (t, n) => {
    const r = n[0], s = r.getAttribute("listIndent"), o = n.filter((u) => u.getAttribute("listIndent") === s);
    let l = null;
    r.previousSibling.getAttribute("listIndent") + 1 !== s && (l = Go(r.previousSibling, {
      sameIndent: !0,
      direction: "backward",
      listIndent: s
    })), i.model.change((u) => {
      for (const h of o)
        for (const f of e)
          if (f.appliesToListItem(h)) {
            const m = l == null ? f.defaultValue : l.getAttribute(f.attributeName);
            u.setAttribute(f.attributeName, m, h);
          }
    });
  };
}
function dU(i, e) {
  return (t, n) => {
    if (n = n.reverse().filter((l) => l.is("element", "listItem")), !n.length)
      return;
    const r = n[0].getAttribute("listIndent"), s = n[0].getAttribute("listType");
    let o = n[0].previousSibling;
    if (o.is("element", "listItem"))
      for (; o.getAttribute("listIndent") !== r; )
        o = o.previousSibling;
    else
      o = null;
    o || (o = n[n.length - 1].nextSibling), !(!o || !o.is("element", "listItem")) && o.getAttribute("listType") === s && i.model.change((l) => {
      const u = n.filter((h) => h.getAttribute("listIndent") === r);
      for (const h of u)
        for (const f of e)
          if (f.appliesToListItem(h)) {
            const m = f.attributeName, v = o.getAttribute(m);
            l.setAttribute(m, v, h);
          }
    });
  };
}
function hU(i, e) {
  return (t) => {
    let n = !1;
    const r = MS(i.model.document.differ.getChanges()).filter((o) => o.getAttribute("listType") !== "todo");
    if (!r.length)
      return n;
    let s = r[r.length - 1].nextSibling;
    if ((!s || !s.is("element", "listItem")) && (s = r[0].previousSibling, s)) {
      const o = r[0].getAttribute("listIndent");
      for (; s.is("element", "listItem") && s.getAttribute("listIndent") !== o && (s = s.previousSibling, !!s); )
        ;
    }
    for (const o of e) {
      const l = o.attributeName;
      for (const u of r) {
        if (!o.appliesToListItem(u)) {
          t.removeAttribute(l, u);
          continue;
        }
        if (!u.hasAttribute(l))
          fU(s, u, o) ? t.setAttribute(l, s.getAttribute(l), u) : t.setAttribute(l, o.defaultValue, u), n = !0;
        else {
          const h = u.previousSibling;
          mU(h, u, o.attributeName) && (t.setAttribute(l, h.getAttribute(l), u), n = !0);
        }
      }
    }
    return n;
  };
}
function fU(i, e, t) {
  if (!i)
    return !1;
  const n = i.getAttribute(t.attributeName);
  return !(!n || n == t.defaultValue || i.getAttribute("listType") !== e.getAttribute("listType"));
}
function mU(i, e, t) {
  if (!i || !i.is("element", "listItem") || e.getAttribute("listType") !== i.getAttribute("listType"))
    return !1;
  const n = i.getAttribute("listIndent");
  if (n < 1 || n !== e.getAttribute("listIndent"))
    return !1;
  const r = i.getAttribute(t);
  return !(!r || r === e.getAttribute(t));
}
function gU(i) {
  return (e) => {
    const t = MS(i.model.document.differ.getChanges()).filter((n) => n.getAttribute("listType") === "todo" && (n.hasAttribute("listStyle") || n.hasAttribute("listReversed") || n.hasAttribute("listStart")));
    if (!t.length)
      return !1;
    for (const n of t)
      e.removeAttribute("listStyle", n), e.removeAttribute("listReversed", n), e.removeAttribute("listStart", n);
    return !0;
  };
}
function O0(i) {
  return (e, t) => {
    t = t.filter((n) => n.is("element", "listItem")), i.model.change((n) => {
      for (const r of t)
        n.removeAttribute("listStyle", r);
    });
  };
}
function MS(i) {
  const e = [];
  for (const t of i) {
    const n = pU(t);
    n && n.is("element", "listItem") && e.push(n);
  }
  return e;
}
function pU(i) {
  return i.type === "attribute" ? i.range.start.nodeAfter : i.type === "insert" ? i.position.nodeAfter : null;
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class _U extends Xe {
  /**
   * Creates an instance of the collapsible view.
   *
   * @param locale The {@link module:core/editor/editor~Editor#locale} instance.
   * @param childViews An optional array of initial child views to be inserted into the collapsible.
   */
  constructor(e, t) {
    super(e);
    const n = this.bindTemplate;
    this.set("isCollapsed", !1), this.set("label", ""), this.buttonView = this._createButtonView(), this.children = this.createCollection(), this.set("_collapsibleAriaLabelUid", void 0), t && this.children.addMany(t), this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-collapsible",
          n.if("isCollapsed", "ck-collapsible_collapsed")
        ]
      },
      children: [
        this.buttonView,
        {
          tag: "div",
          attributes: {
            class: [
              "ck",
              "ck-collapsible__children"
            ],
            role: "region",
            hidden: n.if("isCollapsed", "hidden"),
            "aria-labelledby": n.to("_collapsibleAriaLabelUid")
          },
          children: this.children
        }
      ]
    });
  }
  /**
   * @inheritDoc
   */
  render() {
    super.render(), this._collapsibleAriaLabelUid = this.buttonView.labelView.element.id;
  }
  /**
   * Creates the main {@link #buttonView} of the collapsible.
   */
  _createButtonView() {
    const e = new At(this.locale), t = e.bindTemplate;
    return e.set({
      withText: !0,
      icon: yp
    }), e.extendTemplate({
      attributes: {
        "aria-expanded": t.to("isOn", (n) => String(n))
      }
    }), e.bind("label").to(this), e.bind("isOn").to(this, "isCollapsed", (n) => !n), e.on("execute", () => {
      this.isCollapsed = !this.isCollapsed;
    }), e;
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class vU extends Xe {
  /**
   * Creates an instance of the list properties view.
   *
   * @param locale The {@link module:core/editor/editor~Editor#locale} instance.
   * @param options Options of the view.
   * @param options.enabledProperties An object containing the configuration of enabled list property names.
   * Allows conditional rendering the sub-components of the properties view.
   * @param options.styleButtonViews A list of style buttons to be rendered
   * inside the styles grid. The grid will not be rendered when `enabledProperties` does not include the `'styles'` key.
   * @param options.styleGridAriaLabel An assistive technologies label set on the grid of styles (if the grid is rendered).
   */
  constructor(e, { enabledProperties: t, styleButtonViews: n, styleGridAriaLabel: r }) {
    super(e), this.stylesView = null, this.additionalPropertiesCollapsibleView = null, this.startIndexFieldView = null, this.reversedSwitchButtonView = null, this.focusTracker = new hi(), this.keystrokes = new cr(), this.focusables = new cs();
    const s = [
      "ck",
      "ck-list-properties"
    ];
    this.children = this.createCollection(), this.focusCycler = new ta({
      focusables: this.focusables,
      focusTracker: this.focusTracker,
      keystrokeHandler: this.keystrokes,
      actions: {
        // Navigate #children backwards using the <kbd>Shift</kbd> + <kbd>Tab</kbd> keystroke.
        focusPrevious: "shift + tab",
        // Navigate #children forwards using the <kbd>Tab</kbd> key.
        focusNext: "tab"
      }
    }), t.styles ? (this.stylesView = this._createStylesView(n, r), this.children.add(this.stylesView)) : s.push("ck-list-properties_without-styles"), (t.startIndex || t.reversed) && (this._addNumberedListPropertyViews(t), s.push("ck-list-properties_with-numbered-properties")), this.setTemplate({
      tag: "div",
      attributes: {
        class: s
      },
      children: this.children
    });
  }
  /**
   * @inheritDoc
   */
  render() {
    if (super.render(), this.stylesView) {
      this.focusables.add(this.stylesView), this.focusTracker.add(this.stylesView.element), (this.startIndexFieldView || this.reversedSwitchButtonView) && (this.focusables.add(this.children.last.buttonView), this.focusTracker.add(this.children.last.buttonView.element));
      for (const e of this.stylesView.children)
        this.stylesView.focusTracker.add(e.element);
      s9({
        keystrokeHandler: this.stylesView.keystrokes,
        focusTracker: this.stylesView.focusTracker,
        gridItems: this.stylesView.children,
        // Note: The styles view has a different number of columns depending on whether the other properties
        // are enabled in the dropdown or not (https://github.com/ckeditor/ckeditor5/issues/12340)
        numberOfColumns: () => Ke.window.getComputedStyle(this.stylesView.element).getPropertyValue("grid-template-columns").split(" ").length,
        uiLanguageDirection: this.locale && this.locale.uiLanguageDirection
      });
    }
    if (this.startIndexFieldView) {
      this.focusables.add(this.startIndexFieldView), this.focusTracker.add(this.startIndexFieldView.element), this.listenTo(this.startIndexFieldView.element, "selectstart", (t, n) => {
        n.stopPropagation();
      }, { priority: "high" });
      const e = (t) => t.stopPropagation();
      this.keystrokes.set("arrowright", e), this.keystrokes.set("arrowleft", e), this.keystrokes.set("arrowup", e), this.keystrokes.set("arrowdown", e);
    }
    this.reversedSwitchButtonView && (this.focusables.add(this.reversedSwitchButtonView), this.focusTracker.add(this.reversedSwitchButtonView.element)), this.keystrokes.listenTo(this.element);
  }
  /**
   * @inheritDoc
   */
  focus() {
    this.focusCycler.focusFirst();
  }
  /**
   * @inheritDoc
   */
  focusLast() {
    this.focusCycler.focusLast();
  }
  /**
   * @inheritDoc
   */
  destroy() {
    super.destroy(), this.focusTracker.destroy(), this.keystrokes.destroy();
  }
  /**
   * Creates the list styles grid.
   *
   * @param styleButtons Buttons to be placed in the grid.
   * @param styleGridAriaLabel The assistive technology label of the grid.
   */
  _createStylesView(e, t) {
    const n = new Xe(this.locale);
    return n.children = n.createCollection(), n.children.addMany(e), n.setTemplate({
      tag: "div",
      attributes: {
        "aria-label": t,
        class: [
          "ck",
          "ck-list-styles-list"
        ]
      },
      children: n.children
    }), n.children.delegate("execute").to(this), n.focus = function() {
      this.children.first.focus();
    }, n.focusTracker = new hi(), n.keystrokes = new cr(), n.render(), n.keystrokes.listenTo(n.element), n;
  }
  /**
   * Renders {@link #startIndexFieldView} and/or {@link #reversedSwitchButtonView} depending on the configuration of the properties view.
   *
   * @param enabledProperties An object containing the configuration of enabled list property names
   * (see {@link #constructor}).
   */
  _addNumberedListPropertyViews(e) {
    const t = this.locale.t, n = [];
    e.startIndex && (this.startIndexFieldView = this._createStartIndexField(), n.push(this.startIndexFieldView)), e.reversed && (this.reversedSwitchButtonView = this._createReversedSwitchButton(), n.push(this.reversedSwitchButtonView)), e.styles ? (this.additionalPropertiesCollapsibleView = new _U(this.locale, n), this.additionalPropertiesCollapsibleView.set({
      label: t("List properties"),
      isCollapsed: !0
    }), this.additionalPropertiesCollapsibleView.buttonView.bind("isEnabled").toMany(n, "isEnabled", (...r) => r.some((s) => s)), this.additionalPropertiesCollapsibleView.buttonView.on("change:isEnabled", (r, s, o) => {
      o || (this.additionalPropertiesCollapsibleView.isCollapsed = !0);
    }), this.children.add(this.additionalPropertiesCollapsibleView)) : this.children.addMany(n);
  }
  /**
   * Creates the list start index labeled field.
   */
  _createStartIndexField() {
    const e = this.locale.t, t = new Sp(this.locale, z9);
    return t.set({
      label: e("Start at"),
      class: "ck-numbered-list-properties__start-index"
    }), t.fieldView.set({
      min: 0,
      step: 1,
      value: 1,
      inputMode: "numeric"
    }), t.fieldView.on("input", () => {
      const n = t.fieldView.element, r = n.valueAsNumber;
      Number.isNaN(r) || (n.checkValidity() ? this.fire("listStart", { startIndex: r }) : t.errorText = e("Start index must be greater than 0."));
    }), t;
  }
  /**
   * Creates the reversed list switch button.
   */
  _createReversedSwitchButton() {
    const e = this.locale.t, t = new hh(this.locale);
    return t.set({
      withText: !0,
      label: e("Reversed order"),
      class: "ck-numbered-list-properties__reversed-order"
    }), t.delegate("execute").to(this, "listReversed"), t;
  }
}
const wU = '<svg viewBox="0 0 44 44" xmlns="http://www.w3.org/2000/svg"><path d="M35 29a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17z" fill-opacity=".163"/><path d="M11 27a3 3 0 1 1 0 6 3 3 0 0 1 0-6zm0-9a3 3 0 1 1 0 6 3 3 0 0 1 0-6zm0-9a3 3 0 1 1 0 6 3 3 0 0 1 0-6z"/></svg>', bU = '<svg viewBox="0 0 44 44" xmlns="http://www.w3.org/2000/svg"><path d="M35 29a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17z" fill-opacity=".163"/><path d="M11 27a3 3 0 1 1 0 6 3 3 0 0 1 0-6zm0 1a2 2 0 1 0 0 4 2 2 0 0 0 0-4zm0-10a3 3 0 1 1 0 6 3 3 0 0 1 0-6zm0 1a2 2 0 1 0 0 4 2 2 0 0 0 0-4zm0-10a3 3 0 1 1 0 6 3 3 0 0 1 0-6zm0 1a2 2 0 1 0 0 4 2 2 0 0 0 0-4z"/></svg>', yU = '<svg viewBox="0 0 44 44" xmlns="http://www.w3.org/2000/svg"><path d="M35 29a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17z" fill-opacity=".163"/><path d="M14 27v6H8v-6h6zm0-9v6H8v-6h6zm0-9v6H8V9h6z"/></svg>', EU = '<svg viewBox="0 0 44 44" xmlns="http://www.w3.org/2000/svg"><path d="M35 29a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17z" fill-opacity=".163"/><path d="M10.29 15V8.531H9.286c-.14.393-.4.736-.778 1.03-.378.295-.728.495-1.05.6v1.121a4.257 4.257 0 0 0 1.595-.936V15h1.235zm3.343 0v-1.235h-1.235V15h1.235zM11.3 24v-1.147H8.848c.064-.111.148-.226.252-.343.104-.117.351-.354.74-.712.39-.357.66-.631.81-.821.225-.288.39-.562.494-.824.104-.263.156-.539.156-.829 0-.51-.182-.936-.545-1.279-.363-.342-.863-.514-1.499-.514-.58 0-1.063.148-1.45.444-.387.296-.617.784-.69 1.463l1.23.124c.024-.36.112-.619.264-.774.153-.155.358-.233.616-.233.26 0 .465.074.613.222.148.148.222.36.222.635 0 .25-.085.501-.255.756-.126.185-.468.536-1.024 1.055-.692.641-1.155 1.156-1.389 1.544-.234.389-.375.8-.422 1.233H11.3zm2.333 0v-1.235h-1.235V24h1.235zM9.204 34.11c.615 0 1.129-.2 1.542-.598.413-.398.62-.88.62-1.446 0-.39-.11-.722-.332-.997a1.5 1.5 0 0 0-.886-.532c.619-.337.928-.788.928-1.353 0-.399-.151-.756-.453-1.073-.366-.386-.852-.58-1.459-.58a2.25 2.25 0 0 0-.96.2 1.617 1.617 0 0 0-.668.55c-.16.232-.28.544-.358.933l1.138.194c.032-.282.123-.495.272-.642.15-.146.33-.22.54-.22.215 0 .386.065.515.194s.193.302.193.518c0 .255-.087.46-.263.613-.176.154-.43.227-.765.218l-.136 1.006c.22-.061.409-.092.567-.092.24 0 .444.09.61.272.168.182.251.428.251.739 0 .328-.087.589-.261.782a.833.833 0 0 1-.644.29.841.841 0 0 1-.607-.242c-.167-.16-.27-.394-.307-.698l-1.196.145c.062.542.285.98.668 1.316.384.335.868.503 1.45.503zm4.43-.11v-1.235h-1.236V34h1.235z"/></svg>', CU = '<svg viewBox="0 0 44 44" xmlns="http://www.w3.org/2000/svg"><path d="M35 29a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17z" fill-opacity=".163"/><path d="M5.714 15.11c.624 0 1.11-.22 1.46-.66.421-.533.632-1.408.632-2.627 0-1.222-.21-2.096-.629-2.624-.351-.445-.839-.668-1.463-.668-.624 0-1.11.22-1.459.66-.422.533-.633 1.406-.633 2.619 0 1.236.192 2.095.576 2.577.384.482.89.723 1.516.723zm0-1.024a.614.614 0 0 1-.398-.14c-.115-.094-.211-.283-.287-.565-.077-.283-.115-.802-.115-1.558s.043-1.294.128-1.613c.064-.246.155-.417.272-.512a.617.617 0 0 1 .4-.143.61.61 0 0 1 .398.143c.116.095.211.284.288.567.076.283.114.802.114 1.558s-.043 1.292-.128 1.608c-.064.246-.155.417-.272.512a.617.617 0 0 1-.4.143zm6.078.914V8.531H10.79c-.14.393-.4.736-.778 1.03-.378.295-.728.495-1.05.6v1.121a4.257 4.257 0 0 0 1.595-.936V15h1.235zm3.344 0v-1.235h-1.235V15h1.235zm-9.422 9.11c.624 0 1.11-.22 1.46-.66.421-.533.632-1.408.632-2.627 0-1.222-.21-2.096-.629-2.624-.351-.445-.839-.668-1.463-.668-.624 0-1.11.22-1.459.66-.422.533-.633 1.406-.633 2.619 0 1.236.192 2.095.576 2.577.384.482.89.723 1.516.723zm0-1.024a.614.614 0 0 1-.398-.14c-.115-.094-.211-.283-.287-.565-.077-.283-.115-.802-.115-1.558s.043-1.294.128-1.613c.064-.246.155-.417.272-.512a.617.617 0 0 1 .4-.143.61.61 0 0 1 .398.143c.116.095.211.284.288.567.076.283.114.802.114 1.558s-.043 1.292-.128 1.608c-.064.246-.155.417-.272.512a.617.617 0 0 1-.4.143zm7.088.914v-1.147H10.35c.065-.111.149-.226.253-.343.104-.117.35-.354.74-.712.39-.357.66-.631.81-.821.225-.288.39-.562.493-.824.104-.263.156-.539.156-.829 0-.51-.181-.936-.544-1.279-.364-.342-.863-.514-1.499-.514-.58 0-1.063.148-1.45.444-.387.296-.617.784-.69 1.463l1.23.124c.024-.36.112-.619.264-.774.152-.155.357-.233.615-.233.261 0 .465.074.613.222.148.148.222.36.222.635 0 .25-.085.501-.255.756-.126.185-.467.536-1.024 1.055-.691.641-1.154 1.156-1.388 1.544-.235.389-.375.8-.422 1.233h4.328zm2.334 0v-1.235h-1.235V24h1.235zM5.714 34.11c.624 0 1.11-.22 1.46-.66.421-.533.632-1.408.632-2.627 0-1.222-.21-2.096-.629-2.624-.351-.445-.839-.668-1.463-.668-.624 0-1.11.22-1.459.66-.422.533-.633 1.406-.633 2.619 0 1.236.192 2.095.576 2.577.384.482.89.723 1.516.723zm0-1.024a.614.614 0 0 1-.398-.14c-.115-.094-.211-.283-.287-.565-.077-.283-.115-.802-.115-1.558s.043-1.294.128-1.613c.064-.246.155-.417.272-.512a.617.617 0 0 1 .4-.143.61.61 0 0 1 .398.143c.116.095.211.284.288.567.076.283.114.802.114 1.558s-.043 1.292-.128 1.608c-.064.246-.155.417-.272.512a.617.617 0 0 1-.4.143zm4.992 1.024c.616 0 1.13-.2 1.543-.598.413-.398.62-.88.62-1.446 0-.39-.111-.722-.332-.997a1.5 1.5 0 0 0-.886-.532c.618-.337.927-.788.927-1.353 0-.399-.15-.756-.452-1.073-.366-.386-.853-.58-1.46-.58a2.25 2.25 0 0 0-.96.2 1.617 1.617 0 0 0-.667.55c-.16.232-.28.544-.359.933l1.139.194c.032-.282.123-.495.272-.642.15-.146.33-.22.54-.22.214 0 .386.065.515.194s.193.302.193.518c0 .255-.088.46-.264.613-.175.154-.43.227-.764.218l-.136 1.006c.22-.061.408-.092.566-.092.24 0 .444.09.611.272.167.182.25.428.25.739 0 .328-.086.589-.26.782a.833.833 0 0 1-.644.29.841.841 0 0 1-.607-.242c-.167-.16-.27-.394-.308-.698l-1.195.145c.062.542.284.98.668 1.316.384.335.867.503 1.45.503zm4.43-.11v-1.235h-1.235V34h1.235z"/></svg>', SU = '<svg viewBox="0 0 44 44" xmlns="http://www.w3.org/2000/svg"><path d="M35 29a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17z" fill-opacity=".163"/><path d="M11.88 8.7V7.558h-1.234V8.7h1.234zm0 5.3V9.333h-1.234V14h1.234zm2.5 0v-1.235h-1.234V14h1.235zm-4.75 4.7v-1.142H8.395V18.7H9.63zm0 5.3v-4.667H8.395V24H9.63zm2.5-5.3v-1.142h-1.234V18.7h1.235zm0 5.3v-4.667h-1.234V24h1.235zm2.501 0v-1.235h-1.235V24h1.235zM7.38 28.7v-1.142H6.145V28.7H7.38zm0 5.3v-4.667H6.145V34H7.38zm2.5-5.3v-1.142H8.646V28.7H9.88zm0 5.3v-4.667H8.646V34H9.88zm2.5-5.3v-1.142h-1.234V28.7h1.235zm0 5.3v-4.667h-1.234V34h1.235zm2.501 0v-1.235h-1.235V34h1.235z"/></svg>', TU = '<svg viewBox="0 0 44 44" xmlns="http://www.w3.org/2000/svg"><path d="M35 29a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17z" fill-opacity=".163"/><path d="M11.916 15V8.558h-1.301V15h1.3zm2.465 0v-1.235h-1.235V15h1.235zM9.665 25v-6.442h-1.3V25h1.3zm2.5 0v-6.442h-1.3V25h1.3zm2.466 0v-1.235h-1.235V25h1.235zm-7.216 9v-6.442h-1.3V34h1.3zm2.5 0v-6.442h-1.3V34h1.3zm2.501 0v-6.442h-1.3V34h1.3zm2.465 0v-1.235h-1.235V34h1.235z"/></svg>', xU = '<svg viewBox="0 0 44 44" xmlns="http://www.w3.org/2000/svg"><path d="M35 29a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17z" fill-opacity=".163"/><path d="M9.62 14.105c.272 0 .528-.05.768-.153s.466-.257.677-.462c.009.024.023.072.044.145.047.161.086.283.119.365h1.221a2.649 2.649 0 0 1-.222-.626c-.04-.195-.059-.498-.059-.908l.013-1.441c0-.536-.055-.905-.165-1.105-.11-.201-.3-.367-.569-.497-.27-.13-.68-.195-1.23-.195-.607 0-1.064.108-1.371.325-.308.217-.525.55-.65 1.002l1.12.202c.076-.217.176-.369.299-.455.123-.086.294-.13.514-.13.325 0 .546.05.663.152.118.101.176.27.176.508v.123c-.222.093-.622.194-1.2.303-.427.082-.755.178-.982.288-.227.11-.403.268-.53.474a1.327 1.327 0 0 0-.188.706c0 .398.138.728.415.988.277.261.656.391 1.136.391zm.368-.87a.675.675 0 0 1-.492-.189.606.606 0 0 1-.193-.448c0-.176.08-.32.241-.435.106-.07.33-.142.673-.215a7.19 7.19 0 0 0 .751-.19v.247c0 .296-.016.496-.048.602a.773.773 0 0 1-.295.409 1.07 1.07 0 0 1-.637.22zm4.645.765v-1.235h-1.235V14h1.235zM10.2 25.105c.542 0 1.003-.215 1.382-.646.38-.43.57-1.044.57-1.84 0-.771-.187-1.362-.559-1.774a1.82 1.82 0 0 0-1.41-.617c-.522 0-.973.216-1.354.65v-2.32H7.594V25h1.147v-.686a1.9 1.9 0 0 0 .67.592c.26.133.523.2.79.2zm-.299-.975c-.354 0-.638-.164-.852-.492-.153-.232-.229-.59-.229-1.073 0-.468.098-.818.295-1.048a.93.93 0 0 1 .738-.345c.302 0 .55.118.743.354.193.236.29.62.29 1.154 0 .5-.096.868-.288 1.1-.192.233-.424.35-.697.35zm4.478.87v-1.235h-1.234V25h1.234zm-4.017 9.105c.6 0 1.08-.142 1.437-.426.357-.284.599-.704.725-1.261l-1.213-.207c-.061.326-.167.555-.316.688a.832.832 0 0 1-.576.2.916.916 0 0 1-.75-.343c-.185-.228-.278-.62-.278-1.173 0-.498.091-.853.274-1.066.183-.212.429-.318.736-.318.232 0 .42.061.565.184.145.123.238.306.28.55l1.216-.22c-.146-.501-.387-.874-.722-1.119-.336-.244-.788-.366-1.356-.366-.695 0-1.245.214-1.653.643-.407.43-.61 1.03-.61 1.8 0 .762.202 1.358.608 1.788.406.431.95.646 1.633.646zM14.633 34v-1.235h-1.235V34h1.235z"/></svg>', kU = '<svg viewBox="0 0 44 44" xmlns="http://www.w3.org/2000/svg"><path d="M35 29a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17z" fill-opacity=".163"/><path d="m7.88 15 .532-1.463h2.575L11.549 15h1.415l-2.58-6.442H9.01L6.5 15h1.38zm2.69-2.549H8.811l.87-2.39.887 2.39zM14.88 15v-1.235h-1.234V15h1.234zM9.352 25c.83-.006 1.352-.02 1.569-.044.346-.038.636-.14.872-.305.236-.166.422-.387.558-.664.137-.277.205-.562.205-.855 0-.372-.106-.695-.317-.97-.21-.276-.512-.471-.905-.585a1.51 1.51 0 0 0 .661-.567 1.5 1.5 0 0 0 .244-.83c0-.28-.066-.53-.197-.754a1.654 1.654 0 0 0-.495-.539 1.676 1.676 0 0 0-.672-.266c-.25-.042-.63-.063-1.14-.063H7.158V25h2.193zm.142-3.88H8.46v-1.49h.747c.612 0 .983.007 1.112.022.217.026.38.102.49.226.11.125.165.287.165.486a.68.68 0 0 1-.192.503.86.86 0 0 1-.525.23 11.47 11.47 0 0 1-.944.023h.18zm.17 2.795H8.46v-1.723h1.05c.592 0 .977.03 1.154.092.177.062.313.16.406.295a.84.84 0 0 1 .14.492c0 .228-.06.41-.181.547a.806.806 0 0 1-.473.257c-.126.026-.423.04-.892.04zM14.88 25v-1.235h-1.234V25h1.234zm-5.018 9.11c.691 0 1.262-.17 1.711-.512.45-.341.772-.864.965-1.567l-1.261-.4c-.109.472-.287.818-.536 1.037-.25.22-.547.33-.892.33-.47 0-.85-.173-1.143-.519-.293-.345-.44-.925-.44-1.74 0-.767.15-1.322.447-1.665.297-.343.684-.514 1.162-.514.346 0 .64.096.881.29.242.193.4.457.477.79l1.288-.307c-.147-.516-.367-.911-.66-1.187-.492-.465-1.132-.698-1.92-.698-.902 0-1.63.296-2.184.89-.554.593-.83 1.426-.83 2.498 0 1.014.275 1.813.825 2.397.551.585 1.254.877 2.11.877zM14.88 34v-1.235h-1.234V34h1.234z"/></svg>';
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class AU extends fe {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "ListPropertiesUI";
  }
  init() {
    const e = this.editor, t = e.locale.t, n = e.config.get("list.properties");
    n.styles && e.ui.componentFactory.add("bulletedList", M0({
      editor: e,
      parentCommandName: "bulletedList",
      buttonLabel: t("Bulleted List"),
      buttonIcon: OS,
      styleGridAriaLabel: t("Bulleted list styles toolbar"),
      styleDefinitions: [
        {
          label: t("Toggle the disc list style"),
          tooltip: t("Disc"),
          type: "disc",
          icon: wU
        },
        {
          label: t("Toggle the circle list style"),
          tooltip: t("Circle"),
          type: "circle",
          icon: bU
        },
        {
          label: t("Toggle the square list style"),
          tooltip: t("Square"),
          type: "square",
          icon: yU
        }
      ]
    })), (n.styles || n.startIndex || n.reversed) && e.ui.componentFactory.add("numberedList", M0({
      editor: e,
      parentCommandName: "numberedList",
      buttonLabel: t("Numbered List"),
      buttonIcon: RS,
      styleGridAriaLabel: t("Numbered list styles toolbar"),
      styleDefinitions: [
        {
          label: t("Toggle the decimal list style"),
          tooltip: t("Decimal"),
          type: "decimal",
          icon: EU
        },
        {
          label: t("Toggle the decimal with leading zero list style"),
          tooltip: t("Decimal with leading zero"),
          type: "decimal-leading-zero",
          icon: CU
        },
        {
          label: t("Toggle the lower–roman list style"),
          tooltip: t("Lower–roman"),
          type: "lower-roman",
          icon: SU
        },
        {
          label: t("Toggle the upper–roman list style"),
          tooltip: t("Upper-roman"),
          type: "upper-roman",
          icon: TU
        },
        {
          label: t("Toggle the lower–latin list style"),
          tooltip: t("Lower-latin"),
          type: "lower-latin",
          icon: xU
        },
        {
          label: t("Toggle the upper–latin list style"),
          tooltip: t("Upper-latin"),
          type: "upper-latin",
          icon: kU
        }
      ]
    }));
  }
}
function M0({ editor: i, parentCommandName: e, buttonLabel: t, buttonIcon: n, styleGridAriaLabel: r, styleDefinitions: s }) {
  const o = i.commands.get(e);
  return (l) => {
    const u = Gs(l, fh), h = u.buttonView;
    return u.bind("isEnabled").to(o), u.class = "ck-list-styles-dropdown", h.on("execute", () => {
      i.execute(e), i.editing.view.focus();
    }), h.set({
      label: t,
      icon: n,
      tooltip: !0,
      isToggleable: !0
    }), h.bind("isOn").to(o, "value", (f) => !!f), u.once("change:isOpen", () => {
      const f = IU({
        editor: i,
        dropdownView: u,
        parentCommandName: e,
        styleGridAriaLabel: r,
        styleDefinitions: s
      });
      u.panelView.children.add(f);
    }), u.on("execute", () => {
      i.editing.view.focus();
    }), u;
  };
}
function PU({ editor: i, listStyleCommand: e, parentCommandName: t }) {
  const n = i.locale, r = i.commands.get(t);
  return ({ label: s, type: o, icon: l, tooltip: u }) => {
    const h = new At(n);
    return h.set({ label: s, icon: l, tooltip: u }), e.on("change:value", () => {
      h.isOn = e.value === o;
    }), h.on("execute", () => {
      r.value ? e.value !== o ? i.execute("listStyle", { type: o }) : i.execute("listStyle", { type: e.defaultType }) : i.model.change(() => {
        i.execute("listStyle", { type: o });
      });
    }), h;
  };
}
function IU({ editor: i, dropdownView: e, parentCommandName: t, styleDefinitions: n, styleGridAriaLabel: r }) {
  const s = i.locale, o = i.config.get("list.properties");
  let l = null;
  if (t != "numberedList" && (o.startIndex = !1, o.reversed = !1), o.styles) {
    const h = i.commands.get("listStyle"), f = PU({
      editor: i,
      parentCommandName: t,
      listStyleCommand: h
    }), m = typeof h.isStyleTypeSupported == "function" ? (v) => h.isStyleTypeSupported(v.type) : () => !0;
    l = n.filter(m).map(f);
  }
  const u = new vU(s, {
    styleGridAriaLabel: r,
    enabledProperties: o,
    styleButtonViews: l
  });
  if (o.styles && Ep(e, () => u.stylesView.children.find((h) => h.isOn)), o.startIndex) {
    const h = i.commands.get("listStart");
    u.startIndexFieldView.bind("isEnabled").to(h), u.startIndexFieldView.fieldView.bind("value").to(h), u.on("listStart", (f, m) => i.execute("listStart", m));
  }
  if (o.reversed) {
    const h = i.commands.get("listReversed");
    u.reversedSwitchButtonView.bind("isEnabled").to(h), u.reversedSwitchButtonView.bind("isOn").to(h, "value", (f) => !!f), u.on("listReversed", () => {
      const f = h.value;
      i.execute("listReversed", { reversed: !f });
    });
  }
  return u.delegate("execute").to(e), u;
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class RU extends fe {
  /**
   * @inheritDoc
   */
  static get requires() {
    return [oU, AU];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "ListProperties";
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class OU extends Pt {
  /**
   * @inheritDoc
   */
  refresh() {
    const e = this.editor.model, t = e.document, n = Rn(t.selection.getSelectedBlocks());
    this.value = !!n && n.is("element", "paragraph"), this.isEnabled = !!n && N0(n, e.schema);
  }
  /**
   * Executes the command. All the blocks (see {@link module:engine/model/schema~Schema}) in the selection
   * will be turned to paragraphs.
   *
   * @fires execute
   * @param options Options for the executed command.
   * @param options.selection The selection that the command should be applied to. By default,
   * if not provided, the command is applied to the {@link module:engine/model/document~Document#selection}.
   */
  execute(e = {}) {
    const t = this.editor.model, n = t.document;
    t.change((r) => {
      const s = (e.selection || n.selection).getSelectedBlocks();
      for (const o of s)
        !o.is("element", "paragraph") && N0(o, t.schema) && r.rename(o, "paragraph");
    });
  }
}
function N0(i, e) {
  return e.checkChild(i.parent, "paragraph") && !e.isObject(i);
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class MU extends Pt {
  /**
   * Executes the command.
   *
   * @param options Options for the executed command.
   * @param options.position The model position at which the new paragraph will be inserted.
   * @param options.attributes Attributes keys and values to set on a inserted paragraph.
   * @fires execute
   */
  execute(e) {
    const t = this.editor.model, n = e.attributes;
    let r = e.position;
    t.change((s) => {
      const o = s.createElement("paragraph");
      if (n && t.schema.setAllowedAttributes(o, n, s), !t.schema.checkChild(r.parent, o)) {
        const l = t.schema.findAllowedParent(r, o);
        if (!l)
          return;
        r = s.split(r, l).position;
      }
      t.insertContent(o, r), s.setSelection(o, "in");
    });
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class Eh extends fe {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "Paragraph";
  }
  /**
   * @inheritDoc
   */
  init() {
    const e = this.editor, t = e.model;
    e.commands.add("paragraph", new OU(e)), e.commands.add("insertParagraph", new MU(e)), t.schema.register("paragraph", { inheritAllFrom: "$block" }), e.conversion.elementToElement({ model: "paragraph", view: "p" }), e.conversion.for("upcast").elementToElement({
      model: (n, { writer: r }) => !Eh.paragraphLikeElements.has(n.name) || n.isEmpty ? null : r.createElement("paragraph"),
      view: /.+/,
      converterPriority: "low"
    });
  }
}
Eh.paragraphLikeElements = /* @__PURE__ */ new Set([
  "blockquote",
  "dd",
  "div",
  "dt",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "li",
  "p",
  "td",
  "th"
]);
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const el = "subscript";
class NU extends fe {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "SubscriptEditing";
  }
  /**
   * @inheritDoc
   */
  init() {
    const e = this.editor;
    e.model.schema.extend("$text", { allowAttributes: el }), e.model.schema.setAttributeProperties(el, {
      isFormatting: !0,
      copyOnEnter: !0
    }), e.conversion.attributeToElement({
      model: el,
      view: "sub",
      upcastAlso: [
        {
          styles: {
            "vertical-align": "sub"
          }
        }
      ]
    }), e.commands.add(el, new ra(e, el));
  }
}
const DU = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m7.03 10.349 3.818-3.819a.8.8 0 1 1 1.132 1.132L8.16 11.48l3.819 3.818a.8.8 0 1 1-1.132 1.132L7.03 12.61l-3.818 3.82a.8.8 0 1 1-1.132-1.132L5.9 11.48 2.08 7.662A.8.8 0 1 1 3.212 6.53l3.818 3.82zm8.147 7.829h2.549c.254 0 .447.05.58.152a.49.49 0 0 1 .201.413.54.54 0 0 1-.159.393c-.105.108-.266.162-.48.162h-3.594c-.245 0-.435-.066-.572-.197a.621.621 0 0 1-.205-.463c0-.114.044-.265.132-.453a1.62 1.62 0 0 1 .288-.444c.433-.436.824-.81 1.172-1.122.348-.312.597-.517.747-.615.267-.183.49-.368.667-.553.177-.185.312-.375.405-.57.093-.194.139-.384.139-.57a1.008 1.008 0 0 0-.554-.917 1.197 1.197 0 0 0-.56-.133c-.426 0-.761.182-1.005.546a2.332 2.332 0 0 0-.164.39 1.609 1.609 0 0 1-.258.488c-.096.114-.237.17-.423.17a.558.558 0 0 1-.405-.156.568.568 0 0 1-.161-.427c0-.218.05-.446.151-.683.101-.238.252-.453.452-.646s.454-.349.762-.467a2.998 2.998 0 0 1 1.081-.178c.498 0 .923.076 1.274.228a1.916 1.916 0 0 1 1.004 1.032 1.984 1.984 0 0 1-.156 1.794c-.2.32-.405.572-.613.754-.208.182-.558.468-1.048.857-.49.39-.826.691-1.008.906a2.703 2.703 0 0 0-.24.309z"/></svg>';
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const jm = "subscript";
class BU extends fe {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "SubscriptUI";
  }
  /**
   * @inheritDoc
   */
  init() {
    const e = this.editor, t = e.t;
    e.ui.componentFactory.add(jm, (n) => {
      const r = e.commands.get(jm), s = new At(n);
      return s.set({
        label: t("Subscript"),
        icon: DU,
        tooltip: !0,
        isToggleable: !0
      }), s.bind("isOn", "isEnabled").to(r, "value", "isEnabled"), this.listenTo(s, "execute", () => {
        e.execute(jm), e.editing.view.focus();
      }), s;
    });
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class VU extends fe {
  /**
   * @inheritDoc
   */
  static get requires() {
    return [NU, BU];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "Subscript";
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const tl = "superscript";
class LU extends fe {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "SuperscriptEditing";
  }
  /**
   * @inheritDoc
   */
  init() {
    const e = this.editor;
    e.model.schema.extend("$text", { allowAttributes: tl }), e.model.schema.setAttributeProperties(tl, {
      isFormatting: !0,
      copyOnEnter: !0
    }), e.conversion.attributeToElement({
      model: tl,
      view: "sup",
      upcastAlso: [
        {
          styles: {
            "vertical-align": "super"
          }
        }
      ]
    }), e.commands.add(tl, new ra(e, tl));
  }
}
const FU = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M15.677 8.678h2.549c.254 0 .447.05.58.152a.49.49 0 0 1 .201.413.54.54 0 0 1-.159.393c-.105.108-.266.162-.48.162h-3.594c-.245 0-.435-.066-.572-.197a.621.621 0 0 1-.205-.463c0-.114.044-.265.132-.453a1.62 1.62 0 0 1 .288-.444c.433-.436.824-.81 1.172-1.122.348-.312.597-.517.747-.615.267-.183.49-.368.667-.553.177-.185.312-.375.405-.57.093-.194.139-.384.139-.57a1.008 1.008 0 0 0-.554-.917 1.197 1.197 0 0 0-.56-.133c-.426 0-.761.182-1.005.546a2.332 2.332 0 0 0-.164.39 1.609 1.609 0 0 1-.258.488c-.096.114-.237.17-.423.17a.558.558 0 0 1-.405-.156.568.568 0 0 1-.161-.427c0-.218.05-.446.151-.683.101-.238.252-.453.452-.646s.454-.349.762-.467a2.998 2.998 0 0 1 1.081-.178c.498 0 .923.076 1.274.228a1.916 1.916 0 0 1 1.004 1.032 1.984 1.984 0 0 1-.156 1.794c-.2.32-.405.572-.613.754-.208.182-.558.468-1.048.857-.49.39-.826.691-1.008.906a2.703 2.703 0 0 0-.24.309zM7.03 10.349l3.818-3.819a.8.8 0 1 1 1.132 1.132L8.16 11.48l3.819 3.818a.8.8 0 1 1-1.132 1.132L7.03 12.61l-3.818 3.82a.8.8 0 1 1-1.132-1.132L5.9 11.48 2.08 7.662A.8.8 0 1 1 3.212 6.53l3.818 3.82z"/></svg>';
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const Um = "superscript";
class $U extends fe {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "SuperscriptUI";
  }
  /**
   * @inheritDoc
   */
  init() {
    const e = this.editor, t = e.t;
    e.ui.componentFactory.add(Um, (n) => {
      const r = e.commands.get(Um), s = new At(n);
      return s.set({
        label: t("Superscript"),
        icon: FU,
        tooltip: !0,
        isToggleable: !0
      }), s.bind("isOn", "isEnabled").to(r, "value", "isEnabled"), this.listenTo(s, "execute", () => {
        e.execute(Um), e.editing.view.focus();
      }), s;
    });
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class zU extends fe {
  /**
   * @inheritDoc
   */
  static get requires() {
    return [LU, $U];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "Superscript";
  }
}
const Hl = [
  kz,
  iW,
  aW,
  Eh,
  dW,
  gW,
  RW,
  eW,
  //   TextTransformation,
  VU,
  zU,
  //   CKFinder,
  //   CKFinderUploadAdapter,
  //   CloudServices,
  //   GeneralHtmlSupport,
  Vz,
  //   FontSize,
  //   FontFamily,
  //   FontColor,
  //   FontBackgroundColor,
  //   Autoformat,
  //   BlockQuote,
  //   Heading,
  MW,
  VW,
  jW,
  tj,
  nj,
  //   ImageUpload,
  //   Indent,
  //   IndentBlock,
  Nj,
  nU,
  RU
  //   MediaEmbed,
  //   PasteFromOffice,
  //   PictureEditing,
  // Table,
  // TableToolbar,
], ql = {
  toolbar: {
    items: [
      // 'heading',
      // '|',
      // 'fontfamily',
      // 'fontsize',
      // 'fontColor',
      // 'fontBackgroundColor',
      "|",
      "bold",
      "italic",
      // 'paragraph',
      "underline",
      "strikethrough",
      "|",
      "subscript",
      "superscript",
      "|",
      "alignment",
      "|",
      "numberedList",
      "bulletedList",
      "|",
      "codeBlock",
      // 'outdent',
      // 'indent',
      "|",
      "link",
      // 'blockquote',
      // 'insertTable',
      // 'mediaEmbed',
      "|",
      "undo",
      "redo",
      "|",
      "selectAll"
    ]
  },
  // image: {
  //   resizeUnit: 'px',
  //   toolbar: [
  //     'imageStyle:inline',
  //     'imageStyle:wrapText',
  //     'imageStyle:breakText',
  //     '|',
  //     'toggleImageCaption',
  //     'imageTextAlternative',
  //   ],
  // },
  // table: {
  //   contentToolbar: ['tableColumn', 'tableRow', 'mergeTableCells'],
  // },
  list: {
    properties: {
      styles: !0,
      startIndex: !0,
      reversed: !0
    }
  },
  // This value must be kept in sync with the language defined in webpack.config.js.
  language: "en"
}, WU = {
  plugins: Hl,
  toolbar: ql
};
class Nd extends bh {
}
Nd.builtinPlugins = Hl;
Nd.defaultConfig = ql;
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class jU extends ph {
  /**
   * Creates an instance of the classic editor UI class.
   *
   * @param editor The editor instance.
   * @param view The view of the UI.
   */
  constructor(e, t) {
    super(e), this.view = t, this._toolbarConfig = mh(e.config.get("toolbar")), this._elementReplacer = new pB();
  }
  /**
   * @inheritDoc
   */
  get element() {
    return this.view.element;
  }
  /**
   * Initializes the UI.
   *
   * @param replacementElement The DOM element that will be the source for the created editor.
   */
  init(e) {
    const t = this.editor, n = this.view, r = t.editing.view, s = n.editable, o = r.document.getRoot();
    s.name = o.rootName, n.render();
    const l = s.element;
    this.setEditableElement(s.name, l), n.editable.bind("isFocused").to(this.focusTracker), r.attachDomRoot(l), e && this._elementReplacer.replace(e, this.element), this._initPlaceholder(), this._initToolbar(), this.fire("ready");
  }
  /**
   * @inheritDoc
   */
  destroy() {
    super.destroy();
    const e = this.view, t = this.editor.editing.view;
    this._elementReplacer.restore(), t.detachDomRoot(e.editable.name), e.destroy();
  }
  /**
   * Initializes the editor toolbar.
   */
  _initToolbar() {
    const e = this.view;
    e.stickyPanel.bind("isActive").to(this.focusTracker, "isFocused"), e.stickyPanel.limiterElement = e.element, e.stickyPanel.bind("viewportTopOffset").to(this, "viewportOffset", ({ top: t }) => t || 0), e.toolbar.fillFromConfig(this._toolbarConfig, this.componentFactory), this.addToolbar(e.toolbar);
  }
  /**
   * Enable the placeholder text on the editing root, if any was configured.
   */
  _initPlaceholder() {
    const e = this.editor, t = e.editing.view, n = t.document.getRoot(), r = e.sourceElement;
    let s;
    const o = e.config.get("placeholder");
    o && (s = typeof o == "string" ? o : o[this.view.editable.name]), !s && r && r.tagName.toLowerCase() === "textarea" && (s = r.getAttribute("placeholder")), s && Wl({
      view: t,
      element: n,
      text: s,
      isDirectHost: !1,
      keepOnFocus: !0
    });
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class UU extends B9 {
  /**
   * Creates an instance of the classic editor UI view.
   *
   * @param locale The {@link module:core/editor/editor~Editor#locale} instance.
   * @param editingView The editing view instance this view is related to.
   * @param options Configuration options for the view instance.
   * @param options.shouldToolbarGroupWhenFull When set `true` enables automatic items grouping
   * in the main {@link module:editor-classic/classiceditoruiview~ClassicEditorUIView#toolbar toolbar}.
   * See {@link module:ui/toolbar/toolbarview~ToolbarOptions#shouldGroupWhenFull} to learn more.
   */
  constructor(e, t, n = {}) {
    super(e), this.stickyPanel = new q9(e), this.toolbar = new na(e, {
      shouldGroupWhenFull: n.shouldToolbarGroupWhenFull
    }), this.editable = new vh(e, t);
  }
  /**
   * @inheritDoc
   */
  render() {
    super.render(), this.stickyPanel.content.add(this.toolbar), this.top.add(this.stickyPanel), this.main.add(this.editable);
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
let Ch = class extends Bs(jo(dh)) {
  /**
   * Creates an instance of the classic editor.
   *
   * **Note:** do not use the constructor to create editor instances. Use the static
   * {@link module:editor-classic/classiceditor~ClassicEditor.create `ClassicEditor.create()`} method instead.
   *
   * @param sourceElementOrData The DOM element that will be the source for the created editor
   * or the editor's initial data. For more information see
   * {@link module:editor-classic/classiceditor~ClassicEditor.create `ClassicEditor.create()`}.
   * @param config The editor configuration.
   */
  constructor(e, t = {}) {
    if (!nd(e) && t.initialData !== void 0)
      throw new B("editor-create-initial-data", null);
    super(t), this.config.get("initialData") === void 0 && this.config.set("initialData", HU(e)), nd(e) && (this.sourceElement = e), this.model.document.createRoot();
    const n = !this.config.get("toolbar.shouldNotGroupWhenFull"), r = new UU(this.locale, this.editing.view, {
      shouldToolbarGroupWhenFull: n
    });
    this.ui = new jU(this, r), pp(this);
  }
  /**
   * Destroys the editor instance, releasing all resources used by it.
   *
   * Updates the original editor element with the data if the
   * {@link module:core/editor/editorconfig~EditorConfig#updateSourceElementOnDestroy `updateSourceElementOnDestroy`}
   * configuration option is set to `true`.
   */
  destroy() {
    return this.sourceElement && this.updateSourceElement(), this.ui.destroy(), super.destroy();
  }
  /**
   * Creates a new classic editor instance.
   *
   * There are three ways how the editor can be initialized.
   *
   * # Replacing a DOM element (and loading data from it)
   *
   * You can initialize the editor using an existing DOM element:
   *
   * ```ts
   * ClassicEditor
   * 	.create( document.querySelector( '#editor' ) )
   * 	.then( editor => {
   * 		console.log( 'Editor was initialized', editor );
   * 	} )
   * 	.catch( err => {
   * 		console.error( err.stack );
   * 	} );
   * ```
   *
   * The element's content will be used as the editor data and the element will be replaced by the editor UI.
   *
   * # Creating a detached editor
   *
   * Alternatively, you can initialize the editor by passing the initial data directly as a string.
   * In this case, the editor will render an element that must be inserted into the DOM:
   *
   * ```ts
   * ClassicEditor
   * 	.create( '<p>Hello world!</p>' )
   * 	.then( editor => {
   * 		console.log( 'Editor was initialized', editor );
   *
   * 		// Initial data was provided so the editor UI element needs to be added manually to the DOM.
   * 		document.body.appendChild( editor.ui.element );
   * 	} )
   * 	.catch( err => {
   * 		console.error( err.stack );
   * 	} );
   * ```
   *
   * This lets you dynamically append the editor to your web page whenever it is convenient for you. You may use this method if your
   * web page content is generated on the client side and the DOM structure is not ready at the moment when you initialize the editor.
   *
   * # Replacing a DOM element (and data provided in `config.initialData`)
   *
   * You can also mix these two ways by providing a DOM element to be used and passing the initial data through the configuration:
   *
   * ```ts
   * ClassicEditor
   * 	.create( document.querySelector( '#editor' ), {
   * 		initialData: '<h2>Initial data</h2><p>Foo bar.</p>'
   * 	} )
   * 	.then( editor => {
   * 		console.log( 'Editor was initialized', editor );
   * 	} )
   * 	.catch( err => {
   * 		console.error( err.stack );
   * 	} );
   * ```
   *
   * This method can be used to initialize the editor on an existing element with the specified content in case if your integration
   * makes it difficult to set the content of the source element.
   *
   * Note that an error will be thrown if you pass the initial data both as the first parameter and also in the configuration.
   *
   * # Configuring the editor
   *
   * See the {@link module:core/editor/editorconfig~EditorConfig editor configuration documentation} to learn more about
   * customizing plugins, toolbar and more.
   *
   * # Using the editor from source
   *
   * The code samples listed in the previous sections of this documentation assume that you are using an
   * {@glink installation/getting-started/predefined-builds editor build} (for example – `@ckeditor/ckeditor5-build-classic`).
   *
   * If you want to use the classic editor from source (`@ckeditor/ckeditor5-editor-classic/src/classiceditor`),
   * you need to define the list of
   * {@link module:core/editor/editorconfig~EditorConfig#plugins plugins to be initialized} and
   * {@link module:core/editor/editorconfig~EditorConfig#toolbar toolbar items}. Read more about using the editor from
   * source in the {@glink installation/advanced/alternative-setups/integrating-from-source-webpack dedicated guide}.
   *
   * @param sourceElementOrData The DOM element that will be the source for the created editor
   * or the editor's initial data.
   *
   * If a DOM element is passed, its content will be automatically loaded to the editor upon initialization
   * and the {@link module:editor-classic/classiceditorui~ClassicEditorUI#element editor element} will replace the passed element
   * in the DOM (the original one will be hidden and the editor will be injected next to it).
   *
   * If the {@link module:core/editor/editorconfig~EditorConfig#updateSourceElementOnDestroy updateSourceElementOnDestroy}
   * option is set to `true`, the editor data will be set back to the original element once the editor is destroyed and when a form,
   * in which this element is contained, is submitted (if the original element is a `<textarea>`). This ensures seamless integration
   * with native web forms.
   *
   * If the initial data is passed, a detached editor will be created. In this case you need to insert it into the DOM manually.
   * It is available under the {@link module:editor-classic/classiceditorui~ClassicEditorUI#element `editor.ui.element`} property.
   *
   * @param config The editor configuration.
   * @returns A promise resolved once the editor is ready. The promise resolves with the created editor instance.
   */
  static create(e, t = {}) {
    return new Promise((n) => {
      const r = new this(e, t);
      n(r.initPlugins().then(() => r.ui.init(nd(e) ? e : null)).then(() => r.data.init(r.config.get("initialData"))).then(() => r.fire("ready")).then(() => r));
    });
  }
};
Ch.Context = zl;
Ch.EditorWatchdog = Ul;
Ch.ContextWatchdog = wh;
function HU(i) {
  return nd(i) ? sh(i) : i;
}
function nd(i) {
  return Dr(i);
}
class Np extends Ch {
}
Np.builtinPlugins = Hl;
Np.defaultConfig = ql;
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class qU extends ph {
  /**
   * Creates an instance of the decoupled editor UI class.
   *
   * @param editor The editor instance.
   * @param view The view of the UI.
   */
  constructor(e, t) {
    super(e), this.view = t;
  }
  /**
   * Initializes the UI.
   */
  init() {
    const e = this.editor, t = this.view, n = e.editing.view, r = t.editable, s = n.document.getRoot();
    r.name = s.rootName, t.render();
    const o = r.element;
    this.setEditableElement(r.name, o), t.editable.bind("isFocused").to(this.focusTracker), n.attachDomRoot(o), this._initPlaceholder(), this._initToolbar(), this.fire("ready");
  }
  /**
   * @inheritDoc
   */
  destroy() {
    super.destroy();
    const e = this.view;
    this.editor.editing.view.detachDomRoot(e.editable.name), e.destroy();
  }
  /**
   * Initializes the inline editor toolbar and its panel.
   */
  _initToolbar() {
    const e = this.editor, t = this.view;
    t.toolbar.fillFromConfig(e.config.get("toolbar"), this.componentFactory), this.addToolbar(t.toolbar);
  }
  /**
   * Enable the placeholder text on the editing root, if any was configured.
   */
  _initPlaceholder() {
    const e = this.editor, t = e.editing.view, n = t.document.getRoot();
    e.sourceElement;
    const r = e.config.get("placeholder");
    if (r) {
      const s = typeof r == "string" ? r : r[n.rootName];
      s && Wl({
        view: t,
        element: n,
        text: s,
        isDirectHost: !1,
        keepOnFocus: !0
      });
    }
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class KU extends _h {
  /**
   * Creates an instance of the decoupled editor UI view.
   *
   * @param locale The {@link module:core/editor/editor~Editor#locale} instance.
   * @param editingView The editing view instance this view is related to.
   * @param options Configuration options for the view instance.
   * @param options.editableElement The editable element. If not specified, it will be automatically created by
   * {@link module:ui/editableui/editableuiview~EditableUIView}. Otherwise, the given element will be used.
   * @param options.shouldToolbarGroupWhenFull When set `true` enables automatic items grouping
   * in the main {@link module:editor-decoupled/decouplededitoruiview~DecoupledEditorUIView#toolbar toolbar}.
   * See {@link module:ui/toolbar/toolbarview~ToolbarOptions#shouldGroupWhenFull} to learn more.
   */
  constructor(e, t, n = {}) {
    super(e);
    const r = e.t;
    this.toolbar = new na(e, {
      shouldGroupWhenFull: n.shouldToolbarGroupWhenFull
    }), this.editable = new vh(e, t, n.editableElement, {
      label: (s) => r("Rich Text Editor. Editing area: %0", s.name)
    }), this.toolbar.extendTemplate({
      attributes: {
        class: [
          "ck-reset_all",
          "ck-rounded-corners"
        ],
        dir: e.uiLanguageDirection
      }
    });
  }
  /**
   * @inheritDoc
   */
  render() {
    super.render(), this.registerChild([this.toolbar, this.editable]);
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
let Sh = class extends Bs(jo(dh)) {
  /**
   * Creates an instance of the decoupled editor.
   *
   * **Note:** Do not use the constructor to create editor instances. Use the static
   * {@link module:editor-decoupled/decouplededitor~DecoupledEditor.create `DecoupledEditor.create()`} method instead.
   *
   * @param sourceElementOrData The DOM element that will be the source for the created editor
   * (on which the editor will be initialized) or initial data for the editor. For more information see
   * {@link module:editor-balloon/ballooneditor~BalloonEditor.create `BalloonEditor.create()`}.
   * @param config The editor configuration.
   */
  constructor(e, t = {}) {
    if (!id(e) && t.initialData !== void 0)
      throw new B("editor-create-initial-data", null);
    super(t), this.config.get("initialData") === void 0 && this.config.set("initialData", GU(e)), id(e) && (this.sourceElement = e, _p(this, e)), this.model.document.createRoot();
    const n = !this.config.get("toolbar.shouldNotGroupWhenFull"), r = new KU(this.locale, this.editing.view, {
      editableElement: this.sourceElement,
      shouldToolbarGroupWhenFull: n
    });
    this.ui = new qU(this, r);
  }
  /**
   * Destroys the editor instance, releasing all resources used by it.
   *
   * Updates the original editor element with the data if the
   * {@link module:core/editor/editorconfig~EditorConfig#updateSourceElementOnDestroy `updateSourceElementOnDestroy`}
   * configuration option is set to `true`.
   *
   * **Note**: The decoupled editor does not remove the toolbar and editable when destroyed. You can
   * do that yourself in the destruction chain:
   *
   * ```ts
   * editor.destroy()
   * 	.then( () => {
   * 		// Remove the toolbar from DOM.
   * 		editor.ui.view.toolbar.element.remove();
   *
   * 		// Remove the editable from DOM.
   * 		editor.ui.view.editable.element.remove();
   *
   * 		console.log( 'Editor was destroyed' );
   * 	} );
   * ```
   */
  destroy() {
    const e = this.getData();
    return this.ui.destroy(), super.destroy().then(() => {
      this.sourceElement && this.updateSourceElement(e);
    });
  }
  /**
   * Creates a new decoupled editor instance.
   *
   * **Note:** remember that `DecoupledEditor` does not append the toolbar element to your web page, so you have to do it manually
   * after the editor has been initialized.
   *
   * There are two ways how the editor can be initialized.
   *
   * # Using an existing DOM element (and loading data from it)
   *
   * You can initialize the editor using an existing DOM element:
   *
   * ```ts
   * DecoupledEditor
   * 	.create( document.querySelector( '#editor' ) )
   * 	.then( editor => {
   * 		console.log( 'Editor was initialized', editor );
   *
   * 		// Append the toolbar to the <body> element.
   * 		document.body.appendChild( editor.ui.view.toolbar.element );
   * 	} )
   * 	.catch( err => {
   * 		console.error( err.stack );
   * 	} );
   * ```
   *
   * The element's content will be used as the editor data and the element will become the editable element.
   *
   * # Creating a detached editor
   *
   * Alternatively, you can initialize the editor by passing the initial data directly as a string.
   * In this case, you will have to manually append both the toolbar element and the editable element to your web page.
   *
   * ```ts
   * DecoupledEditor
   * 	.create( '<p>Hello world!</p>' )
   * 	.then( editor => {
   * 		console.log( 'Editor was initialized', editor );
   *
   * 		// Append the toolbar to the <body> element.
   * 		document.body.appendChild( editor.ui.view.toolbar.element );
   *
   * 		// Initial data was provided so the editor UI element needs to be added manually to the DOM.
   * 		document.body.appendChild( editor.ui.getEditableElement() );
   * 	} )
   * 	.catch( err => {
   * 		console.error( err.stack );
   * 	} );
   * ```
   *
   * This lets you dynamically append the editor to your web page whenever it is convenient for you. You may use this method if your
   * web page content is generated on the client side and the DOM structure is not ready at the moment when you initialize the editor.
   *
   * # Using an existing DOM element (and data provided in `config.initialData`)
   *
   * You can also mix these two ways by providing a DOM element to be used and passing the initial data through the configuration:
   *
   * ```ts
   * DecoupledEditor
   * 	.create( document.querySelector( '#editor' ), {
   * 		initialData: '<h2>Initial data</h2><p>Foo bar.</p>'
   * 	} )
   * 	.then( editor => {
   * 		console.log( 'Editor was initialized', editor );
   *
   * 		// Append the toolbar to the <body> element.
   * 		document.body.appendChild( editor.ui.view.toolbar.element );
   * 	} )
   * 	.catch( err => {
   * 		console.error( err.stack );
   * 	} );
   * ```
   *
   * This method can be used to initialize the editor on an existing element with the specified content in case if your integration
   * makes it difficult to set the content of the source element.
   *
   * Note that an error will be thrown if you pass the initial data both as the first parameter and also in the configuration.
   *
   * # Configuring the editor
   *
   * See the {@link module:core/editor/editorconfig~EditorConfig editor configuration documentation} to learn more about
   * customizing plugins, toolbar and more.
   *
   * # Using the editor from source
   *
   * The code samples listed in the previous sections of this documentation assume that you are using an
   * {@glink installation/getting-started/predefined-builds editor build}
   * (for example – `@ckeditor/ckeditor5-build-decoupled`).
   *
   * If you want to use the decoupled editor from source (`@ckeditor/ckeditor5-editor-decoupled/src/decouplededitor`),
   * you need to define the list of
   * {@link module:core/editor/editorconfig~EditorConfig#plugins plugins to be initialized} and
   * {@link module:core/editor/editorconfig~EditorConfig#toolbar toolbar items}. Read more about using the editor from
   * source in the {@glink installation/advanced/alternative-setups/integrating-from-source-webpack dedicated guide}.
   *
   * @param sourceElementOrData The DOM element that will be the source for the created editor
   * or the editor's initial data.
   *
   * If a DOM element is passed, its content will be automatically loaded to the editor upon initialization.
   * The editor data will be set back to the original element once the editor is destroyed only if the
   * {@link module:core/editor/editorconfig~EditorConfig#updateSourceElementOnDestroy updateSourceElementOnDestroy}
   * option is set to `true`.
   *
   * If the initial data is passed, a detached editor will be created. In this case you need to insert it into the DOM manually.
   * It is available via
   * {@link module:editor-decoupled/decouplededitorui~DecoupledEditorUI#getEditableElement `editor.ui.getEditableElement()`}.
   *
   * @param config The editor configuration.
   * @returns A promise resolved once the editor is ready. The promise resolves with the created editor instance.
   */
  static create(e, t = {}) {
    return new Promise((n) => {
      if (id(e) && e.tagName === "TEXTAREA")
        throw new B("editor-wrong-element", null);
      const r = new this(e, t);
      n(r.initPlugins().then(() => r.ui.init()).then(() => r.data.init(r.config.get("initialData"))).then(() => r.fire("ready")).then(() => r));
    });
  }
};
Sh.Context = zl;
Sh.EditorWatchdog = Ul;
Sh.ContextWatchdog = wh;
function GU(i) {
  return id(i) ? sh(i) : i;
}
function id(i) {
  return Dr(i);
}
class Dp extends Sh {
}
Dp.builtinPlugins = Hl;
Dp.defaultConfig = ql;
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
class YU extends ph {
  /**
   * Creates an instance of the inline editor UI class.
   *
   * @param editor The editor instance.
   * @param view The view of the UI.
   */
  constructor(e, t) {
    super(e), this.view = t, this._toolbarConfig = mh(e.config.get("toolbar"));
  }
  /**
   * @inheritDoc
   */
  get element() {
    return this.view.editable.element;
  }
  /**
   * Initializes the UI.
   */
  init() {
    const e = this.editor, t = this.view, n = e.editing.view, r = t.editable, s = n.document.getRoot();
    r.name = s.rootName, t.render();
    const o = r.element;
    this.setEditableElement(r.name, o), r.bind("isFocused").to(this.focusTracker), n.attachDomRoot(o), this._initPlaceholder(), this._initToolbar(), this.fire("ready");
  }
  /**
   * @inheritDoc
   */
  destroy() {
    super.destroy();
    const e = this.view;
    this.editor.editing.view.detachDomRoot(e.editable.name), e.destroy();
  }
  /**
   * Initializes the inline editor toolbar and its panel.
   */
  _initToolbar() {
    const e = this.editor, t = this.view, n = t.editable.element, r = t.toolbar;
    t.panel.bind("isVisible").to(this.focusTracker, "isFocused"), t.bind("viewportTopOffset").to(this, "viewportOffset", ({ top: s }) => s || 0), t.listenTo(e.ui, "update", () => {
      t.panel.isVisible && t.panel.pin({
        target: n,
        positions: t.panelPositions
      });
    }), r.fillFromConfig(this._toolbarConfig, this.componentFactory), this.addToolbar(r);
  }
  /**
   * Enable the placeholder text on the editing root, if any was configured.
   */
  _initPlaceholder() {
    const e = this.editor, t = e.editing.view, n = t.document.getRoot();
    e.sourceElement;
    const r = e.config.get("placeholder");
    if (r) {
      const s = typeof r == "string" ? r : r[n.rootName];
      s && Wl({
        view: t,
        element: n,
        text: s,
        isDirectHost: !1,
        keepOnFocus: !0
      });
    }
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
const JU = $l("px");
class XU extends _h {
  /**
   * Creates an instance of the inline editor UI view.
   *
   * @param locale The {@link module:core/editor/editor~Editor#locale} instance.
   * @param editingView The editing view instance this view is related to.
   * @param editableElement The editable element. If not specified, it will be automatically created by
   * {@link module:ui/editableui/editableuiview~EditableUIView}. Otherwise, the given element will be used.
   * @param options Configuration options for the view instance.
   * @param options.shouldToolbarGroupWhenFull When set `true` enables automatic items grouping
   * in the main {@link module:editor-inline/inlineeditoruiview~InlineEditorUIView#toolbar toolbar}.
   * See {@link module:ui/toolbar/toolbarview~ToolbarOptions#shouldGroupWhenFull} to learn more.
   */
  constructor(e, t, n, r = {}) {
    super(e);
    const s = e.t;
    this.toolbar = new na(e, {
      shouldGroupWhenFull: r.shouldToolbarGroupWhenFull,
      isFloating: !0
    }), this.set("viewportTopOffset", 0), this.panel = new gn(e), this.panelPositions = this._getPanelPositions(), this.panel.extendTemplate({
      attributes: {
        class: "ck-toolbar-container"
      }
    }), this.editable = new vh(e, t, n, {
      label: (o) => s("Rich Text Editor. Editing area: %0", o.name)
    }), this._resizeObserver = null;
  }
  /**
   * @inheritDoc
   */
  render() {
    if (super.render(), this.body.add(this.panel), this.registerChild(this.editable), this.panel.content.add(this.toolbar), this.toolbar.options.shouldGroupWhenFull) {
      const t = this.editable.element;
      this._resizeObserver = new xt(t, () => {
        this.toolbar.maxWidth = JU(new pt(t).width);
      });
    }
  }
  /**
   * @inheritDoc
   */
  destroy() {
    super.destroy(), this._resizeObserver && this._resizeObserver.destroy();
  }
  /**
   * Determines the panel top position of the {@link #panel} in {@link #panelPositions}.
   *
   * @param editableRect Rect of the {@link #element}.
   * @param panelRect Rect of the {@link #panel}.
   */
  _getPanelPositionTop(e, t) {
    let n;
    return e.top > t.height + this.viewportTopOffset ? n = e.top - t.height : e.bottom > t.height + this.viewportTopOffset + 50 ? n = this.viewportTopOffset : n = e.bottom, n;
  }
  /**
   * Returns the positions for {@link #panelPositions}.
   *
   * See: {@link module:utils/dom/position~Options#positions}.
   */
  _getPanelPositions() {
    const e = [
      (t, n) => ({
        top: this._getPanelPositionTop(t, n),
        left: t.left,
        name: "toolbar_west",
        config: {
          withArrow: !1
        }
      }),
      (t, n) => ({
        top: this._getPanelPositionTop(t, n),
        left: t.left + t.width - n.width,
        name: "toolbar_east",
        config: {
          withArrow: !1
        }
      })
    ];
    return this.locale.uiLanguageDirection === "ltr" ? e : e.reverse();
  }
}
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
let Th = class extends Bs(jo(dh)) {
  /**
   * Creates an instance of the inline editor.
   *
   * **Note:** Do not use the constructor to create editor instances. Use the static
   * {@link module:editor-inline/inlineeditor~InlineEditor.create `InlineEditor.create()`} method instead.
   *
   * @param sourceElementOrData The DOM element that will be the source for the created editor
   * (on which the editor will be initialized) or initial data for the editor. For more information see
   * {@link module:editor-inline/inlineeditor~InlineEditor.create `InlineEditor.create()`}.
   * @param config The editor configuration.
   */
  constructor(e, t = {}) {
    if (!rd(e) && t.initialData !== void 0)
      throw new B("editor-create-initial-data", null);
    super(t), this.config.get("initialData") === void 0 && this.config.set("initialData", ZU(e)), this.model.document.createRoot(), rd(e) && (this.sourceElement = e, _p(this, e));
    const n = !this.config.get("toolbar.shouldNotGroupWhenFull"), r = new XU(this.locale, this.editing.view, this.sourceElement, {
      shouldToolbarGroupWhenFull: n
    });
    this.ui = new YU(this, r), pp(this);
  }
  /**
   * Destroys the editor instance, releasing all resources used by it.
   *
   * Updates the original editor element with the data if the
   * {@link module:core/editor/editorconfig~EditorConfig#updateSourceElementOnDestroy `updateSourceElementOnDestroy`}
   * configuration option is set to `true`.
   */
  destroy() {
    const e = this.getData();
    return this.ui.destroy(), super.destroy().then(() => {
      this.sourceElement && this.updateSourceElement(e);
    });
  }
  /**
   * Creates a new inline editor instance.
   *
   * There are three general ways how the editor can be initialized.
   *
   * # Using an existing DOM element (and loading data from it)
   *
   * You can initialize the editor using an existing DOM element:
   *
   * ```ts
   * InlineEditor
   * 	.create( document.querySelector( '#editor' ) )
   * 	.then( editor => {
   * 		console.log( 'Editor was initialized', editor );
   * 	} )
   * 	.catch( err => {
   * 		console.error( err.stack );
   * 	} );
   * ```
   *
   * The element's content will be used as the editor data and the element will become the editable element.
   *
   * # Creating a detached editor
   *
   * Alternatively, you can initialize the editor by passing the initial data directly as a `String`.
   * In this case, the editor will render an element that must be inserted into the DOM for the editor to work properly:
   *
   * ```ts
   * InlineEditor
   * 	.create( '<p>Hello world!</p>' )
   * 	.then( editor => {
   * 		console.log( 'Editor was initialized', editor );
   *
   * 		// Initial data was provided so the editor UI element needs to be added manually to the DOM.
   * 		document.body.appendChild( editor.ui.element );
   * 	} )
   * 	.catch( err => {
   * 		console.error( err.stack );
   * 	} );
   * ```
   *
   * This lets you dynamically append the editor to your web page whenever it is convenient for you. You may use this method if your
   * web page content is generated on the client side and the DOM structure is not ready at the moment when you initialize the editor.
   *
   * # Using an existing DOM element (and data provided in `config.initialData`)
   *
   * You can also mix these two ways by providing a DOM element to be used and passing the initial data through the configuration:
   *
   * ```ts
   * InlineEditor
   * 	.create( document.querySelector( '#editor' ), {
   * 		initialData: '<h2>Initial data</h2><p>Foo bar.</p>'
   * 	} )
   * 	.then( editor => {
   * 		console.log( 'Editor was initialized', editor );
   * 	} )
   * 	.catch( err => {
   * 		console.error( err.stack );
   * 	} );
   * ```
   *
   * This method can be used to initialize the editor on an existing element with the specified content in case if your integration
   * makes it difficult to set the content of the source element.
   *
   * Note that an error will be thrown if you pass the initial data both as the first parameter and also in the configuration.
   *
   * # Configuring the editor
   *
   * See the {@link module:core/editor/editorconfig~EditorConfig editor configuration documentation} to learn more about
   * customizing plugins, toolbar and more.
   *
   * # Using the editor from source
   *
   * The code samples listed in the previous sections of this documentation assume that you are using an
   * {@glink installation/getting-started/predefined-builds editor build} (for example – `@ckeditor/ckeditor5-build-inline`).
   *
   * If you want to use the inline editor from source (`@ckeditor/ckeditor5-editor-inline/src/inlineeditor`),
   * you need to define the list of
   * {@link module:core/editor/editorconfig~EditorConfig#plugins plugins to be initialized} and
   * {@link module:core/editor/editorconfig~EditorConfig#toolbar toolbar items}. Read more about using the editor from
   * source in the {@glink installation/advanced/alternative-setups/integrating-from-source-webpack dedicated guide}.
   *
   * @param sourceElementOrData The DOM element that will be the source for the created editor
   * or the editor's initial data.
   *
   * If a DOM element is passed, its content will be automatically loaded to the editor upon initialization.
   * The editor data will be set back to the original element once the editor is destroyed only if the
   * {@link module:core/editor/editorconfig~EditorConfig#updateSourceElementOnDestroy updateSourceElementOnDestroy}
   * option is set to `true`.
   *
   * If the initial data is passed, a detached editor will be created. In this case you need to insert it into the DOM manually.
   * It is available under the {@link module:editor-inline/inlineeditorui~InlineEditorUI#element `editor.ui.element`} property.
   *
   * @param config The editor configuration.
   * @returns A promise resolved once the editor is ready. The promise resolves with the created editor instance.
   */
  static create(e, t = {}) {
    return new Promise((n) => {
      if (rd(e) && e.tagName === "TEXTAREA")
        throw new B("editor-wrong-element", null);
      const r = new this(e, t);
      n(r.initPlugins().then(() => r.ui.init()).then(() => r.data.init(r.config.get("initialData"))).then(() => r.fire("ready")).then(() => r));
    });
  }
};
Th.Context = zl;
Th.EditorWatchdog = Ul;
Th.ContextWatchdog = wh;
function ZU(i) {
  return rd(i) ? sh(i) : i;
}
function rd(i) {
  return Dr(i);
}
class Bp extends Th {
}
Bp.builtinPlugins = Hl;
Bp.defaultConfig = ql;
const QU = Fg()((i, { rows: e, multiline: t }) => ({
  root: {
    width: "100%",
    height: "auto",
    "& .ck": {
      minHeight: "inherit",
      outline: "none"
    },
    "& .ck.ck-editor__editable_inline>:last-child": {
      marginTop: 0,
      marginBottom: 0
    },
    "& .ck.ck-editor__editable_inline>:first-of-type": {
      marginBottom: 0,
      marginTop: 0
    },
    "& .ck.ck-editor__editable:not(.ck-editor__nested_editable).ck-focused": {
      border: `thin solid ${i.palette.divider}`
    },
    "& .ck.ck-content": {
      color: i.palette.text.primary
    }
  },
  rows: t ? {
    "& .ck.ck-content": {
      minHeight: i.spacing(e * 2.1),
      overflowY: "auto"
    }
  } : {},
  multiline: t ? {} : {
    "& .ck.ck-editor__editable_inline": {
      overflow: "hidden"
    }
  }
})), pH = jP(
  ({
    className: i,
    style: e,
    classes: t,
    variant: n = "classic",
    value: r,
    config: s = P1.cloneDeep(WU),
    multiline: o = !0,
    disabled: l = !1,
    onChange: u,
    rows: h = 5,
    ...f
  }, m) => {
    const { classes: v, cx: C } = QU(
      {
        rows: h,
        multiline: o
      },
      {
        props: {
          classes: t
        }
      }
    ), k = k1(() => P1.merge(
      o ? {} : {
        toolbar: ["bold", "italic"],
        restrictedEditing: {
          allowedCommands: ["bold", "italic"],
          allowedAttributes: []
        }
      },
      s
    ), [s, o]), S = k1(() => {
      switch (n) {
        case "balloon":
          return Nd;
        case "balloonBlock":
          return Nd;
        case "decoupled":
          return Dp;
        case "inline":
          return Bp;
        default:
          return Np;
      }
    }, [n]), x = UP(null);
    return A1(() => {
      if (!x || !m || !x.current?.sourceElement)
        return;
      const N = x.current.sourceElement;
      typeof m == "function" ? m(N) : m.current = N;
    }, [m]), A1(() => {
      x.current && r !== x.current.getData() && x.current.setData(r || "");
    }, [r]), /* @__PURE__ */ Jn(
      "div",
      {
        className: C(v.root, v.multiline, v.rows, i),
        style: e,
        children: /* @__PURE__ */ Jn(
          sd.CKEditor,
          {
            ...f,
            editor: S,
            data: r,
            config: k,
            disabled: l,
            onReady: (N) => {
              x.current = N, N && (o || N.editing.view.document.on(
                "keydown",
                (y, A) => {
                  A.keyCode === 13 && (A.stopPropagation(), A.preventDefault(), y.stop());
                },
                { priority: "highest" }
              ), N.setData(r || ""));
            },
            onChange: (N, y) => {
              const A = y.getData();
              u && u(null, A);
            }
          }
        )
      }
    );
  }
);
export {
  pH as RichTextEditor
};
